{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to ShapeWorks!","text":""},{"location":"index.html#what-is-shapeworks","title":"What is ShapeWorks?","text":"<p>ShapeWorks is a free, open-source suite of software tools that uses a flexible method for automated construction of compact statistical landmark-based shape models of ensembles of anatomical shapes that do not rely on any specific surface parameterization. The method requires very little preprocessing or parameter tuning and applies to a wide range of shape analysis problems, including nonmanifold surfaces and arbitrary topology objects. ShapeWorks includes tools for preprocessing data, computing landmark-based shape models, and visualizing the results.</p>"},{"location":"index.html#latest-greatest","title":"Latest &amp; Greatest","text":"<p>Release Notes</p> <p>Please visit Release Notes to know about the ShapeWorks' cutting-edge features and improvements.</p>"},{"location":"index.html#why-use-shapeworks","title":"Why use ShapeWorks?","text":"<p>ShapeWorks is the only publicly available tool that learns a population-specific anatomical mapping in a way that respects population variability without relying on a user-defined template/atlas. </p> <p>It produces more detailed surface-to-surface correspondences than traditional landmark-based approaches. </p> <p>Its optimized approach offers increased power for testing biological hypotheses of shape and shape differences, captures subtle shape variations, and decreases observer bias for reproducible scientific results. </p> <p>ShapeWorks can discover the underlying mode of variation in the box-bump ensemble in comparison to existing publicly available shape modeling software packages </p>"},{"location":"index.html#shapeworks-get-togethers","title":"ShapeWorks Get-Togethers","text":"<p>Where to start? What are the latest features? How to customize existing workflows?</p> <p>A monthly virtual get-together meeting for ShapeWorks users is organized to demonstrate new features, discuss the customization of the shape modeling workflow to users' own use cases, and get suggestions to improve the software and documentation. If you would like to be added to the invitation list, please send an email to <code>shireen-at-sci-dot-utah-dot-edu</code>.</p>"},{"location":"index.html#shapeworks-workshops-webinars","title":"ShapeWorks Workshops &amp; Webinars","text":""},{"location":"index.html#shapeworks-sb3c-2021","title":"ShapeWorks @SB3C 2021","text":"<p>Part 1: Statistical Shape Modeling &amp; ShapeWorks Speakers: Shireen Elhabian and Alan Morris</p> <p> <p>Part 2: ShapeWorks Success Stories in Orthopedics  Speakers: Heath Henninger, Andrew Anderson, and Amy Lenz</p> <p> <p>Part 3: Next Generation of ShapeWorks  Speakers: Shireen Elhabian, Andrew Anderson, Penny Atkins, and Riddhish Bhalodia</p> <p>"},{"location":"index.html#shapeworks-in-action","title":"ShapeWorks in Action!","text":"<p>The underlying scientific premise of ShapeWorks, particle-based shape modeling, is a groupwise approach to placing landmarks (i.e., correspondences) that consider variability in the entire cohort of images. </p> <p>ShapeWorks uses a set of interacting particle systems, one for each shape, to produce optimal sets of surface correspondences in an ensemble. Particles interact with one another via mutually repelling forces to cover and, therefore, describe surface geometry optimally. Particles are positioned on surfaces automatically by optimizing the model's information content via an entropy optimization scheme. </p> <p>In particular, ShapeWorks explicitly models the inherent trade-off between the model's statistical simplicity (i.e., compactness) in the shape space and the accuracy of the shape representations (i.e., good surface samplings) in the configuration space. </p> <p>ShapeWorks has been effective in various applications, including psychology, biological phenotyping, cardiology, and orthopedics. See relevant papers and ShapeWorks Success Stories. </p> <p>Now enjoy some tour videos for different recent software releases.</p> <p>ShapeWorks 6.6 tour - MONAI Label, Shared Boundaries, Java/MATLAB, Segmentation Tools, Particle to Surface Metrics, and more ...</p> <p> <p>ShapeWorks 6.5 tour - Shape / Scalar Correlation, Network Analysis, DeepSSM Improvments, and more ...</p> <p> <p>ShapeWorks 6.4 tour - Multi-level PCA, Improved Constraints, Python Docs, and more ...</p> <p> <p>ShapeWorks 6.3 tour - Landmarks, cutting planes, free form constraints in Studio, and more ...</p> <p> <p>ShapeWorks 6.2 tour - DeepSSM in Studio, multi-domain alignments, shape evaluation charts, scalar and opacity controls, and more ...</p> <p> <p>ShapeWorks 6.1 tour - multi-domain support, mesh grooming, improved models for complex anatomies, and more ...</p> <p> <p>ShapeWorks 6.0 tour - mesh support and more in ShapeWorks Studio</p> <p> <p>ShapeWorks 5.5 tour - feature support in ShapeWorks Studio</p> <p> <p>Grooming segmentations, optimizing correspondences, and analyzing shape models in ShapeWorks Studio </p> <p>"},{"location":"todo.html","title":"Documentation ToDo List","text":""},{"location":"todo.html#to-addedit-for-docs","title":"To add/edit for docs","text":"<ul> <li> <code>index.md#shapeworks-in-action</code>: Add the box bump examples and reference our benchmark study. </li> <li> <code>index.md#shapeworks-in-action</code>: Add video for illustration</li> <li> <code>index.md#with-shapeworks-you-can</code>: show case ShapeWorks in different studies (e.g., ortho and cardilogy) and cite relevant papers</li> <li> <code>index.md</code> and repo readme: Showcase our SSM benchmark study</li> <li> <code>users/papers.md</code>: Add links to the papers and update the list of papers with recent ones</li> <li> <code>about/release-notes.md</code>: Fix links in release notes</li> <li> <code>about/team.md</code>: May be some pics</li> <li> <code>dev/autodoc.md</code>: Which dir to use for autodoc for commands? </li> <li> Spell and grammar check all markdown files </li> <li> <code>use-cases/ellipsoid.md</code>: Add a figure showing some samples of the dataset that highlight the mode of variation</li> <li> Be consistent: multi-scale vs multiscale in the md files</li> <li> Be consistent: we vs you (e.g., in use cases)</li> <li> Add illustrating images to the groom steps in groom and specific use cases</li> <li> Update md files for groom/optimize and use cases to reflect the new workflow (icp, bounding box, crop) that does not apply explicitly resample images/segmentations beyond the isoresample step and use transforamtions as input to the optimization</li> <li> For groom and use cases, update the reference selection documentation to reflect any recent updates in this process (e.g., meshes, pairwise distance matrix ... etc)</li> <li> <code>workflow/XX.md</code>: Review and edit the workflow md files. Add/update the decription of single vs multiscale.</li> <li> <code>use-cases/ellipsoid.md</code>: Add video/snapshots for the optimized model and groomed data</li> <li> <code>use-cases/XX.md</code>: Update optimization parameters based on Examples/Python</li> <li> <code>use-cases/XX.md</code>: Update use cases to reflect multi-scale being integrated into the optimizer</li> <li> Add documentation for femur_mesh and lumps use cases</li> <li> <code>use-cases/left-atrium.md</code>:Check the left atrium use case for saving txt files to carry over images to reflect recent changes (consolidation)</li> <li> Consolidate docs/pdfs</li> <li> Add to use cases how to run with prepped data</li> <li> Add mean and PCA visuals for ellipsoid and fixed domain ellipsoid use cases</li> <li> Review and edit ellipsoid use cases</li> <li> Review and edit femur use case</li> <li> Review and edit right ventricle use case</li> <li> Once meshes work, update the femur use case to indicate that this is optional and add femur_mesh use case</li> <li> Instructions on how to add videos to the documentation (thumbnails that link to youtube)</li> <li> Instructions to add a new use case</li> <li> Revise the right ventricle use case after release it. Might need more results to illustrate group differences.</li> <li> Instructions for Doxygen and building doxygen.</li> <li> <code>dev/commands.md</code>:How to add shapeworks commands?</li> <li> <code>dev/gh-actions.md</code>: getting started with github actions</li> <li> <code>dev/python-apis.md</code>: How to Add Python APIs?</li> <li> <code>dev/tests.md</code>: How to Add and Run Unit Tests?</li> <li> Remove all hard-coded links outside docs (relative paths) except for (1) web links (e.g. segmentation softwares, markdown edits ... etc) and (2) shapeworks releases, and shapeworks data portal.</li> </ul>"},{"location":"todo.html#to-investigate-for-docs","title":"To investigate for docs","text":"<ul> <li> How can we use repo_url in markdown files to link to repo files? -- not needed any more, we won't include any links outside docs except for weblinks, shapeworks releases and data portal.</li> <li> How to use google_analytics?</li> </ul>"},{"location":"todo.html#for-shapeworks-repo","title":"For ShapeWorks repo","text":"<ul> <li> Change the autodoc dir for commands in github action and release, see 'dev/autodoc.md'</li> <li> Update <code>DocumentationUtilsPackage</code> to generate md for mkdocs (ShapeworksCommand.md)</li> <li> Add <code>mkdocs build</code> for autodoc (deploy) to github actions and release</li> <li> When a use case launches Studio, does it load groomed data? It does, based on the launch function that takes in distance transforms, local, and world point files.</li> <li> Review and edit comments in the .py <li> A fixed domain use case that include grooming the new samples</li> <li> Revisit the fixed domain use case, why do we need the path for the mean shape? why not use the mean of the fixed domains?</li> <li> Release and update the right ventricle use case</li>"},{"location":"todo.html#misc","title":"Misc","text":"<ul> <li> Add link to documentation http://sciinstitute.github.io/ShapeWorks/ to shapeworks.sci.utah.edu</li> <li> Prepped vs groomed? Be consistent in documentation, tags for RunUseCase, and output folders from running use cases</li> </ul>"},{"location":"about/contact.html","title":"Contact Us","text":""},{"location":"about/contact.html#users-forum","title":"Users Forum","text":"<p>Our user forum is located here: ShapeWorks Discourse Group. </p> <p>This forum is a place for ShapeWorks users to discuss how to customize shape modeling workflows for their own use cases, troubleshoot issues end-users facing when using ShapeWorks, keep track of suggestions to improve the software and documentation, and ensure awareness of the latest ShapeWorks tools within the research community.</p>"},{"location":"about/contact.html#users-mailing-list","title":"Users Mailing List","text":"<p>Please join our mailing list by sending a message to sympa@sci.utah.edu with the subject <code>subscribe shapeworks-users</code> and an empty body. You can also email any questions, bugs, or feature requests to shapeworks-users@sci.utah.edu.</p>"},{"location":"about/contact.html#developers-mailing-list","title":"Developers Mailing List","text":"<p>You can join our developer support mailing list by sending a message to sympa@sci.utah.edu with the subject <code>subscribe shapeworks-dev-support</code> and an empty body.</p> <p>As a developer, if you encounter any problems or bugs, please report them using the issue tracker on GitHub. This includes feature requests. Feel free to add improvements using git pull requests. You can also email ShapeWorkers at shapeworks-dev-support@sci.utah.edu.</p>"},{"location":"about/license.html","title":"ShapeWorks License","text":"<p>ShapeWorks is available for free and is open source under the MIT License.</p> <p>The MIT License Copyright (c) 2012 Scientific Computing and Imaging Institute, University of Utah. License for the specific language governing rights and limitations under Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/release-notes.html","title":"Release Notes","text":""},{"location":"about/release-notes.html#shapeworks-661-2025-05","title":"ShapeWorks 6.6.1 - 2025-05","text":""},{"location":"about/release-notes.html#fixes","title":"Fixes","text":"<ul> <li>Fix loading of non-binary segmentations</li> <li>Add padding for visualization of segmentation surfaces</li> <li>Add Blue/Red color map for scalar visualization</li> <li>Fix PCA/Group sliders when switching projects</li> <li>Fix stats being reloaded when groups are changed</li> <li>Fix a crash that can happen when changing projects while mesh warping</li> <li>Turn off group animate checkbox when deactivating analysis module</li> <li>Disallow network analysis when there are no scalar features</li> <li>Auto adjust network analysis alpha when necessary</li> <li>Add logging of groom and optimize parameters to file log</li> <li>Fix itk image factory registration for network analysis with image based features</li> <li>Added warning about inconsistent number of values in particle vector</li> <li>Fix libomp.dylib install problem on mac arm64 </li> <li>Update URL for UpdateChecker</li> </ul>"},{"location":"about/release-notes.html#shapeworks-660-2025-05","title":"ShapeWorks 6.6.0 - 2025-05","text":""},{"location":"about/release-notes.html#what-is-new","title":"What is new?","text":"<ul> <li> <p>ShapeWorks Back-end</p> <ul> <li>Improved support for varied image sizes in DeepSSM (#2218)</li> <li>Faster and more robust neighborhood computation code in the optimizer (#2314)</li> <li>Added Java bindings for ShapeWorks</li> <li>Added Matlab bindings for ShapeWorks</li> <li>Improve mesh domain memory usage (#2353)</li> </ul> </li> <li> <p>ShapeWorks Front-end</p> <ul> <li>Added new MONAI Label tool in Studio</li> <li>Added basic segmentation tools in Studio</li> <li>Modeling Shared Boundaries is now fully supported in Studio</li> <li>Added ability to close a project</li> <li>Added evaluation metrics and graphs for shape+scalar analysis (#2218)</li> <li>Added feature to evaluate generalization and specificity using particle to surface distance (#2212)</li> <li>Added ability to limit number of threads for grooming/optimization in Studio</li> <li>Added ability to manually choose reference template mesh for mesh warping (#1085)</li> </ul> </li> </ul>"},{"location":"about/release-notes.html#fixes_1","title":"Fixes","text":"<ul> <li>Fix bug in Studio where parameters are lost switching modules (#2263)</li> <li>Fix problem where VTK DLL was being marked as a virus (#2308)</li> <li>Fix problem loading certain kinds of NIFTI files (#2294)</li> <li>Placing landmarks on very zoomed in anatomy, causes landmarks to be misplaced (#2346)</li> <li>Studio crash when removing all shapes (#2354)</li> <li>Fix Crash on exporting mesh from computed shape (#2335)</li> <li></li> </ul>"},{"location":"about/release-notes.html#shapeworks-651-2024-08","title":"ShapeWorks 6.5.1 - 2024-08","text":""},{"location":"about/release-notes.html#fixes_2","title":"Fixes","text":"<ul> <li>Fix VTK Python version for windows (#2308)</li> <li>Fix some alignment issues in grooming</li> <li>Fix crash during ICP alignment with multiple domains</li> </ul>"},{"location":"about/release-notes.html#shapeworks-650-2024-03","title":"ShapeWorks 6.5.0 - 2024-03","text":""},{"location":"about/release-notes.html#what-is-new_1","title":"What is new?","text":"<ul> <li> <p>ShapeWorks Back-end</p> <ul> <li>DeepSSM variants and losses (TL network and other options) (#1881)</li> <li>Ability to use mesh scalar fields as correspondence attribute (#2081)</li> <li>Tool to compute cortical thickness using surface and CT (#2103)</li> <li>Tool to compute geodesic fields from landmarks (#2102) and use as a correspondence attribute</li> <li>Ability to run geodesic distance on a decimated mesh to improve speed</li> </ul> </li> <li> <p>ShapeWorks Front-end</p> <ul> <li>Shape and Scalar Correlation / Prediction (2 Block PLS) (#985)</li> <li>Particle Area Analysis (#2140)</li> <li>Compute the mean and standard deviation of the area associated with each particle</li> <li>Studio can now run models with fixed domains support</li> <li>Studio can now exclude subjects from grooming/optimization</li> <li>Free form constraints can now be applied from one shape to others</li> <li>Improved Brightness and Contrast control for slice viewer</li> <li>Cortical thickness values can be displayed as an inner contour for QA on slices (#2177)</li> <li>Network and SPM1D Analysis</li> <li>Statistically analyze feature map data using the relative size of the network of connected particles</li> <li>DeepSSM Enhancements in Studio</li> <li>Validation and Testing shapes/images are now held out from training grooming/optimization</li> <li>Image registration is used to align Validation and Testing</li> <li>Validation shapes have correspondence generated using fixed domains</li> <li>Inference on new images can now be performed using an existing model</li> </ul> </li> <li> <p>User's Support</p> <ul> <li>macOS Silicon (arm64) support</li> </ul> </li> </ul>"},{"location":"about/release-notes.html#fixes_3","title":"Fixes","text":"<ul> <li>Bug fix for very large covariance matrices (#2118)</li> <li>Fix windows python multiprocessing</li> <li>Fix bug when saving project after defining only 2 points of a plane (#2091)</li> <li>Improved data augmentation API (#2072)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-642-2023-07-05","title":"ShapeWorks 6.4.2 - 2023-07-05","text":""},{"location":"about/release-notes.html#fixes_4","title":"Fixes","text":"<ul> <li>Fix python module versions preventing python import from working (#2104)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-641-2023-05-10","title":"ShapeWorks 6.4.1 - 2023-05-10","text":""},{"location":"about/release-notes.html#fixes_5","title":"Fixes","text":"<ul> <li>Fix grooming crash when there are free form constraints in an untitled/unsaved project (#2078)</li> <li>Fix update checker potentially crashing (#2079)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-640-2023-05-05","title":"ShapeWorks 6.4.0 - 2023-05-05","text":""},{"location":"about/release-notes.html#what-is-new_2","title":"What is new?","text":"<ul> <li>ShapeWorks Back-end<ul> <li>New shapeworks 'analyze' command for offline analysis of shape models</li> <li>Improved free form constraints that now support doubly connected areas (e.g. donut-like)</li> <li>Data Portal migrated to new ShapeWorks Cloud and swcc (ShapeWorks Cloud Client) tool</li> <li>ShapeWorks can now be used as a 3rd party library (details here)</li> <li>Added support for 'save_init_splits' and 'checkpointing_interval' parameters in the project spreadsheet formats</li> <li>Added new JSON based file format for storing ShapeWorks projects (swproj)</li> <li>Added a unified logging library for ShapeWorks (spdlog)</li> <li>Uniform numerical computation of specificity across platforms</li> <li>Updated dependencies.  Python now at 3.9, PyTorch 1.11.0, VTK 9.1, ITK 5.2.1</li> </ul> </li> <li>ShapeWorks Front-end<ul> <li>Studio can now automatically check for updates and prompt the user to download them</li> <li>Improved progress bar in Studio is more representative and also estimates time remaining</li> <li>Added ability to arbitrarily scale difference arrows in Studio</li> <li>Added file association support for swproj file extension on Windows and Mac</li> <li>New multi-level analysis feature in Studio (details here)</li> <li>Added ability to hide/show particles per domain</li> </ul> </li> <li>User's Support<ul> <li>Hip Use Case: The use case uses the hip joint to demonstrate the capability of ShapeWorks    to capture inter-domain correlations and interactions directly on triangular surface meshes.    The use case showcases calculating the alignment options available for multiple organ anatomies.   (details here)</li> <li>Added options to the incremental use case when run in --interactive mode, including sorting method,    initial model size, and incremental batch size. The sorting method determines how the shapes are sorted    to be added incrementally. There are three options: random, median, distribution.   (details here)</li> <li>Python API documentation has been added to the ShapeWorks documentation site</li> </ul> </li> </ul>"},{"location":"about/release-notes.html#fixes_6","title":"Fixes","text":"<ul> <li>Fix Studio python problem causing crash on group differences (#1781)</li> <li>Fix Studio slow/hanging on certain free form constraints (#1817, #1801)</li> <li>Fix crashes on certain projects (#1800, #1815)</li> <li>Fix procrustes with multi-domain models (#1755)</li> <li>Fixed crashes in groom due to multi-threading (#1944)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-632-2022-10-04","title":"ShapeWorks 6.3.2 - 2022-10-04","text":""},{"location":"about/release-notes.html#fixes_7","title":"Fixes","text":"<ul> <li>Fix install_shapeworks.sh on Linux (#1883)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-631-2022-07-22","title":"ShapeWorks 6.3.1 - 2022-07-22","text":""},{"location":"about/release-notes.html#fixes_8","title":"Fixes","text":"<ul> <li>Fix Studio python problem causing crash on group differences (#1781)</li> <li>Fix Studio slow/hanging on certain free form constraints (#1817, #1801)</li> <li>Fix crashes on certain projects (#1800, #1815)</li> </ul>"},{"location":"about/release-notes.html#shapeworks-630-2022-06-09","title":"ShapeWorks 6.3.0 - 2022-06-09","text":""},{"location":"about/release-notes.html#what-is-new_3","title":"What is new?","text":"<ul> <li>ShapeWorks Back-end<ul> <li>Added constraints functionality for the mesh domain both clipping and augmented lagrangian together with a flag to flip between the two options.</li> <li>Group Difference Statistics in Python can now perform LDA.  The use case also demonstrates Linear Discrimination of Variation (LDA) for analyzing shape variation between the subgroups.</li> </ul> </li> <li>ShapeWorks Front-end<ul> <li>New selectable and configurable colormap support</li> <li>Added new support for showing the difference to the mean for any given mesh (subjects or generated PCA mode positions)</li> <li>Added new support for displaying multiple image types (e.g. original vs groomed) with individual opacity settings. Also ability to show surface to surface distance.</li> <li>The multiple domains groom section has been upgraded to its own panel for better UI consistency. A new checkbox for applying grooming steps to all domains has been added to assist when many domains are in use</li> <li>A new image export dialog as been added with various export options</li> <li>PCA Montage and Fringe plot export.  Building on the image export dialog, the PCA Montage exporter allows you to create a multi-image montage across PCA modes.</li> <li>Export scalar values: Addition export options have been added to export mesh scalars, particle scalars, and all subjects particle scalars.</li> <li>Image volume support: New support has been added for displaying 2D slices from image volumes (e.g. CT/MRI)</li> <li>Landmark placement UI in Studio, landmark registration, landmarks as initializers</li> <li>Cutting planes UI in Studio: Added new support for defining and manipulating cutting planes</li> <li>Free form constraints UI in Studio: Added new support for defining free form constraints</li> <li>Procrustes scaling only mode: New support for running procrustes in a scaling-only mode has been added.</li> <li>Good/bad particle display: The Particles Panel enabled the display of \"good/bad particles\" in ShapeWorks Studio.</li> <li>Group LDA chart in Studio: Support for the group LDA chart has been added in Studio</li> </ul> </li> <li>User's Support<ul> <li>Added grooming steps to mesh-based use cases using the mesh Python API</li> <li>Alignment transforms are now passed to the optimizer and used in optimization instead of being applied before optimization. This results in local particles in the original data's coordinate system, allowing for easier subsequent analysis</li> <li>The use cases now use project spreadsheets in optimizations instead of XML files. This format is more interpretable and allows of better integration with Studio. The project sheets support multiple domains, fixed domains, constraints</li> <li>The femur use case has been refactored into a single use case where alignment transforms and cutting plane constraints are passed in optimization.</li> <li>Grooming added for multiple domain use cases. The pipeline demonstrates alignment w.r.t domain 1 ellipsoids.</li> <li>DeepSSM Use Case:<ul> <li>The DeepSSM use case has been updated to demonstrate the full pipeline, including training data generation instead of relying on the femur use case to create a training shape model.</li> <li>The use case now demonstrates how to optimize validation particles via fixed domain optimization where the training particles are unchanged.</li> <li>Image-to-image registration tools have been added to prepare DeepSSM input images without requiring corresponding segmentations or meshes. This allows for true inference with DeepSSM.</li> </ul> </li> <li>Incremental Use Case:<ul> <li>A new use case has been added, demonstrating how a shape model can be optimized incrementally on 3D supershapes. This approach is beneficial when the cohort of shapes is very large, and single optimization would be slow, and when the dataset is small but contains a large amount of shape variation.</li> <li>Functionality has been added to select the order of shape optimization based on the distance of each shape to all others in the cohort. This allows for particles to be fit to inlier shapes first, then outliers.</li> <li>Documentation has been added that explains the use case and quantitatively demonstrates the benefit of incremental optimization.</li> </ul> </li> <li>Added a Studio use case for constraints and a pseudo-tutorial for it in the documentation.</li> </ul> </li> </ul>"},{"location":"about/release-notes.html#fixes_9","title":"Fixes","text":"<ul> <li>Studio: TabWidget rendering on MacOS 11/12 fixed</li> <li>Mesh::toDistanceTransform fixed</li> <li>Studio: Fixed optimization abort not always aborting</li> <li>Optimize: Fixed particle splitting for use with input transforms</li> <li>Studio: Fix clamping of glyph size</li> <li>Studio: Fix bug when groom output path is blank</li> </ul>"},{"location":"about/release-notes.html#shapeworks-621-2022-01-07","title":"ShapeWorks 6.2.1 - 2022-01-07","text":""},{"location":"about/release-notes.html#what-is-new_4","title":"What is new?","text":"<ul> <li>ShapeWorks Back-end<ul> <li>Added new <code>isolate</code> functionality that isolates the largest object in a segmentation</li> <li>Added remeshing using ACVD library</li> <li>Added option to save mesh file as binary (default is ASCII)</li> <li>Uniform transform interface added: ITK transforms can be applied to meshes and VTK transforms can be applied to images. </li> </ul> </li> <li>ShapeWorks Front-end<ul> <li>Studio: Added convert to mesh pipeline for segmentation inputs (can run both image and mesh pipelines)</li> <li>Studio: Added reflection, remeshing, image cropping, image resampling to grooming</li> <li>Studio: New UI for grooming</li> </ul> </li> <li>User's Support<ul> <li>Updated <code>ellipsoid_mesh</code> use case to demonstrate mesh grooming</li> <li>Combined the functionality of the three femur use cases - <code>femur</code>,<code>femur_mesh</code>,<code>femur_cut</code> into one use case. The <code>femur_cut</code> use case now demonstrates the process of grooming meshes and the associated images , optimization on meshes with a single cutting plane as a constraint.</li> </ul> </li> </ul>"},{"location":"about/release-notes.html#fixes_10","title":"Fixes","text":"<ul> <li>Studio: Fixed display names in the corner (removing long paths)</li> <li>Studio: Fixed recomputation of shape statistics upon re-running shape model and removing shapes</li> </ul>"},{"location":"about/release-notes.html#shapeworks-62-2021-11-16","title":"ShapeWorks 6.2 - 2021-11-16","text":""},{"location":"about/release-notes.html#what-is-new_5","title":"What is new?","text":""},{"location":"about/release-notes.html#shapeworks-back-end","title":"ShapeWorks Back-end","text":"<ul> <li> <p>New <code>Mesh</code> grooming tools: The following grooming tools are supported from all three different interfaces - command line, C++ and Python:  </p> <ul> <li><code>curvature</code>: computes curvature (types include principal, gaussian, and mean curvature) of a given triangular mesh and returns a field that contains a scalar value for each mesh vertex. See mesh-curvature to know about function parameters. </li> <li><code>fixElement</code>: fixes element winding of a given triangular mesh as a quality control step for preparing meshes for shape modeling. See fix-element to know about function parameters.  </li> <li><code>geodesicDistance</code>: the computation of geodesic distances enables feature-based correspondences. Read this paper for more details. Below are exemplar usage scenarios.    <ul> <li><code>geodesicDistance (pointA, pointB)</code>: computes geodesic distance between 2 points on a triangular mesh. See geodesic-distance to know about function parameters.  </li> <li><code>geodesicDistance (landmark)</code>: computes geodesic distances between all points on a triangular mesh to a given point (landmark). See geodesic-distance-landmark to know about function parameters.   </li> <li><code>geodesicDistance (curve)</code>: computes geodesic distances between all points on mesh and set of points (curve)  <code>computeMeanNormals</code>: computes the average surface normal for each mesh vertex in a given set of triangular meshes with vertex-wise correspondences and returns a field containing a normal vector for each mesh vertex. See mean-normals to know about function parameters. </li> </ul> </li> </ul> </li> <li> <p>New <code>Mesh</code> query/operator tools: The following tools are supported from all three different interfaces - command line, C++ and Python:    </p> <ul> <li><code>operator+=</code>: appends a mesh to an existing mesh. The result of this operator is a single mesh with a single vertex and face lists.</li> <li><code>closestPoint</code>: returns the closest point on a face in the mesh to a given point in space. See closest-point to know about function parameters. </li> <li><code>closestPointId</code>: returns closest point id in the mesh to a given point in space   </li> <li><code>points</code>: returns matrix with number of points with (x,y,z) coordinates of each point   </li> <li><code>faces</code>: returns matrix with number of faces with indices of the three points from which each face is composed   </li> <li><code>getFace</code>: return indices of the three points with which the face at the given index is composed   </li> </ul> </li> <li> <p><code>Mesh</code> fields: Added support for passing multi-valued fields in addition to scalar fields. Previously field operations such as <code>getField</code>, <code>setField</code> supported only single-value components. Now, these operations can be used for multi-valued components as well. This is useful for associated surface meshes with positional (i.e., spatially varying) features, e.g., application-specific features such as cortical thickness and bone density, and computationally driven features such as geodesics to anatomical landmarks, curvatures, and surface normals.   </p> </li> <li> <p>Free-form constraints (FFCs): FFCs support has been added. Added a unit test for FFCs, a typical sphere unit test with a constraint that cuts the sphere like a tennis ball grove. Also added a unit test with two domains, both spheres in different locations. The first sphere has one cutting plane and 25 sphere constraints, and the second sphere has one cutting plane and one free form constraint. See Free-Form Constraints for more details.</p> </li> </ul>"},{"location":"about/release-notes.html#shapeworks-front-end","title":"ShapeWorks Front-end","text":"<ul> <li> <p>Multiple domains in Studio: Support for multiple alignment strategies is now present in Studio. It allows analysis with and without articulation with a choice of reference domain or global alignment. See Multiple Domain Alignments</p> </li> <li> <p>New analysis features in Studio: Shape evaluation charts for compactness, specificity, and generalization have been added. See for Metrics Panel more details.</p> </li> <li> <p>Usability features in Studio: New usability features such as group p-value display, feature map scalar control, surface opacity controls on a per doamin basis, message history window, suppressible error dialog, narrow band optimization parameter, multiple domain expore options (combined and support) and allow initial landmark points. See New in ShapeWorks Studio 6.2 for more details.</p> </li> </ul>"},{"location":"about/release-notes.html#users-support","title":"User's Support","text":"<ul> <li> <p>Shape cohort generation: Added segmentation and image generation for 2D contour supershapes. See this Jupyter Notebook for more details.</p> </li> <li> <p>Analyzing the group differences: A new use case has been added, demonstrating the functionality of shape statistics tools to perform hypothesis testing of group shape differences. See Femur: Group Difference Statistics in Python for more details.   </p> </li> <li> <p>Sub-sampling for multiple domains: We can now perform subsampling for multiple domains data by combining the individual shapes from all the domains and generating combined shapes. We perform a clustering-based subset selection on the combined shapes so that the subset is representative of the entire dataset and all domains. The representative subset of the specified sample size will be helpful to run through the SSM pipeline so that the use case runs faster and uses less memory.</p> </li> <li> <p>API reference in Documentation: Information about different classes (e.g Image), functions (e.g Image::antialias), function parameters, function return types in C++ API has been added. Check out Groups, Classes, Namespaces, Files for more details.</p> </li> </ul>"},{"location":"about/release-notes.html#deep-learning","title":"Deep Learning","text":"<ul> <li>DeepSSM in Studio: The ability to run DeepSSM has been added to Studio. See DeepSSM in Studio for more details.</li> </ul>"},{"location":"about/release-notes.html#improvements","title":"Improvements","text":""},{"location":"about/release-notes.html#shapeworks-back-end_1","title":"ShapeWorks Back-end","text":"<ul> <li> <p>Safe construction of <code>Image</code> instances in Python: Images can now be safely constructed without copying and passed without copying from/to Python. In particular, passing Images for rendering using <code>pyvista</code> is now transparent and copy-free (note: copying is still supported if necessary). A Jupyter Notebook was added to demonstrate <code>Image</code> initialization and passing.</p> </li> <li> <p>Efficient data sharing between Python and C++: Added efficient sharing of large data between Python and C++ (for both <code>Mesh</code> fields and <code>Image</code> data) that enables Python tools which access <code>Mesh</code> fields or <code>Image</code> data for visualization and analysis, or wish to create an Image or add fields from NumPy to a <code>Mesh</code>, to do so with optimal efficiency without fear of memory leak due to mishandled transfers. </p> </li> <li> <p>Improved Python APIs: <code>Coordsys</code> of images in Python can now be set using <code>setCoordsys</code>. Fixed Python bindings and improved interactive help where necessary. More efficient conversion of shapeworks <code>Mesh</code> in Python to vtk mesh by creating a <code>PolyData</code> instead of performing IO operations.</p> </li> <li> <p>Transforms in <code>Image</code> and <code>Mesh</code> API: Separate transforms such as center of mass, rigid registration and thin plate spiline can be created. They are passed efficiently and transparently between Python and C++. These transform functions create and accept numpy arrays instead of using proprietary transform type in the Python API. A jupyter notebook was to demonstrate this for images and meshes. </p> </li> <li> <p>Optimizer exports alignment transforms: Write individual procrustes transforms. The ShapeWorks <code>Optimizer</code> can now export individual procrustes transform files if requested. Use the xml tag <code>&lt;write_transform_files&gt; 1 &lt;/write_transform_files&gt;</code> to enable it. Additionally, for project spreadsheets (e.g., Studio), individual procrustes transforms will be added as additional columns in the data sheet. See Optimize for more details.</p> </li> <li> <p>Improved testing: More robust testing of Python tests was achieved by adding code to ensure that all tests are performed for all functions, whereas before the test failure was reported immediately without testing if any related functions failed. Concrete seeding of random number generators (only for testing) is utilized to ensure objective comparison of results across all platforms. Improved verification of use case testing by comparing shape statistics compactness, generalization, and specificity against a good shape model instead of checking for a file. A log file (<code>verify.log</code>) is written that contains the use case outputs and summary.</p> </li> </ul>"},{"location":"about/release-notes.html#users-support_1","title":"User's Support","text":"<ul> <li> <p>Use cases: Added <code>--mesh_mode</code> option to image-based use cases. When running in mesh mode, after grooming segmentations, distance transforms are converted to meshes, and optimization is done directly on meshes, saving memory footprint and allowing the usage of geodesic distances for particle repulsion. This enables improved modeling for thin structures and high curvature regions. See Use Case Documentation for more details. </p> </li> <li> <p>Improved use cases documentation: Restructured use cases documentation to reduce repetition and better highlight the focus and differences of each demonstration. Added relevant documentation links for every step and parameter in use case descriptions. Reorganized use case documentation based on category (i.e., mesh-based, constraint-based, etc.). See Getting Started with Use Cases for information on running use cases and Examples for an overview of released use cases. More explanation of interpreting modes of variation in Shapes. What &amp; From Where?.</p> </li> <li> <p>Restructured <code>ellipsoid_evaluate</code> use case: The computation time for calculating specificity, compactness, and generalization metrics have been dramatically reduced. A 50X speedup was experienced when calculating evaluation metrics for all modes for a dataset with 75 shapes, each with 1024 particles. We can now calculate the evaluation metrics for all the modes or query the values for a specified mode. The use case has been modified to demonstrate these functionalities. See Ellipsoid: Shape Evaluation in Python for more details.</p> </li> </ul>"},{"location":"about/release-notes.html#fixes_11","title":"Fixes","text":""},{"location":"about/release-notes.html#shapeworks-back-end_2","title":"ShapeWorks Back-end","text":"<ul> <li>Memory leak: Fixed memory leak issues in <code>FEMesh</code> operations</li> </ul>"},{"location":"about/release-notes.html#shapeworks-front-end_1","title":"ShapeWorks Front-end","text":"<ul> <li>Fix processing of all orientation images: We have fixed ShapeWorks to handle all orientations of images. Previously, only a subset (such as RAI) was fully compatible with all tools. </li> </ul>"},{"location":"about/release-notes.html#shapeworks-61-2021-06-28","title":"ShapeWorks 6.1 - 2021-06-28","text":""},{"location":"about/release-notes.html#what-is-new_6","title":"What is new?","text":""},{"location":"about/release-notes.html#shapeworks-back-end_3","title":"ShapeWorks Back-end","text":"<ul> <li>Improved shape models for convoluted structures: Geodesic distance-based repulsion is now supported for mesh domains. This improves results on structures with thin and/or convoluted features at the cost of increased memory and runtime. Refer to the <code>thin_cavity_bean</code> use case for an example.</li> <li>Optimizing shape models on contours: N-dimensional contour domains are now supported in ShapeWorks. Refer to the <code>supershapes_1mode_contour</code> use case for an example.</li> <li>Robust and scalable primitive-based constrained surface sampling: Constraints are now implemented by turning the problem into an unconstrained optimization using the augmented lagrangian inequality formulation. The new implementation supports both cutting planes and spheres. It also supports multiple constraints per domain/shape with different types.</li> <li>Consolidated library for shape statistics: The <code>shapeworks</code> computational library is updated to include refactored code for shape statistics, including functions to read particle files and compute eigenvectors, eigenvalues, and PCA loadings. </li> </ul>"},{"location":"about/release-notes.html#shapeworks-front-end_2","title":"ShapeWorks Front-end","text":"<ul> <li>Grooming support for meshes in Studio: Multiple grooming features for mesh domains are added to Studio, including two methods for mesh smoothing, hole filling, mesh centering, and iterative closest point for rigid pre-alignment with automated reference shape selection.</li> <li>Multiple domains support in Studio: Multiple domains are added to Studio where shape models are optimized in the given domains' shared/joint shape spaces to capture inter-domains correlations and interactions. The way multiple domains are implemented allows for an arbitrary number of domains as long as all shape samples in a given cohort have the same domains. Furthermore, the multiple domain support enables modeling scenarios with mixed-type domains (e.g., meshes and contours).</li> <li>Python APIs for shape statistics: Python APIs for principal component analysis (PCA) are added for shape statistics. These APIs include reading particle files and computing eigenvectors, eigenvalues, and PCA loadings. See <code>ellipsoid_pca</code> for a demonstrating example.</li> </ul>"},{"location":"about/release-notes.html#users-support_2","title":"User's Support","text":"<ul> <li> <p>Multi-domain shape cohort generation: Ellipsoid joint generation is added to ShapeWorks' cohort generator python module. Shape cohorts with multiple domains can be generated with options to control the distance separating the domains and modes of variations (size/rotation). These cohorts can be used for troubleshooting multiple domain shape modeling workflows.</p> </li> <li> <p>New use cases: A new use case (<code>ellipsoid_pca</code>) demonstrating the usage of the new PCA tools is added. The <code>thin_cavity_bean</code> use case is added to demonstrate geodesic distance-based particle-to-particle interactions to demonstrate improved shape statistics and surface sampling for thin and convoluted structures. The <code>supershapes_1mode_contour</code> use case is added to demonstrate shape modeling using contour domains. Another two new use cases, <code>ellipsoid_multiple_domain</code> and <code>ellipsoid_multiple_domain_mesh</code>, are added to demonstrate a typical shape modeling workflow for multiple domains using binary segmentations and surface meshes, respectively.</p> </li> </ul>"},{"location":"about/release-notes.html#improvements_1","title":"Improvements","text":""},{"location":"about/release-notes.html#shapeworks-back-end_4","title":"ShapeWorks Back-end","text":"<ul> <li>Particle splitting is agnostic to constraints: Particle splitting and constraints will no longer require that no particle violates constraints. It will work even if a particle violates a constraint. Multiple unit tests are added.</li> <li>Mesh reconstruction for multiple meshes: The warp-mesh command is extended to work with multiple meshes at the same time with the same reference mesh and points.</li> <li>Improvements to the <code>Image</code> and <code>Mesh</code> libraries: Exact specification of crop regions and clip plane for both images and meshes are enabled.</li> <li>Better error detection and handling.</li> <li>More robust automated testing to ensure improvements do not break existing functionality.</li> </ul>"},{"location":"about/release-notes.html#shapeworks-front-end_3","title":"ShapeWorks Front-end","text":"<ul> <li>Multiple domain support: <code>OptimizeUtils</code> and <code>AnalyzeUtils</code> are updated to handle multiple domain datasets.</li> <li>Restructured use cases: Depreciated <code>GroomUtils</code>, <code>CommonUtils</code>, and <code>EvaluationUtils</code>. All use cases are restructured to make the grooming steps more transparent and demonstrate the usage of Python APIs with inline documentation. </li> <li>Improved ShapeWorks Python module library coverage: The entire ShapeWorks library framework now accessible via Python bindings. </li> <li>Python types support in ShapeWorks Python module: ShapeWorks Python module uses generic Python types (e.g., numpy, arrays, lists) rather than opaque wrappers for parameters to/from ShapeWorks objects. It is now possible to instantiate shapeworks.Image from a numpy array. One can now request raw image data as a numpy array. </li> <li>Safe dot-chain operations in ShapeWorks Python module:  The \u201cdot chain\u201d operations are now safely enabled (e.g., <code>img.translate([tx, ty, tz]).rotate(45, shapeworks::Z).scale([sx, sy, sz))</code>)</li> <li><code>RunUseCase</code> improvements: <code>RunUseCase</code> no longer requires <code>--use_case</code> before the use case name. This makes it simpler to use since omitting a use case name immediately prints help, which itself shows the list of use cases as a required argument rather than listing them with the other optional args. <code>RunUseCase</code> no longer accepts paths to shapeworks executables or Python modules. All of these are in the user's conda environment, or set using the <code>devenv</code> for testing by developers.</li> </ul>"},{"location":"about/release-notes.html#deep-learning-shape-modeling","title":"Deep Learning &amp; Shape Modeling","text":"<ul> <li>Refactored DeepSSM: Defined a config file for DeepSSM parameters that are used in training and testing. This will be helpful for parameter tuning, model comparison, and adding additional functionality and parameters to DeepSSM.</li> <li>DeepSSM with fine-tuning: A fine-tuning option has been added to DeepSSM. This allows the model to learn the mapping between the PCA space to the correspondence point space, improving accuracy.</li> <li>Improved DeepSSM evaluation: DeepSSM evaluation has been adapted to use ShapeWorks mesh warp function and Python binding mesh distance function.</li> <li>DeepSSM on both GPU and CPU: The DeepSSM use case has been adapted to run on both GPU and CPU. It is considerably faster on GPU but no longer exits when running on CPU.</li> </ul>"},{"location":"about/release-notes.html#users-support_3","title":"User's Support","text":"<ul> <li>Improved documentation: More clear documentation both from Python, the command line, and online are added.</li> <li>Improved notebooks: Notebooks are significantly simplified by moving helper functions into the ShapeWorks Python module, reducing redundant information, and using only the PyVista library for visualization. </li> <li>Improved installation: Users no longer are required to modify PATHs or pass parameters to find executables or import the ShapeWorks Python module. Installation works even if non-standard installation directories are used and it works on all platforms.</li> <li>New shapeworks environments can now be created using <code>install_shapeworks [name]</code>: This supports multiple installations on the same platform, where users can change installation just by activating a different conda environment.</li> <li>Clean installation for ShapeWorks Python module: ShapeWorks Python module is now seamlessly installed as part of ShapeWorks suite installation on all platforms. The Python module no longer requires any special path modifications to import. </li> </ul>"},{"location":"about/release-notes.html#fixes_12","title":"Fixes","text":""},{"location":"about/release-notes.html#shapeworks-back-end_5","title":"ShapeWorks Back-end","text":"<ul> <li>Image to Array: ShapeWorks image functionality is fixed such that an image can be successfully converted to a numpy array and back to a ShapeWorks image. </li> </ul>"},{"location":"about/release-notes.html#shapeworks-front-end_4","title":"ShapeWorks Front-end","text":"<ul> <li>Notebook visualization: Volume renderings using ITK Widgets were causing notebooks to crash on some platforms. The notebooks are now updated to no longer use ITK Widgets for visualization and instead use the more robust and stable PyVista library. </li> <li>Use case file writing: RunUseCase.py has been updated to check that the current folder is writable before proceeding so that use case output can be saved. </li> </ul>"},{"location":"about/release-notes.html#deep-learning-shape-modeling_1","title":"Deep Learning &amp; Shape Modeling","text":"<ul> <li>DeepSSM evaluation: The DeepSSM evaluation step in the use case is updated to use ShapeWorks mesh distance rather than the deprecated SurfaceToSurfaceDistance command. </li> </ul>"},{"location":"about/release-notes.html#shapeworks-60-2021-03-30","title":"ShapeWorks 6.0 - 2021-03-30","text":""},{"location":"about/release-notes.html#whats-new","title":"What's New","text":""},{"location":"about/release-notes.html#users-support_4","title":"User's Support","text":"<ul> <li>New discussion forum: We started an online discussion forum (shapeworks.discourse.group). This forum is a place for ShapeWorks users to discuss how to customize shape modeling workflows for their own use cases, troubleshoot issues end-users facing when using ShapeWorks, keep track of suggestions to improve the software and documentation, and ensure awareness of the latest ShapeWorks tools within the research community. </li> <li>Tiny tests for use cases: All use cases now have a tiny test that can be run using the <code>--tiny_test</code> option. When the tiny test is run, only the data necessary for the test is downloaded rather than all of the data.</li> <li>Running use cases on subsets: All of the use cases (mesh or segmentation based) can now be run on a subset of the data using the <code>--use_subsample</code> option. Note that the entire dataset is downloaded in this case so that a subset that is representative of the entire dataset can be selected.</li> <li>Generating shape cohorts: Example shape cohorts with analytic correspondences can now be generated using the ShapeWorks package <code>GenerateShapeCohort</code>. Currently, cohorts of parameterized ellipsoids or supershapes can be generated. Options are available to specify the degree to which the cohort is groomed (i.e., a cohort can be generated to be in alignment or misaligned in various ways). These cohorts can help with troubleshooting the shape modeling workflow.</li> <li>Notebook demonstrating cohort generation: A Jupyter notebook was added that demonstrates how to use GenerateShapeCohort.</li> </ul>"},{"location":"about/release-notes.html#shapeworks-back-end_6","title":"ShapeWorks Back-end","text":"<ul> <li> <p>Support for use_normals with meshes: Added support for surface normals when optimizing directly on meshes. This results in improved shape models on thin domains. See ShapeWorks Directly on Meshes for more details.</p> </li> <li> <p>Consolidation of mesh-based grooming tools: Updated the <code>shapeworks</code> API to include mesh-based grooming tools (smooth, decimate, invert normals, reflect, alignment, fill holes, probe volume at mesh vertices, clip, translate, scale, bounding box, quality control, surface to surface distance, to image and to distance transform). Added mesh-based query tools (center, center of mass, number of points, number of faces, get field names, set field, get field, set field value, get field value, get field range, get field mean, get field std and comparison). This includes a full complement of unit tests.</p> </li> </ul>"},{"location":"about/release-notes.html#all-in-one-studio-front-end","title":"All-in-one Studio Front-end","text":"<ul> <li>Mesh support in Studio: Added support for mesh inputs with minimal grooming. See New in ShapeWorks Studio for more details.</li> <li>New and faster surface reconstruction: Added a new surface reconstruction method with support for both mesh or image inputs. This method is much faster and is the new default. See New in ShapeWorks Studio for more details.</li> <li>Feature maps support for meshes: Added support for loading and displaying scalar values from mesh inputs. See New in ShapeWorks Studio for more details.</li> <li>User help in Studio: Added user interface tooltips and Help-&gt;Keyboard shortcuts.</li> <li>Detailed optimization progress: Added particle count, initialization/optimization phase, and iteration count on the status bar in addition to the progress bar. (user feature request)</li> <li>Enabled aborting grooming: Added ability to abort grooming step.</li> </ul>"},{"location":"about/release-notes.html#deep-learning-shape-modeling_2","title":"Deep Learning &amp; Shape Modeling","text":"<ul> <li>DeepSSM now saves both the \"best\" and \"final\" model: The final model is saved after all training epochs have run. The best model is saved after the epoch that had the lowest prediction error on the validation set. The best model makes use of early stopping to prevent overfitting.</li> <li>Visualization of DeepSSM errors: The error meshes that are output from running the DeepSSM use case can now be visualized in Studio. These meshes have a distance scalar field that captures the distance between the true and predicted mesh. To view in Studio simply run: <code>ShapeWorksStudio path/to/error/mesh.vtk</code>.</li> <li>Data augmentation handles modeling scenarios that need Procrustes alignment: Data augmentation can now be run on a dataset for which Procrustes was used in optimization. When both the local and world .particle files are passed as arguments for data augmentation, the translation is accounted for in the augmented data.</li> <li>Visualizing data augmentation: Parallel violin plots are used to compare the distribution of real and augmented data visually.</li> <li>Demonstrating data augmentation: A Jupyter notebook that demonstrates the data augmentation process has been added. In this notebook, parallel violin plots are used to compare the distribution of real and augmented data visually.</li> </ul>"},{"location":"about/release-notes.html#improvements_2","title":"Improvements","text":""},{"location":"about/release-notes.html#users-support_5","title":"User's Support","text":"<ul> <li>Improved Python grooming utils: GroomUtils.py now uses Python binding rather than calling command-line tools.</li> </ul>"},{"location":"about/release-notes.html#shapeworks-back-end_7","title":"ShapeWorks Back-end","text":"<ul> <li>Enable multi-threading on Mac platforms: Switched from OpenMP to TBB (thread building blocks), allowing multithreading on Mac. Performance improvements include a ~4x speedup on Mac laptop and same speed or better on Linux/Windows.</li> <li>Performance improvements in <code>shapeworks optimize</code>: ~20% faster optimization in mesh and image domains by replacing specific data structures (that were initially in place to allow interactive removal of particles during the optimization). ~50% faster optimization in mesh domain by caching nearest-triangle lookups.</li> </ul>"},{"location":"about/release-notes.html#all-in-one-studio-front-end_1","title":"All-in-one Studio Front-end","text":"<ul> <li>Improved Studio viewer: Added ability to use 2 viewers (in between 1 and 4). Added ability to choose orientation marker (medical, triad) and location (corner).</li> <li>Improved Studio interface: Added new checkbox for automatic glyph sizing. Added support for drag and drop of images and meshes. Scalar bar color is now opposite of background color (e.g., when the background is white, the text should be dark) (user request).</li> <li>Improved responsiveness: Improved particle shape statistics computation speed. Improved user interface responsiveness during optimization. Improved distance transform loading for surface reconstruction.</li> <li>Improved error handling: Enhanced error handling and graceful reporting of errors such as attempts to write/save to read-only directories and filesystems.</li> </ul>"},{"location":"about/release-notes.html#deep-learning-shape-modeling_3","title":"Deep Learning &amp; Shape Modeling","text":"<ul> <li>More control on data augmentation: In data augmentation, the user can now either specify how many PCA components to retain in embedding OR what percentage of population variability to retain. For example, suppose the user specifies that 95% of population variability should be kept. In that case, the number of components will be automatically selected such that less than 5% of shape variation is lost in embedding.</li> </ul>"},{"location":"about/release-notes.html#fixes_13","title":"Fixes","text":""},{"location":"about/release-notes.html#shapeworks-back-end_8","title":"ShapeWorks Back-end","text":"<ul> <li>Replaced mesh library: Replaced backend mesh library to fix bugs that caused optimizer crashing when optimizing particles directly on meshes.</li> <li>Gradient of normals for image domain: Corrected a long-standing bug where we used the hessian in place of the gradient of the normal. If you have an existing use case with use_normals enabled, the normal weighting may have to be adjusted.</li> <li>Cutting planes constraints for mesh domains: Fixed a bug in the integration of mesh domains with cutting planes constraints, where the optimization gets stuck due to the fact that constraints get violated when not being considered by geodesic walks.</li> </ul>"},{"location":"about/release-notes.html#all-in-one-studio-front-end_2","title":"All-in-one Studio Front-end","text":"<ul> <li>Fixed bugs in Data: Fixed a bug when adding and removing shapes. Studio now appends <code>.xlsx</code> when saving a project file.</li> <li>Fixed bugs in Optimize: Studio optimize default for initial relative weighting is smaller than relative weighting to enable a better surface sampling during initialization. Enable file menu when the optimization is aborted.</li> <li>Fixed bugs in Analyze: Limit PCA modes to the number of samples - 1. Surface reconstruction for spheres is fixed. Fixed a bug that produced blank screens and error messages on the consoles when switching out of analysis while PCA animation is running. Fixed a sample display bug that occurred when loading XML project for analysis and exploring individual samples after switching to PCA animation.</li> </ul>"},{"location":"about/release-notes.html#shapeworks-550-2020-10-15","title":"ShapeWorks 5.5.0 - 2020-10-15","text":""},{"location":"about/release-notes.html#whats-new_1","title":"What's New","text":""},{"location":"about/release-notes.html#users-support_6","title":"User's Support","text":"<ul> <li> <p>Revamped documentation: New documentation to support both end-users and open-source developer community in one easily navigable place. This documentation includes background information about statistical shape modeling, the scientific premise of ShapeWorks, and how to get started. It also demonstrates the latest software features, exemplar use cases, and instructions to build/install ShapeWorks.</p> </li> <li> <p>Optimized shape models for use cases: All datasets on the ShapeWorks Data Portal now have the shape model output from running the use cases with a corresponding <code>analyze.xml</code> for launching Studio. Users can <code>cd</code> to where the data is extracted and call <code>ShapeWorksStudio analyze.xml</code> to visualize these shape models.</p> </li> </ul>"},{"location":"about/release-notes.html#shapeworks-back-end_9","title":"ShapeWorks Back-end","text":"<ul> <li> <p>ShapeWorks directly on meshes: ShapeWorks now supports particle optimization directly on triangular surface meshes. This mesh support also enables working with open meshes without additional user inputs. See ShapeWorks Directly on Meshes for more details. For exemplar use cases, see Femur Mesh: SSM directly from meshes and Lumps: SSM directly from meshes to learn how to get started. This mesh support allows for significant memory savings (9.2GB to 53MB in the femur use case).</p> </li> <li> <p>New ShapeWorks API: Consolidation of image-based and segmentation-based grooming tools that creates a stable and reusable API making it much easier and more flexible for users to groom their datasets. This includes a full complement of unit tests. See ShapeWorks API for more details.</p> </li> </ul>"},{"location":"about/release-notes.html#all-in-one-studio-front-end_3","title":"All-in-one Studio Front-end","text":"<ul> <li> <p>Feature maps support: Studio supports the integration of 3d volume feature maps to map imaging data to the optimized shape model. See New in ShapeWorks Studio for more details.</p> </li> <li> <p>New interface for group analysis: Studio supports group definitions from spreadsheets. The new interface supports multiple group sets within the same project file and categorical groups compared to the old binary groups (i.e., yes/no) setting. See New in ShapeWorks Studio for more details.</p> </li> <li> <p>User notes in Studio: Studio stores/loads a rich text notes section in the spreadsheet.</p> </li> </ul>"},{"location":"about/release-notes.html#deep-learning-shape-modeling_4","title":"Deep Learning &amp; Shape Modeling","text":"<ul> <li> <p>New Python package for model-based data augmentation: A Python package for data augmentation has been added. See Data Augmentation for Deep Learning for more details.</p> </li> <li> <p>DeepSSM Python package: A Python package has been added for a deep learning framework that estimates statistical representations of shape directly from unsegmented images once trained. See SSMs Directly from Images for more details. </p> </li> <li> <p>New DeepSSM use case: We added a new use case called <code>deep_ssm</code> that demonstrates data augmentation and deep learning on the femur data. See Femur SSM Directly from Images for more details. </p> </li> </ul>"},{"location":"about/release-notes.html#improvements_3","title":"Improvements","text":""},{"location":"about/release-notes.html#users-support_7","title":"User's Support","text":"<ul> <li> <p>Improved data/output organization for use cases: Use case organization has been updated such that downloaded data goes into one folder (<code>ShapeWorks/Examples/Python/Data/</code>) and use case output goes into another (<code>ShapeWorks/Examples/Python/Output/</code>). This organization will avoid re-downloading use case datasets if the user deleted the output folder. </p> </li> <li> <p>Enable only-shape data for the femur use case: Femur use case demonstrates the processing workflow starting from surface meshes and can now be run without grooming images (in case they are not available). To groom with images, use the <code>--start_with_image_and_segmentation_data</code> tag. If this tag is not included, images will not be used in grooming.</p> </li> </ul>"},{"location":"about/release-notes.html#shapeworks-back-end_10","title":"ShapeWorks Back-end","text":"<ul> <li>Improved constrained particle optimization: An improved implementation for cutting planes that support single and multiple cutting planes per sample has been added. This can be used in modeling scenarios where statistical modeling/analysis is needed for a region-of-interest on the anatomy/object-class at hand without having to affect the input data. See Ellipsoid: Cutting Planes and Femur with Cutting Planes for exemplar use cases.</li> </ul>"},{"location":"about/release-notes.html#all-in-one-studio-front-end_4","title":"All-in-one Studio Front-end","text":"<ul> <li>Improved interface design for Studio: User interface improvements to Studio have been added. These improvements include collapsable analysis panels to improve screen usability, a cleaner file menu, an about box that shows website information and software version, and a splash screen that enables the opening of new/recent projects.</li> </ul>"},{"location":"about/release-notes.html#fixes_14","title":"Fixes","text":""},{"location":"about/release-notes.html#shapeworks-back-end_11","title":"ShapeWorks Back-end","text":"<ul> <li> <p>Constraint-aware particles initialization and optimization: The initialization and optimization steps now respect the user-defined constraints when using signed distance transforms. Hence, at no point, particles will violate the constraints, allowing for arbitrarily defined cutting planes. </p> </li> <li> <p>Constraint-aware particles splitting: Added constraint aware particle splitting for signed distance transforms. The particle splitting only occurred towards a single quadrant. This is fixed by allowing particle splits to shift in a different direction for each particle in every domain.</p> </li> <li> <p>Constraint-aware particle projection: Projecting particles on the surface while manipulating/optimizing particle position now respects the user-defined constraints.</p> </li> </ul>"},{"location":"about/release-notes.html#shapeworks-541-2020-06-15","title":"ShapeWorks 5.4.1 - 2020-06-15","text":""},{"location":"about/release-notes.html#fixes_15","title":"Fixes","text":"<ul> <li>ShapeWorks Studio: Fixed crash when importing data on a new/blank project.    </li> </ul>"},{"location":"about/release-notes.html#shapeworks-540-2020-06-10","title":"ShapeWorks 5.4.0 - 2020-06-10","text":""},{"location":"about/release-notes.html#whats-new_2","title":"What's New","text":"<ul> <li>New, flexible ShapeWorks project file format: New spreadsheet (XLSX) based project file format that can easily handle multiple shape modeling scenarios. It is now fully integrated into Studio. See the ellipsoid studio example in <code>Examples/Studio/ellipsoid.xlsx</code> for an example.</li> <li>Exporting shape parameters: Added PCA Raw Component Score Export to Studio.</li> <li>New Getting Started documentation: New Getting started documentation goes over shape modeling workflow documentation, different ShapeWorks interfaces with a video illustration for Studio.</li> <li>Lower memory footprint and faster optimization: ShapeWorks is now using OpenVDB, a more memory-efficient data structure, for signed distance transforms. Along with other refactoring and code optimizations, ShapeWorks now uses 85% less memory (from 57.09GB to 9.67GB in one use case). Additionally, the particle optimizer is now 2X faster.</li> <li>Automated development builds: We now offer up-to-date development binary builds that track the master branch, available here. Please understand that these are in-progress development builds, not official releases.</li> </ul>"},{"location":"about/release-notes.html#improvements_4","title":"Improvements","text":"<ul> <li>Improved scalability for Studio: Files now loaded on-demand as necessary.</li> <li>Restructured datasets portal: Better and more consistent directory structure for use cases datasets. See datasets guidelines for more details. Visit our ShapeWorks Portal to register and download datasets to run use cases.</li> <li>Lower memory footprint for estimating correspondences for new shapes on existing shape models: For  usage, only distance transforms for the new shapes will be loaded. <li>Improved use case documentation: Better documentation for the RunUseCase input arguments.</li> <li>Documentation for running existing shape models: Added instructions on how to load a pre-trained shape model without running the full pipeline.</li> <li>Consistent cross-platform splitting direction: Correspondence point splits take a random direction, but are now consistent and repeatable across platforms for reproducible shape models.</li>"},{"location":"about/release-notes.html#fixes_16","title":"Fixes","text":"<ul> <li>Mesh export in Studio: Changed exported meshes to be compatible with CloudCompare</li> </ul>"},{"location":"about/release-notes.html#shapeworks-530-2020-02-20","title":"ShapeWorks 5.3.0 - 2020-02-20","text":""},{"location":"about/release-notes.html#whats-new_3","title":"What's New","text":"<ul> <li>Use cases: Added fixed domains use case that demonstrates adding a single shape to an existing shape model</li> <li>Use cases: Added ellipsoid evaluation use that demonstrates the quantitative evaluation of the ellipsoid</li> <li>New commands: Added commands to the <code>shapeworks</code> executable to quantitatively evaluate shape models: read-particle-system, compactness, generalization, specificity</li> <li>New shapeworks executables commands: read-image, write-image, antialias, isoresample, binarize, recenter-image, pad.</li> <li>New build method: Separate build_dependencies script (see Documentation/Build/BUILD.md)</li> </ul>"},{"location":"about/release-notes.html#improvements_5","title":"Improvements","text":"<ul> <li>Use cases: Updated femur use case with an interactive cutting plane selection</li> <li>Studio: Replaced bar chart with explained variance chart</li> </ul>"},{"location":"about/release-notes.html#shapeworks-522-2020-01-09","title":"ShapeWorks 5.2.2 - 2020-01-09","text":""},{"location":"about/release-notes.html#fixes_17","title":"Fixes","text":"<ul> <li>Returned to superbuild.sh build process</li> <li>Fixed non-Qt build</li> <li>Fixed Windows conda_installs.bat</li> <li>Studio: Fixed import and processing of non-RAI image volumes</li> <li>Studio: Fix centering of groomed and reconstructed volumes</li> </ul>"},{"location":"about/release-notes.html#shapeworks-521-2019-11-09","title":"ShapeWorks 5.2.1 - 2019-11-09","text":""},{"location":"about/release-notes.html#fixes_18","title":"Fixes","text":"<ul> <li>Fix examples, binaries</li> </ul>"},{"location":"about/release-notes.html#shapeworks-520-2019-11-07","title":"ShapeWorks 5.2.0 - 2019-11-07","text":""},{"location":"about/release-notes.html#whats-new_4","title":"What's New","text":"<ul> <li>Studio: Added live particle optimization updates</li> <li>Studio: Added \"Stop optimization\" button</li> <li>Use cases: Added a femur use case that demonstrates grooming surface meshes along with imaging data for shape modeling</li> <li>Use cases: Added a left atrium use case that demonstrates grooming images data along with shape data and build multi-scale shape models</li> <li>Use cases: New portal downloadable example data (ellipsoid, left atrium, and femurs)</li> <li>Windows installer and binary releases for Mac and Linux</li> <li>CMake-based superbuild with all dependencies built automatically</li> </ul>"},{"location":"about/release-notes.html#improvements_6","title":"Improvements","text":"<ul> <li>Studio: Added support for reading View2 parameter files</li> <li>Studio: Added legacy (View2) surface reconstructor</li> <li>Studio: Replaced optimization library with same used by ShapeWorksRun</li> </ul>"},{"location":"about/release-notes.html#fixes_19","title":"Fixes","text":"<ul> <li>Studio: Fixes crashes on exit during optimizations (clean shutdown of threads)</li> </ul>"},{"location":"about/team.html","title":"Meet ShapeWorkers!","text":""},{"location":"about/team.html#principal-investigators","title":"Principal Investigators","text":"<ul> <li>Shireen Elhabian</li> </ul>"},{"location":"about/team.html#software-developers","title":"Software Developers","text":"<ul> <li>Alan Morris</li> <li>Nawazish Khan</li> </ul>"},{"location":"about/team.html#researchers","title":"Researchers","text":"<ul> <li>Mokshagna Karanam</li> <li>Zahid Aziz</li> <li>Tushar Kataria</li> </ul>"},{"location":"about/team.html#past-contributors","title":"Past Contributors","text":"<ul> <li>Ross Whitaker</li> <li>Joshua Cates (now @ 3Dio)</li> <li>Manasi Datar (now @ Siemens)</li> <li>Brig Bagley</li> <li>Praful Agrawal (now @ Amazon Inc.)</li> <li>Oleks Korshak (now @ Microsoft)</li> <li>Anupama Goparaju (now @ Galileo Financial Technologies)</li> <li>Atefeh Ghanaatikashani (now @ Tesla Inc.)</li> <li>Karthik Karanth (now @ Adobe)</li> <li>Cameron Christensen</li> <li>Archanasri Subramanian (now @ Amazon)</li> <li>Riddhish Bhalodia (now @ Meta)</li> <li>Jadie Adams (now @ Kitware)</li> <li>Hong Xu (now @ Astera Institute)</li> <li>Krithika Iyer (now postdoc @ Sheikh Zayed Institute for Pediatric Surgical Innovation)</li> </ul>"},{"location":"api/Classes/classColorScheme.html","title":"ColorScheme","text":""},{"location":"api/Classes/classColorScheme.html#public-classes","title":"Public Classes","text":"Name struct rgb"},{"location":"api/Classes/classColorScheme.html#public-functions","title":"Public Functions","text":"Name QColor background_qcolor(int alpha) QColor foreground_qcolor() QColor get_text_color() double get_text_intensity() ColorScheme() ~ColorScheme()"},{"location":"api/Classes/classColorScheme.html#public-attributes","title":"Public Attributes","text":"Name rgb foreground rgb background rgb alt"},{"location":"api/Classes/classColorScheme.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classColorScheme.html#function-background_qcolor","title":"function background_qcolor","text":"<pre><code>inline QColor background_qcolor(\n    int alpha\n)\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#function-foreground_qcolor","title":"function foreground_qcolor","text":"<pre><code>inline QColor foreground_qcolor()\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#function-get_text_color","title":"function get_text_color","text":"<pre><code>inline QColor get_text_color()\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#function-get_text_intensity","title":"function get_text_intensity","text":"<pre><code>inline double get_text_intensity()\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#function-colorscheme","title":"function ColorScheme","text":"<pre><code>inline ColorScheme()\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#function-colorscheme_1","title":"function ~ColorScheme","text":"<pre><code>inline ~ColorScheme()\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classColorScheme.html#variable-foreground","title":"variable foreground","text":"<pre><code>rgb foreground;\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#variable-background","title":"variable background","text":"<pre><code>rgb background;\n</code></pre>"},{"location":"api/Classes/classColorScheme.html#variable-alt","title":"variable alt","text":"<pre><code>rgb alt;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classColorSchemes.html","title":"ColorSchemes","text":"<p>Inherits from std::vector&lt; ColorScheme &gt;</p>"},{"location":"api/Classes/classColorSchemes.html#public-functions","title":"Public Functions","text":"Name ColorSchemes() ~ColorSchemes()"},{"location":"api/Classes/classColorSchemes.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classColorSchemes.html#function-colorschemes","title":"function ColorSchemes","text":"<pre><code>inline ColorSchemes()\n</code></pre>"},{"location":"api/Classes/classColorSchemes.html#function-colorschemes_1","title":"function ~ColorSchemes","text":"<pre><code>inline ~ColorSchemes()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classCustomSlider.html","title":"CustomSlider","text":"<p>Inherits from QSlider</p>"},{"location":"api/Classes/classCustomSlider.html#public-functions","title":"Public Functions","text":"Name CustomSlider(Qt::Orientation orientation, QWidget * parent =nullptr) CustomSlider(QWidget * parent =nullptr)"},{"location":"api/Classes/classCustomSlider.html#protected-functions","title":"Protected Functions","text":"Name virtual void paintEvent(QPaintEvent * ev)"},{"location":"api/Classes/classCustomSlider.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classCustomSlider.html#function-customslider","title":"function CustomSlider","text":"<pre><code>inline explicit CustomSlider(\n    Qt::Orientation orientation,\n    QWidget * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classCustomSlider.html#function-customslider_1","title":"function CustomSlider","text":"<pre><code>explicit CustomSlider(\n    QWidget * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classCustomSlider.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classCustomSlider.html#function-paintevent","title":"function paintEvent","text":"<pre><code>virtual void paintEvent(\n    QPaintEvent * ev\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html","title":"CustomSurfaceReconstructionFilter","text":"<p>Inherits from vtkImageAlgorithm</p>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#public-functions","title":"Public Functions","text":"Name vtkTypeMacro(CustomSurfaceReconstructionFilter , vtkImageAlgorithm ) void PrintSelf(ostream &amp; os, vtkIndent indent) vtkGetMacro(NeighborhoodSize , int ) vtkSetMacro(NeighborhoodSize , int ) vtkGetMacro(SampleSpacing , double ) vtkSetMacro(SampleSpacing , double ) CustomSurfaceReconstructionFilter * New()"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#protected-functions","title":"Protected Functions","text":"Name CustomSurfaceReconstructionFilter() ~CustomSurfaceReconstructionFilter() virtual int RequestInformation(vtkInformation * , vtkInformationVector ** , vtkInformationVector * ) virtual int RequestData(vtkInformation * , vtkInformationVector ** , vtkInformationVector * ) virtual int FillInputPortInformation(int , vtkInformation * )"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#protected-attributes","title":"Protected Attributes","text":"Name int NeighborhoodSize double SampleSpacing"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    CustomSurfaceReconstructionFilter ,\n    vtkImageAlgorithm \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    ostream &amp; os,\n    vtkIndent indent\n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-vtkgetmacro","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    NeighborhoodSize ,\n    int \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-vtksetmacro","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    NeighborhoodSize ,\n    int \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-vtkgetmacro_1","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    SampleSpacing ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-vtksetmacro_1","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    SampleSpacing ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-new","title":"function New","text":"<pre><code>static CustomSurfaceReconstructionFilter * New()\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-customsurfacereconstructionfilter","title":"function CustomSurfaceReconstructionFilter","text":"<pre><code>CustomSurfaceReconstructionFilter()\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-customsurfacereconstructionfilter_1","title":"function ~CustomSurfaceReconstructionFilter","text":"<pre><code>inline ~CustomSurfaceReconstructionFilter()\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-requestinformation","title":"function RequestInformation","text":"<pre><code>virtual int RequestInformation(\n    vtkInformation * ,\n    vtkInformationVector ** ,\n    vtkInformationVector * \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-requestdata","title":"function RequestData","text":"<pre><code>virtual int RequestData(\n    vtkInformation * ,\n    vtkInformationVector ** ,\n    vtkInformationVector * \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#function-fillinputportinformation","title":"function FillInputPortInformation","text":"<pre><code>virtual int FillInputPortInformation(\n    int ,\n    vtkInformation * \n)\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#variable-neighborhoodsize","title":"variable NeighborhoodSize","text":"<pre><code>int NeighborhoodSize;\n</code></pre>"},{"location":"api/Classes/classCustomSurfaceReconstructionFilter.html#variable-samplespacing","title":"variable SampleSpacing","text":"<pre><code>double SampleSpacing;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEAreaCoverage.html","title":"FEAreaCoverage","text":""},{"location":"api/Classes/classFEAreaCoverage.html#public-functions","title":"Public Functions","text":"Name FEAreaCoverage() void SetSelection1(vector&lt; int &gt; &amp; s) void SetSelection2(vector&lt; int &gt; &amp; s) vector&lt; double &gt; Apply(std::shared_ptr&lt; FEMesh &gt; mesh1, std::shared_ptr&lt; FEMesh &gt; mesh2) void AllowBackIntersection(bool b) bool AllowBackIntersection() const void SetAngleThreshold(double w) double GetAngleThreshold() const void SetBackSearchRadius(double R) double GetBackSearchRadius() const"},{"location":"api/Classes/classFEAreaCoverage.html#protected-functions","title":"Protected Functions","text":"Name void UpdateSurface(FEAreaCoverage::Surface &amp; s) bool intersect(const vec3d &amp; r, const vec3d &amp; N, FEAreaCoverage::Surface &amp; surf, Intersection &amp; q) bool faceIntersect(FEAreaCoverage::Surface &amp; surf, const Ray &amp; ray, int nface, Intersection &amp; q)"},{"location":"api/Classes/classFEAreaCoverage.html#protected-attributes","title":"Protected Attributes","text":"Name Surface m_surf1 Surface m_surf2 bool m_ballowBackIntersections double m_angleThreshold double m_backSearchRadius"},{"location":"api/Classes/classFEAreaCoverage.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEAreaCoverage.html#function-feareacoverage","title":"function FEAreaCoverage","text":"<pre><code>FEAreaCoverage()\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-setselection1","title":"function SetSelection1","text":"<pre><code>inline void SetSelection1(\n    vector&lt; int &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-setselection2","title":"function SetSelection2","text":"<pre><code>inline void SetSelection2(\n    vector&lt; int &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-apply","title":"function Apply","text":"<pre><code>vector&lt; double &gt; Apply(\n    std::shared_ptr&lt; FEMesh &gt; mesh1,\n    std::shared_ptr&lt; FEMesh &gt; mesh2\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-allowbackintersection","title":"function AllowBackIntersection","text":"<pre><code>void AllowBackIntersection(\n    bool b\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-allowbackintersection_1","title":"function AllowBackIntersection","text":"<pre><code>bool AllowBackIntersection() const\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-setanglethreshold","title":"function SetAngleThreshold","text":"<pre><code>void SetAngleThreshold(\n    double w\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-getanglethreshold","title":"function GetAngleThreshold","text":"<pre><code>double GetAngleThreshold() const\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-setbacksearchradius","title":"function SetBackSearchRadius","text":"<pre><code>void SetBackSearchRadius(\n    double R\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-getbacksearchradius","title":"function GetBackSearchRadius","text":"<pre><code>double GetBackSearchRadius() const\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEAreaCoverage.html#function-updatesurface","title":"function UpdateSurface","text":"<pre><code>void UpdateSurface(\n    FEAreaCoverage::Surface &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-intersect","title":"function intersect","text":"<pre><code>bool intersect(\n    const vec3d &amp; r,\n    const vec3d &amp; N,\n    FEAreaCoverage::Surface &amp; surf,\n    Intersection &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#function-faceintersect","title":"function faceIntersect","text":"<pre><code>bool faceIntersect(\n    FEAreaCoverage::Surface &amp; surf,\n    const Ray &amp; ray,\n    int nface,\n    Intersection &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFEAreaCoverage.html#variable-m_surf1","title":"variable m_surf1","text":"<pre><code>Surface m_surf1;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#variable-m_surf2","title":"variable m_surf2","text":"<pre><code>Surface m_surf2;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#variable-m_ballowbackintersections","title":"variable m_ballowBackIntersections","text":"<pre><code>bool m_ballowBackIntersections;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#variable-m_anglethreshold","title":"variable m_angleThreshold","text":"<pre><code>double m_angleThreshold;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage.html#variable-m_backsearchradius","title":"variable m_backSearchRadius","text":"<pre><code>double m_backSearchRadius;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html","title":"FEAreaCoverage::Surface","text":""},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#public-functions","title":"Public Functions","text":"Name Surface() int Faces() void Create(std::shared_ptr&lt; FEMesh &gt; m) int Nodes()"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#public-attributes","title":"Public Attributes","text":"Name std::shared_ptr&lt; FEMesh &gt; m_mesh vector&lt; int &gt; m_face vector&lt; int &gt; m_node vector&lt; vec3d &gt; m_pos vector&lt; int &gt; m_lnode vector&lt; vec3d &gt; m_norm vector&lt; vec3d &gt; m_fnorm vector&lt; vector&lt; int &gt; &gt; m_NLT"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#function-surface","title":"function Surface","text":"<pre><code>inline Surface()\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#function-faces","title":"function Faces","text":"<pre><code>inline int Faces()\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#function-create","title":"function Create","text":"<pre><code>void Create(\n    std::shared_ptr&lt; FEMesh &gt; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes()\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_mesh","title":"variable m_mesh","text":"<pre><code>std::shared_ptr&lt; FEMesh &gt; m_mesh;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_face","title":"variable m_face","text":"<pre><code>vector&lt; int &gt; m_face;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_node","title":"variable m_node","text":"<pre><code>vector&lt; int &gt; m_node;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_pos","title":"variable m_pos","text":"<pre><code>vector&lt; vec3d &gt; m_pos;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_lnode","title":"variable m_lnode","text":"<pre><code>vector&lt; int &gt; m_lnode;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_norm","title":"variable m_norm","text":"<pre><code>vector&lt; vec3d &gt; m_norm;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_fnorm","title":"variable m_fnorm","text":"<pre><code>vector&lt; vec3d &gt; m_fnorm;\n</code></pre>"},{"location":"api/Classes/classFEAreaCoverage_1_1Surface.html#variable-m_nlt","title":"variable m_NLT","text":"<pre><code>vector&lt; vector&lt; int &gt; &gt; m_NLT;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEAutoMesher.html","title":"FEAutoMesher","text":""},{"location":"api/Classes/classFEAutoMesher.html#public-functions","title":"Public Functions","text":"Name FEAutoMesher() void BuildMesh(FEMesh * pm) void AutoPartitionSurface(FEMesh &amp; m) void AutoPartitionEdges(FEMesh &amp; m) void AutoPartitionNodes(FEMesh &amp; m) void Repartition(FEMesh &amp; m) void SetSmoothingAngle(double w) double GetSmoothingAngle()"},{"location":"api/Classes/classFEAutoMesher.html#protected-functions","title":"Protected Functions","text":"Name void BuildFaces(FEMesh &amp; m) void BuildEdges(FEMesh &amp; m)"},{"location":"api/Classes/classFEAutoMesher.html#protected-attributes","title":"Protected Attributes","text":"Name FEMesh * m_pm double m_wsmooth"},{"location":"api/Classes/classFEAutoMesher.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEAutoMesher.html#function-feautomesher","title":"function FEAutoMesher","text":"<pre><code>FEAutoMesher()\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-buildmesh","title":"function BuildMesh","text":"<pre><code>void BuildMesh(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-autopartitionsurface","title":"function AutoPartitionSurface","text":"<pre><code>void AutoPartitionSurface(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-autopartitionedges","title":"function AutoPartitionEdges","text":"<pre><code>void AutoPartitionEdges(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-autopartitionnodes","title":"function AutoPartitionNodes","text":"<pre><code>void AutoPartitionNodes(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-repartition","title":"function Repartition","text":"<pre><code>void Repartition(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-setsmoothingangle","title":"function SetSmoothingAngle","text":"<pre><code>inline void SetSmoothingAngle(\n    double w\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-getsmoothingangle","title":"function GetSmoothingAngle","text":"<pre><code>inline double GetSmoothingAngle()\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEAutoMesher.html#function-buildfaces","title":"function BuildFaces","text":"<pre><code>void BuildFaces(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#function-buildedges","title":"function BuildEdges","text":"<pre><code>void BuildEdges(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFEAutoMesher.html#variable-m_pm","title":"variable m_pm","text":"<pre><code>FEMesh * m_pm;\n</code></pre>"},{"location":"api/Classes/classFEAutoMesher.html#variable-m_wsmooth","title":"variable m_wsmooth","text":"<pre><code>double m_wsmooth;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFECVDDecimationModifier.html","title":"FECVDDecimationModifier","text":"<p>More...</p> <p><code>#include &lt;FECVDDecimationModifier.h&gt;</code></p>"},{"location":"api/Classes/classFECVDDecimationModifier.html#public-functions","title":"Public Functions","text":"Name FECVDDecimationModifier()Constructor. FEMesh * Apply(FEMesh * pm)Apply the decimation modifier."},{"location":"api/Classes/classFECVDDecimationModifier.html#public-attributes","title":"Public Attributes","text":"Name double m_pct percentage of target number of clusters/vertices bool m_bcvd double m_sel_pct double m_gradient"},{"location":"api/Classes/classFECVDDecimationModifier.html#detailed-description","title":"Detailed Description","text":"<pre><code>class FECVDDecimationModifier;\n</code></pre> <p>This class implements a modifier that coarses a plygonal mesh using an approximated centroidal voronoi diagram. </p>"},{"location":"api/Classes/classFECVDDecimationModifier.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier.html#function-fecvddecimationmodifier","title":"function FECVDDecimationModifier","text":"<pre><code>FECVDDecimationModifier()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classFECVDDecimationModifier.html#function-apply","title":"function Apply","text":"<pre><code>FEMesh * Apply(\n    FEMesh * pm\n)\n</code></pre> <p>Apply the decimation modifier. </p>"},{"location":"api/Classes/classFECVDDecimationModifier.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier.html#variable-m_pct","title":"variable m_pct","text":"<pre><code>double m_pct;\n</code></pre> <p>percentage of target number of clusters/vertices </p>"},{"location":"api/Classes/classFECVDDecimationModifier.html#variable-m_bcvd","title":"variable m_bcvd","text":"<pre><code>bool m_bcvd;\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier.html#variable-m_sel_pct","title":"variable m_sel_pct","text":"<pre><code>double m_sel_pct;\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier.html#variable-m_gradient","title":"variable m_gradient","text":"<pre><code>double m_gradient;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html","title":"FECVDDecimationModifier::Cluster","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#public-functions","title":"Public Functions","text":"Name Cluster() int faces() const"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#public-attributes","title":"Public Attributes","text":"Name vec3d m_sgamma double m_srho vector&lt; int &gt; m_fid"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#function-cluster","title":"function Cluster","text":"<pre><code>inline Cluster()\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#function-faces","title":"function faces","text":"<pre><code>inline int faces() const\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#variable-m_sgamma","title":"variable m_sgamma","text":"<pre><code>vec3d m_sgamma;\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#variable-m_srho","title":"variable m_srho","text":"<pre><code>double m_srho;\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1Cluster.html#variable-m_fid","title":"variable m_fid","text":"<pre><code>vector&lt; int &gt; m_fid;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html","title":"FECVDDecimationModifier::NODE","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-types","title":"Public Types","text":"Name enum @0"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-functions","title":"Public Functions","text":"Name NODE() bool AttachToCluster(int n)"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-attributes","title":"Public Attributes","text":"Name int c int nc"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#enum-0","title":"enum @0","text":"Enumerator Value Description MAX_CLUSTERS =23"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#function-node","title":"function NODE","text":"<pre><code>inline NODE()\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#function-attachtocluster","title":"function AttachToCluster","text":"<pre><code>bool AttachToCluster(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#variable-c","title":"variable c","text":"<pre><code>int c;\n</code></pre>"},{"location":"api/Classes/classFECVDDecimationModifier_1_1NODE.html#variable-nc","title":"variable nc","text":"<pre><code>int nc;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFECoreMesh.html","title":"FECoreMesh","text":"<p>More...</p> <p><code>#include &lt;FECoreMesh.h&gt;</code></p> <p>Inherited by FEMesh</p>"},{"location":"api/Classes/classFECoreMesh.html#public-functions","title":"Public Functions","text":"Name FECoreMesh()constructor virtual ~FECoreMesh()destructor virtual void Create(int nodes, int elems, int faces =0, int edges =0) =0allocate space for mesh bool IsType(int ntype)check the type of the mesh virtual int Elements() const =0total number of elements virtual FEElement_ &amp; ElementRef(int n) =0return reference to element virtual FEElement * ElementPtr(int n =0) =0return pointer to element int Nodes() const int Edges() const int Faces() const FENode &amp; Node(int n) FEEdge &amp; Edge(int n) FEFace &amp; Face(int n) FENode * NodePtr(int n =0) FEEdge * EdgePtr(int n =0) FEFace * FacePtr(int n =0)"},{"location":"api/Classes/classFECoreMesh.html#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; FENode &gt; m_Node FE nodes. std::vector&lt; FEEdge &gt; m_Edge FE edges. std::vector&lt; FEFace &gt; m_Face FE faces."},{"location":"api/Classes/classFECoreMesh.html#detailed-description","title":"Detailed Description","text":"<pre><code>class FECoreMesh;\n</code></pre> <p>This class defines a simple mesh structure that provides basic container services for storing mesh data. </p>"},{"location":"api/Classes/classFECoreMesh.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFECoreMesh.html#function-fecoremesh","title":"function FECoreMesh","text":"<pre><code>FECoreMesh()\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classFECoreMesh.html#function-fecoremesh_1","title":"function ~FECoreMesh","text":"<pre><code>virtual ~FECoreMesh()\n</code></pre> <p>destructor </p>"},{"location":"api/Classes/classFECoreMesh.html#function-create","title":"function Create","text":"<pre><code>virtual void Create(\n    int nodes,\n    int elems,\n    int faces =0,\n    int edges =0\n) =0\n</code></pre> <p>allocate space for mesh </p> <p>Reimplemented by: FEMesh::Create</p>"},{"location":"api/Classes/classFECoreMesh.html#function-istype","title":"function IsType","text":"<pre><code>bool IsType(\n    int ntype\n)\n</code></pre> <p>check the type of the mesh </p>"},{"location":"api/Classes/classFECoreMesh.html#function-elements","title":"function Elements","text":"<pre><code>virtual int Elements() const =0\n</code></pre> <p>total number of elements </p> <p>Reimplemented by: FEMesh::Elements</p>"},{"location":"api/Classes/classFECoreMesh.html#function-elementref","title":"function ElementRef","text":"<pre><code>virtual FEElement_ &amp; ElementRef(\n    int n\n) =0\n</code></pre> <p>return reference to element </p> <p>Reimplemented by: FEMesh::ElementRef</p>"},{"location":"api/Classes/classFECoreMesh.html#function-elementptr","title":"function ElementPtr","text":"<pre><code>virtual FEElement * ElementPtr(\n    int n =0\n) =0\n</code></pre> <p>return pointer to element </p> <p>Reimplemented by: FEMesh::ElementPtr</p>"},{"location":"api/Classes/classFECoreMesh.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes() const\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-edges","title":"function Edges","text":"<pre><code>inline int Edges() const\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-faces","title":"function Faces","text":"<pre><code>inline int Faces() const\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-node","title":"function Node","text":"<pre><code>inline FENode &amp; Node(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-edge","title":"function Edge","text":"<pre><code>inline FEEdge &amp; Edge(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-face","title":"function Face","text":"<pre><code>inline FEFace &amp; Face(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-nodeptr","title":"function NodePtr","text":"<pre><code>inline FENode * NodePtr(\n    int n =0\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-edgeptr","title":"function EdgePtr","text":"<pre><code>inline FEEdge * EdgePtr(\n    int n =0\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#function-faceptr","title":"function FacePtr","text":"<pre><code>inline FEFace * FacePtr(\n    int n =0\n)\n</code></pre>"},{"location":"api/Classes/classFECoreMesh.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFECoreMesh.html#variable-m_node","title":"variable m_Node","text":"<pre><code>std::vector&lt; FENode &gt; m_Node;\n</code></pre> <p>FE nodes. </p>"},{"location":"api/Classes/classFECoreMesh.html#variable-m_edge","title":"variable m_Edge","text":"<pre><code>std::vector&lt; FEEdge &gt; m_Edge;\n</code></pre> <p>FE edges. </p>"},{"location":"api/Classes/classFECoreMesh.html#variable-m_face","title":"variable m_Face","text":"<pre><code>std::vector&lt; FEFace &gt; m_Face;\n</code></pre> <p>FE faces. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEEdge.html","title":"FEEdge","text":"<p>Inherits from FEItem</p>"},{"location":"api/Classes/classFEEdge.html#public-types","title":"Public Types","text":"Name enum @1"},{"location":"api/Classes/classFEEdge.html#public-functions","title":"Public Functions","text":"Name FEEdge()constructor bool operator==(const FEEdge &amp; e)edge comparison int Nodes()return number of nodes int FindNode(int node)find a node"},{"location":"api/Classes/classFEEdge.html#public-attributes","title":"Public Attributes","text":"Name int n edge nodes int m_elem the element to which this edge belongs (used only by beams) int m_nbr the two adjacent edges (if there are more edges incident to a node, the neighbour is set to -1)"},{"location":"api/Classes/classFEEdge.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFEEdge.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classFEEdge.html#enum-1","title":"enum @1","text":"Enumerator Value Description MAX_NODES 3"},{"location":"api/Classes/classFEEdge.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEEdge.html#function-feedge","title":"function FEEdge","text":"<pre><code>FEEdge()\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classFEEdge.html#function-operator","title":"function operator==","text":"<pre><code>bool operator==(\n    const FEEdge &amp; e\n)\n</code></pre> <p>edge comparison </p>"},{"location":"api/Classes/classFEEdge.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes()\n</code></pre> <p>return number of nodes </p>"},{"location":"api/Classes/classFEEdge.html#function-findnode","title":"function FindNode","text":"<pre><code>int FindNode(\n    int node\n)\n</code></pre> <p>find a node </p>"},{"location":"api/Classes/classFEEdge.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEEdge.html#variable-n","title":"variable n","text":"<pre><code>int n;\n</code></pre> <p>edge nodes </p>"},{"location":"api/Classes/classFEEdge.html#variable-m_elem","title":"variable m_elem","text":"<pre><code>int m_elem;\n</code></pre> <p>the element to which this edge belongs (used only by beams) </p>"},{"location":"api/Classes/classFEEdge.html#variable-m_nbr","title":"variable m_nbr","text":"<pre><code>int m_nbr;\n</code></pre> <p>the two adjacent edges (if there are more edges incident to a node, the neighbour is set to -1) </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEElement.html","title":"FEElement","text":"<p>Inherits from FEElement_, FEItem</p>"},{"location":"api/Classes/classFEElement.html#public-types","title":"Public Types","text":"Name enum @3"},{"location":"api/Classes/classFEElement.html#public-functions","title":"Public Functions","text":"Name FEElement()constructor FEElement(const FEElement &amp; el)copy constructor FEElement &amp; operator=(const FEElement &amp; el)assignment operator void SetType(int ntype)Set the element type."},{"location":"api/Classes/classFEElement.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEElement_</p> Name FEElement_()constructor bool is_equal(FEElement_ &amp; e) int GetType() constreturn the element type bool IsType(int ntype) constIs the element of this type. int Nodes() constnumber of nodes int Faces() constNumber of faces (shells have no faces) int Edges() constNumber of edges (solids have no edges) int GetFace(int i, int * n)Get only the nodes of face i (only solids have faces) FEFace GetFace(int i)Get the face i (only solids have faces) FEFace GetShellFace()Get the face of a shell. FEEdge GetEdge(int i)Get the edge. bool IsExterior()Is this an exterior element. bool IsSolid() bool IsShell() bool IsBeam() <p>Protected Functions inherited from FEElement_</p> Name void copy(const FEElement_ &amp; el) <p>Public Attributes inherited from FEElement_</p> Name int * m_node pointer to node data int * m_nbr neighbour elements int * m_face faces (-1 for interior faces) double * m_h element thickness (only used by shells) vec3d m_fiber fiber orientation mat3d m_Q local material orientation bool m_Qactive active local material orientation double m_a0 cross-sectional area (only used by truss elements) <p>Protected Attributes inherited from FEElement_</p> Name int m_ntype type of element int m_nodes nr of nodes int m_nfaces nr of faces ( 0 for shells) int m_nedges nr of edges ( 0 for solids) <p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFEElement.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classFEElement.html#enum-3","title":"enum @3","text":"Enumerator Value Description MAX_NODES 27"},{"location":"api/Classes/classFEElement.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEElement.html#function-feelement","title":"function FEElement","text":"<pre><code>FEElement()\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classFEElement.html#function-feelement_1","title":"function FEElement","text":"<pre><code>FEElement(\n    const FEElement &amp; el\n)\n</code></pre> <p>copy constructor </p>"},{"location":"api/Classes/classFEElement.html#function-operator","title":"function operator=","text":"<pre><code>FEElement &amp; operator=(\n    const FEElement &amp; el\n)\n</code></pre> <p>assignment operator </p>"},{"location":"api/Classes/classFEElement.html#function-settype","title":"function SetType","text":"<pre><code>void SetType(\n    int ntype\n)\n</code></pre> <p>Set the element type. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEElementData.html","title":"FEElementData","text":""},{"location":"api/Classes/classFEElementData.html#public-functions","title":"Public Functions","text":"Name FEElementData() FEElementData(const FEElementData &amp; d) FEElementData &amp; operator=(const FEElementData &amp; d) void Create(FEMesh * pm, double v =0.0) int Size() double get(int i) void set(int i, double v) double &amp; operator[](int i) void SetName(const char * sz) const char * GetName() void FillRandomBox(double fmin, double fmax)"},{"location":"api/Classes/classFEElementData.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEElementData.html#function-feelementdata","title":"function FEElementData","text":"<pre><code>FEElementData()\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-feelementdata_1","title":"function FEElementData","text":"<pre><code>FEElementData(\n    const FEElementData &amp; d\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-operator","title":"function operator=","text":"<pre><code>FEElementData &amp; operator=(\n    const FEElementData &amp; d\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-create","title":"function Create","text":"<pre><code>void Create(\n    FEMesh * pm,\n    double v =0.0\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-size","title":"function Size","text":"<pre><code>inline int Size()\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-get","title":"function get","text":"<pre><code>inline double get(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-set","title":"function set","text":"<pre><code>inline void set(\n    int i,\n    double v\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-operator_1","title":"function operator[]","text":"<pre><code>inline double &amp; operator[](\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-setname","title":"function SetName","text":"<pre><code>void SetName(\n    const char * sz\n)\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-getname","title":"function GetName","text":"<pre><code>inline const char * GetName()\n</code></pre>"},{"location":"api/Classes/classFEElementData.html#function-fillrandombox","title":"function FillRandomBox","text":"<pre><code>void FillRandomBox(\n    double fmin,\n    double fmax\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEElement__.html","title":"FEElement_","text":"<p>Inherits from FEItem</p> <p>Inherited by FEElement, FETri3</p>"},{"location":"api/Classes/classFEElement__.html#public-functions","title":"Public Functions","text":"Name FEElement_()constructor bool is_equal(FEElement_ &amp; e) int GetType() constreturn the element type bool IsType(int ntype) constIs the element of this type. int Nodes() constnumber of nodes int Faces() constNumber of faces (shells have no faces) int Edges() constNumber of edges (solids have no edges) int GetFace(int i, int * n)Get only the nodes of face i (only solids have faces) FEFace GetFace(int i)Get the face i (only solids have faces) FEFace GetShellFace()Get the face of a shell. FEEdge GetEdge(int i)Get the edge. bool IsExterior()Is this an exterior element. bool IsSolid() bool IsShell() bool IsBeam()"},{"location":"api/Classes/classFEElement__.html#protected-functions","title":"Protected Functions","text":"Name void copy(const FEElement_ &amp; el)"},{"location":"api/Classes/classFEElement__.html#public-attributes","title":"Public Attributes","text":"Name int * m_node pointer to node data int * m_nbr neighbour elements int * m_face faces (-1 for interior faces) double * m_h element thickness (only used by shells) vec3d m_fiber fiber orientation mat3d m_Q local material orientation bool m_Qactive active local material orientation double m_a0 cross-sectional area (only used by truss elements)"},{"location":"api/Classes/classFEElement__.html#protected-attributes","title":"Protected Attributes","text":"Name int m_ntype type of element int m_nodes nr of nodes int m_nfaces nr of faces ( 0 for shells) int m_nedges nr of edges ( 0 for solids)"},{"location":"api/Classes/classFEElement__.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFEElement__.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEElement__.html#function-feelement_","title":"function FEElement_","text":"<pre><code>FEElement_()\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classFEElement__.html#function-is_equal","title":"function is_equal","text":"<pre><code>bool is_equal(\n    FEElement_ &amp; e\n)\n</code></pre>"},{"location":"api/Classes/classFEElement__.html#function-gettype","title":"function GetType","text":"<pre><code>inline int GetType() const\n</code></pre> <p>return the element type </p>"},{"location":"api/Classes/classFEElement__.html#function-istype","title":"function IsType","text":"<pre><code>inline bool IsType(\n    int ntype\n) const\n</code></pre> <p>Is the element of this type. </p>"},{"location":"api/Classes/classFEElement__.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes() const\n</code></pre> <p>number of nodes </p>"},{"location":"api/Classes/classFEElement__.html#function-faces","title":"function Faces","text":"<pre><code>inline int Faces() const\n</code></pre> <p>Number of faces (shells have no faces) </p>"},{"location":"api/Classes/classFEElement__.html#function-edges","title":"function Edges","text":"<pre><code>inline int Edges() const\n</code></pre> <p>Number of edges (solids have no edges) </p>"},{"location":"api/Classes/classFEElement__.html#function-getface","title":"function GetFace","text":"<pre><code>int GetFace(\n    int i,\n    int * n\n)\n</code></pre> <p>Get only the nodes of face i (only solids have faces) </p>"},{"location":"api/Classes/classFEElement__.html#function-getface_1","title":"function GetFace","text":"<pre><code>FEFace GetFace(\n    int i\n)\n</code></pre> <p>Get the face i (only solids have faces) </p>"},{"location":"api/Classes/classFEElement__.html#function-getshellface","title":"function GetShellFace","text":"<pre><code>FEFace GetShellFace()\n</code></pre> <p>Get the face of a shell. </p>"},{"location":"api/Classes/classFEElement__.html#function-getedge","title":"function GetEdge","text":"<pre><code>FEEdge GetEdge(\n    int i\n)\n</code></pre> <p>Get the edge. </p>"},{"location":"api/Classes/classFEElement__.html#function-isexterior","title":"function IsExterior","text":"<pre><code>bool IsExterior()\n</code></pre> <p>Is this an exterior element. </p>"},{"location":"api/Classes/classFEElement__.html#function-issolid","title":"function IsSolid","text":"<pre><code>inline bool IsSolid()\n</code></pre>"},{"location":"api/Classes/classFEElement__.html#function-isshell","title":"function IsShell","text":"<pre><code>inline bool IsShell()\n</code></pre>"},{"location":"api/Classes/classFEElement__.html#function-isbeam","title":"function IsBeam","text":"<pre><code>inline bool IsBeam()\n</code></pre>"},{"location":"api/Classes/classFEElement__.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEElement__.html#function-copy","title":"function copy","text":"<pre><code>void copy(\n    const FEElement_ &amp; el\n)\n</code></pre>"},{"location":"api/Classes/classFEElement__.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEElement__.html#variable-m_node","title":"variable m_node","text":"<pre><code>int * m_node;\n</code></pre> <p>pointer to node data </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_nbr","title":"variable m_nbr","text":"<pre><code>int * m_nbr;\n</code></pre> <p>neighbour elements </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_face","title":"variable m_face","text":"<pre><code>int * m_face;\n</code></pre> <p>faces (-1 for interior faces) </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_h","title":"variable m_h","text":"<pre><code>double * m_h;\n</code></pre> <p>element thickness (only used by shells) </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_fiber","title":"variable m_fiber","text":"<pre><code>vec3d m_fiber;\n</code></pre> <p>fiber orientation </p> <p>Todo: maybe I can add an element attribute section </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_q","title":"variable m_Q","text":"<pre><code>mat3d m_Q;\n</code></pre> <p>local material orientation </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_qactive","title":"variable m_Qactive","text":"<pre><code>bool m_Qactive;\n</code></pre> <p>active local material orientation </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_a0","title":"variable m_a0","text":"<pre><code>double m_a0;\n</code></pre> <p>cross-sectional area (only used by truss elements) </p>"},{"location":"api/Classes/classFEElement__.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFEElement__.html#variable-m_ntype","title":"variable m_ntype","text":"<pre><code>int m_ntype;\n</code></pre> <p>type of element </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_nodes","title":"variable m_nodes","text":"<pre><code>int m_nodes;\n</code></pre> <p>nr of nodes </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_nfaces","title":"variable m_nfaces","text":"<pre><code>int m_nfaces;\n</code></pre> <p>nr of faces ( 0 for shells) </p>"},{"location":"api/Classes/classFEElement__.html#variable-m_nedges","title":"variable m_nedges","text":"<pre><code>int m_nedges;\n</code></pre> <p>nr of edges ( 0 for solids) </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEFace.html","title":"FEFace","text":"<p>Inherits from FEItem</p>"},{"location":"api/Classes/classFEFace.html#public-types","title":"Public Types","text":"Name enum @2"},{"location":"api/Classes/classFEFace.html#public-functions","title":"Public Functions","text":"Name FEFace()constructor bool operator==(const FEFace &amp; f)comparison operator int Nodes()return number of nodes int Edges()return number of edges void GetEdgeNodes(int i, int * n)get the edge node numbers bool HasEdge(int n1, int n2)See if this face has an edge. bool HasNode(int i)See if this face has node with ID i. int FindNode(int i)Fine the array index of node with ID i. bool IsExternal()Is this face internal or external."},{"location":"api/Classes/classFEFace.html#public-attributes","title":"Public Attributes","text":"Name int n nodal ID's int m_nodes number of nodes int m_nbr neighbour faces vec3d m_fn face normal vec3d m_nn node normals int m_sid smoothing ID int m_elem the elements to which this face belongs"},{"location":"api/Classes/classFEFace.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFEFace.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classFEFace.html#enum-2","title":"enum @2","text":"Enumerator Value Description MAX_NODES 9"},{"location":"api/Classes/classFEFace.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEFace.html#function-feface","title":"function FEFace","text":"<pre><code>FEFace()\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classFEFace.html#function-operator","title":"function operator==","text":"<pre><code>bool operator==(\n    const FEFace &amp; f\n)\n</code></pre> <p>comparison operator </p>"},{"location":"api/Classes/classFEFace.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes()\n</code></pre> <p>return number of nodes </p>"},{"location":"api/Classes/classFEFace.html#function-edges","title":"function Edges","text":"<pre><code>int Edges()\n</code></pre> <p>return number of edges </p>"},{"location":"api/Classes/classFEFace.html#function-getedgenodes","title":"function GetEdgeNodes","text":"<pre><code>void GetEdgeNodes(\n    int i,\n    int * n\n)\n</code></pre> <p>get the edge node numbers </p>"},{"location":"api/Classes/classFEFace.html#function-hasedge","title":"function HasEdge","text":"<pre><code>bool HasEdge(\n    int n1,\n    int n2\n)\n</code></pre> <p>See if this face has an edge. </p>"},{"location":"api/Classes/classFEFace.html#function-hasnode","title":"function HasNode","text":"<pre><code>bool HasNode(\n    int i\n)\n</code></pre> <p>See if this face has node with ID i. </p>"},{"location":"api/Classes/classFEFace.html#function-findnode","title":"function FindNode","text":"<pre><code>int FindNode(\n    int i\n)\n</code></pre> <p>Fine the array index of node with ID i. </p>"},{"location":"api/Classes/classFEFace.html#function-isexternal","title":"function IsExternal","text":"<pre><code>inline bool IsExternal()\n</code></pre> <p>Is this face internal or external. </p>"},{"location":"api/Classes/classFEFace.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEFace.html#variable-n","title":"variable n","text":"<pre><code>int n;\n</code></pre> <p>nodal ID's </p>"},{"location":"api/Classes/classFEFace.html#variable-m_nodes","title":"variable m_nodes","text":"<pre><code>int m_nodes;\n</code></pre> <p>number of nodes </p>"},{"location":"api/Classes/classFEFace.html#variable-m_nbr","title":"variable m_nbr","text":"<pre><code>int m_nbr;\n</code></pre> <p>neighbour faces </p>"},{"location":"api/Classes/classFEFace.html#variable-m_fn","title":"variable m_fn","text":"<pre><code>vec3d m_fn;\n</code></pre> <p>face normal </p>"},{"location":"api/Classes/classFEFace.html#variable-m_nn","title":"variable m_nn","text":"<pre><code>vec3d m_nn;\n</code></pre> <p>node normals </p>"},{"location":"api/Classes/classFEFace.html#variable-m_sid","title":"variable m_sid","text":"<pre><code>int m_sid;\n</code></pre> <p>smoothing ID </p>"},{"location":"api/Classes/classFEFace.html#variable-m_elem","title":"variable m_elem","text":"<pre><code>int m_elem;\n</code></pre> <p>the elements to which this face belongs </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEFillHole.html","title":"FEFillHole","text":""},{"location":"api/Classes/classFEFillHole.html#public-classes","title":"Public Classes","text":"Name class EdgeRing struct FACE"},{"location":"api/Classes/classFEFillHole.html#public-functions","title":"Public Functions","text":"Name FEFillHole() FEMesh * Apply(FEMesh * pm) bool AFM(FEMesh &amp; mesh, EdgeRing &amp; ring, vector&lt; FACE &gt; &amp; tri_list, vector&lt; vec3d &gt; &amp; node_list) vec3d newNode(vec3d current_node, vec3d next_node, vec3d prev_node, vec3d node_normal, double scale, bool concave) bool DivideRing(EdgeRing &amp; ring, vector&lt; FACE &gt; &amp; tri_list) bool DivideRing1(EdgeRing &amp; ring, vector&lt; FACE &gt; &amp; tri_list) void FillAllHoles(FEMesh * pm)"},{"location":"api/Classes/classFEFillHole.html#public-attributes","title":"Public Attributes","text":"Name bool optimize bool insertNodes"},{"location":"api/Classes/classFEFillHole.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEFillHole.html#function-fefillhole","title":"function FEFillHole","text":"<pre><code>inline FEFillHole()\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-apply","title":"function Apply","text":"<pre><code>FEMesh * Apply(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-afm","title":"function AFM","text":"<pre><code>bool AFM(\n    FEMesh &amp; mesh,\n    EdgeRing &amp; ring,\n    vector&lt; FACE &gt; &amp; tri_list,\n    vector&lt; vec3d &gt; &amp; node_list\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-newnode","title":"function newNode","text":"<pre><code>vec3d newNode(\n    vec3d current_node,\n    vec3d next_node,\n    vec3d prev_node,\n    vec3d node_normal,\n    double scale,\n    bool concave\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-dividering","title":"function DivideRing","text":"<pre><code>bool DivideRing(\n    EdgeRing &amp; ring,\n    vector&lt; FACE &gt; &amp; tri_list\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-dividering1","title":"function DivideRing1","text":"<pre><code>bool DivideRing1(\n    EdgeRing &amp; ring,\n    vector&lt; FACE &gt; &amp; tri_list\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#function-fillallholes","title":"function FillAllHoles","text":"<pre><code>void FillAllHoles(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEFillHole.html#variable-optimize","title":"variable optimize","text":"<pre><code>bool optimize;\n</code></pre>"},{"location":"api/Classes/classFEFillHole.html#variable-insertnodes","title":"variable insertNodes","text":"<pre><code>bool insertNodes;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html","title":"FEFillHole::EdgeRing","text":""},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#public-functions","title":"Public Functions","text":"Name EdgeRing() EdgeRing(const EdgeRing &amp; ring) void operator=(const EdgeRing &amp; ring) bool empty() void add(int n, const vec3d &amp; r, const vec3d &amp; nn) void clear() int size() int operator[](int i) void GetLeftEar(int n0, int n1, EdgeRing &amp; ear) void GetRightEar(int n0, int n1, EdgeRing &amp; ear)"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#public-attributes","title":"Public Attributes","text":"Name vector&lt; vec3d &gt; m_r vector&lt; int &gt; m_node int m_winding vector&lt; vec3d &gt; m_normal"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-edgering","title":"function EdgeRing","text":"<pre><code>inline EdgeRing()\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-edgering_1","title":"function EdgeRing","text":"<pre><code>inline EdgeRing(\n    const EdgeRing &amp; ring\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-operator","title":"function operator=","text":"<pre><code>inline void operator=(\n    const EdgeRing &amp; ring\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-empty","title":"function empty","text":"<pre><code>inline bool empty()\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-add","title":"function add","text":"<pre><code>inline void add(\n    int n,\n    const vec3d &amp; r,\n    const vec3d &amp; nn\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-size","title":"function size","text":"<pre><code>inline int size()\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-operator_1","title":"function operator[]","text":"<pre><code>inline int operator[](\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-getleftear","title":"function GetLeftEar","text":"<pre><code>void GetLeftEar(\n    int n0,\n    int n1,\n    EdgeRing &amp; ear\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#function-getrightear","title":"function GetRightEar","text":"<pre><code>void GetRightEar(\n    int n0,\n    int n1,\n    EdgeRing &amp; ear\n)\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#variable-m_r","title":"variable m_r","text":"<pre><code>vector&lt; vec3d &gt; m_r;\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#variable-m_node","title":"variable m_node","text":"<pre><code>vector&lt; int &gt; m_node;\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#variable-m_winding","title":"variable m_winding","text":"<pre><code>int m_winding;\n</code></pre>"},{"location":"api/Classes/classFEFillHole_1_1EdgeRing.html#variable-m_normal","title":"variable m_normal","text":"<pre><code>vector&lt; vec3d &gt; m_normal;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEFixMesh.html","title":"FEFixMesh","text":""},{"location":"api/Classes/classFEFixMesh.html#public-functions","title":"Public Functions","text":"Name FEFixMesh() FEMesh * Apply(FEMesh * pm) void SetTask(int n) void SetThickness(double m) FEMesh * RemoveDuplicateElements(FEMesh * pm) FEMesh * RemoveNonManifoldElements(FEMesh * pm) FEMesh * FixElementWinding(FEMesh * pm) FEMesh * FillAllHoles(FEMesh * pm) FEMesh * FixinvertedElements(FEMesh * pm) FEMesh * FixReferenceSurface(FEMesh * pm) FEMesh * InterpolateShellThickness(FEMesh * pm)"},{"location":"api/Classes/classFEFixMesh.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEFixMesh.html#function-fefixmesh","title":"function FEFixMesh","text":"<pre><code>inline FEFixMesh()\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-apply","title":"function Apply","text":"<pre><code>FEMesh * Apply(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-settask","title":"function SetTask","text":"<pre><code>void SetTask(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-setthickness","title":"function SetThickness","text":"<pre><code>void SetThickness(\n    double m\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-removeduplicateelements","title":"function RemoveDuplicateElements","text":"<pre><code>FEMesh * RemoveDuplicateElements(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-removenonmanifoldelements","title":"function RemoveNonManifoldElements","text":"<pre><code>FEMesh * RemoveNonManifoldElements(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-fixelementwinding","title":"function FixElementWinding","text":"<pre><code>FEMesh * FixElementWinding(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-fillallholes","title":"function FillAllHoles","text":"<pre><code>FEMesh * FillAllHoles(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-fixinvertedelements","title":"function FixinvertedElements","text":"<pre><code>FEMesh * FixinvertedElements(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-fixreferencesurface","title":"function FixReferenceSurface","text":"<pre><code>FEMesh * FixReferenceSurface(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEFixMesh.html#function-interpolateshellthickness","title":"function InterpolateShellThickness","text":"<pre><code>FEMesh * InterpolateShellThickness(\n    FEMesh * pm\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEItem.html","title":"FEItem","text":"<p>Inherited by FEEdge, FEElement_, FEFace, FENode</p>"},{"location":"api/Classes/classFEItem.html#public-functions","title":"Public Functions","text":"Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state)"},{"location":"api/Classes/classFEItem.html#public-attributes","title":"Public Attributes","text":"Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFEItem.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEItem.html#function-feitem","title":"function FEItem","text":"<pre><code>inline FEItem()\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-isvisible","title":"function IsVisible","text":"<pre><code>inline bool IsVisible() const\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-isselected","title":"function IsSelected","text":"<pre><code>inline bool IsSelected() const\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-select","title":"function Select","text":"<pre><code>inline void Select()\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-unselect","title":"function UnSelect","text":"<pre><code>inline void UnSelect()\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-show","title":"function Show","text":"<pre><code>inline void Show()\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-hide","title":"function Hide","text":"<pre><code>inline void Hide()\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-getfestate","title":"function GetFEState","text":"<pre><code>inline unsigned int GetFEState() const\n</code></pre>"},{"location":"api/Classes/classFEItem.html#function-setfestate","title":"function SetFEState","text":"<pre><code>inline void SetFEState(\n    unsigned int state\n)\n</code></pre>"},{"location":"api/Classes/classFEItem.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEItem.html#variable-m_ntag","title":"variable m_ntag","text":"<pre><code>int m_ntag;\n</code></pre>"},{"location":"api/Classes/classFEItem.html#variable-m_gid","title":"variable m_gid","text":"<pre><code>int m_gid;\n</code></pre>"},{"location":"api/Classes/classFEItem.html#variable-m_nid","title":"variable m_nid","text":"<pre><code>int m_nid;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEMesh.html","title":"FEMesh","text":"<p>Inherits from FECoreMesh</p>"},{"location":"api/Classes/classFEMesh.html#public-functions","title":"Public Functions","text":"Name FEMesh() FEMesh(FEMesh &amp; m) virtual ~FEMesh() virtual void Create(int nodes, int elems, int faces =0, int edges =0)allocate space for mesh void ShallowCopy(FEMesh * pm) void Clear()\u2014 C L E A N U P \u2014 void DeleteEdges() virtual int Elements() constreturn number of elements FEElement &amp; Element(int n)return element virtual FEElement_ &amp; ElementRef(int n)return reference to element virtual FEElement * ElementPtr(int n =0)return pointer to element int FindFace(FEElement * pe, FEFace &amp; f, FEFace &amp; fe) void FindNodesFromPart(int gid, vector&lt; int &gt; &amp; node) std::vector&lt; FENode &gt; &amp; NodeArray() std::vector&lt; FEFace &gt; &amp; FaceArray() std::vector&lt; FEElement &gt; &amp; ElementArray() double GetElementValue(int n) void SetElementValue(int n, double v) void UpdateValueRange() void GetValueRange(double &amp; vmin, double &amp; vmax) vec3d ProjectToSurface(vec3d r, vec3d t) vec3d ProjectToFace(vec3d p, FEFace &amp; f, double &amp; r, double &amp; s) vec3d ProjectToEdge(vec3d e1, vec3d e2, vec3d p, double &amp; r) bool FindIntersection(FEFace &amp; f, vec3d x, vec3d n, vec3d &amp; q, double &amp; g) void Update() void UpdateElementNeighbors() void UpdateFaces() void UpdateEdges() void UpdateNodes() void AutoSmooth(double w) void UpdateNormals() void PartitionSelection() void RemoveIsolatedNodes() void AddNode(FENode &amp; n) FEMesh * DetachSelectedMesh() void DetachSelectedPart() FEMesh * ExtractSelectedFaces() void DeleteTaggedElements(int tag) void DeleteTaggedFaces(int tag) void DeleteTaggedEdges(int tag) void FindDuplicateFaces(vector&lt; int &gt; &amp; l) void FindDuplicateEdges(vector&lt; int &gt; &amp; l) void DeleteSelectedElements() void DeleteSelectedFaces() void DeleteSelectedNodes() void InvertTaggedElements(int ntag) void InvertSelectedElements() double ShellJacobian(FEElement &amp; el) void RemoveDuplicateElements() void FixinvertedElements() void FixReferenceSurface() void InterpolateShellThickness(double ) void RemoveNonManifoldElements() void FixElementWinding() void FixElementWinding2() void TagAllElements(int ntag) int DataFields() FEElementData * AddDataField(const char * szname, double v =0.0) FEElementData &amp; GetDataField(int i) double ShortestEdge() void BuildNodeElementTable(vector&lt; vector&lt; int &gt; &gt; &amp; NET) void BuildNodeFaceTable(vector&lt; vector&lt; int &gt; &gt; &amp; NFT) void BuildNodeEdgeTable(vector&lt; vector&lt; int &gt; &gt; &amp; NET) void BuildEdgeTable(vector&lt; pair&lt; int, int &gt; &gt; &amp; ET) void BuildNodeNodeTable(vector&lt; set&lt; int &gt; &gt; &amp; NNT) void BuildSurfaceNodeNodeTable(vector&lt; set&lt; int &gt; &gt; &amp; NNT) void BuildElementEdgeTable(vector&lt; vector&lt; int &gt; &gt; &amp; EET, vector&lt; pair&lt; int, int &gt; &gt; &amp; ET) void BuildFaceTable(vector&lt; FEFace &gt; &amp; FT) void BuildElementFaceTable(vector&lt; vector&lt; int &gt; &gt; &amp; EFT, vector&lt; FEFace &gt; &amp; FT) void BuildFaceEdgeTable(vector&lt; vector&lt; int &gt; &gt; &amp; FET, vector&lt; pair&lt; int, int &gt; &gt; &amp; ET) void BuildFaceFaceTable(vector&lt; int &gt; &amp; FFT, vector&lt; FEFace &gt; &amp; FT) void BuildEdgeEdgeTable(vector&lt; int &gt; &amp; EET, vector&lt; pair&lt; int, int &gt; &gt; &amp; ET)"},{"location":"api/Classes/classFEMesh.html#protected-functions","title":"Protected Functions","text":"Name bool IntersectTri(vec3d * y, vec3d x, vec3d n, vec3d &amp; q, double &amp; g) bool IntersectQuad(vec3d * y, vec3d x, vec3d n, vec3d &amp; q, double &amp; g)"},{"location":"api/Classes/classFEMesh.html#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; FEElement &gt; m_Elem FE elements. std::vector&lt; double &gt; m_data element values double m_min double m_max value range of element data vector&lt; FEElementData &gt; m_map"},{"location":"api/Classes/classFEMesh.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FECoreMesh</p> Name FECoreMesh()constructor virtual ~FECoreMesh()destructor bool IsType(int ntype)check the type of the mesh int Nodes() const int Edges() const int Faces() const FENode &amp; Node(int n) FEEdge &amp; Edge(int n) FEFace &amp; Face(int n) FENode * NodePtr(int n =0) FEEdge * EdgePtr(int n =0) FEFace * FacePtr(int n =0) <p>Protected Attributes inherited from FECoreMesh</p> Name std::vector&lt; FENode &gt; m_Node FE nodes. std::vector&lt; FEEdge &gt; m_Edge FE edges. std::vector&lt; FEFace &gt; m_Face FE faces."},{"location":"api/Classes/classFEMesh.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEMesh.html#function-femesh","title":"function FEMesh","text":"<pre><code>FEMesh()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-femesh_1","title":"function FEMesh","text":"<pre><code>FEMesh(\n    FEMesh &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-femesh_2","title":"function ~FEMesh","text":"<pre><code>virtual ~FEMesh()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-create","title":"function Create","text":"<pre><code>virtual void Create(\n    int nodes,\n    int elems,\n    int faces =0,\n    int edges =0\n)\n</code></pre> <p>allocate space for mesh </p> <p>Reimplements: FECoreMesh::Create</p>"},{"location":"api/Classes/classFEMesh.html#function-shallowcopy","title":"function ShallowCopy","text":"<pre><code>void ShallowCopy(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-clear","title":"function Clear","text":"<pre><code>void Clear()\n</code></pre> <p>\u2014 C L E A N U P \u2014</p>"},{"location":"api/Classes/classFEMesh.html#function-deleteedges","title":"function DeleteEdges","text":"<pre><code>inline void DeleteEdges()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-elements","title":"function Elements","text":"<pre><code>inline virtual int Elements() const\n</code></pre> <p>return number of elements </p> <p>Reimplements: FECoreMesh::Elements</p>"},{"location":"api/Classes/classFEMesh.html#function-element","title":"function Element","text":"<pre><code>inline FEElement &amp; Element(\n    int n\n)\n</code></pre> <p>return element </p>"},{"location":"api/Classes/classFEMesh.html#function-elementref","title":"function ElementRef","text":"<pre><code>inline virtual FEElement_ &amp; ElementRef(\n    int n\n)\n</code></pre> <p>return reference to element </p> <p>Reimplements: FECoreMesh::ElementRef</p>"},{"location":"api/Classes/classFEMesh.html#function-elementptr","title":"function ElementPtr","text":"<pre><code>inline virtual FEElement * ElementPtr(\n    int n =0\n)\n</code></pre> <p>return pointer to element </p> <p>Reimplements: FECoreMesh::ElementPtr</p>"},{"location":"api/Classes/classFEMesh.html#function-findface","title":"function FindFace","text":"<pre><code>int FindFace(\n    FEElement * pe,\n    FEFace &amp; f,\n    FEFace &amp; fe\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-findnodesfrompart","title":"function FindNodesFromPart","text":"<pre><code>void FindNodesFromPart(\n    int gid,\n    vector&lt; int &gt; &amp; node\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-nodearray","title":"function NodeArray","text":"<pre><code>inline std::vector&lt; FENode &gt; &amp; NodeArray()\n</code></pre> <p>Todo: Maybe I should delete these </p> <p>Get the node array </p>"},{"location":"api/Classes/classFEMesh.html#function-facearray","title":"function FaceArray","text":"<pre><code>inline std::vector&lt; FEFace &gt; &amp; FaceArray()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-elementarray","title":"function ElementArray","text":"<pre><code>inline std::vector&lt; FEElement &gt; &amp; ElementArray()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-getelementvalue","title":"function GetElementValue","text":"<pre><code>inline double GetElementValue(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-setelementvalue","title":"function SetElementValue","text":"<pre><code>inline void SetElementValue(\n    int n,\n    double v\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updatevaluerange","title":"function UpdateValueRange","text":"<pre><code>void UpdateValueRange()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-getvaluerange","title":"function GetValueRange","text":"<pre><code>void GetValueRange(\n    double &amp; vmin,\n    double &amp; vmax\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-projecttosurface","title":"function ProjectToSurface","text":"<pre><code>vec3d ProjectToSurface(\n    vec3d r,\n    vec3d t\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-projecttoface","title":"function ProjectToFace","text":"<pre><code>vec3d ProjectToFace(\n    vec3d p,\n    FEFace &amp; f,\n    double &amp; r,\n    double &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-projecttoedge","title":"function ProjectToEdge","text":"<pre><code>vec3d ProjectToEdge(\n    vec3d e1,\n    vec3d e2,\n    vec3d p,\n    double &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-findintersection","title":"function FindIntersection","text":"<pre><code>bool FindIntersection(\n    FEFace &amp; f,\n    vec3d x,\n    vec3d n,\n    vec3d &amp; q,\n    double &amp; g\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-update","title":"function Update","text":"<pre><code>void Update()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updateelementneighbors","title":"function UpdateElementNeighbors","text":"<pre><code>void UpdateElementNeighbors()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updatefaces","title":"function UpdateFaces","text":"<pre><code>void UpdateFaces()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updateedges","title":"function UpdateEdges","text":"<pre><code>void UpdateEdges()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updatenodes","title":"function UpdateNodes","text":"<pre><code>void UpdateNodes()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-autosmooth","title":"function AutoSmooth","text":"<pre><code>void AutoSmooth(\n    double w\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-updatenormals","title":"function UpdateNormals","text":"<pre><code>void UpdateNormals()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-partitionselection","title":"function PartitionSelection","text":"<pre><code>void PartitionSelection()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-removeisolatednodes","title":"function RemoveIsolatedNodes","text":"<pre><code>void RemoveIsolatedNodes()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-addnode","title":"function AddNode","text":"<pre><code>inline void AddNode(\n    FENode &amp; n\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-detachselectedmesh","title":"function DetachSelectedMesh","text":"<pre><code>FEMesh * DetachSelectedMesh()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-detachselectedpart","title":"function DetachSelectedPart","text":"<pre><code>void DetachSelectedPart()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-extractselectedfaces","title":"function ExtractSelectedFaces","text":"<pre><code>FEMesh * ExtractSelectedFaces()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deletetaggedelements","title":"function DeleteTaggedElements","text":"<pre><code>void DeleteTaggedElements(\n    int tag\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deletetaggedfaces","title":"function DeleteTaggedFaces","text":"<pre><code>void DeleteTaggedFaces(\n    int tag\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deletetaggededges","title":"function DeleteTaggedEdges","text":"<pre><code>void DeleteTaggedEdges(\n    int tag\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-findduplicatefaces","title":"function FindDuplicateFaces","text":"<pre><code>void FindDuplicateFaces(\n    vector&lt; int &gt; &amp; l\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-findduplicateedges","title":"function FindDuplicateEdges","text":"<pre><code>void FindDuplicateEdges(\n    vector&lt; int &gt; &amp; l\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deleteselectedelements","title":"function DeleteSelectedElements","text":"<pre><code>void DeleteSelectedElements()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deleteselectedfaces","title":"function DeleteSelectedFaces","text":"<pre><code>void DeleteSelectedFaces()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-deleteselectednodes","title":"function DeleteSelectedNodes","text":"<pre><code>void DeleteSelectedNodes()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-inverttaggedelements","title":"function InvertTaggedElements","text":"<pre><code>void InvertTaggedElements(\n    int ntag\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-invertselectedelements","title":"function InvertSelectedElements","text":"<pre><code>void InvertSelectedElements()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-shelljacobian","title":"function ShellJacobian","text":"<pre><code>double ShellJacobian(\n    FEElement &amp; el\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-removeduplicateelements","title":"function RemoveDuplicateElements","text":"<pre><code>void RemoveDuplicateElements()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-fixinvertedelements","title":"function FixinvertedElements","text":"<pre><code>void FixinvertedElements()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-fixreferencesurface","title":"function FixReferenceSurface","text":"<pre><code>void FixReferenceSurface()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-interpolateshellthickness","title":"function InterpolateShellThickness","text":"<pre><code>void InterpolateShellThickness(\n    double \n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-removenonmanifoldelements","title":"function RemoveNonManifoldElements","text":"<pre><code>void RemoveNonManifoldElements()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-fixelementwinding","title":"function FixElementWinding","text":"<pre><code>void FixElementWinding()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-fixelementwinding2","title":"function FixElementWinding2","text":"<pre><code>void FixElementWinding2()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-tagallelements","title":"function TagAllElements","text":"<pre><code>void TagAllElements(\n    int ntag\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-datafields","title":"function DataFields","text":"<pre><code>inline int DataFields()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-adddatafield","title":"function AddDataField","text":"<pre><code>FEElementData * AddDataField(\n    const char * szname,\n    double v =0.0\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-getdatafield","title":"function GetDataField","text":"<pre><code>inline FEElementData &amp; GetDataField(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-shortestedge","title":"function ShortestEdge","text":"<pre><code>double ShortestEdge()\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildnodeelementtable","title":"function BuildNodeElementTable","text":"<pre><code>void BuildNodeElementTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; NET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildnodefacetable","title":"function BuildNodeFaceTable","text":"<pre><code>void BuildNodeFaceTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; NFT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildnodeedgetable","title":"function BuildNodeEdgeTable","text":"<pre><code>void BuildNodeEdgeTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; NET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildedgetable","title":"function BuildEdgeTable","text":"<pre><code>void BuildEdgeTable(\n    vector&lt; pair&lt; int, int &gt; &gt; &amp; ET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildnodenodetable","title":"function BuildNodeNodeTable","text":"<pre><code>void BuildNodeNodeTable(\n    vector&lt; set&lt; int &gt; &gt; &amp; NNT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildsurfacenodenodetable","title":"function BuildSurfaceNodeNodeTable","text":"<pre><code>void BuildSurfaceNodeNodeTable(\n    vector&lt; set&lt; int &gt; &gt; &amp; NNT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildelementedgetable","title":"function BuildElementEdgeTable","text":"<pre><code>void BuildElementEdgeTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; EET,\n    vector&lt; pair&lt; int, int &gt; &gt; &amp; ET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildfacetable","title":"function BuildFaceTable","text":"<pre><code>void BuildFaceTable(\n    vector&lt; FEFace &gt; &amp; FT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildelementfacetable","title":"function BuildElementFaceTable","text":"<pre><code>void BuildElementFaceTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; EFT,\n    vector&lt; FEFace &gt; &amp; FT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildfaceedgetable","title":"function BuildFaceEdgeTable","text":"<pre><code>void BuildFaceEdgeTable(\n    vector&lt; vector&lt; int &gt; &gt; &amp; FET,\n    vector&lt; pair&lt; int, int &gt; &gt; &amp; ET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildfacefacetable","title":"function BuildFaceFaceTable","text":"<pre><code>void BuildFaceFaceTable(\n    vector&lt; int &gt; &amp; FFT,\n    vector&lt; FEFace &gt; &amp; FT\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-buildedgeedgetable","title":"function BuildEdgeEdgeTable","text":"<pre><code>void BuildEdgeEdgeTable(\n    vector&lt; int &gt; &amp; EET,\n    vector&lt; pair&lt; int, int &gt; &gt; &amp; ET\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEMesh.html#function-intersecttri","title":"function IntersectTri","text":"<pre><code>bool IntersectTri(\n    vec3d * y,\n    vec3d x,\n    vec3d n,\n    vec3d &amp; q,\n    double &amp; g\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#function-intersectquad","title":"function IntersectQuad","text":"<pre><code>bool IntersectQuad(\n    vec3d * y,\n    vec3d x,\n    vec3d n,\n    vec3d &amp; q,\n    double &amp; g\n)\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFEMesh.html#variable-m_elem","title":"variable m_Elem","text":"<pre><code>std::vector&lt; FEElement &gt; m_Elem;\n</code></pre> <p>FE elements. </p>"},{"location":"api/Classes/classFEMesh.html#variable-m_data","title":"variable m_data","text":"<pre><code>std::vector&lt; double &gt; m_data;\n</code></pre> <p>element values </p>"},{"location":"api/Classes/classFEMesh.html#variable-m_min","title":"variable m_min","text":"<pre><code>double m_min;\n</code></pre>"},{"location":"api/Classes/classFEMesh.html#variable-m_max","title":"variable m_max","text":"<pre><code>double m_max;\n</code></pre> <p>value range of element data </p>"},{"location":"api/Classes/classFEMesh.html#variable-m_map","title":"variable m_map","text":"<pre><code>vector&lt; FEElementData &gt; m_map;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html","title":"FEMeshSmoothingModifier","text":"<p>More...</p> <p><code>#include &lt;FEMeshSmoothingModifier.h&gt;</code></p>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#public-functions","title":"Public Functions","text":"Name FEMeshSmoothingModifier()Constructor. FEMesh * Apply(FEMesh * pm)Apply the smoothing modifier."},{"location":"api/Classes/classFEMeshSmoothingModifier.html#protected-functions","title":"Protected Functions","text":"Name double area_triangle(vec3d r[3]) double distance(vec3d x, vec3d y) double random() void Laplacian_Smoothing(FEMesh * pm, vector&lt; int &gt; hashmap) void Laplacian_Smoothing2(FEMesh * pm, vector&lt; int &gt; hashmap) void Taubin_Smoothing(FEMesh * pm, vector&lt; int &gt; hashmap) void Crease_Enhancing_Diffusion(FEMesh * pm, vector&lt; int &gt; hashmap) void Add_Noise(FEMesh * pm, vector&lt; int &gt; hashmap)"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#public-attributes","title":"Public Attributes","text":"Name double m_threshold1 double m_threshold2 double m_iteration int m_method"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#detailed-description","title":"Detailed Description","text":"<pre><code>class FEMeshSmoothingModifier;\n</code></pre> <p>This class implements a modifier that coarses a plygonal mesh using an approximated centroidal voronoi diagram. </p>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-femeshsmoothingmodifier","title":"function FEMeshSmoothingModifier","text":"<pre><code>FEMeshSmoothingModifier()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-apply","title":"function Apply","text":"<pre><code>FEMesh * Apply(\n    FEMesh * pm\n)\n</code></pre> <p>Apply the smoothing modifier. </p>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-area_triangle","title":"function area_triangle","text":"<pre><code>double area_triangle(\n    vec3d r[3]\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-distance","title":"function distance","text":"<pre><code>double distance(\n    vec3d x,\n    vec3d y\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-random","title":"function random","text":"<pre><code>double random()\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-laplacian_smoothing","title":"function Laplacian_Smoothing","text":"<pre><code>void Laplacian_Smoothing(\n    FEMesh * pm,\n    vector&lt; int &gt; hashmap\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-laplacian_smoothing2","title":"function Laplacian_Smoothing2","text":"<pre><code>void Laplacian_Smoothing2(\n    FEMesh * pm,\n    vector&lt; int &gt; hashmap\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-taubin_smoothing","title":"function Taubin_Smoothing","text":"<pre><code>void Taubin_Smoothing(\n    FEMesh * pm,\n    vector&lt; int &gt; hashmap\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-crease_enhancing_diffusion","title":"function Crease_Enhancing_Diffusion","text":"<pre><code>void Crease_Enhancing_Diffusion(\n    FEMesh * pm,\n    vector&lt; int &gt; hashmap\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#function-add_noise","title":"function Add_Noise","text":"<pre><code>void Add_Noise(\n    FEMesh * pm,\n    vector&lt; int &gt; hashmap\n)\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFEMeshSmoothingModifier.html#variable-m_threshold1","title":"variable m_threshold1","text":"<pre><code>double m_threshold1;\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#variable-m_threshold2","title":"variable m_threshold2","text":"<pre><code>double m_threshold2;\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#variable-m_iteration","title":"variable m_iteration","text":"<pre><code>double m_iteration;\n</code></pre>"},{"location":"api/Classes/classFEMeshSmoothingModifier.html#variable-m_method","title":"variable m_method","text":"<pre><code>int m_method;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFENode.html","title":"FENode","text":"<p>Inherits from FEItem</p>"},{"location":"api/Classes/classFENode.html#public-functions","title":"Public Functions","text":"Name FENode()"},{"location":"api/Classes/classFENode.html#public-attributes","title":"Public Attributes","text":"Name vec3d r bool m_bext double m_ndata"},{"location":"api/Classes/classFENode.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFENode.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFENode.html#function-fenode","title":"function FENode","text":"<pre><code>inline FENode()\n</code></pre>"},{"location":"api/Classes/classFENode.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classFENode.html#variable-r","title":"variable r","text":"<pre><code>vec3d r;\n</code></pre>"},{"location":"api/Classes/classFENode.html#variable-m_bext","title":"variable m_bext","text":"<pre><code>bool m_bext;\n</code></pre>"},{"location":"api/Classes/classFENode.html#variable-m_ndata","title":"variable m_ndata","text":"<pre><code>double m_ndata;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFENodeElementList.html","title":"FENodeElementList","text":""},{"location":"api/Classes/classFENodeElementList.html#public-functions","title":"Public Functions","text":"Name FENodeElementList(FEMesh * pm) ~FENodeElementList() void Build() int Valence(int n) FEElement * Element(int n, int j)"},{"location":"api/Classes/classFENodeElementList.html#protected-attributes","title":"Protected Attributes","text":"Name FEMesh * m_pm vector&lt; int &gt; m_val vector&lt; int &gt; m_off vector&lt; FEElement * &gt; m_pelem"},{"location":"api/Classes/classFENodeElementList.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFENodeElementList.html#function-fenodeelementlist","title":"function FENodeElementList","text":"<pre><code>FENodeElementList(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#function-fenodeelementlist_1","title":"function ~FENodeElementList","text":"<pre><code>~FENodeElementList()\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#function-build","title":"function Build","text":"<pre><code>void Build()\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#function-valence","title":"function Valence","text":"<pre><code>inline int Valence(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#function-element","title":"function Element","text":"<pre><code>inline FEElement * Element(\n    int n,\n    int j\n)\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFENodeElementList.html#variable-m_pm","title":"variable m_pm","text":"<pre><code>FEMesh * m_pm;\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#variable-m_val","title":"variable m_val","text":"<pre><code>vector&lt; int &gt; m_val;\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#variable-m_off","title":"variable m_off","text":"<pre><code>vector&lt; int &gt; m_off;\n</code></pre>"},{"location":"api/Classes/classFENodeElementList.html#variable-m_pelem","title":"variable m_pelem","text":"<pre><code>vector&lt; FEElement * &gt; m_pelem;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFENodeFaceList.html","title":"FENodeFaceList","text":""},{"location":"api/Classes/classFENodeFaceList.html#public-functions","title":"Public Functions","text":"Name FENodeFaceList(FEMesh * pm) ~FENodeFaceList(void ) void Build() void BuildSorted() int Nodes() FENode &amp; Node(int i) int Valence(int i) FEFace * Face(int n, int i) bool HasFace(int n, FEFace * pf)"},{"location":"api/Classes/classFENodeFaceList.html#protected-functions","title":"Protected Functions","text":"Name void Sort(int node)"},{"location":"api/Classes/classFENodeFaceList.html#protected-attributes","title":"Protected Attributes","text":"Name FEMesh * m_pm vector&lt; int &gt; m_node vector&lt; int &gt; m_val vector&lt; FEFace * &gt; m_pface vector&lt; int &gt; m_off"},{"location":"api/Classes/classFENodeFaceList.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFENodeFaceList.html#function-fenodefacelist","title":"function FENodeFaceList","text":"<pre><code>FENodeFaceList(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-fenodefacelist_1","title":"function ~FENodeFaceList","text":"<pre><code>~FENodeFaceList(\n    void \n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-build","title":"function Build","text":"<pre><code>void Build()\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-buildsorted","title":"function BuildSorted","text":"<pre><code>void BuildSorted()\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-nodes","title":"function Nodes","text":"<pre><code>inline int Nodes()\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-node","title":"function Node","text":"<pre><code>inline FENode &amp; Node(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-valence","title":"function Valence","text":"<pre><code>inline int Valence(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-face","title":"function Face","text":"<pre><code>inline FEFace * Face(\n    int n,\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#function-hasface","title":"function HasFace","text":"<pre><code>bool HasFace(\n    int n,\n    FEFace * pf\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFENodeFaceList.html#function-sort","title":"function Sort","text":"<pre><code>void Sort(\n    int node\n)\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFENodeFaceList.html#variable-m_pm","title":"variable m_pm","text":"<pre><code>FEMesh * m_pm;\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#variable-m_node","title":"variable m_node","text":"<pre><code>vector&lt; int &gt; m_node;\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#variable-m_val","title":"variable m_val","text":"<pre><code>vector&lt; int &gt; m_val;\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#variable-m_pface","title":"variable m_pface","text":"<pre><code>vector&lt; FEFace * &gt; m_pface;\n</code></pre>"},{"location":"api/Classes/classFENodeFaceList.html#variable-m_off","title":"variable m_off","text":"<pre><code>vector&lt; int &gt; m_off;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFENodeNodeList.html","title":"FENodeNodeList","text":""},{"location":"api/Classes/classFENodeNodeList.html#public-functions","title":"Public Functions","text":"Name FENodeNodeList(FEMesh * pm) ~FENodeNodeList() void Build() int Valence(int n) int Node(int n, int j)"},{"location":"api/Classes/classFENodeNodeList.html#protected-attributes","title":"Protected Attributes","text":"Name FEMesh * m_pm vector&lt; int &gt; m_val vector&lt; int &gt; m_off vector&lt; int &gt; m_node"},{"location":"api/Classes/classFENodeNodeList.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFENodeNodeList.html#function-fenodenodelist","title":"function FENodeNodeList","text":"<pre><code>FENodeNodeList(\n    FEMesh * pm\n)\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#function-fenodenodelist_1","title":"function ~FENodeNodeList","text":"<pre><code>~FENodeNodeList()\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#function-build","title":"function Build","text":"<pre><code>void Build()\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#function-valence","title":"function Valence","text":"<pre><code>inline int Valence(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#function-node","title":"function Node","text":"<pre><code>inline int Node(\n    int n,\n    int j\n)\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classFENodeNodeList.html#variable-m_pm","title":"variable m_pm","text":"<pre><code>FEMesh * m_pm;\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#variable-m_val","title":"variable m_val","text":"<pre><code>vector&lt; int &gt; m_val;\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#variable-m_off","title":"variable m_off","text":"<pre><code>vector&lt; int &gt; m_off;\n</code></pre>"},{"location":"api/Classes/classFENodeNodeList.html#variable-m_node","title":"variable m_node","text":"<pre><code>vector&lt; int &gt; m_node;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFETri3.html","title":"FETri3","text":"<p>Inherits from FEElement_, FEItem</p>"},{"location":"api/Classes/classFETri3.html#public-functions","title":"Public Functions","text":"Name FETri3()Constructor. FETri3(FETri3 &amp; el)copy constructor FETri3 &amp; operator=(FETri3 &amp; el)assignment operator"},{"location":"api/Classes/classFETri3.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from FEElement_</p> Name FEElement_()constructor bool is_equal(FEElement_ &amp; e) int GetType() constreturn the element type bool IsType(int ntype) constIs the element of this type. int Nodes() constnumber of nodes int Faces() constNumber of faces (shells have no faces) int Edges() constNumber of edges (solids have no edges) int GetFace(int i, int * n)Get only the nodes of face i (only solids have faces) FEFace GetFace(int i)Get the face i (only solids have faces) FEFace GetShellFace()Get the face of a shell. FEEdge GetEdge(int i)Get the edge. bool IsExterior()Is this an exterior element. bool IsSolid() bool IsShell() bool IsBeam() <p>Protected Functions inherited from FEElement_</p> Name void copy(const FEElement_ &amp; el) <p>Public Attributes inherited from FEElement_</p> Name int * m_node pointer to node data int * m_nbr neighbour elements int * m_face faces (-1 for interior faces) double * m_h element thickness (only used by shells) vec3d m_fiber fiber orientation mat3d m_Q local material orientation bool m_Qactive active local material orientation double m_a0 cross-sectional area (only used by truss elements) <p>Protected Attributes inherited from FEElement_</p> Name int m_ntype type of element int m_nodes nr of nodes int m_nfaces nr of faces ( 0 for shells) int m_nedges nr of edges ( 0 for solids) <p>Public Functions inherited from FEItem</p> Name FEItem() bool IsVisible() const bool IsSelected() const void Select() void UnSelect() void Show() void Hide() unsigned int GetFEState() const void SetFEState(unsigned int state) <p>Public Attributes inherited from FEItem</p> Name int m_ntag int m_gid int m_nid"},{"location":"api/Classes/classFETri3.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFETri3.html#function-fetri3","title":"function FETri3","text":"<pre><code>FETri3()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classFETri3.html#function-fetri3_1","title":"function FETri3","text":"<pre><code>FETri3(\n    FETri3 &amp; el\n)\n</code></pre> <p>copy constructor </p>"},{"location":"api/Classes/classFETri3.html#function-operator","title":"function operator=","text":"<pre><code>FETri3 &amp; operator=(\n    FETri3 &amp; el\n)\n</code></pre> <p>assignment operator </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEVTKExport.html","title":"FEVTKExport","text":""},{"location":"api/Classes/classFEVTKExport.html#public-functions","title":"Public Functions","text":"Name FEVTKExport() ~FEVTKExport() =default bool Export(FEMesh &amp; mesh, const char * szfile) std::string ExportToString(FEMesh &amp; mesh) bool ExportToStream(FEMesh &amp; mesh, std::ostream &amp; out) void SetOptions(VTKEXPORT o) vtkSmartPointer&lt; vtkPolyData &gt; ExportToVTK(FEMesh &amp; mesh)"},{"location":"api/Classes/classFEVTKExport.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEVTKExport.html#function-fevtkexport","title":"function FEVTKExport","text":"<pre><code>FEVTKExport()\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-fevtkexport_1","title":"function ~FEVTKExport","text":"<pre><code>~FEVTKExport() =default\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-export","title":"function Export","text":"<pre><code>bool Export(\n    FEMesh &amp; mesh,\n    const char * szfile\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-exporttostring","title":"function ExportToString","text":"<pre><code>std::string ExportToString(\n    FEMesh &amp; mesh\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-exporttostream","title":"function ExportToStream","text":"<pre><code>bool ExportToStream(\n    FEMesh &amp; mesh,\n    std::ostream &amp; out\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-setoptions","title":"function SetOptions","text":"<pre><code>inline void SetOptions(\n    VTKEXPORT o\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKExport.html#function-exporttovtk","title":"function ExportToVTK","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; ExportToVTK(\n    FEMesh &amp; mesh\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classFEVTKimport.html","title":"FEVTKimport","text":""},{"location":"api/Classes/classFEVTKimport.html#public-functions","title":"Public Functions","text":"Name FEVTKimport() ~FEVTKimport(void ) FEMesh * Load(const char * szfile) FEMesh * Load(istream &amp; stream) FEMesh * Load(vtkPolyData * polydata)"},{"location":"api/Classes/classFEVTKimport.html#protected-functions","title":"Protected Functions","text":"Name bool BuildMesh() FEMesh * errf(const char * sz, ... ) void Close()"},{"location":"api/Classes/classFEVTKimport.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classFEVTKimport.html#function-fevtkimport","title":"function FEVTKimport","text":"<pre><code>FEVTKimport()\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-fevtkimport_1","title":"function ~FEVTKimport","text":"<pre><code>~FEVTKimport(\n    void \n)\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-load","title":"function Load","text":"<pre><code>FEMesh * Load(\n    const char * szfile\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-load_1","title":"function Load","text":"<pre><code>FEMesh * Load(\n    istream &amp; stream\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-load_2","title":"function Load","text":"<pre><code>FEMesh * Load(\n    vtkPolyData * polydata\n)\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classFEVTKimport.html#function-buildmesh","title":"function BuildMesh","text":"<pre><code>bool BuildMesh()\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-errf","title":"function errf","text":"<pre><code>FEMesh * errf(\n    const char * sz,\n    ... \n)\n</code></pre>"},{"location":"api/Classes/classFEVTKimport.html#function-close","title":"function Close","text":"<pre><code>void Close()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classGLCOLOR.html","title":"GLCOLOR","text":""},{"location":"api/Classes/classGLCOLOR.html#public-functions","title":"Public Functions","text":"Name GLCOLOR() GLCOLOR(uchar ur, uchar ug, uchar ub, uchar ua =255) GLCOLOR operator*(double f) GLCOLOR operator+(GLCOLOR &amp; c)"},{"location":"api/Classes/classGLCOLOR.html#public-attributes","title":"Public Attributes","text":"Name uchar a uchar b uchar g uchar r"},{"location":"api/Classes/classGLCOLOR.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classGLCOLOR.html#function-glcolor","title":"function GLCOLOR","text":"<pre><code>inline GLCOLOR()\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#function-glcolor_1","title":"function GLCOLOR","text":"<pre><code>inline GLCOLOR(\n    uchar ur,\n    uchar ug,\n    uchar ub,\n    uchar ua =255\n)\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#function-operator","title":"function operator*","text":"<pre><code>inline GLCOLOR operator*(\n    double f\n)\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#function-operator_1","title":"function operator+","text":"<pre><code>inline GLCOLOR operator+(\n    GLCOLOR &amp; c\n)\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classGLCOLOR.html#variable-a","title":"variable a","text":"<pre><code>uchar a;\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#variable-b","title":"variable b","text":"<pre><code>uchar b;\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#variable-g","title":"variable g","text":"<pre><code>uchar g;\n</code></pre>"},{"location":"api/Classes/classGLCOLOR.html#variable-r","title":"variable r","text":"<pre><code>uchar r;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classLegacyMeshGenerator.html","title":"LegacyMeshGenerator","text":""},{"location":"api/Classes/classLegacyMeshGenerator.html#public-functions","title":"Public Functions","text":"Name LegacyMeshGenerator() ~LegacyMeshGenerator() void setNeighborhoodSize(int size) void setSampleSpacing(double spacing) void setUsePowerCrust(bool enabled) void setSmoothingAmount(float amount) vtkSmartPointer&lt; vtkPolyData &gt; buildMesh(const Eigen::VectorXd &amp; shape)"},{"location":"api/Classes/classLegacyMeshGenerator.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classLegacyMeshGenerator.html#function-legacymeshgenerator","title":"function LegacyMeshGenerator","text":"<pre><code>LegacyMeshGenerator()\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-legacymeshgenerator_1","title":"function ~LegacyMeshGenerator","text":"<pre><code>~LegacyMeshGenerator()\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-setneighborhoodsize","title":"function setNeighborhoodSize","text":"<pre><code>void setNeighborhoodSize(\n    int size\n)\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-setsamplespacing","title":"function setSampleSpacing","text":"<pre><code>void setSampleSpacing(\n    double spacing\n)\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-setusepowercrust","title":"function setUsePowerCrust","text":"<pre><code>void setUsePowerCrust(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-setsmoothingamount","title":"function setSmoothingAmount","text":"<pre><code>void setSmoothingAmount(\n    float amount\n)\n</code></pre>"},{"location":"api/Classes/classLegacyMeshGenerator.html#function-buildmesh","title":"function buildMesh","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; buildMesh(\n    const Eigen::VectorXd &amp; shape\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classMeshSettings.html","title":"MeshSettings","text":"<p>Settings for creating a mesh.  More...</p> <p><code>#include &lt;MeshSettings.h&gt;</code></p>"},{"location":"api/Classes/classMeshSettings.html#public-functions","title":"Public Functions","text":"Name MeshSettings()Constructor. ~MeshSettings()Destructor."},{"location":"api/Classes/classMeshSettings.html#detailed-description","title":"Detailed Description","text":"<pre><code>class MeshSettings;\n</code></pre> <p>Settings for creating a mesh. </p> <p>The MeshSettings class represents a set of settings used it creating a mesh. </p>"},{"location":"api/Classes/classMeshSettings.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classMeshSettings.html#function-meshsettings","title":"function MeshSettings","text":"<pre><code>MeshSettings()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classMeshSettings.html#function-meshsettings_1","title":"function ~MeshSettings","text":"<pre><code>~MeshSettings()\n</code></pre> <p>Destructor. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classObjectReader.html","title":"ObjectReader","text":"<p>More...</p>"},{"location":"api/Classes/classObjectReader.html#public-types","title":"Public Types","text":"Name typedef ObjectReader Self typedef T ObjectType"},{"location":"api/Classes/classObjectReader.html#public-functions","title":"Public Functions","text":"Name const std::vector&lt; ObjectType &gt; &amp; GetOutput() const std::vector&lt; ObjectType &gt; &amp; GetOutput() void SetFileName(const char * fn) void SetFileName(const std::string &amp; fn) const std::string &amp; GetFileName() const void Read() void Update() ObjectReader() virtual ~ObjectReader()"},{"location":"api/Classes/classObjectReader.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass ObjectReader;\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classObjectReader.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ObjectReader ObjectReader&lt; T &gt;::Self;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classObjectReader.html#typedef-objecttype","title":"typedef ObjectType","text":"<pre><code>typedef T ObjectReader&lt; T &gt;::ObjectType;\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classObjectReader.html#function-getoutput","title":"function GetOutput","text":"<pre><code>inline const std::vector&lt; ObjectType &gt; &amp; GetOutput() const\n</code></pre> <p>Get the output of the reader. The output is a std::vector of TransformType. </p>"},{"location":"api/Classes/classObjectReader.html#function-getoutput_1","title":"function GetOutput","text":"<pre><code>inline std::vector&lt; ObjectType &gt; &amp; GetOutput()\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-setfilename","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const char * fn\n)\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-setfilename_1","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const std::string &amp; fn\n)\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-getfilename","title":"function GetFileName","text":"<pre><code>inline const std::string &amp; GetFileName() const\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-read","title":"function Read","text":"<pre><code>inline void Read()\n</code></pre> <p>Read the file. </p>"},{"location":"api/Classes/classObjectReader.html#function-update","title":"function Update","text":"<pre><code>inline void Update()\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-objectreader","title":"function ObjectReader","text":"<pre><code>inline ObjectReader()\n</code></pre>"},{"location":"api/Classes/classObjectReader.html#function-objectreader_1","title":"function ~ObjectReader","text":"<pre><code>inline virtual ~ObjectReader()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classObjectWriter.html","title":"ObjectWriter","text":"<p>More...</p>"},{"location":"api/Classes/classObjectWriter.html#public-types","title":"Public Types","text":"Name typedef ObjectWriter Self typedef T ObjectType"},{"location":"api/Classes/classObjectWriter.html#public-functions","title":"Public Functions","text":"Name void SetInput(const std::vector&lt; ObjectType &gt; &amp; p) void SetFileName(const char * fn) void SetFileName(const std::string &amp; fn) const std::string &amp; GetFileName() const void Write() void Update() ObjectWriter() virtual ~ObjectWriter()"},{"location":"api/Classes/classObjectWriter.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass ObjectWriter;\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classObjectWriter.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ObjectWriter ObjectWriter&lt; T &gt;::Self;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classObjectWriter.html#typedef-objecttype","title":"typedef ObjectType","text":"<pre><code>typedef T ObjectWriter&lt; T &gt;::ObjectType;\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classObjectWriter.html#function-setinput","title":"function SetInput","text":"<pre><code>inline void SetInput(\n    const std::vector&lt; ObjectType &gt; &amp; p\n)\n</code></pre> <p>Set the input vector. The input is a reference to a std::vector of ObjectType. </p>"},{"location":"api/Classes/classObjectWriter.html#function-setfilename","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const char * fn\n)\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#function-setfilename_1","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const std::string &amp; fn\n)\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#function-getfilename","title":"function GetFileName","text":"<pre><code>inline const std::string &amp; GetFileName() const\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#function-write","title":"function Write","text":"<pre><code>inline void Write()\n</code></pre> <p>Write the file. </p>"},{"location":"api/Classes/classObjectWriter.html#function-update","title":"function Update","text":"<pre><code>inline void Update()\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#function-objectwriter","title":"function ObjectWriter","text":"<pre><code>inline ObjectWriter()\n</code></pre>"},{"location":"api/Classes/classObjectWriter.html#function-objectwriter_1","title":"function ~ObjectWriter","text":"<pre><code>inline virtual ~ObjectWriter()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleEvent_1_1_01Parent.html","title":"classParticleEvent 1 1 01Parent","text":"<p>title: ParticleEvent:: Parent</p>"},{"location":"api/Classes/classParticleEvent_1_1_01Parent.html#particleevent-parent","title":"ParticleEvent:: Parent","text":"<p>More...</p>"},{"location":"api/Classes/classParticleEvent_1_1_01Parent.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleEvent:: Parent;\n</code></pre> <p>all Particle events.</p> <p>Event that carries Position index and a Domain index information. This is used, for example to indicate which position has changed in the particle system on InvokeEvent. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleImageDomain.html","title":"ParticleImageDomain","text":"<p>More...</p> <p><code>#include &lt;ImageDomain.h&gt;</code></p>"},{"location":"api/Classes/classParticleImageDomain.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleImageDomain;\n</code></pre> <p>A bounding-box region domain that sets its bounding box according to the origin, spacing, and RequestedRegion of a specified itk::Image. This Domain object may be sampled for interpolated image values using the Sample(Point) method. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleImageDomainWithCurvature.html","title":"ParticleImageDomainWithCurvature","text":"<p>More...</p> <p><code>#include &lt;ImageDomainWithCurvature.h&gt;</code></p>"},{"location":"api/Classes/classParticleImageDomainWithCurvature.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleImageDomainWithCurvature;\n</code></pre> <p>See: </p> <ul> <li>ParticleImageDomain</li> <li>ParticleClipRegionDomain </li> <li>ParticleDomain </li> </ul> <p>An image domain that extends ParticleImageDomainWithGradN with curvature information.</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleImageDomainWithGradN.html","title":"ParticleImageDomainWithGradN","text":"<p>More...</p> <p><code>#include &lt;ImageDomainWithGradN.h&gt;</code></p>"},{"location":"api/Classes/classParticleImageDomainWithGradN.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleImageDomainWithGradN;\n</code></pre> <p>See: </p> <ul> <li>ParticleImageDomain</li> <li>ParticleClipRegionDomain </li> <li>ParticleDomain </li> </ul> <p>An image domain that extends ParticleImageDomainWithGradients with gradient of normals information.</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleImageDomainWithGradients.html","title":"ParticleImageDomainWithGradients","text":"<p>More...</p> <p><code>#include &lt;ImageDomainWithGradients.h&gt;</code></p>"},{"location":"api/Classes/classParticleImageDomainWithGradients.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleImageDomainWithGradients;\n</code></pre> <p>See: </p> <ul> <li>ParticleImageDomain</li> <li>ParticleClipRegionDomain </li> <li>ParticleDomain </li> </ul> <p>An image domain that extends ParticleImageDomainWithGradients with image gradient information. Gradient values are interpolated with the SampleGradients(point) method.</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleImplicitSurfaceDomain.html","title":"ParticleImplicitSurfaceDomain","text":"<p>More...</p> <p><code>#include &lt;ImplicitSurfaceDomain.h&gt;</code></p>"},{"location":"api/Classes/classParticleImplicitSurfaceDomain.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleImplicitSurfaceDomain;\n</code></pre> <p>A 3D cartesian domain that constrains points so that they always lie an implicit surface. The implicit surface is defined as the zero isosurface of the given image. Constraints are applied using a Newton-Raphson iteration, and this class assumes it has a distance transform as an image. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleMeanCurvatureAttribute.html","title":"ParticleMeanCurvatureAttribute","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleProcrustesRegistration.html","title":"ParticleProcrustesRegistration","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleShapeLinearRegressionMatrixAttribute.html","title":"ParticleShapeLinearRegressionMatrixAttribute","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleShapeMatrixAttribute.html","title":"ParticleShapeMatrixAttribute","text":"<p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES!  More...</p> <p><code>#include &lt;LegacyShapeMatrix.h&gt;</code></p>"},{"location":"api/Classes/classParticleShapeMatrixAttribute.html#detailed-description","title":"Detailed Description","text":"<pre><code>class ParticleShapeMatrixAttribute;\n</code></pre> <p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </p> <p>Each column represents a single shape. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classParticleShapeMixedEffectsMatrixAttribute.html","title":"ParticleShapeMixedEffectsMatrixAttribute","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classPreferences.html","title":"Preferences","text":"<p>Application preferences.  More...</p> <p><code>#include &lt;Preferences.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classPreferences.html#public-types","title":"Public Types","text":"Name enum OrientationMarkerType enum OrientationMarkerCorner enum @4"},{"location":"api/Classes/classPreferences.html#public-signals","title":"Public Signals","text":"Name void color_scheme_changed(int newIndex) void glyph_properties_changed() void threading_changed_signal() void sliders_changed_signal()"},{"location":"api/Classes/classPreferences.html#public-functions","title":"Public Functions","text":"Name Preferences() void restore_defaults() void add_recent_file(QString file, QString path) QStringList get_recent_files() QStringList get_recent_paths() QByteArray get_window_geometry() void set_window_geometry(QByteArray geometry) QByteArray get_window_state() void set_window_state(QByteArray state) QString get_last_directory() void set_last_directory(QString value) bool get_cache_enabled() void set_cache_enabled(bool value) bool get_parallel_enabled() void set_parallel_enabled(bool value) int get_memory_cache_percent() void set_memory_cache_percent(int value) int get_num_threads() void set_num_threads(int num_threads) int get_dataloader_num_workers() void set_dataloader_num_workers(int num_workers) float get_glyph_size() void set_glyph_size(float value) float get_glyph_quality() void set_glyph_quality(float value) bool get_glyph_auto_size() void set_glyph_auto_size(bool value) bool get_glyph_scale_arrows() void set_glyph_scale_arrows(bool value) float get_pca_range() void set_pca_range(float value) int get_pca_steps() void set_pca_steps(int value) void set_color_scheme(int value) int get_color_scheme() void set_particle_colors(int value) int get_particle_colors() void set_color_map(int value) int get_color_map() void set_discrete_color_mode(bool value) bool get_discrete_color_mode() void set_reverse_color_map(bool value) bool get_reverse_color_map() bool get_center_checked() void set_center_checked(bool value) int get_geodesic_cache_multiplier() void set_geodesic_cache_multiplier(int value) OrientationMarkerType get_orientation_marker_type() void set_orientation_marker_type(OrientationMarkerType type) OrientationMarkerCorner get_orientation_marker_corner() void set_orientation_marker_corner(OrientationMarkerCorner corner) QString get_groom_file_template() void set_groom_file_template(QString groom_file_template) QString get_optimize_file_template() void set_optimize_file_template(QString optimize_file_template) QSize get_export_override_size() void set_export_override_size(QSize size) bool get_export_override_size_enabled() void set_export_override_size_enabled(bool enabled) bool get_export_show_orientation_marker() void set_export_show_orientation_marker(bool value) bool get_export_show_color_scale() void set_export_show_color_scale(bool value) int get_export_num_pca_images() void set_export_num_pca_images(int number) double get_export_pca_range() void set_export_pca_range(double range) void set_export_pca_modes(QString string) QString get_export_pca_modes() bool get_auto_update_check() void set_auto_update_check(bool enabled) QDateTime get_update_snooze_until() void set_update_snooze_until(QDateTime date) QString get_device_id() bool get_telemetry_enabled() void set_telemetry_enabled(bool enabled) bool get_telemetry_asked() void set_telemetry_asked(bool asked) QStringList get_pending_telemetry_events() void set_pending_telemetry_events(QStringList events)"},{"location":"api/Classes/classPreferences.html#detailed-description","title":"Detailed Description","text":"<pre><code>class Preferences;\n</code></pre> <p>Application preferences. </p> <p>The Preferences singleton controls all preferences for the application. Values persist via the QSettings class. </p>"},{"location":"api/Classes/classPreferences.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classPreferences.html#enum-orientationmarkertype","title":"enum OrientationMarkerType","text":"Enumerator Value Description medical 0 triad 1 none 2"},{"location":"api/Classes/classPreferences.html#enum-orientationmarkercorner","title":"enum OrientationMarkerCorner","text":"Enumerator Value Description upper_right 0 lower_right 1 lower_left 2 upper_left 3"},{"location":"api/Classes/classPreferences.html#enum-4","title":"enum @4","text":"Enumerator Value Description MAX_RECENT_FILES 64"},{"location":"api/Classes/classPreferences.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classPreferences.html#signal-color_scheme_changed","title":"signal color_scheme_changed","text":"<pre><code>void color_scheme_changed(\n    int newIndex\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#signal-glyph_properties_changed","title":"signal glyph_properties_changed","text":"<pre><code>void glyph_properties_changed()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#signal-threading_changed_signal","title":"signal threading_changed_signal","text":"<pre><code>void threading_changed_signal()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#signal-sliders_changed_signal","title":"signal sliders_changed_signal","text":"<pre><code>void sliders_changed_signal()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classPreferences.html#function-preferences","title":"function Preferences","text":"<pre><code>Preferences()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-restore_defaults","title":"function restore_defaults","text":"<pre><code>void restore_defaults()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-add_recent_file","title":"function add_recent_file","text":"<pre><code>void add_recent_file(\n    QString file,\n    QString path\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_recent_files","title":"function get_recent_files","text":"<pre><code>QStringList get_recent_files()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_recent_paths","title":"function get_recent_paths","text":"<pre><code>QStringList get_recent_paths()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_window_geometry","title":"function get_window_geometry","text":"<pre><code>QByteArray get_window_geometry()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_window_geometry","title":"function set_window_geometry","text":"<pre><code>void set_window_geometry(\n    QByteArray geometry\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_window_state","title":"function get_window_state","text":"<pre><code>QByteArray get_window_state()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_window_state","title":"function set_window_state","text":"<pre><code>void set_window_state(\n    QByteArray state\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_last_directory","title":"function get_last_directory","text":"<pre><code>QString get_last_directory()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_last_directory","title":"function set_last_directory","text":"<pre><code>void set_last_directory(\n    QString value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_cache_enabled","title":"function get_cache_enabled","text":"<pre><code>bool get_cache_enabled()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_cache_enabled","title":"function set_cache_enabled","text":"<pre><code>void set_cache_enabled(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_parallel_enabled","title":"function get_parallel_enabled","text":"<pre><code>bool get_parallel_enabled()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_parallel_enabled","title":"function set_parallel_enabled","text":"<pre><code>void set_parallel_enabled(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_memory_cache_percent","title":"function get_memory_cache_percent","text":"<pre><code>int get_memory_cache_percent()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_memory_cache_percent","title":"function set_memory_cache_percent","text":"<pre><code>void set_memory_cache_percent(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_num_threads","title":"function get_num_threads","text":"<pre><code>int get_num_threads()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_num_threads","title":"function set_num_threads","text":"<pre><code>void set_num_threads(\n    int num_threads\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_dataloader_num_workers","title":"function get_dataloader_num_workers","text":"<pre><code>int get_dataloader_num_workers()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_dataloader_num_workers","title":"function set_dataloader_num_workers","text":"<pre><code>void set_dataloader_num_workers(\n    int num_workers\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_glyph_size","title":"function get_glyph_size","text":"<pre><code>float get_glyph_size()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_glyph_size","title":"function set_glyph_size","text":"<pre><code>void set_glyph_size(\n    float value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_glyph_quality","title":"function get_glyph_quality","text":"<pre><code>float get_glyph_quality()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_glyph_quality","title":"function set_glyph_quality","text":"<pre><code>void set_glyph_quality(\n    float value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_glyph_auto_size","title":"function get_glyph_auto_size","text":"<pre><code>bool get_glyph_auto_size()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_glyph_auto_size","title":"function set_glyph_auto_size","text":"<pre><code>void set_glyph_auto_size(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_glyph_scale_arrows","title":"function get_glyph_scale_arrows","text":"<pre><code>bool get_glyph_scale_arrows()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_glyph_scale_arrows","title":"function set_glyph_scale_arrows","text":"<pre><code>void set_glyph_scale_arrows(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_pca_range","title":"function get_pca_range","text":"<pre><code>float get_pca_range()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_pca_range","title":"function set_pca_range","text":"<pre><code>void set_pca_range(\n    float value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_pca_steps","title":"function get_pca_steps","text":"<pre><code>int get_pca_steps()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_pca_steps","title":"function set_pca_steps","text":"<pre><code>void set_pca_steps(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_color_scheme","title":"function set_color_scheme","text":"<pre><code>void set_color_scheme(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_color_scheme","title":"function get_color_scheme","text":"<pre><code>int get_color_scheme()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_particle_colors","title":"function set_particle_colors","text":"<pre><code>void set_particle_colors(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_particle_colors","title":"function get_particle_colors","text":"<pre><code>int get_particle_colors()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_color_map","title":"function set_color_map","text":"<pre><code>void set_color_map(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_color_map","title":"function get_color_map","text":"<pre><code>int get_color_map()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_discrete_color_mode","title":"function set_discrete_color_mode","text":"<pre><code>void set_discrete_color_mode(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_discrete_color_mode","title":"function get_discrete_color_mode","text":"<pre><code>bool get_discrete_color_mode()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_reverse_color_map","title":"function set_reverse_color_map","text":"<pre><code>void set_reverse_color_map(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_reverse_color_map","title":"function get_reverse_color_map","text":"<pre><code>bool get_reverse_color_map()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_center_checked","title":"function get_center_checked","text":"<pre><code>bool get_center_checked()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_center_checked","title":"function set_center_checked","text":"<pre><code>void set_center_checked(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_geodesic_cache_multiplier","title":"function get_geodesic_cache_multiplier","text":"<pre><code>int get_geodesic_cache_multiplier()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_geodesic_cache_multiplier","title":"function set_geodesic_cache_multiplier","text":"<pre><code>void set_geodesic_cache_multiplier(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_orientation_marker_type","title":"function get_orientation_marker_type","text":"<pre><code>OrientationMarkerType get_orientation_marker_type()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_orientation_marker_type","title":"function set_orientation_marker_type","text":"<pre><code>void set_orientation_marker_type(\n    OrientationMarkerType type\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_orientation_marker_corner","title":"function get_orientation_marker_corner","text":"<pre><code>OrientationMarkerCorner get_orientation_marker_corner()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_orientation_marker_corner","title":"function set_orientation_marker_corner","text":"<pre><code>void set_orientation_marker_corner(\n    OrientationMarkerCorner corner\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_groom_file_template","title":"function get_groom_file_template","text":"<pre><code>QString get_groom_file_template()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_groom_file_template","title":"function set_groom_file_template","text":"<pre><code>void set_groom_file_template(\n    QString groom_file_template\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_optimize_file_template","title":"function get_optimize_file_template","text":"<pre><code>QString get_optimize_file_template()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_optimize_file_template","title":"function set_optimize_file_template","text":"<pre><code>void set_optimize_file_template(\n    QString optimize_file_template\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_override_size","title":"function get_export_override_size","text":"<pre><code>QSize get_export_override_size()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_override_size","title":"function set_export_override_size","text":"<pre><code>void set_export_override_size(\n    QSize size\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_override_size_enabled","title":"function get_export_override_size_enabled","text":"<pre><code>bool get_export_override_size_enabled()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_override_size_enabled","title":"function set_export_override_size_enabled","text":"<pre><code>void set_export_override_size_enabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_show_orientation_marker","title":"function get_export_show_orientation_marker","text":"<pre><code>bool get_export_show_orientation_marker()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_show_orientation_marker","title":"function set_export_show_orientation_marker","text":"<pre><code>void set_export_show_orientation_marker(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_show_color_scale","title":"function get_export_show_color_scale","text":"<pre><code>bool get_export_show_color_scale()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_show_color_scale","title":"function set_export_show_color_scale","text":"<pre><code>void set_export_show_color_scale(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_num_pca_images","title":"function get_export_num_pca_images","text":"<pre><code>int get_export_num_pca_images()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_num_pca_images","title":"function set_export_num_pca_images","text":"<pre><code>void set_export_num_pca_images(\n    int number\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_pca_range","title":"function get_export_pca_range","text":"<pre><code>double get_export_pca_range()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_pca_range","title":"function set_export_pca_range","text":"<pre><code>void set_export_pca_range(\n    double range\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_export_pca_modes","title":"function set_export_pca_modes","text":"<pre><code>void set_export_pca_modes(\n    QString string\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_export_pca_modes","title":"function get_export_pca_modes","text":"<pre><code>QString get_export_pca_modes()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_auto_update_check","title":"function get_auto_update_check","text":"<pre><code>bool get_auto_update_check()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_auto_update_check","title":"function set_auto_update_check","text":"<pre><code>void set_auto_update_check(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_update_snooze_until","title":"function get_update_snooze_until","text":"<pre><code>QDateTime get_update_snooze_until()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_update_snooze_until","title":"function set_update_snooze_until","text":"<pre><code>void set_update_snooze_until(\n    QDateTime date\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_device_id","title":"function get_device_id","text":"<pre><code>QString get_device_id()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_telemetry_enabled","title":"function get_telemetry_enabled","text":"<pre><code>bool get_telemetry_enabled()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_telemetry_enabled","title":"function set_telemetry_enabled","text":"<pre><code>void set_telemetry_enabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_telemetry_asked","title":"function get_telemetry_asked","text":"<pre><code>bool get_telemetry_asked()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_telemetry_asked","title":"function set_telemetry_asked","text":"<pre><code>void set_telemetry_asked(\n    bool asked\n)\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-get_pending_telemetry_events","title":"function get_pending_telemetry_events","text":"<pre><code>QStringList get_pending_telemetry_events()\n</code></pre>"},{"location":"api/Classes/classPreferences.html#function-set_pending_telemetry_events","title":"function set_pending_telemetry_events","text":"<pre><code>void set_pending_telemetry_events(\n    QStringList events\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classProcrustes3D.html","title":"Procrustes3D","text":""},{"location":"api/Classes/classProcrustes3D.html#public-types","title":"Public Types","text":"Name typedef double RealType typedef vnl_vector_fixed&lt; double, 3 &gt; PointType typedef std::vector&lt; PointType &gt; ShapeType typedef ShapeType::iterator ShapeIteratorType typedef std::vector&lt; ShapeType &gt; ShapeListType typedef ShapeListType::iterator ShapeListIteratorType typedef std::vector&lt; SimilarityTransform3D &gt; SimilarityTransformListType typedef SimilarityTransformListType::iterator SimilarityTransformListIteratorType typedef vnl_matrix_fixed&lt; double, 3+1, 3+1 &gt; TransformMatrixType typedef std::vector&lt; TransformMatrixType &gt; TransformMatrixListType typedef TransformMatrixListType::iterator TransformMatrixIteratorType"},{"location":"api/Classes/classProcrustes3D.html#public-functions","title":"Public Functions","text":"Name Procrustes3D() Procrustes3D(bool do_scaling, bool do_rotation_translation) bool GetScaling() const void ScalingOn() void ScalingOff() bool GetRotationTranslation() const void RotationTranslationOn() void RotationTranslationOff() void AlignShapes(SimilarityTransformListType &amp; transforms, ShapeListType &amp; shapes) void RemoveTranslation(SimilarityTransformListType &amp; transforms, ShapeListType &amp; shapes) void ConstructTransformMatrices(SimilarityTransformListType &amp; transforms, TransformMatrixListType &amp; transformMatrices) void ConstructTransformMatrix(SimilarityTransform3D &amp; transform, TransformMatrixType &amp; transformMatrix) void ComputeMeanShape(ShapeType &amp; mean, ShapeListType &amp; shapeList) void ComputeCenterOfMass(ShapeType &amp; shape, PointType &amp; center) void CenterShape(ShapeType &amp; shape) void ComputeCommonCenter(SimilarityTransformListType &amp; transforms, PointType &amp; center) void AlignSourceToTarget(SimilarityTransform3D &amp; transform, ShapeType &amp; target, ShapeType &amp; source) int ComputeMedianShape(ShapeListType &amp; shapeList) void TransformShape(ShapeType &amp; shape, SimilarityTransform3D &amp; transform) void TransformShapes(ShapeListType &amp; shapes, SimilarityTransformListType &amp; transforms) RealType ComputeSumOfSquares(ShapeListType &amp; shapes)"},{"location":"api/Classes/classProcrustes3D.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classProcrustes3D.html#typedef-realtype","title":"typedef RealType","text":"<pre><code>typedef double Procrustes3D::RealType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef vnl_vector_fixed&lt;double, 3&gt; Procrustes3D::PointType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-shapetype","title":"typedef ShapeType","text":"<pre><code>typedef std::vector&lt;PointType&gt; Procrustes3D::ShapeType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-shapeiteratortype","title":"typedef ShapeIteratorType","text":"<pre><code>typedef ShapeType::iterator Procrustes3D::ShapeIteratorType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-shapelisttype","title":"typedef ShapeListType","text":"<pre><code>typedef std::vector&lt;ShapeType&gt; Procrustes3D::ShapeListType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-shapelistiteratortype","title":"typedef ShapeListIteratorType","text":"<pre><code>typedef ShapeListType::iterator Procrustes3D::ShapeListIteratorType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-similaritytransformlisttype","title":"typedef SimilarityTransformListType","text":"<pre><code>typedef std::vector&lt;SimilarityTransform3D&gt; Procrustes3D::SimilarityTransformListType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-similaritytransformlistiteratortype","title":"typedef SimilarityTransformListIteratorType","text":"<pre><code>typedef SimilarityTransformListType::iterator Procrustes3D::SimilarityTransformListIteratorType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-transformmatrixtype","title":"typedef TransformMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt;double, 3 + 1, 3 + 1&gt; Procrustes3D::TransformMatrixType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-transformmatrixlisttype","title":"typedef TransformMatrixListType","text":"<pre><code>typedef std::vector&lt;TransformMatrixType&gt; Procrustes3D::TransformMatrixListType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#typedef-transformmatrixiteratortype","title":"typedef TransformMatrixIteratorType","text":"<pre><code>typedef TransformMatrixListType::iterator Procrustes3D::TransformMatrixIteratorType;\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classProcrustes3D.html#function-procrustes3d","title":"function Procrustes3D","text":"<pre><code>inline Procrustes3D()\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-procrustes3d_1","title":"function Procrustes3D","text":"<pre><code>inline Procrustes3D(\n    bool do_scaling,\n    bool do_rotation_translation\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-getscaling","title":"function GetScaling","text":"<pre><code>inline bool GetScaling() const\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-scalingon","title":"function ScalingOn","text":"<pre><code>inline void ScalingOn()\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-scalingoff","title":"function ScalingOff","text":"<pre><code>inline void ScalingOff()\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-getrotationtranslation","title":"function GetRotationTranslation","text":"<pre><code>inline bool GetRotationTranslation() const\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-rotationtranslationon","title":"function RotationTranslationOn","text":"<pre><code>inline void RotationTranslationOn()\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-rotationtranslationoff","title":"function RotationTranslationOff","text":"<pre><code>inline void RotationTranslationOff()\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-alignshapes","title":"function AlignShapes","text":"<pre><code>void AlignShapes(\n    SimilarityTransformListType &amp; transforms,\n    ShapeListType &amp; shapes\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-removetranslation","title":"function RemoveTranslation","text":"<pre><code>void RemoveTranslation(\n    SimilarityTransformListType &amp; transforms,\n    ShapeListType &amp; shapes\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-constructtransformmatrices","title":"function ConstructTransformMatrices","text":"<pre><code>void ConstructTransformMatrices(\n    SimilarityTransformListType &amp; transforms,\n    TransformMatrixListType &amp; transformMatrices\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-constructtransformmatrix","title":"function ConstructTransformMatrix","text":"<pre><code>void ConstructTransformMatrix(\n    SimilarityTransform3D &amp; transform,\n    TransformMatrixType &amp; transformMatrix\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-computemeanshape","title":"function ComputeMeanShape","text":"<pre><code>void ComputeMeanShape(\n    ShapeType &amp; mean,\n    ShapeListType &amp; shapeList\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-computecenterofmass","title":"function ComputeCenterOfMass","text":"<pre><code>void ComputeCenterOfMass(\n    ShapeType &amp; shape,\n    PointType &amp; center\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-centershape","title":"function CenterShape","text":"<pre><code>void CenterShape(\n    ShapeType &amp; shape\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-computecommoncenter","title":"function ComputeCommonCenter","text":"<pre><code>void ComputeCommonCenter(\n    SimilarityTransformListType &amp; transforms,\n    PointType &amp; center\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-alignsourcetotarget","title":"function AlignSourceToTarget","text":"<pre><code>void AlignSourceToTarget(\n    SimilarityTransform3D &amp; transform,\n    ShapeType &amp; target,\n    ShapeType &amp; source\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-computemedianshape","title":"function ComputeMedianShape","text":"<pre><code>int ComputeMedianShape(\n    ShapeListType &amp; shapeList\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-transformshape","title":"function TransformShape","text":"<pre><code>static void TransformShape(\n    ShapeType &amp; shape,\n    SimilarityTransform3D &amp; transform\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-transformshapes","title":"function TransformShapes","text":"<pre><code>static void TransformShapes(\n    ShapeListType &amp; shapes,\n    SimilarityTransformListType &amp; transforms\n)\n</code></pre>"},{"location":"api/Classes/classProcrustes3D.html#function-computesumofsquares","title":"function ComputeSumOfSquares","text":"<pre><code>static RealType ComputeSumOfSquares(\n    ShapeListType &amp; shapes\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classReconstruction.html","title":"Reconstruction","text":"<p>More...</p>"},{"location":"api/Classes/classReconstruction.html#public-types","title":"Public Types","text":"Name typedef itk::GradientImageFilter&lt; ImageType, PixelType &gt; GradientFilterType typedef itk::GradientMagnitudeImageFilter&lt; ImageType, ImageType &gt; GradientMagnitudeFilterType typedef itk::Image&lt; itk::CovariantVector&lt; PixelType, 3 &gt;, 3 &gt; GradientImageType typedef itk::ImageRegionIterator&lt; GradientImageType &gt; GradientImageIteratorType typedef itk::ImageRegionIterator&lt; ImageType &gt; ImageIteratorType typedef itk::ImageFileWriter&lt; ImageType &gt; WriterType typedef itk::ImageToVTKImageFilter&lt; ImageType &gt; ITK2VTKConnectorType typedef itk::AddImageFilter&lt; ImageType, ImageType &gt; AddImageFilterType typedef itk::ResampleImageFilter&lt; ImageType, ImageType &gt; ResampleFilterType typedef TInterpolatorType&lt; ImageType, TCoordRep &gt; InterpolatorType typedef itk::MultiplyImageFilter&lt; ImageType, ImageType, ImageType &gt; MultiplyByConstantImageFilterType typedef itk::ImageDuplicator&lt; ImageType &gt; DuplicatorType typedef TTransformType&lt; TCoordRep, 3 &gt; TransformType typedef itk::Point&lt; TCoordRep, 3 &gt; PointType typedef std::vector&lt; PointType &gt; PointArrayType typedef TransformType::PointSetType PointSetType typedef PointSetType::PointIdentifier PointIdType"},{"location":"api/Classes/classReconstruction.html#public-functions","title":"Public Functions","text":"Name Reconstruction(std::string out_prefix =\"\", float decimationPercent =0.3f, double angleThresh =45.0f, size_t numClusters =5, bool fixWinding =true, bool doLaplacianSmoothingBeforeDecimation =true, bool doLaplacianSmoothingAfterDecimation =true, float smoothingLambda =0.5f, int smoothingIterations =1, bool usePairwiseNormalsDifferencesForGoodBad =false) ~Reconstruction() vtkSmartPointer&lt; vtkPolyData &gt; getDenseMean(std::vector&lt; PointArrayType &gt; local_pts =std::vector&lt; PointArrayType &gt;(), std::vector&lt; PointArrayType &gt; global_pts =std::vector&lt; PointArrayType &gt;(), std::vector&lt; std::string &gt; distance_transform =std::vector&lt; std::string &gt;()) void reset() void setDecimation(float dec) void setNumClusters(int num) void setMaxAngle(double angleDegrees) void setFixWinding(bool fixWinding) void setLaplacianSmoothingBeforeDecimation(bool doLaplacianSmoothingBeforeDecimation) void setLaplacianSmoothingAfterDecimation(bool doLaplacianSmoothingAfterDecimation) void setSmoothingLambda(float smoothingLambda) void setSmoothingIterations(int smoothingIterations) void setOutputEnabled(bool enabled) void setMeanBeforeWarpEnabled(bool enabled) vtkSmartPointer&lt; vtkPolyData &gt; getMesh(PointArrayType local_pts) void readMeanInfo(std::string dense, std::string sparse, std::string goodPoints) bool sparseDone() bool denseDone() void writeMeanInfo(std::string nameBase) vtkSmartPointer&lt; vtkPoints &gt; SparseMean() vtkSmartPointer&lt; vtkPolyData &gt; DenseMean() std::vector&lt; bool &gt; GoodPoints() std::string OutPrefix() void setOutPrefix(std::string out_prefix) std::vector&lt; PointArrayType &gt; computeSparseMean(std::vector&lt; PointArrayType &gt; local_pts, itk::Point&lt; TCoordRep &gt; &amp; common_center, bool do_procrustes =true, bool do_procrustes_scaling =false) void setOrigin(typename ImageType::PointType origin) void EnablePairwiseNormalsDifferencesForGoodBad() void DisablePairwiseNormalsDifferencesForGoodBad()"},{"location":"api/Classes/classReconstruction.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename TCoordRep, unsigned &gt; class TTransformType =itk::CompactlySupportedRBFSparseKernelTransform,\ntemplate&lt; typename ImageType, typename TCoordRep &gt; class TInterpolatorType =itk::LinearInterpolateImageFunction,\ntypename TCoordRep  =double,\ntypename PixelType  =float,\ntypename ImageType  =itk::Image&lt;PixelType, 3&gt;&gt;\nclass Reconstruction;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classReconstruction.html#typedef-gradientfiltertype","title":"typedef GradientFilterType","text":"<pre><code>typedef itk::GradientImageFilter&lt;ImageType, PixelType&gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::GradientFilterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-gradientmagnitudefiltertype","title":"typedef GradientMagnitudeFilterType","text":"<pre><code>typedef itk::GradientMagnitudeImageFilter&lt;ImageType, ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::GradientMagnitudeFilterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-gradientimagetype","title":"typedef GradientImageType","text":"<pre><code>typedef itk::Image&lt; itk::CovariantVector&lt; PixelType, 3 &gt;, 3 &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::GradientImageType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-gradientimageiteratortype","title":"typedef GradientImageIteratorType","text":"<pre><code>typedef itk::ImageRegionIterator&lt; GradientImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::GradientImageIteratorType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-imageiteratortype","title":"typedef ImageIteratorType","text":"<pre><code>typedef itk::ImageRegionIterator&lt; ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::ImageIteratorType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-writertype","title":"typedef WriterType","text":"<pre><code>typedef itk::ImageFileWriter&lt; ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::WriterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-itk2vtkconnectortype","title":"typedef ITK2VTKConnectorType","text":"<pre><code>typedef itk::ImageToVTKImageFilter&lt;ImageType&gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::ITK2VTKConnectorType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-addimagefiltertype","title":"typedef AddImageFilterType","text":"<pre><code>typedef itk::AddImageFilter&lt;ImageType, ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::AddImageFilterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-resamplefiltertype","title":"typedef ResampleFilterType","text":"<pre><code>typedef itk::ResampleImageFilter&lt;ImageType, ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::ResampleFilterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-interpolatortype","title":"typedef InterpolatorType","text":"<pre><code>typedef TInterpolatorType&lt; ImageType, TCoordRep &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::InterpolatorType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-multiplybyconstantimagefiltertype","title":"typedef MultiplyByConstantImageFilterType","text":"<pre><code>typedef itk::MultiplyImageFilter&lt;ImageType, ImageType, ImageType&gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::MultiplyByConstantImageFilterType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-duplicatortype","title":"typedef DuplicatorType","text":"<pre><code>typedef itk::ImageDuplicator&lt; ImageType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::DuplicatorType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-transformtype","title":"typedef TransformType","text":"<pre><code>typedef TTransformType&lt; TCoordRep, 3 &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::TransformType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef itk::Point&lt; TCoordRep, 3 &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::PointType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-pointarraytype","title":"typedef PointArrayType","text":"<pre><code>typedef std::vector&lt; PointType &gt; Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::PointArrayType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-pointsettype","title":"typedef PointSetType","text":"<pre><code>typedef TransformType::PointSetType Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::PointSetType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#typedef-pointidtype","title":"typedef PointIdType","text":"<pre><code>typedef PointSetType::PointIdentifier Reconstruction&lt; TTransformType, TInterpolatorType, TCoordRep, PixelType, ImageType &gt;::PointIdType;\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classReconstruction.html#function-reconstruction","title":"function Reconstruction","text":"<pre><code>Reconstruction(\n    std::string out_prefix =\"\",\n    float decimationPercent =0.3f,\n    double angleThresh =45.0f,\n    size_t numClusters =5,\n    bool fixWinding =true,\n    bool doLaplacianSmoothingBeforeDecimation =true,\n    bool doLaplacianSmoothingAfterDecimation =true,\n    float smoothingLambda =0.5f,\n    int smoothingIterations =1,\n    bool usePairwiseNormalsDifferencesForGoodBad =false\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-reconstruction_1","title":"function ~Reconstruction","text":"<pre><code>~Reconstruction()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-getdensemean","title":"function getDenseMean","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; getDenseMean(\n    std::vector&lt; PointArrayType &gt; local_pts =std::vector&lt; PointArrayType &gt;(),\n    std::vector&lt; PointArrayType &gt; global_pts =std::vector&lt; PointArrayType &gt;(),\n    std::vector&lt; std::string &gt; distance_transform =std::vector&lt; std::string &gt;()\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setdecimation","title":"function setDecimation","text":"<pre><code>void setDecimation(\n    float dec\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setnumclusters","title":"function setNumClusters","text":"<pre><code>void setNumClusters(\n    int num\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setmaxangle","title":"function setMaxAngle","text":"<pre><code>void setMaxAngle(\n    double angleDegrees\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setfixwinding","title":"function setFixWinding","text":"<pre><code>void setFixWinding(\n    bool fixWinding\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setlaplaciansmoothingbeforedecimation","title":"function setLaplacianSmoothingBeforeDecimation","text":"<pre><code>void setLaplacianSmoothingBeforeDecimation(\n    bool doLaplacianSmoothingBeforeDecimation\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setlaplaciansmoothingafterdecimation","title":"function setLaplacianSmoothingAfterDecimation","text":"<pre><code>void setLaplacianSmoothingAfterDecimation(\n    bool doLaplacianSmoothingAfterDecimation\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setsmoothinglambda","title":"function setSmoothingLambda","text":"<pre><code>void setSmoothingLambda(\n    float smoothingLambda\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setsmoothingiterations","title":"function setSmoothingIterations","text":"<pre><code>void setSmoothingIterations(\n    int smoothingIterations\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setoutputenabled","title":"function setOutputEnabled","text":"<pre><code>void setOutputEnabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setmeanbeforewarpenabled","title":"function setMeanBeforeWarpEnabled","text":"<pre><code>void setMeanBeforeWarpEnabled(\n    bool enabled\n)\n</code></pre> <p>Set if the mean DT before warp is enabled or not Disabling this allows Reconstruction to use DTs that are of different sizes and with different origins </p>"},{"location":"api/Classes/classReconstruction.html#function-getmesh","title":"function getMesh","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; getMesh(\n    PointArrayType local_pts\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-readmeaninfo","title":"function readMeanInfo","text":"<pre><code>void readMeanInfo(\n    std::string dense,\n    std::string sparse,\n    std::string goodPoints\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-sparsedone","title":"function sparseDone","text":"<pre><code>bool sparseDone()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-densedone","title":"function denseDone","text":"<pre><code>bool denseDone()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-writemeaninfo","title":"function writeMeanInfo","text":"<pre><code>void writeMeanInfo(\n    std::string nameBase\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-sparsemean","title":"function SparseMean","text":"<pre><code>inline vtkSmartPointer&lt; vtkPoints &gt; SparseMean()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-densemean","title":"function DenseMean","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; DenseMean()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-goodpoints","title":"function GoodPoints","text":"<pre><code>inline std::vector&lt; bool &gt; GoodPoints()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-outprefix","title":"function OutPrefix","text":"<pre><code>inline std::string OutPrefix()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setoutprefix","title":"function setOutPrefix","text":"<pre><code>inline void setOutPrefix(\n    std::string out_prefix\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-computesparsemean","title":"function computeSparseMean","text":"<pre><code>std::vector&lt; PointArrayType &gt; computeSparseMean(\n    std::vector&lt; PointArrayType &gt; local_pts,\n    itk::Point&lt; TCoordRep &gt; &amp; common_center,\n    bool do_procrustes =true,\n    bool do_procrustes_scaling =false\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-setorigin","title":"function setOrigin","text":"<pre><code>inline void setOrigin(\n    typename ImageType::PointType origin\n)\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-enablepairwisenormalsdifferencesforgoodbad","title":"function EnablePairwiseNormalsDifferencesForGoodBad","text":"<pre><code>inline void EnablePairwiseNormalsDifferencesForGoodBad()\n</code></pre>"},{"location":"api/Classes/classReconstruction.html#function-disablepairwisenormalsdifferencesforgoodbad","title":"function DisablePairwiseNormalsDifferencesForGoodBad","text":"<pre><code>inline void DisablePairwiseNormalsDifferencesForGoodBad()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html","title":"StudioImageActorPointPlacer","text":"<p>Inherits from vtkImageActorPointPlacer</p>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#public-functions","title":"Public Functions","text":"Name StudioImageActorPointPlacer * New() vtkTypeMacro(StudioImageActorPointPlacer , vtkImageActorPointPlacer ) void PrintSelf(ostream &amp; os, vtkIndent indent) override int ComputeWorldPosition(vtkRenderer * renderer, double displayPos[2], double worldPos[3], double worldOrient[9]) override int ValidateWorldPosition(double worldPos[3]) override int UpdateWorldPosition(vtkRenderer * renderer, double worldPos[3], double worldOrient[9]) override"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#protected-functions","title":"Protected Functions","text":"Name StudioImageActorPointPlacer() ~StudioImageActorPointPlacer() override"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-new","title":"function New","text":"<pre><code>static StudioImageActorPointPlacer * New()\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    StudioImageActorPointPlacer ,\n    vtkImageActorPointPlacer \n)\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    ostream &amp; os,\n    vtkIndent indent\n) override\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-computeworldposition","title":"function ComputeWorldPosition","text":"<pre><code>int ComputeWorldPosition(\n    vtkRenderer * renderer,\n    double displayPos[2],\n    double worldPos[3],\n    double worldOrient[9]\n) override\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-validateworldposition","title":"function ValidateWorldPosition","text":"<pre><code>int ValidateWorldPosition(\n    double worldPos[3]\n) override\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-updateworldposition","title":"function UpdateWorldPosition","text":"<pre><code>int UpdateWorldPosition(\n    vtkRenderer * renderer,\n    double worldPos[3],\n    double worldOrient[9]\n) override\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-studioimageactorpointplacer","title":"function StudioImageActorPointPlacer","text":"<pre><code>StudioImageActorPointPlacer()\n</code></pre>"},{"location":"api/Classes/classStudioImageActorPointPlacer.html#function-studioimageactorpointplacer_1","title":"function ~StudioImageActorPointPlacer","text":"<pre><code>~StudioImageActorPointPlacer() override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classStudioLogger.html","title":"StudioLogger","text":"<p>Handle logger callbacks via Qt for thread correctness. </p> <p><code>#include &lt;StudioLogger.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classStudioLogger.html#public-signals","title":"Public Signals","text":"Name void message(std::string str) void error(std::string str) void warning(std::string str) void debug(std::string str) void status(std::string str) void progress(int value, std::string str)"},{"location":"api/Classes/classStudioLogger.html#public-functions","title":"Public Functions","text":"Name StudioLogger() virtual ~StudioLogger() void register_callbacks() void handle_message(std::string str) void handle_error(std::string str) void handle_warning(std::string str) void handle_debug(std::string str) void handle_status(std::string str) void handle_progress(double value, std::string str)"},{"location":"api/Classes/classStudioLogger.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classStudioLogger.html#signal-message","title":"signal message","text":"<pre><code>void message(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#signal-error","title":"signal error","text":"<pre><code>void error(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#signal-warning","title":"signal warning","text":"<pre><code>void warning(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#signal-debug","title":"signal debug","text":"<pre><code>void debug(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#signal-status","title":"signal status","text":"<pre><code>void status(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int value,\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classStudioLogger.html#function-studiologger","title":"function StudioLogger","text":"<pre><code>inline StudioLogger()\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-studiologger_1","title":"function ~StudioLogger","text":"<pre><code>virtual ~StudioLogger()\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-register_callbacks","title":"function register_callbacks","text":"<pre><code>void register_callbacks()\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_message","title":"function handle_message","text":"<pre><code>void handle_message(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_error","title":"function handle_error","text":"<pre><code>void handle_error(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_warning","title":"function handle_warning","text":"<pre><code>void handle_warning(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_debug","title":"function handle_debug","text":"<pre><code>void handle_debug(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_status","title":"function handle_status","text":"<pre><code>void handle_status(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classStudioLogger.html#function-handle_progress","title":"function handle_progress","text":"<pre><code>void handle_progress(\n    double value,\n    std::string str\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classSurfaceReconstructor.html","title":"SurfaceReconstructor","text":""},{"location":"api/Classes/classSurfaceReconstructor.html#public-functions","title":"Public Functions","text":"Name SurfaceReconstructor() ~SurfaceReconstructor() void initializeReconstruction(std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; local_pts, std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; global_pts, std::vector&lt; std::string &gt; distance_transforms, double maxAngle, float decimationPercent, int numClusters) bool hasDenseMean() void setMean(vtkSmartPointer&lt; vtkPoints &gt; sparseMean, vtkSmartPointer&lt; vtkPolyData &gt; denseMean, std::vector&lt; bool &gt; goodPoints) void writeMeanInfo(std::string baseName) void readMeanInfo(std::string dense, std::string sparse, std::string goodPoints) void resetReconstruct() void set_number_of_clusters(int num_clusters) void set_normal_angle(double angle) void set_decimation_percent(double decimation) bool get_surface_reconstruction_available() vtkSmartPointer&lt; vtkPolyData &gt; build_mesh(const Eigen::VectorXd &amp; shape)"},{"location":"api/Classes/classSurfaceReconstructor.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classSurfaceReconstructor.html#function-surfacereconstructor","title":"function SurfaceReconstructor","text":"<pre><code>SurfaceReconstructor()\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-surfacereconstructor_1","title":"function ~SurfaceReconstructor","text":"<pre><code>~SurfaceReconstructor()\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-initializereconstruction","title":"function initializeReconstruction","text":"<pre><code>void initializeReconstruction(\n    std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; local_pts,\n    std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; global_pts,\n    std::vector&lt; std::string &gt; distance_transforms,\n    double maxAngle,\n    float decimationPercent,\n    int numClusters\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-hasdensemean","title":"function hasDenseMean","text":"<pre><code>bool hasDenseMean()\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-setmean","title":"function setMean","text":"<pre><code>void setMean(\n    vtkSmartPointer&lt; vtkPoints &gt; sparseMean,\n    vtkSmartPointer&lt; vtkPolyData &gt; denseMean,\n    std::vector&lt; bool &gt; goodPoints\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-writemeaninfo","title":"function writeMeanInfo","text":"<pre><code>void writeMeanInfo(\n    std::string baseName\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-readmeaninfo","title":"function readMeanInfo","text":"<pre><code>void readMeanInfo(\n    std::string dense,\n    std::string sparse,\n    std::string goodPoints\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-resetreconstruct","title":"function resetReconstruct","text":"<pre><code>void resetReconstruct()\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-set_number_of_clusters","title":"function set_number_of_clusters","text":"<pre><code>void set_number_of_clusters(\n    int num_clusters\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-set_normal_angle","title":"function set_normal_angle","text":"<pre><code>void set_normal_angle(\n    double angle\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-set_decimation_percent","title":"function set_decimation_percent","text":"<pre><code>void set_decimation_percent(\n    double decimation\n)\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-get_surface_reconstruction_available","title":"function get_surface_reconstruction_available","text":"<pre><code>bool get_surface_reconstruction_available()\n</code></pre>"},{"location":"api/Classes/classSurfaceReconstructor.html#function-build_mesh","title":"function build_mesh","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; build_mesh(\n    const Eigen::VectorXd &amp; shape\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classUtils.html","title":"Utils","text":""},{"location":"api/Classes/classUtils.html#public-functions","title":"Public Functions","text":"Name std::vector&lt; int &gt; randperm(int n) void readSparseShape(vtkSmartPointer&lt; vtkPoints &gt; &amp; points, char * filename, int number_of_particles =-1) void writeSparseShape(char * filename, vtkSmartPointer&lt; vtkPoints &gt; particles) void readSparseShape(std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; points, char * filename, int number_of_particles =-1) void writeSparseShape(char * filename, std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points) std::vector&lt; int &gt; readParticleIds(char * filename) void writeParticleIds(char * filename, std::vector&lt; int &gt; ids) void quiet_delete_file(const std::string &amp; filename) void computeCenterOfMassForShapeEnsemble(std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list, itk::Point&lt; double, 3 &gt; &amp; center) void computeCenterOfMassForShape(std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points, itk::Point&lt; double, 3 &gt; &amp; center) void updateMin(double curVal, double &amp; minVal) void updateMax(double curVal, double &amp; maxVal) void getBoundingBoxForShapeEnsemble(std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list, double &amp; min_x, double &amp; min_y, double &amp; min_z, double &amp; max_x, double &amp; max_y, double &amp; max_z) void getBoundingBoxForShape(std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points, double &amp; min_x, double &amp; min_y, double &amp; min_z, double &amp; max_x, double &amp; max_y, double &amp; max_z) void spherical2cartesian(const double inPoint[3], double outPoint[3]) void cartesian2spherical(const double inPoint[3], double outPoint[3]) vtkSmartPointer&lt; vtkPoints &gt; convertToPhysicalCoordinates(vtkSmartPointer&lt; vtkPoints &gt; particles, int number_of_particles, const itk::Image&lt; float, 3 &gt;::SpacingType &amp; spacing, const itk::Image&lt; float, 3 &gt;::PointType &amp; origin) vtkSmartPointer&lt; vtkPoints &gt; convertToImageCoordinates(vtkSmartPointer&lt; vtkPoints &gt; particles, int number_of_particles, const itk::Image&lt; float, 3 &gt;::SpacingType &amp; spacing, const itk::Image&lt; float, 3 &gt;::PointType &amp; origin) std::string num2str(float num) std::string num2str(int num) std::vector&lt; double &gt; linspace(double a, double b, size_t N) std::string int2str(int n, int number_of_zeros) template &lt;typename T &gt; void multiply_into(Eigen::MatrixXd &amp; out, const vnl_matrix&lt; T &gt; &amp; lhs, const vnl_matrix&lt; T &gt; &amp; rhs) double averageThetaBruteForce(std::vector&lt; double &gt; thetas, double dtheta) double averageThetaChord(std::vector&lt; double &gt; thetas) double averageThetaArc(std::vector&lt; double &gt; thetas)"},{"location":"api/Classes/classUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classUtils.html#function-randperm","title":"function randperm","text":"<pre><code>static std::vector&lt; int &gt; randperm(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-readsparseshape","title":"function readSparseShape","text":"<pre><code>static void readSparseShape(\n    vtkSmartPointer&lt; vtkPoints &gt; &amp; points,\n    char * filename,\n    int number_of_particles =-1\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-writesparseshape","title":"function writeSparseShape","text":"<pre><code>static void writeSparseShape(\n    char * filename,\n    vtkSmartPointer&lt; vtkPoints &gt; particles\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-readsparseshape_1","title":"function readSparseShape","text":"<pre><code>static void readSparseShape(\n    std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; points,\n    char * filename,\n    int number_of_particles =-1\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-writesparseshape_1","title":"function writeSparseShape","text":"<pre><code>static void writeSparseShape(\n    char * filename,\n    std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-readparticleids","title":"function readParticleIds","text":"<pre><code>static std::vector&lt; int &gt; readParticleIds(\n    char * filename\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-writeparticleids","title":"function writeParticleIds","text":"<pre><code>static void writeParticleIds(\n    char * filename,\n    std::vector&lt; int &gt; ids\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-quiet_delete_file","title":"function quiet_delete_file","text":"<pre><code>static void quiet_delete_file(\n    const std::string &amp; filename\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-computecenterofmassforshapeensemble","title":"function computeCenterOfMassForShapeEnsemble","text":"<pre><code>static void computeCenterOfMassForShapeEnsemble(\n    std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list,\n    itk::Point&lt; double, 3 &gt; &amp; center\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-computecenterofmassforshape","title":"function computeCenterOfMassForShape","text":"<pre><code>static void computeCenterOfMassForShape(\n    std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points,\n    itk::Point&lt; double, 3 &gt; &amp; center\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-updatemin","title":"function updateMin","text":"<pre><code>static void updateMin(\n    double curVal,\n    double &amp; minVal\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-updatemax","title":"function updateMax","text":"<pre><code>static void updateMax(\n    double curVal,\n    double &amp; maxVal\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-getboundingboxforshapeensemble","title":"function getBoundingBoxForShapeEnsemble","text":"<pre><code>static void getBoundingBoxForShapeEnsemble(\n    std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list,\n    double &amp; min_x,\n    double &amp; min_y,\n    double &amp; min_z,\n    double &amp; max_x,\n    double &amp; max_y,\n    double &amp; max_z\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-getboundingboxforshape","title":"function getBoundingBoxForShape","text":"<pre><code>static void getBoundingBoxForShape(\n    std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points,\n    double &amp; min_x,\n    double &amp; min_y,\n    double &amp; min_z,\n    double &amp; max_x,\n    double &amp; max_y,\n    double &amp; max_z\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-spherical2cartesian","title":"function spherical2cartesian","text":"<pre><code>static void spherical2cartesian(\n    const double inPoint[3],\n    double outPoint[3]\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-cartesian2spherical","title":"function cartesian2spherical","text":"<pre><code>static void cartesian2spherical(\n    const double inPoint[3],\n    double outPoint[3]\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-converttophysicalcoordinates","title":"function convertToPhysicalCoordinates","text":"<pre><code>static vtkSmartPointer&lt; vtkPoints &gt; convertToPhysicalCoordinates(\n    vtkSmartPointer&lt; vtkPoints &gt; particles,\n    int number_of_particles,\n    const itk::Image&lt; float, 3 &gt;::SpacingType &amp; spacing,\n    const itk::Image&lt; float, 3 &gt;::PointType &amp; origin\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-converttoimagecoordinates","title":"function convertToImageCoordinates","text":"<pre><code>static vtkSmartPointer&lt; vtkPoints &gt; convertToImageCoordinates(\n    vtkSmartPointer&lt; vtkPoints &gt; particles,\n    int number_of_particles,\n    const itk::Image&lt; float, 3 &gt;::SpacingType &amp; spacing,\n    const itk::Image&lt; float, 3 &gt;::PointType &amp; origin\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-num2str","title":"function num2str","text":"<pre><code>static std::string num2str(\n    float num\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-num2str_1","title":"function num2str","text":"<pre><code>static std::string num2str(\n    int num\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-linspace","title":"function linspace","text":"<pre><code>static std::vector&lt; double &gt; linspace(\n    double a,\n    double b,\n    size_t N\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-int2str","title":"function int2str","text":"<pre><code>static std::string int2str(\n    int n,\n    int number_of_zeros\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-multiply_into","title":"function multiply_into","text":"<pre><code>template &lt;typename T &gt;\nstatic void multiply_into(\n    Eigen::MatrixXd &amp; out,\n    const vnl_matrix&lt; T &gt; &amp; lhs,\n    const vnl_matrix&lt; T &gt; &amp; rhs\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-averagethetabruteforce","title":"function averageThetaBruteForce","text":"<pre><code>static double averageThetaBruteForce(\n    std::vector&lt; double &gt; thetas,\n    double dtheta\n)\n</code></pre> <p>Given a set of theta measurements, pick the \"average\" (approximately).</p> <p>More formally, given a set of orientations, we wish to identify a \"reference theta\" such that the sum of the squared differences between each theta and the reference theta is minimized. This can be visualized: each theta (including the reference theta) can be mapped onto the unit circle): we wish to minimize the distance between the reference point and every other points by traveling along the circumference of the unit circle.</p>"},{"location":"api/Classes/classUtils.html#approximate-chord-solution","title":"APPROXIMATE CHORD SOLUTION","text":"<p>This is hard, however, so instead of computing the distance along the circumference, we compute the distance along the chord.</p> <p>This method is by ebolson@umich.edu, inspired by a similar problem in Horn's \"closed-form solution of absolute orientation using unit quaternions\".</p> <p>Let a be the set of input points, and R(a_i) represent a rotation of point a_i around the origin:</p> <p>R(x) = [ cos(theta)a_x - sin(theta)a_y,][ sin(theta)*a_x + cos(theta)*a_y ]</p> <p>The error is:</p> <p>X^2 = SUM ( R(a_i) - [1 0]' )' * (R(a_i) - [1 0]')</p> <p>= SUM R'R - 2[1 0]R(a) + [1 0][]'</p> <p>Note that R'R is constant, because R and R' are orthogonal. (R'R = I). Dropping constant terms:</p> <p>X^2 = SUM 2[1 0]R(a)</p> <p>Differentiating with respect to theta:</p> <p>dX^2/dtheta = SUM cos(theta)a_x - sin(theta)a_y = 0</p> <p>Collecting cos and sin terms:</p> <p>cos(theta) SUM a_x = sin(theta) SUM a_y</p> <p>e.g.,:</p> <p>theta = atan2( SUM a_y , SUM a_x )</p>"},{"location":"api/Classes/classUtils.html#exact-solution","title":"EXACT SOLUTION","text":"<p>This solution runs in O(n log n).</p> <p>Let us suppose that all of the input angles are mapped to [-PI, PI].</p> <p>All the input points can be shifted to be within PI degrees of the reference angle by adding a multiple of 2PI degrees. If all the input angles are constrained to [-PI, PI], then we can find a reference angle [-PI, 2PI] such that all input points are within PI degrees by either adding 0 or exactly 2PI to individual input points.</p> <p>More so, the input points that we must add 2PI to are the M points with the smallest theta, but we do not know M. This is necessary when the correct reference angle is large: the smallest points will be more than PI degrees away, so they need to be moved to the right side of the reference angle.</p> <p>If we knew M, computing the reference angle is easy: it is simply the average of the (possibly shifted) input points. Let x[i] be the input point [-PI,PI] and y[i] be the possibly shifted version of that point, y[i] = x[i] + 2PI if i &lt; M, otherwise y[i] = x[i].</p> <p>r = reference angle = (1 / N) * SUM_i y[i] error = SUM_i (y[i] - r)^2</p> <p>We simply search over each value of M (from 0 to N), and recompute the error. Both the reference angle and error can be written in terms of the first and second moments of y[i], which gives us the following strategy:</p> <p>1) Compute A1 and A2, the first and second moments of y[i], assuming M = 0. (This is just the first and second moments of x[i]). This involves iterating over each of the input points.</p> <p>2) Considering the points in x[i] in sorted order, update A1 and A2 such that they reflect y[i] = x[i] + 2PI. Compute the new reference theta and error after every point (an O(1) operation) and report the theta whose error was the smallest.</p> <p>Total run time is O(N log N) due to the sort operation. The other two passes are O(N). Memory usage is O(N), since all points must be stored so they can be sorted.</p>"},{"location":"api/Classes/classUtils.html#summary","title":"SUMMARY","text":""},{"location":"api/Classes/classUtils.html#method-runtime-memory-notes","title":"method         runtime          memory         notes","text":"<p>brute O(2PI*N / eps) O(N) worst-case error is eps/2 exact O(N log N) O(N) chord O(N) O(1) minimizes squared chord length, not squared arc length.</p> <p>Real-world performance: the exact method is typically faster than the chord method, presumably because of the high cost of computing trigonometric functions used in the Chord method. This advantage decreases with larger number of points (due to the super-linear cost of sorting), but even at 50000 points, the optimal method is (a bit) faster than the chord method.</p> <p>Reference: Olson, Edwin. \"On computing the average orientation of vectors and lines.\" In Robotics and Automation (ICRA), 2011 IEEE International Conference on, pp. 3869-3874. IEEE, 2011.</p> <p>Code is written in C++ from author's java implmentation by Shireen Elhabian - SCI institute, University of Utah </p>"},{"location":"api/Classes/classUtils.html#function-averagethetachord","title":"function averageThetaChord","text":"<pre><code>static double averageThetaChord(\n    std::vector&lt; double &gt; thetas\n)\n</code></pre>"},{"location":"api/Classes/classUtils.html#function-averagethetaarc","title":"function averageThetaArc","text":"<pre><code>static double averageThetaArc(\n    std::vector&lt; double &gt; thetas\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html","title":"itk::AdvancedTransform","text":"<p>Transform maps points, vectors and covariant vectors from an input space to an output space.  More...</p> <p><code>#include &lt;itkAdvancedTransform.h&gt;</code></p> <p>Inherits from Transform&lt; TScalarType, 3, 3 &gt;</p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#public-types","title":"Public Types","text":"Name typedef AdvancedTransform Self typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef Superclass::ScalarType ScalarType typedef Superclass::ParametersType ParametersType typedef Superclass::ParametersValueType ParametersValueType typedef Superclass::NumberOfParametersType NumberOfParametersType typedef Superclass::DerivativeType DerivativeType typedef Superclass::JacobianType JacobianType typedef Superclass::InputVectorType InputVectorType typedef Superclass::OutputVectorType OutputVectorType typedef Superclass::InputCovariantVectorType InputCovariantVectorType typedef Superclass::OutputCovariantVectorType OutputCovariantVectorType typedef Superclass::InputVnlVectorType InputVnlVectorType typedef Superclass::OutputVnlVectorType OutputVnlVectorType typedef Superclass::InputPointType InputPointType typedef Superclass::OutputPointType OutputPointType typedef Superclass::InverseTransformBaseType InverseTransformBaseType typedef Superclass::InverseTransformBasePointer InverseTransformBasePointer typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; TransformType typedef TransformType::Pointer TransformTypePointer typedef TransformType::ConstPointer TransformTypeConstPointer typedef std::vector&lt; unsigned long &gt; NonZeroJacobianIndicesType typedef Matrix&lt; ScalarType, OutputSpaceDimension, InputSpaceDimension &gt; SpatialJacobianType typedef std::vector&lt; SpatialJacobianType &gt; JacobianOfSpatialJacobianType typedef FixedArray&lt; Matrix&lt; ScalarType, InputSpaceDimension, InputSpaceDimension &gt;, OutputSpaceDimension &gt; SpatialHessianType typedef std::vector&lt; SpatialHessianType &gt; JacobianOfSpatialHessianType typedef SpatialJacobianType::InternalMatrixType InternalMatrixType typedef OutputCovariantVectorType MovingImageGradientType typedef MovingImageGradientType::ValueType MovingImageGradientValueType"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#public-functions","title":"Public Functions","text":"Name itkTypeMacro(AdvancedTransform , Transform ) itkStaticConstMacro(InputSpaceDimension , unsigned int , NInputDimensions ) itkStaticConstMacro(OutputSpaceDimension , unsigned int , NOutputDimensions ) virtual NumberOfParametersType GetNumberOfNonZeroJacobianIndices(void ) const itkGetConstMacro(HasNonZeroSpatialHessian , bool ) itkGetConstMacro(HasNonZeroJacobianOfSpatialHessian , bool ) virtual void GetJacobian(const InputPointType &amp; ipp, JacobianType &amp; j, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void EvaluateJacobianWithImageGradientProduct(const InputPointType &amp; ipp, const MovingImageGradientType &amp; movingImageGradient, DerivativeType &amp; imageJacobian, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj) const =0 virtual void ComputeJacobianWithRespectToParameters(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const virtual void ComputeJacobianWithRespectToPosition(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const virtual void GetSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh) const =0 virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#protected-functions","title":"Protected Functions","text":"Name AdvancedTransform() AdvancedTransform(NumberOfParametersType numberOfParameters) virtual ~AdvancedTransform()"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#protected-attributes","title":"Protected Attributes","text":"Name bool m_HasNonZeroSpatialHessian bool m_HasNonZeroJacobianOfSpatialHessian"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TScalarType ,\nunsigned int NInputDimensions =3,\nunsigned int NOutputDimensions =3&gt;\nclass itk::AdvancedTransform;\n</code></pre> <p>Transform maps points, vectors and covariant vectors from an input space to an output space. </p> <p>Par: Registration Framework Support</p> <p>Typically a Transform class has several methods for setting its parameters. For use in the registration framework, the parameters must also be represented by an array of doubles to allow communication with generic optimizers. The Array of transformation parameters is set using the SetParameters() method.</p> <p>This abstract class define the generic interface for a geometrical transformation from one space to another. The class provides methods for mapping points, vectors and covariant vectors from the input space to the output space.</p> <p>Given that transformation are not necessarily invertible, this basic class does not provide the methods for back transformation. Back transform methods are implemented in derived classes where appropriate.</p> <p>Another requirement of the registration framework is the computation of the Jacobian of the transform T. In general, an ImageToImageMetric requires the knowledge of this Jacobian in order to compute the metric derivatives. The Jacobian is a matrix whose element are the partial derivatives of the transformation with respect to the array of parameters mu that defines the transform, evaluated at a point p: dT/dmu(p).</p> <p>If penalty terms are included in the registration, the transforms also need to implement other derivatives of T. Often, penalty terms are functions of the spatial derivatives of T. Therefore, e.g. the SpatialJacobian dT/dx and the SpatialHessian d^2T/dx_idx_j require implementation. The GetValueAndDerivative() requires the d/dmu of those terms. Therefore, we additionally define GetJacobianOfSpatialJacobian() and GetJacobianOfSpatialHessian(). </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef AdvancedTransform itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt; Self &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt; const Self &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-scalartype","title":"typedef ScalarType","text":"<pre><code>typedef Superclass::ScalarType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::ScalarType;\n</code></pre> <p>Typedefs from the Superclass. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-parameterstype","title":"typedef ParametersType","text":"<pre><code>typedef Superclass::ParametersType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::ParametersType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-parametersvaluetype","title":"typedef ParametersValueType","text":"<pre><code>typedef Superclass::ParametersValueType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::ParametersValueType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-numberofparameterstype","title":"typedef NumberOfParametersType","text":"<pre><code>typedef Superclass::NumberOfParametersType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::NumberOfParametersType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-derivativetype","title":"typedef DerivativeType","text":"<pre><code>typedef Superclass::DerivativeType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::DerivativeType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-jacobiantype","title":"typedef JacobianType","text":"<pre><code>typedef Superclass::JacobianType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::JacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inputvectortype","title":"typedef InputVectorType","text":"<pre><code>typedef Superclass::InputVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-outputvectortype","title":"typedef OutputVectorType","text":"<pre><code>typedef Superclass::OutputVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::OutputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inputcovariantvectortype","title":"typedef InputCovariantVectorType","text":"<pre><code>typedef Superclass::InputCovariantVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-outputcovariantvectortype","title":"typedef OutputCovariantVectorType","text":"<pre><code>typedef Superclass::OutputCovariantVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::OutputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inputvnlvectortype","title":"typedef InputVnlVectorType","text":"<pre><code>typedef Superclass::InputVnlVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InputVnlVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-outputvnlvectortype","title":"typedef OutputVnlVectorType","text":"<pre><code>typedef Superclass::OutputVnlVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::OutputVnlVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inputpointtype","title":"typedef InputPointType","text":"<pre><code>typedef Superclass::InputPointType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-outputpointtype","title":"typedef OutputPointType","text":"<pre><code>typedef Superclass::OutputPointType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::OutputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inversetransformbasetype","title":"typedef InverseTransformBaseType","text":"<pre><code>typedef Superclass::InverseTransformBaseType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InverseTransformBaseType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-inversetransformbasepointer","title":"typedef InverseTransformBasePointer","text":"<pre><code>typedef Superclass::InverseTransformBasePointer itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InverseTransformBasePointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-transformtype","title":"typedef TransformType","text":"<pre><code>typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::TransformType;\n</code></pre> <p>Transform typedefs for the from Superclass. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-transformtypepointer","title":"typedef TransformTypePointer","text":"<pre><code>typedef TransformType::Pointer itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::TransformTypePointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-transformtypeconstpointer","title":"typedef TransformTypeConstPointer","text":"<pre><code>typedef TransformType::ConstPointer itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::TransformTypeConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-nonzerojacobianindicestype","title":"typedef NonZeroJacobianIndicesType","text":"<pre><code>typedef std::vector&lt; unsigned long &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::NonZeroJacobianIndicesType;\n</code></pre> <p>Types for the (Spatial)Jacobian/Hessian. Using an itk::FixedArray instead of an std::vector gives a performance gain for the SpatialHessianType. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-spatialjacobiantype","title":"typedef SpatialJacobianType","text":"<pre><code>typedef Matrix&lt; ScalarType, OutputSpaceDimension, InputSpaceDimension &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::SpatialJacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-jacobianofspatialjacobiantype","title":"typedef JacobianOfSpatialJacobianType","text":"<pre><code>typedef std::vector&lt; SpatialJacobianType &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::JacobianOfSpatialJacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-spatialhessiantype","title":"typedef SpatialHessianType","text":"<pre><code>typedef FixedArray&lt; Matrix&lt; ScalarType, InputSpaceDimension, InputSpaceDimension &gt;, OutputSpaceDimension &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::SpatialHessianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-jacobianofspatialhessiantype","title":"typedef JacobianOfSpatialHessianType","text":"<pre><code>typedef std::vector&lt; SpatialHessianType &gt; itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::JacobianOfSpatialHessianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-internalmatrixtype","title":"typedef InternalMatrixType","text":"<pre><code>typedef SpatialJacobianType::InternalMatrixType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::InternalMatrixType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-movingimagegradienttype","title":"typedef MovingImageGradientType","text":"<pre><code>typedef OutputCovariantVectorType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::MovingImageGradientType;\n</code></pre> <p>Typedef for the moving image gradient type. This type is defined by the B-spline interpolator as typedef CovariantVector&lt; RealType, ImageDimension &gt; As we cannot access this type we simply re-construct it to be identical. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#typedef-movingimagegradientvaluetype","title":"typedef MovingImageGradientValueType","text":"<pre><code>typedef MovingImageGradientType::ValueType itk::AdvancedTransform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;::MovingImageGradientValueType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    AdvancedTransform ,\n    Transform \n)\n</code></pre> <p>New method for creating an object using a factory. Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    InputSpaceDimension ,\n    unsigned int ,\n    NInputDimensions \n)\n</code></pre> <p>Dimension of the domain space. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-itkstaticconstmacro_1","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    OutputSpaceDimension ,\n    unsigned int ,\n    NOutputDimensions \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getnumberofnonzerojacobianindices","title":"function GetNumberOfNonZeroJacobianIndices","text":"<pre><code>virtual NumberOfParametersType GetNumberOfNonZeroJacobianIndices(\n    void \n) const\n</code></pre> <p>Get the number of nonzero Jacobian indices. By default all. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-itkgetconstmacro","title":"function itkGetConstMacro","text":"<pre><code>itkGetConstMacro(\n    HasNonZeroSpatialHessian ,\n    bool \n)\n</code></pre> <p>Whether the advanced transform has nonzero matrices. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-itkgetconstmacro_1","title":"function itkGetConstMacro","text":"<pre><code>itkGetConstMacro(\n    HasNonZeroJacobianOfSpatialHessian ,\n    bool \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getjacobian","title":"function GetJacobian","text":"<pre><code>virtual void GetJacobian(\n    const InputPointType &amp; ipp,\n    JacobianType &amp; j,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetJacobian, itk::KernelTransform2::GetJacobian</p> <p>This returns a sparse version of the Jacobian of the transformation.</p> <p>The Jacobian is expressed as a vector of partial derivatives of the transformation components with respect to the parameters \\(\\mu\\) that define the transformation \\(T\\), evaluated at a point \\(p\\).</p> <p>  with \\(m\\) the number of parameters, i.e. the size of \\(\\mu\\), and \\(d\\) the dimension of the image. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-evaluatejacobianwithimagegradientproduct","title":"function EvaluateJacobianWithImageGradientProduct","text":"<pre><code>virtual void EvaluateJacobianWithImageGradientProduct(\n    const InputPointType &amp; ipp,\n    const MovingImageGradientType &amp; movingImageGradient,\n    DerivativeType &amp; imageJacobian,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const\n</code></pre> <p>Compute the inner product of the Jacobian with the moving image gradient. The Jacobian is (partially) constructed inside this function, but not returned. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getspatialjacobian","title":"function GetSpatialJacobian","text":"<pre><code>virtual void GetSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetSpatialJacobian, itk::KernelTransform2::GetSpatialJacobian</p> <p>Compute the spatial Jacobian of the transformation.</p> <p>The spatial Jacobian is expressed as a vector of partial derivatives of the transformation components with respect to the spatial position \\(x\\), evaluated at a point \\(p\\).</p> <p>  with \\(m\\) the number of parameters, i.e. the size of \\(\\mu\\), and \\(d\\) the dimension of the image. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-computejacobianwithrespecttoparameters","title":"function ComputeJacobianWithRespectToParameters","text":"<pre><code>inline virtual void ComputeJacobianWithRespectToParameters(\n    const InputPointType &amp; itkNotUsedp,\n    JacobianType &amp; itkNotUsedj\n) const\n</code></pre> <p>Override some pure virtual ITK4 functions. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-computejacobianwithrespecttoposition","title":"function ComputeJacobianWithRespectToPosition","text":"<pre><code>inline virtual void ComputeJacobianWithRespectToPosition(\n    const InputPointType &amp; itkNotUsedp,\n    JacobianType &amp; itkNotUsedj\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getspatialhessian","title":"function GetSpatialHessian","text":"<pre><code>virtual void GetSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetSpatialHessian, itk::KernelTransform2::GetSpatialHessian</p> <p>Compute the spatial Hessian of the transformation.</p> <p>The spatial Hessian is the vector of matrices of partial second order derivatives of the transformation components with respect to the spatial position \\(x\\), evaluated at a point \\(p\\).</p> <p>  with i the i-th component of the transformation. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getjacobianofspatialjacobian","title":"function GetJacobianOfSpatialJacobian","text":"<pre><code>virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetJacobianOfSpatialJacobian, itk::KernelTransform2::GetJacobianOfSpatialJacobian</p> <p>Compute the Jacobian of the spatial Jacobian of the transformation.</p> <p>The Jacobian of the spatial Jacobian is the derivative of the spatial Jacobian to the transformation parameters \\(\\mu\\), evaluated at a point \\(p\\). </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getjacobianofspatialjacobian_1","title":"function GetJacobianOfSpatialJacobian","text":"<pre><code>virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetJacobianOfSpatialJacobian, itk::KernelTransform2::GetJacobianOfSpatialJacobian</p> <p>Compute both the spatial Jacobian and the Jacobian of the spatial Jacobian of the transformation. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getjacobianofspatialhessian","title":"function GetJacobianOfSpatialHessian","text":"<pre><code>virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetJacobianOfSpatialHessian, itk::KernelTransform2::GetJacobianOfSpatialHessian</p> <p>Compute the Jacobian of the spatial Hessian of the transformation.</p> <p>The Jacobian of the spatial Hessian is the derivative of the spatial Hessian to the transformation parameters \\(\\mu\\), evaluated at a point \\(p\\). </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-getjacobianofspatialhessian_1","title":"function GetJacobianOfSpatialHessian","text":"<pre><code>virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const =0\n</code></pre> <p>Reimplemented by: itk::KernelTransform2::GetJacobianOfSpatialHessian, itk::KernelTransform2::GetJacobianOfSpatialHessian</p> <p>Compute both the spatial Hessian and the Jacobian of the spatial Hessian of the transformation. </p>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-advancedtransform","title":"function AdvancedTransform","text":"<pre><code>AdvancedTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-advancedtransform_1","title":"function AdvancedTransform","text":"<pre><code>AdvancedTransform(\n    NumberOfParametersType numberOfParameters\n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#function-advancedtransform_2","title":"function ~AdvancedTransform","text":"<pre><code>inline virtual ~AdvancedTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#variable-m_hasnonzerospatialhessian","title":"variable m_HasNonZeroSpatialHessian","text":"<pre><code>bool m_HasNonZeroSpatialHessian;\n</code></pre>"},{"location":"api/Classes/classitk_1_1AdvancedTransform.html#variable-m_hasnonzerojacobianofspatialhessian","title":"variable m_HasNonZeroJacobianOfSpatialHessian","text":"<pre><code>bool m_HasNonZeroJacobianOfSpatialHessian;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1BSplineInterpolateImageFunctionWithDoubleCoefficents.html","title":"itk::BSplineInterpolateImageFunctionWithDoubleCoefficents","text":"<p>More...</p> <p>Inherits from BSplineInterpolateImageFunction&lt; TImageType, double, double &gt;</p>"},{"location":"api/Classes/classitk_1_1BSplineInterpolateImageFunctionWithDoubleCoefficents.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename TImageType ,\ntypename TCoordRep  =double&gt;\nclass itk::BSplineInterpolateImageFunctionWithDoubleCoefficents;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html","title":"itk::CompactlySupportedRBFSparseKernelTransform","text":"<p>More...</p> <p>Inherits from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;, Transform&lt; TScalarType, NDimensions, NDimensions &gt;</p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#public-types","title":"Public Types","text":"Name typedef CompactlySupportedRBFSparseKernelTransform Self typedef SparseKernelTransform&lt; TScalarType, NDimensions &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef Superclass::ScalarType ScalarType typedef Superclass::ParametersType ParametersType typedef Superclass::JacobianType JacobianType typedef Superclass::InputPointType InputPointType typedef Superclass::OutputPointType OutputPointType typedef Superclass::InputVectorType InputVectorType typedef Superclass::OutputVectorType OutputVectorType typedef Superclass::InputCovariantVectorType InputCovariantVectorType typedef Superclass::OutputCovariantVectorType OutputCovariantVectorType typedef Superclass::PointsIterator PointsIterator"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#protected-types","title":"Protected Types","text":"Name typedef Superclass::GMatrixType GMatrixType"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(CompactlySupportedRBFSparseKernelTransform , SparseKernelTransform ) itkStaticConstMacro(SpaceDimension , unsigned int , Superclass::SpaceDimension ) void SetSigma(double sigma) virtual void ComputeJacobianWithRespectToParameters(const InputPointType &amp; in, JacobianType &amp; jacobian) const"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#protected-functions","title":"Protected Functions","text":"Name CompactlySupportedRBFSparseKernelTransform() virtual ~CompactlySupportedRBFSparseKernelTransform() virtual const GMatrixType &amp; ComputeG(const InputVectorType &amp; landmarkVector) const override virtual void ComputeDeformationContribution(const InputPointType &amp; inputPoint, OutputPointType &amp; result) const override"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;</p> Name typedef DefaultStaticMeshTraits&lt; TScalarType, NDimensions, NDimensions, TScalarType, TScalarType &gt; PointSetTraitsType typedef PointSet&lt; InputPointType, NDimensions, PointSetTraitsType &gt; PointSetType typedef PointSetType::Pointer PointSetPointer typedef PointSetType::PointsContainer PointsContainer typedef PointSetType::PointsContainerConstIterator PointsConstIterator typedef itk::VectorContainer&lt; unsigned long, InputVectorType &gt; VectorSetType typedef VectorSetType::Pointer VectorSetPointer typedef Eigen::Matrix&lt; TScalarType, NDimensions, NDimensions &gt; IMatrixType typedef Eigen::Triplet&lt; TScalarType &gt; TripletType typedef Eigen::SparseMatrix&lt; TScalarType &gt; LMatrixType typedef Eigen::SparseMatrix&lt; TScalarType &gt; KMatrixType typedef Eigen::SparseMatrix&lt; TScalarType &gt; PMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; YMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; WMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; DMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, NDimensions &gt; AMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, 1 &gt; BMatrixType typedef Eigen::Matrix&lt; TScalarType, 1, NDimensions &gt; RowMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, 1 &gt; ColumnMatrixType <p>Public Functions inherited from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;</p> Name itkGetObjectMacro(SourceLandmarks , PointSetType ) virtual void SetSourceLandmarks(PointSetType * ) itkGetObjectMacro(TargetLandmarks , PointSetType ) virtual void SetTargetLandmarks(PointSetType * ) itkGetObjectMacro(Displacements , VectorSetType ) void ComputeWMatrix(void ) const virtual OutputPointType TransformPoint(const InputPointType &amp; thisPoint) const virtual void SetIdentity() virtual void SetParameters(const ParametersType &amp; ) virtual void SetFixedParameters(const ParametersType &amp; ) virtual void UpdateParameters(void ) const virtual const ParametersType &amp; GetParameters(void ) const virtual const ParametersType &amp; GetFixedParameters(void ) const virtual void SetStiffness(double stiffness) itkGetMacro(Stiffness , double ) <p>Protected Functions inherited from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;</p> Name SparseKernelTransform() virtual ~SparseKernelTransform() void PrintSelf(std::ostream &amp; os, Indent indent) const virtual const GMatrixType &amp; ComputeReflexiveG(PointsIterator ) const void ComputeK() const void ComputeL() const void ComputeP() const void ComputeY() const void ComputeD() const void ReorganizeW(void ) const <p>Public Attributes inherited from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;</p> Name PointSetPointer m_SourceLandmarks PointSetPointer m_TargetLandmarks <p>Protected Attributes inherited from itk::SparseKernelTransform&lt; TScalarType, 3 &gt;</p> Name double m_Stiffness VectorSetPointer m_Displacements LMatrixType m_LMatrix LMatrixType m_LMatrixInverse KMatrixType m_KMatrix PMatrixType m_PMatrix YMatrixType m_YMatrix WMatrixType m_WMatrix DMatrixType m_DMatrix AMatrixType m_AMatrix BMatrixType m_BVector GMatrixType m_GMatrix bool m_WMatrixComputed bool m_LMatrixComputed bool m_LInverseComputed IMatrixType m_I"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TScalarType ,\nunsigned int NDimensions =3&gt;\nclass itk::CompactlySupportedRBFSparseKernelTransform;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef CompactlySupportedRBFSparseKernelTransform itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef SparseKernelTransform&lt; TScalarType, NDimensions&gt; itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt;Self&gt; itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt;const Self&gt; itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-scalartype","title":"typedef ScalarType","text":"<pre><code>typedef Superclass::ScalarType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::ScalarType;\n</code></pre> <p>Scalar type. </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-parameterstype","title":"typedef ParametersType","text":"<pre><code>typedef Superclass::ParametersType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::ParametersType;\n</code></pre> <p>Parameters type. </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-jacobiantype","title":"typedef JacobianType","text":"<pre><code>typedef Superclass::JacobianType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::JacobianType;\n</code></pre> <p>Jacobian Type </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-inputpointtype","title":"typedef InputPointType","text":"<pre><code>typedef Superclass::InputPointType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::InputPointType;\n</code></pre> <p>These (rather redundant) typedefs are needed because on SGI, typedefs are not inherited </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-outputpointtype","title":"typedef OutputPointType","text":"<pre><code>typedef Superclass::OutputPointType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::OutputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-inputvectortype","title":"typedef InputVectorType","text":"<pre><code>typedef Superclass::InputVectorType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::InputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-outputvectortype","title":"typedef OutputVectorType","text":"<pre><code>typedef Superclass::OutputVectorType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::OutputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-inputcovariantvectortype","title":"typedef InputCovariantVectorType","text":"<pre><code>typedef Superclass::InputCovariantVectorType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::InputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-outputcovariantvectortype","title":"typedef OutputCovariantVectorType","text":"<pre><code>typedef Superclass::OutputCovariantVectorType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::OutputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-pointsiterator","title":"typedef PointsIterator","text":"<pre><code>typedef Superclass::PointsIterator itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointsIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#typedef-gmatrixtype","title":"typedef GMatrixType","text":"<pre><code>typedef Superclass::GMatrixType itk::CompactlySupportedRBFSparseKernelTransform&lt; TScalarType, NDimensions &gt;::GMatrixType;\n</code></pre> <p>These (rather redundant) typedefs are needed because on SGI, typedefs are not inherited. </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>New macro for creation of through a Smart Pointer </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    CompactlySupportedRBFSparseKernelTransform ,\n    SparseKernelTransform \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    SpaceDimension ,\n    unsigned int ,\n    Superclass::SpaceDimension \n)\n</code></pre> <p>Dimension of the domain space. </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-setsigma","title":"function SetSigma","text":"<pre><code>inline void SetSigma(\n    double sigma\n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-computejacobianwithrespecttoparameters","title":"function ComputeJacobianWithRespectToParameters","text":"<pre><code>virtual void ComputeJacobianWithRespectToParameters(\n    const InputPointType &amp; in,\n    JacobianType &amp; jacobian\n) const\n</code></pre> <p>Reimplements: itk::SparseKernelTransform::ComputeJacobianWithRespectToParameters</p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-compactlysupportedrbfsparsekerneltransform","title":"function CompactlySupportedRBFSparseKernelTransform","text":"<pre><code>inline CompactlySupportedRBFSparseKernelTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-compactlysupportedrbfsparsekerneltransform_1","title":"function ~CompactlySupportedRBFSparseKernelTransform","text":"<pre><code>inline virtual ~CompactlySupportedRBFSparseKernelTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-computeg","title":"function ComputeG","text":"<pre><code>virtual const GMatrixType &amp; ComputeG(\n    const InputVectorType &amp; landmarkVector\n) const override\n</code></pre> <p>Reimplements: itk::SparseKernelTransform::ComputeG</p> <p>Compute G(x) This is essentially the kernel of the transform. By overriding this method, we can obtain (among others): Elastic body spline Thin plate spline Volume spline </p>"},{"location":"api/Classes/classitk_1_1CompactlySupportedRBFSparseKernelTransform.html#function-computedeformationcontribution","title":"function ComputeDeformationContribution","text":"<pre><code>virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint,\n    OutputPointType &amp; result\n) const override\n</code></pre> <p>Reimplements: itk::SparseKernelTransform::ComputeDeformationContribution</p> <p>Compute the contribution of the landmarks weighted by the kernel funcion to the global deformation of the space </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html","title":"itk::Functor::MultiplyByConstant","text":"<p>More...</p>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#public-functions","title":"Public Functions","text":"Name MultiplyByConstant() ~MultiplyByConstant() bool operator!=(const MultiplyByConstant &amp; other) const bool operator==(const MultiplyByConstant &amp; other) const TOutput operator()(const TInput &amp; A) const void SetConstant(TConstant ct) const TConstant &amp; GetConstant() const"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#public-attributes","title":"Public Attributes","text":"Name TConstant m_Constant"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TInput ,\nclass TConstant ,\nclass TOutput &gt;\nclass itk::Functor::MultiplyByConstant;\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-multiplybyconstant","title":"function MultiplyByConstant","text":"<pre><code>inline MultiplyByConstant()\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-multiplybyconstant_1","title":"function ~MultiplyByConstant","text":"<pre><code>inline ~MultiplyByConstant()\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-operator","title":"function operator!=","text":"<pre><code>inline bool operator!=(\n    const MultiplyByConstant &amp; other\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const MultiplyByConstant &amp; other\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-operator_2","title":"function operator()","text":"<pre><code>inline TOutput operator()(\n    const TInput &amp; A\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-setconstant","title":"function SetConstant","text":"<pre><code>inline void SetConstant(\n    TConstant ct\n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#function-getconstant","title":"function GetConstant","text":"<pre><code>inline const TConstant &amp; GetConstant() const\n</code></pre>"},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1Functor_1_1MultiplyByConstant.html#variable-m_constant","title":"variable m_Constant","text":"<pre><code>TConstant m_Constant;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html","title":"itk::KernelTransform2","text":"<p>More...</p> <p><code>#include &lt;itkKernelTransform2.h&gt;</code></p> <p>Inherits from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;, Transform&lt; TScalarType, 3, 3 &gt;</p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-types","title":"Public Types","text":"Name typedef KernelTransform2 Self typedef AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef Superclass::ScalarType ScalarType typedef Superclass::ParametersType ParametersType typedef Superclass::NumberOfParametersType NumberOfParametersType typedef Superclass::JacobianType JacobianType typedef Superclass::InputPointType InputPointType typedef Superclass::OutputPointType OutputPointType typedef Superclass::InputVectorType InputVectorType typedef Superclass::OutputVectorType OutputVectorType typedef Superclass::InputCovariantVectorType InputCovariantVectorType typedef Superclass::OutputCovariantVectorType OutputCovariantVectorType typedef Superclass::InputVnlVectorType InputVnlVectorType typedef Superclass::OutputVnlVectorType OutputVnlVectorType typedef Superclass::NonZeroJacobianIndicesType NonZeroJacobianIndicesType typedef Superclass::SpatialJacobianType SpatialJacobianType typedef Superclass::JacobianOfSpatialJacobianType JacobianOfSpatialJacobianType typedef Superclass::SpatialHessianType SpatialHessianType typedef Superclass::JacobianOfSpatialHessianType JacobianOfSpatialHessianType typedef Superclass::InternalMatrixType InternalMatrixType typedef DefaultStaticMeshTraits&lt; TScalarType, NDimensions, NDimensions, TScalarType, TScalarType &gt; PointSetTraitsType typedef PointSet&lt; InputPointType, NDimensions, PointSetTraitsType &gt; PointSetType typedef PointSetType::Pointer PointSetPointer typedef PointSetType::PointsContainer PointsContainer typedef PointSetType::PointsContainerIterator PointsIterator typedef PointSetType::PointsContainerConstIterator PointsConstIterator typedef VectorContainer&lt; unsigned long, InputVectorType &gt; VectorSetType typedef VectorSetType::Pointer VectorSetPointer typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; IMatrixType typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; GMatrixType typedef vnl_matrix&lt; TScalarType &gt; LMatrixType typedef vnl_matrix&lt; TScalarType &gt; KMatrixType typedef vnl_matrix&lt; TScalarType &gt; PMatrixType typedef vnl_matrix&lt; TScalarType &gt; YMatrixType typedef vnl_matrix&lt; TScalarType &gt; WMatrixType typedef vnl_matrix&lt; TScalarType &gt; DMatrixType typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; AMatrixType typedef vnl_vector_fixed&lt; TScalarType, NDimensions &gt; BMatrixType typedef vnl_matrix_fixed&lt; TScalarType, 1, NDimensions &gt; RowMatrixType typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, 1 &gt; ColumnMatrixType"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-types","title":"Protected Types","text":"Name typedef vnl_svd&lt; ScalarType &gt; SVDDecompositionType typedef vnl_qr&lt; ScalarType &gt; QRDecompositionType"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-functions","title":"Public Functions","text":"Name itkTypeMacro(KernelTransform2 , AdvancedTransform ) itkNewMacro(Self ) itkStaticConstMacro(SpaceDimension , unsigned int , NDimensions ) virtual NumberOfParametersType GetNumberOfParameters(void ) const itkGetObjectMacro(SourceLandmarks , PointSetType ) virtual void SetSourceLandmarks(PointSetType * ) itkGetObjectMacro(TargetLandmarks , PointSetType ) virtual void SetTargetLandmarks(PointSetType * ) itkGetObjectMacro(Displacements , VectorSetType ) void ComputeWMatrix(void ) void ComputeLInverse(void ) virtual OutputPointType TransformPoint(const InputPointType &amp; thisPoint) const virtual OutputVectorType TransformVector(const InputVectorType &amp; ) const virtual OutputVnlVectorType TransformVector(const InputVnlVectorType &amp; ) const virtual OutputCovariantVectorType TransformCovariantVector(const InputCovariantVectorType &amp; ) const virtual void GetJacobian(const InputPointType &amp; , JacobianType &amp; , NonZeroJacobianIndicesType &amp; ) const virtual void SetIdentity(void ) virtual void SetParameters(const ParametersType &amp; ) virtual void SetFixedParameters(const ParametersType &amp; ) virtual void UpdateParameters(void ) virtual const ParametersType &amp; GetParameters(void ) const virtual const ParametersType &amp; GetFixedParameters(void ) const virtual void SetStiffness(double stiffness) itkGetMacro(Stiffness , double ) virtual void SetAlpha(TScalarType  itkNotUsedAlpha) virtual TScalarType GetAlpha(void ) const itkSetMacro(PoissonRatio , TScalarType ) virtual const TScalarType GetPoissonRatio(void ) const itkSetMacro(MatrixInversionMethod , std::string ) itkGetConstReferenceMacro(MatrixInversionMethod , std::string ) virtual void GetSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj) const virtual void GetSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh) const virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-functions","title":"Protected Functions","text":"Name KernelTransform2() virtual ~KernelTransform2() void PrintSelf(std::ostream &amp; os, Indent indent) const virtual void ComputeG(const InputVectorType &amp; landmarkVector, GMatrixType &amp; GMatrix) const virtual void ComputeReflexiveG(PointsIterator , GMatrixType &amp; GMatrix) const virtual void ComputeDeformationContribution(const InputPointType &amp; inputPoint, OutputPointType &amp; result) const void ComputeK(void ) void ComputeL(void ) void ComputeP(void ) void ComputeY(void ) void ComputeD(void ) void ReorganizeW(void )"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-attributes","title":"Public Attributes","text":"Name PointSetPointer m_SourceLandmarks PointSetPointer m_TargetLandmarks"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-attributes","title":"Protected Attributes","text":"Name double m_Stiffness VectorSetPointer m_Displacements LMatrixType m_LMatrix LMatrixType m_LMatrixInverse KMatrixType m_KMatrix PMatrixType m_PMatrix YMatrixType m_YMatrix WMatrixType m_WMatrix DMatrixType m_DMatrix AMatrixType m_AMatrix BMatrixType m_BVector bool m_WMatrixComputed bool m_LMatrixComputed bool m_LInverseComputed bool m_LMatrixDecompositionComputed SVDDecompositionType * m_LMatrixDecompositionSVD QRDecompositionType * m_LMatrixDecompositionQR IMatrixType m_I NonZeroJacobianIndicesType m_NonZeroJacobianIndices NonZeroJacobianIndicesType m_NonZeroJacobianIndicesTemp bool m_FastComputationPossible"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name typedef Superclass::ParametersValueType ParametersValueType typedef Superclass::DerivativeType DerivativeType typedef Superclass::InverseTransformBaseType InverseTransformBaseType typedef Superclass::InverseTransformBasePointer InverseTransformBasePointer typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; TransformType typedef TransformType::Pointer TransformTypePointer typedef TransformType::ConstPointer TransformTypeConstPointer typedef OutputCovariantVectorType MovingImageGradientType typedef MovingImageGradientType::ValueType MovingImageGradientValueType <p>Public Functions inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name virtual NumberOfParametersType GetNumberOfNonZeroJacobianIndices(void ) const itkGetConstMacro(HasNonZeroSpatialHessian , bool ) itkGetConstMacro(HasNonZeroJacobianOfSpatialHessian , bool ) virtual void EvaluateJacobianWithImageGradientProduct(const InputPointType &amp; ipp, const MovingImageGradientType &amp; movingImageGradient, DerivativeType &amp; imageJacobian, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void ComputeJacobianWithRespectToParameters(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const virtual void ComputeJacobianWithRespectToPosition(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const <p>Protected Functions inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name AdvancedTransform() AdvancedTransform(NumberOfParametersType numberOfParameters) virtual ~AdvancedTransform() <p>Protected Attributes inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name bool m_HasNonZeroSpatialHessian bool m_HasNonZeroJacobianOfSpatialHessian"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TScalarType ,\nunsigned int NDimensions&gt;\nclass itk::KernelTransform2;\n</code></pre> <p>Intended to be a base class for elastic body spline and thin plate spline. This is implemented in as straightforward a manner as possible from the IEEE TMI paper by Davis, Khotanzad, Flamig, and Harms, Vol. 16, No. 3 June 1997. Notation closely follows their paper, so if you have it in front of you, this code will make a lot more sense.</p> <p>KernelTransform2: Provides support for defining source and target landmarks Defines a number of data types used in the computations Defines the mathematical framework used to compute all splines, so that subclasses need only provide a kernel specific to that spline</p> <p>This formulation allows the stiffness of the spline to be adjusted, allowing the spline to vary from interpolating the landmarks to approximating the landmarks. This part of the formulation is based on the short paper by R. Sprengel, K. Rohr, H. Stiehl. \"Thin-Plate Spline Approximation for Image Registration\". In 18th International Conference of the IEEE Engineering in Medicine and Biology Society. 1996.</p> <p>This class was modified to support its use in the ITK registration framework by Rupert Brooks, McGill Centre for Intelligent Machines, Montreal, Canada March 2007. See the Insight Journal Paper by Brooks, R., Arbel, T. \"Improvements to the itk::KernelTransform and its subclasses.\"</p> <p>Modified to include it in elastix:</p> <ul> <li>style</li> <li>make it inherit from AdvancedTransform</li> <li>make it threadsafe, like was done in the itk as well.</li> <li>Support for matrix inversion by QR decomposition, instead of SVD. QR is much faster. Used in SetParameters() and SetFixedParameters().</li> <li>Much faster Jacobian computation for some of the derived kernel transforms. </li> </ul>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef KernelTransform2 itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt; Self &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt; const Self &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-scalartype","title":"typedef ScalarType","text":"<pre><code>typedef Superclass::ScalarType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::ScalarType;\n</code></pre> <p>Typedefs. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-parameterstype","title":"typedef ParametersType","text":"<pre><code>typedef Superclass::ParametersType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::ParametersType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-numberofparameterstype","title":"typedef NumberOfParametersType","text":"<pre><code>typedef Superclass::NumberOfParametersType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::NumberOfParametersType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-jacobiantype","title":"typedef JacobianType","text":"<pre><code>typedef Superclass::JacobianType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::JacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-inputpointtype","title":"typedef InputPointType","text":"<pre><code>typedef Superclass::InputPointType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::InputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-outputpointtype","title":"typedef OutputPointType","text":"<pre><code>typedef Superclass::OutputPointType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::OutputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-inputvectortype","title":"typedef InputVectorType","text":"<pre><code>typedef Superclass::InputVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::InputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-outputvectortype","title":"typedef OutputVectorType","text":"<pre><code>typedef Superclass::OutputVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::OutputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-inputcovariantvectortype","title":"typedef InputCovariantVectorType","text":"<pre><code>typedef Superclass::InputCovariantVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::InputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-outputcovariantvectortype","title":"typedef OutputCovariantVectorType","text":"<pre><code>typedef Superclass::OutputCovariantVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::OutputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-inputvnlvectortype","title":"typedef InputVnlVectorType","text":"<pre><code>typedef Superclass::InputVnlVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::InputVnlVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-outputvnlvectortype","title":"typedef OutputVnlVectorType","text":"<pre><code>typedef Superclass::OutputVnlVectorType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::OutputVnlVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-nonzerojacobianindicestype","title":"typedef NonZeroJacobianIndicesType","text":"<pre><code>typedef Superclass::NonZeroJacobianIndicesType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::NonZeroJacobianIndicesType;\n</code></pre> <p>AdvancedTransform typedefs. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-spatialjacobiantype","title":"typedef SpatialJacobianType","text":"<pre><code>typedef Superclass::SpatialJacobianType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::SpatialJacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-jacobianofspatialjacobiantype","title":"typedef JacobianOfSpatialJacobianType","text":"<pre><code>typedef Superclass::JacobianOfSpatialJacobianType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::JacobianOfSpatialJacobianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-spatialhessiantype","title":"typedef SpatialHessianType","text":"<pre><code>typedef Superclass::SpatialHessianType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::SpatialHessianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-jacobianofspatialhessiantype","title":"typedef JacobianOfSpatialHessianType","text":"<pre><code>typedef Superclass::JacobianOfSpatialHessianType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::JacobianOfSpatialHessianType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-internalmatrixtype","title":"typedef InternalMatrixType","text":"<pre><code>typedef Superclass::InternalMatrixType itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::InternalMatrixType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointsettraitstype","title":"typedef PointSetTraitsType","text":"<pre><code>typedef DefaultStaticMeshTraits&lt; TScalarType, NDimensions, NDimensions, TScalarType, TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointSetTraitsType;\n</code></pre> <p>PointList typedef. This type is used for maintaining lists of points, specifically, the source and target landmark lists. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointsettype","title":"typedef PointSetType","text":"<pre><code>typedef PointSet&lt; InputPointType, NDimensions, PointSetTraitsType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointSetType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointsetpointer","title":"typedef PointSetPointer","text":"<pre><code>typedef PointSetType::Pointer itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointSetPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointscontainer","title":"typedef PointsContainer","text":"<pre><code>typedef PointSetType::PointsContainer itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointsContainer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointsiterator","title":"typedef PointsIterator","text":"<pre><code>typedef PointSetType::PointsContainerIterator itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointsIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pointsconstiterator","title":"typedef PointsConstIterator","text":"<pre><code>typedef PointSetType::PointsContainerConstIterator itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PointsConstIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-vectorsettype","title":"typedef VectorSetType","text":"<pre><code>typedef VectorContainer&lt; unsigned long, InputVectorType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::VectorSetType;\n</code></pre> <p>VectorSet typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-vectorsetpointer","title":"typedef VectorSetPointer","text":"<pre><code>typedef VectorSetType::Pointer itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::VectorSetPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-imatrixtype","title":"typedef IMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::IMatrixType;\n</code></pre> <p>'I' (identity) matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-gmatrixtype","title":"typedef GMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::GMatrixType;\n</code></pre> <p>'G' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-lmatrixtype","title":"typedef LMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::LMatrixType;\n</code></pre> <p>'L' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-kmatrixtype","title":"typedef KMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::KMatrixType;\n</code></pre> <p>'K' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-pmatrixtype","title":"typedef PMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::PMatrixType;\n</code></pre> <p>'P' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-ymatrixtype","title":"typedef YMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::YMatrixType;\n</code></pre> <p>'Y' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-wmatrixtype","title":"typedef WMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::WMatrixType;\n</code></pre> <p>'W' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-dmatrixtype","title":"typedef DMatrixType","text":"<pre><code>typedef vnl_matrix&lt; TScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::DMatrixType;\n</code></pre> <p>'D' matrix typedef. Deformation component </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-amatrixtype","title":"typedef AMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::AMatrixType;\n</code></pre> <p>'A' matrix typedef. Rotational part of the Affine component </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-bmatrixtype","title":"typedef BMatrixType","text":"<pre><code>typedef vnl_vector_fixed&lt; TScalarType, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::BMatrixType;\n</code></pre> <p>'B' matrix typedef. Translational part of the Affine component </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-rowmatrixtype","title":"typedef RowMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt; TScalarType, 1, NDimensions &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::RowMatrixType;\n</code></pre> <p>Row matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-columnmatrixtype","title":"typedef ColumnMatrixType","text":"<pre><code>typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, 1 &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::ColumnMatrixType;\n</code></pre> <p>Column matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-svddecompositiontype","title":"typedef SVDDecompositionType","text":"<pre><code>typedef vnl_svd&lt; ScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::SVDDecompositionType;\n</code></pre> <p>Decompositions, needed for the L matrix. These decompositions are cached for performance reasons during registration. During registration, in every iteration SetParameters() is called, which in turn calls ComputeWMatrix(). The L matrix is not changed however, and therefore it is not needed to redo the decomposition. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#typedef-qrdecompositiontype","title":"typedef QRDecompositionType","text":"<pre><code>typedef vnl_qr&lt; ScalarType &gt; itk::KernelTransform2&lt; TScalarType, NDimensions &gt;::QRDecompositionType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    KernelTransform2 ,\n    AdvancedTransform \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>New macro for creation of through a Smart Pointer. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    SpaceDimension ,\n    unsigned int ,\n    NDimensions \n)\n</code></pre> <p>Dimension of the domain space. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getnumberofparameters","title":"function GetNumberOfParameters","text":"<pre><code>inline virtual NumberOfParametersType GetNumberOfParameters(\n    void \n) const\n</code></pre> <p>Return the number of parameters that completely define the Transform. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkgetobjectmacro","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    SourceLandmarks ,\n    PointSetType \n)\n</code></pre> <p>Get the source landmarks list, which we will denote \\( p \\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setsourcelandmarks","title":"function SetSourceLandmarks","text":"<pre><code>virtual void SetSourceLandmarks(\n    PointSetType * \n)\n</code></pre> <p>Set the source landmarks list. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkgetobjectmacro_1","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    TargetLandmarks ,\n    PointSetType \n)\n</code></pre> <p>Get the target landmarks list, which we will denote \\( q \\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-settargetlandmarks","title":"function SetTargetLandmarks","text":"<pre><code>virtual void SetTargetLandmarks(\n    PointSetType * \n)\n</code></pre> <p>Set the target landmarks list. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkgetobjectmacro_2","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    Displacements ,\n    VectorSetType \n)\n</code></pre> <p>Get the displacements list, which we will denote \\( d \\), where \\( d_i = q_i - p_i \\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computewmatrix","title":"function ComputeWMatrix","text":"<pre><code>void ComputeWMatrix(\n    void \n)\n</code></pre> <p>Compute W matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computelinverse","title":"function ComputeLInverse","text":"<pre><code>void ComputeLInverse(\n    void \n)\n</code></pre> <p>Compute L matrix inverse. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-transformpoint","title":"function TransformPoint","text":"<pre><code>virtual OutputPointType TransformPoint(\n    const InputPointType &amp; thisPoint\n) const\n</code></pre> <p>Compute the position of point in the new space </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-transformvector","title":"function TransformVector","text":"<pre><code>inline virtual OutputVectorType TransformVector(\n    const InputVectorType &amp; \n) const\n</code></pre> <p>These vector transforms are not implemented for this transform. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-transformvector_1","title":"function TransformVector","text":"<pre><code>inline virtual OutputVnlVectorType TransformVector(\n    const InputVnlVectorType &amp; \n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-transformcovariantvector","title":"function TransformCovariantVector","text":"<pre><code>inline virtual OutputCovariantVectorType TransformCovariantVector(\n    const InputCovariantVectorType &amp; \n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getjacobian","title":"function GetJacobian","text":"<pre><code>virtual void GetJacobian(\n    const InputPointType &amp; ,\n    JacobianType &amp; ,\n    NonZeroJacobianIndicesType &amp; \n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetJacobian</p> <p>Compute the Jacobian of the transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setidentity","title":"function SetIdentity","text":"<pre><code>virtual void SetIdentity(\n    void \n)\n</code></pre> <p>Set the Transformation Parameters to be an identity transform. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setparameters","title":"function SetParameters","text":"<pre><code>virtual void SetParameters(\n    const ParametersType &amp; \n)\n</code></pre> <p>Set the Transformation Parameters and update the internal transformation. The parameters represent the source landmarks. Each landmark point is represented by NDimensions doubles. All the landmarks are concatenated to form one flat Array."},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setfixedparameters","title":"function SetFixedParameters","text":"<pre><code>virtual void SetFixedParameters(\n    const ParametersType &amp; \n)\n</code></pre> <p>Set Transform Fixed Parameters: To support the transform file writer this function was added to set the target landmarks similar to the SetParameters function setting the source landmarks </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-updateparameters","title":"function UpdateParameters","text":"<pre><code>virtual void UpdateParameters(\n    void \n)\n</code></pre> <p>Update the Parameters array from the landmarks coordinates. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getparameters","title":"function GetParameters","text":"<pre><code>virtual const ParametersType &amp; GetParameters(\n    void \n) const\n</code></pre> <p>Get the Transformation Parameters - Gets the source landmarks. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getfixedparameters","title":"function GetFixedParameters","text":"<pre><code>virtual const ParametersType &amp; GetFixedParameters(\n    void \n) const\n</code></pre> <p>Get Transform Fixed Parameters - Gets the target landmarks. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setstiffness","title":"function SetStiffness","text":"<pre><code>inline virtual void SetStiffness(\n    double stiffness\n)\n</code></pre> <p>Stiffness of the spline. A stiffness of zero results in the standard interpolating spline. A non-zero stiffness allows the spline to approximate rather than interpolate the landmarks. Stiffness values are usually rather small, typically in the range of 0.001 to 0.1. The approximating spline formulation is based on the short paper by R. Sprengel, K. Rohr, H. Stiehl. \"Thin-Plate Spline Approximation for Image Registration\". In 18th International Conference of the IEEE Engineering in Medicine and Biology Society. 1996. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkgetmacro","title":"function itkGetMacro","text":"<pre><code>itkGetMacro(\n    Stiffness ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-setalpha","title":"function SetAlpha","text":"<pre><code>inline virtual void SetAlpha(\n    TScalarType  itkNotUsedAlpha\n)\n</code></pre> <p>This method makes only sense for the ElasticBody splines. Declare here, so that you can always call it if you don't know the type of kernel beforehand. It will be overridden in the ElasticBodySplineKernelTransform and in the ElasticBodyReciprocalSplineKernelTransform. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getalpha","title":"function GetAlpha","text":"<pre><code>inline virtual TScalarType GetAlpha(\n    void \n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itksetmacro","title":"function itkSetMacro","text":"<pre><code>itkSetMacro(\n    PoissonRatio ,\n    TScalarType \n)\n</code></pre> <p>This method makes only sense for the ElasticBody splines. Declare here, so that you can always call it if you don't know the type of kernel beforehand. It will be overridden in the ElasticBodySplineKernelTransform and in the ElasticBodyReciprocalSplineKernelTransform. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getpoissonratio","title":"function GetPoissonRatio","text":"<pre><code>inline virtual const TScalarType GetPoissonRatio(\n    void \n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itksetmacro_1","title":"function itkSetMacro","text":"<pre><code>itkSetMacro(\n    MatrixInversionMethod ,\n    std::string \n)\n</code></pre> <p>Matrix inversion by SVD or QR decomposition. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-itkgetconstreferencemacro","title":"function itkGetConstReferenceMacro","text":"<pre><code>itkGetConstReferenceMacro(\n    MatrixInversionMethod ,\n    std::string \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getspatialjacobian","title":"function GetSpatialJacobian","text":"<pre><code>inline virtual void GetSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetSpatialJacobian</p> <p>Must be provided. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getspatialhessian","title":"function GetSpatialHessian","text":"<pre><code>inline virtual void GetSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetSpatialHessian</p> <p>Compute the spatial Hessian of the transformation.</p> <p>The spatial Hessian is the vector of matrices of partial second order derivatives of the transformation components with respect to the spatial position \\(x\\), evaluated at a point \\(p\\).</p> <p>  with i the i-th component of the transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getjacobianofspatialjacobian","title":"function GetJacobianOfSpatialJacobian","text":"<pre><code>inline virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetJacobianOfSpatialJacobian</p> <p>Compute the Jacobian of the spatial Jacobian of the transformation.</p> <p>The Jacobian of the spatial Jacobian is the derivative of the spatial Jacobian to the transformation parameters \\(\\mu\\), evaluated at a point \\(p\\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getjacobianofspatialjacobian_1","title":"function GetJacobianOfSpatialJacobian","text":"<pre><code>inline virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetJacobianOfSpatialJacobian</p> <p>Compute both the spatial Jacobian and the Jacobian of the spatial Jacobian of the transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getjacobianofspatialhessian","title":"function GetJacobianOfSpatialHessian","text":"<pre><code>inline virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetJacobianOfSpatialHessian</p> <p>Compute the Jacobian of the spatial Hessian of the transformation.</p> <p>The Jacobian of the spatial Hessian is the derivative of the spatial Hessian to the transformation parameters \\(\\mu\\), evaluated at a point \\(p\\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-getjacobianofspatialhessian_1","title":"function GetJacobianOfSpatialHessian","text":"<pre><code>inline virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices\n) const\n</code></pre> <p>Reimplements: itk::AdvancedTransform::GetJacobianOfSpatialHessian</p> <p>Compute both the spatial Hessian and the Jacobian of the spatial Hessian of the transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-kerneltransform2","title":"function KernelTransform2","text":"<pre><code>KernelTransform2()\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-kerneltransform2_1","title":"function ~KernelTransform2","text":"<pre><code>virtual ~KernelTransform2()\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    std::ostream &amp; os,\n    Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computeg","title":"function ComputeG","text":"<pre><code>virtual void ComputeG(\n    const InputVectorType &amp; landmarkVector,\n    GMatrixType &amp; GMatrix\n) const\n</code></pre> <p>Reimplemented by: itk::ThinPlateSplineKernelTransform2::ComputeG</p> <p>Compute G(x) This is essentially the kernel of the transform. By overriding this method, we can obtain (among others): Elastic body spline Thin plate spline Volume spline. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computereflexiveg","title":"function ComputeReflexiveG","text":"<pre><code>virtual void ComputeReflexiveG(\n    PointsIterator ,\n    GMatrixType &amp; GMatrix\n) const\n</code></pre> <p>Compute a G(x) for a point to itself (i.e. for the block diagonal elements of the matrix K. Parameter indicates for which landmark the reflexive G is to be computed. The default implementation for the reflexive contribution is a diagonal matrix where the diagonal elements are the stiffness of the spline. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computedeformationcontribution","title":"function ComputeDeformationContribution","text":"<pre><code>virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint,\n    OutputPointType &amp; result\n) const\n</code></pre> <p>Reimplemented by: itk::ThinPlateSplineKernelTransform2::ComputeDeformationContribution</p> <p>Compute the contribution of the landmarks weighted by the kernel function to the global deformation of the space. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computek","title":"function ComputeK","text":"<pre><code>void ComputeK(\n    void \n)\n</code></pre> <p>Compute K matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computel","title":"function ComputeL","text":"<pre><code>void ComputeL(\n    void \n)\n</code></pre> <p>Compute L matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computep","title":"function ComputeP","text":"<pre><code>void ComputeP(\n    void \n)\n</code></pre> <p>Compute P matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computey","title":"function ComputeY","text":"<pre><code>void ComputeY(\n    void \n)\n</code></pre> <p>Compute Y matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-computed","title":"function ComputeD","text":"<pre><code>void ComputeD(\n    void \n)\n</code></pre> <p>Compute displacements \\( q_i - p_i \\). </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#function-reorganizew","title":"function ReorganizeW","text":"<pre><code>void ReorganizeW(\n    void \n)\n</code></pre> <p>Warning: This method release the memory of the W Matrix. </p> <p>Reorganize the components of W into D (deformable), A (rotation part of affine) and B (translational part of affine ) components. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_sourcelandmarks","title":"variable m_SourceLandmarks","text":"<pre><code>PointSetPointer m_SourceLandmarks;\n</code></pre> <p>The list of source landmarks, denoted 'p'. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_targetlandmarks","title":"variable m_TargetLandmarks","text":"<pre><code>PointSetPointer m_TargetLandmarks;\n</code></pre> <p>The list of target landmarks, denoted 'q'. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_stiffness","title":"variable m_Stiffness","text":"<pre><code>double m_Stiffness;\n</code></pre> <p>Stiffness parameter. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_displacements","title":"variable m_Displacements","text":"<pre><code>VectorSetPointer m_Displacements;\n</code></pre> <p>The list of displacements. d[i] = q[i] - p[i]; </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrix","title":"variable m_LMatrix","text":"<pre><code>LMatrixType m_LMatrix;\n</code></pre> <p>The L matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrixinverse","title":"variable m_LMatrixInverse","text":"<pre><code>LMatrixType m_LMatrixInverse;\n</code></pre> <p>The inverse of L, which we also cache. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_kmatrix","title":"variable m_KMatrix","text":"<pre><code>KMatrixType m_KMatrix;\n</code></pre> <p>The K matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_pmatrix","title":"variable m_PMatrix","text":"<pre><code>PMatrixType m_PMatrix;\n</code></pre> <p>The P matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_ymatrix","title":"variable m_YMatrix","text":"<pre><code>YMatrixType m_YMatrix;\n</code></pre> <p>The Y matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_wmatrix","title":"variable m_WMatrix","text":"<pre><code>WMatrixType m_WMatrix;\n</code></pre> <p>The W matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_dmatrix","title":"variable m_DMatrix","text":"<pre><code>DMatrixType m_DMatrix;\n</code></pre> <p>The Deformation matrix. This is an auxiliary matrix that will hold the Deformation (non-affine) part of the transform. Those are the coefficients that will multiply the Kernel function. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_amatrix","title":"variable m_AMatrix","text":"<pre><code>AMatrixType m_AMatrix;\n</code></pre> <p>Rotational/Shearing part of the Affine component of the Transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_bvector","title":"variable m_BVector","text":"<pre><code>BMatrixType m_BVector;\n</code></pre> <p>Translational part of the Affine component of the Transformation. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_wmatrixcomputed","title":"variable m_WMatrixComputed","text":"<pre><code>bool m_WMatrixComputed;\n</code></pre> <p>The G matrix. It used to be mutable because m_GMatrix was made an ivar only to avoid copying the matrix at return time but this is not necessary. SK: we don't need this matrix anymore as a member. Has the W matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrixcomputed","title":"variable m_LMatrixComputed","text":"<pre><code>bool m_LMatrixComputed;\n</code></pre> <p>Has the L matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_linversecomputed","title":"variable m_LInverseComputed","text":"<pre><code>bool m_LInverseComputed;\n</code></pre> <p>Has the L inverse matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrixdecompositioncomputed","title":"variable m_LMatrixDecompositionComputed","text":"<pre><code>bool m_LMatrixDecompositionComputed;\n</code></pre> <p>Has the L matrix decomposition been computed? </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrixdecompositionsvd","title":"variable m_LMatrixDecompositionSVD","text":"<pre><code>SVDDecompositionType * m_LMatrixDecompositionSVD;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_lmatrixdecompositionqr","title":"variable m_LMatrixDecompositionQR","text":"<pre><code>QRDecompositionType * m_LMatrixDecompositionQR;\n</code></pre>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_i","title":"variable m_I","text":"<pre><code>IMatrixType m_I;\n</code></pre> <p>Identity matrix. </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_nonzerojacobianindices","title":"variable m_NonZeroJacobianIndices","text":"<pre><code>NonZeroJacobianIndicesType m_NonZeroJacobianIndices;\n</code></pre> <p>Precomputed nonzero Jacobian indices (simply all params) </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_nonzerojacobianindicestemp","title":"variable m_NonZeroJacobianIndicesTemp","text":"<pre><code>NonZeroJacobianIndicesType m_NonZeroJacobianIndicesTemp;\n</code></pre> <p>for old GetJacobian() method: </p>"},{"location":"api/Classes/classitk_1_1KernelTransform2.html#variable-m_fastcomputationpossible","title":"variable m_FastComputationPossible","text":"<pre><code>bool m_FastComputationPossible;\n</code></pre> <p>The Jacobian can be computed much faster for some of the derived kerbel transforms, most notably the TPS. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html","title":"itk::MultiplyByConstantImageFilter","text":"<p>Multiply input pixels by a constant.  More...</p> <p><code>#include &lt;itkMultiplyByConstantImageFilter.h&gt;</code></p> <p>Inherits from UnaryFunctorImageFilter&lt; TInputImage, TOutputImage, Functor::MultiplyByConstant&lt; TInputImage::PixelType, TConstant, TOutputImage::PixelType &gt; &gt;</p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#public-types","title":"Public Types","text":"Name typedef MultiplyByConstantImageFilter Self typedef UnaryFunctorImageFilter&lt; TInputImage, TOutputImage, Functor::MultiplyByConstant&lt; typename TInputImage::PixelType, TConstant, typename TOutputImage::PixelType &gt; &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(MultiplyByConstantImageFilter , UnaryFunctorImageFilter ) void SetConstant(TConstant ct) const TConstant &amp; GetConstant() const"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#protected-functions","title":"Protected Functions","text":"Name MultiplyByConstantImageFilter() virtual ~MultiplyByConstantImageFilter() void PrintSelf(std::ostream &amp; os, Indent indent) const"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TInputImage ,\nclass TConstant ,\nclass TOutputImage &gt;\nclass itk::MultiplyByConstantImageFilter;\n</code></pre> <p>Multiply input pixels by a constant. </p> <p>See: UnaryFunctorImageFilter </p> <p>Author: Tom Vercauteren, INRIA &amp; Mauna Kea Technologies</p> <p>This filter is templated over the input image type and the output image type.</p> <p>This implementation was taken from the Insight Journal paper: http://hdl.handle.net/1926/510</p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef MultiplyByConstantImageFilter itk::MultiplyByConstantImageFilter&lt; TInputImage, TConstant, TOutputImage &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef UnaryFunctorImageFilter&lt; TInputImage,TOutputImage, Functor::MultiplyByConstant&lt; typename TInputImage::PixelType, TConstant, typename TOutputImage::PixelType&gt; &gt; itk::MultiplyByConstantImageFilter&lt; TInputImage, TConstant, TOutputImage &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt;Self&gt; itk::MultiplyByConstantImageFilter&lt; TInputImage, TConstant, TOutputImage &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt;const Self&gt; itk::MultiplyByConstantImageFilter&lt; TInputImage, TConstant, TOutputImage &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    MultiplyByConstantImageFilter ,\n    UnaryFunctorImageFilter \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-setconstant","title":"function SetConstant","text":"<pre><code>inline void SetConstant(\n    TConstant ct\n)\n</code></pre> <p>Set the constant that will be used to multiply all the image pixels </p>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-getconstant","title":"function GetConstant","text":"<pre><code>inline const TConstant &amp; GetConstant() const\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-multiplybyconstantimagefilter","title":"function MultiplyByConstantImageFilter","text":"<pre><code>inline MultiplyByConstantImageFilter()\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-multiplybyconstantimagefilter_1","title":"function ~MultiplyByConstantImageFilter","text":"<pre><code>inline virtual ~MultiplyByConstantImageFilter()\n</code></pre>"},{"location":"api/Classes/classitk_1_1MultiplyByConstantImageFilter.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html","title":"itk::SparseKernelTransform","text":"<p>More...</p> <p><code>#include &lt;itkSparseKernelTransform.h&gt;</code></p> <p>Inherits from Transform&lt; TScalarType, NDimensions, NDimensions &gt;</p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-types","title":"Public Types","text":"Name typedef SparseKernelTransform Self typedef Transform&lt; TScalarType, NDimensions, NDimensions &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef Superclass::ScalarType ScalarType typedef Superclass::ParametersType ParametersType typedef Superclass::JacobianType JacobianType typedef Superclass::InputPointType InputPointType typedef Superclass::OutputPointType OutputPointType typedef Superclass::InputVectorType InputVectorType typedef Superclass::OutputVectorType OutputVectorType typedef DefaultStaticMeshTraits&lt; TScalarType, NDimensions, NDimensions, TScalarType, TScalarType &gt; PointSetTraitsType typedef PointSet&lt; InputPointType, NDimensions, PointSetTraitsType &gt; PointSetType typedef PointSetType::Pointer PointSetPointer typedef PointSetType::PointsContainer PointsContainer typedef PointSetType::PointsContainerIterator PointsIterator typedef PointSetType::PointsContainerConstIterator PointsConstIterator typedef itk::VectorContainer&lt; unsigned long, InputVectorType &gt; VectorSetType typedef VectorSetType::Pointer VectorSetPointer typedef Eigen::Matrix&lt; TScalarType, NDimensions, NDimensions &gt; IMatrixType typedef Eigen::Triplet&lt; TScalarType &gt; TripletType typedef Eigen::Matrix&lt; TScalarType, NDimensions, NDimensions &gt; GMatrixType typedef Eigen::SparseMatrix&lt; TScalarType &gt; LMatrixType typedef Eigen::SparseMatrix&lt; TScalarType &gt; KMatrixType typedef Eigen::SparseMatrix&lt; TScalarType &gt; PMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; YMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; WMatrixType typedef Eigen::Matrix&lt; TScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; DMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, NDimensions &gt; AMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, 1 &gt; BMatrixType typedef Eigen::Matrix&lt; TScalarType, 1, NDimensions &gt; RowMatrixType typedef Eigen::Matrix&lt; TScalarType, NDimensions, 1 &gt; ColumnMatrixType"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-functions","title":"Public Functions","text":"Name itkTypeMacro(SparseKernelTransform , Transform ) itkNewMacro(Self ) itkStaticConstMacro(SpaceDimension , unsigned int , NDimensions ) itkGetObjectMacro(SourceLandmarks , PointSetType ) virtual void SetSourceLandmarks(PointSetType * ) itkGetObjectMacro(TargetLandmarks , PointSetType ) virtual void SetTargetLandmarks(PointSetType * ) itkGetObjectMacro(Displacements , VectorSetType ) void ComputeWMatrix(void ) const virtual OutputPointType TransformPoint(const InputPointType &amp; thisPoint) const virtual void SetIdentity() virtual void SetParameters(const ParametersType &amp; ) virtual void SetFixedParameters(const ParametersType &amp; ) virtual void UpdateParameters(void ) const virtual const ParametersType &amp; GetParameters(void ) const virtual const ParametersType &amp; GetFixedParameters(void ) const virtual void ComputeJacobianWithRespectToParameters(const InputPointType &amp; in, JacobianType &amp; jacobian) const virtual void SetStiffness(double stiffness) itkGetMacro(Stiffness , double )"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#protected-functions","title":"Protected Functions","text":"Name SparseKernelTransform() virtual ~SparseKernelTransform() void PrintSelf(std::ostream &amp; os, Indent indent) const virtual const GMatrixType &amp; ComputeG(const InputVectorType &amp; landmarkVector) const virtual const GMatrixType &amp; ComputeReflexiveG(PointsIterator ) const virtual void ComputeDeformationContribution(const InputPointType &amp; inputPoint, OutputPointType &amp; result) const void ComputeK() const void ComputeL() const void ComputeP() const void ComputeY() const void ComputeD() const void ReorganizeW(void ) const"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-attributes","title":"Public Attributes","text":"Name PointSetPointer m_SourceLandmarks PointSetPointer m_TargetLandmarks"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#protected-attributes","title":"Protected Attributes","text":"Name double m_Stiffness VectorSetPointer m_Displacements LMatrixType m_LMatrix LMatrixType m_LMatrixInverse KMatrixType m_KMatrix PMatrixType m_PMatrix YMatrixType m_YMatrix WMatrixType m_WMatrix DMatrixType m_DMatrix AMatrixType m_AMatrix BMatrixType m_BVector GMatrixType m_GMatrix bool m_WMatrixComputed bool m_LMatrixComputed bool m_LInverseComputed IMatrixType m_I"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TScalarType ,\nunsigned int NDimensions&gt;\nclass itk::SparseKernelTransform;\n</code></pre> <p>Intended to be a base class for elastic body spline and thin plate spline. This is implemented in as straightforward a manner as possible from the IEEE TMI paper by Davis, Khotanzad, Flamig, and Harms, Vol. 16, No. 3 June 1997. Notation closely follows their paper, so if you have it in front of you, this code will make a lot more sense.</p> <p>SparseKernelTransform: Provides support for defining source and target landmarks Defines a number of data types used in the computations Defines the mathematical framework used to compute all splines, so that subclasses need only provide a kernel specific to that spline</p> <p>This formulation allows the stiffness of the spline to be adjusted, allowing the spline to vary from interpolating the landmarks to approximating the landmarks. This part of the formulation is based on the short paper by R. Sprengel, K. Rohr, H. Stiehl. \"Thin-Plate Spline Approximation for Image Registration\". In 18th International Conference of the IEEE Engineering in Medicine and Biology Society. 1996.</p> <p>This class was modified to support its use in the ITK registration framework by Rupert Brooks, McGill Centre for Intelligent Machines, Montreal, Canada March 2007. See the Insight Journal Paper by Brooks, R., Arbel, T. \"Improvements to the itk::KernelTransform and its subclasses.\" </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef SparseKernelTransform itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Transform&lt;TScalarType, NDimensions, NDimensions &gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt;Self&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt;const Self&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-scalartype","title":"typedef ScalarType","text":"<pre><code>typedef Superclass::ScalarType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::ScalarType;\n</code></pre> <p>Scalar type. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-parameterstype","title":"typedef ParametersType","text":"<pre><code>typedef Superclass::ParametersType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::ParametersType;\n</code></pre> <p>Parameters type. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-jacobiantype","title":"typedef JacobianType","text":"<pre><code>typedef Superclass::JacobianType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::JacobianType;\n</code></pre> <p>Jacobian type. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-inputpointtype","title":"typedef InputPointType","text":"<pre><code>typedef Superclass::InputPointType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::InputPointType;\n</code></pre> <p>Standard coordinate point type for this class. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-outputpointtype","title":"typedef OutputPointType","text":"<pre><code>typedef Superclass::OutputPointType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::OutputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-inputvectortype","title":"typedef InputVectorType","text":"<pre><code>typedef Superclass::InputVectorType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::InputVectorType;\n</code></pre> <p>Standard vector type for this class. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-outputvectortype","title":"typedef OutputVectorType","text":"<pre><code>typedef Superclass::OutputVectorType itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::OutputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointsettraitstype","title":"typedef PointSetTraitsType","text":"<pre><code>typedef DefaultStaticMeshTraits&lt;TScalarType, NDimensions, NDimensions, TScalarType, TScalarType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointSetTraitsType;\n</code></pre> <p>PointList typedef. This type is used for maintaining lists of points, specifically, the source and target landmark lists. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointsettype","title":"typedef PointSetType","text":"<pre><code>typedef PointSet&lt;InputPointType, NDimensions, PointSetTraitsType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointSetType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointsetpointer","title":"typedef PointSetPointer","text":"<pre><code>typedef PointSetType::Pointer itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointSetPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointscontainer","title":"typedef PointsContainer","text":"<pre><code>typedef PointSetType::PointsContainer itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointsContainer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointsiterator","title":"typedef PointsIterator","text":"<pre><code>typedef PointSetType::PointsContainerIterator itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointsIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pointsconstiterator","title":"typedef PointsConstIterator","text":"<pre><code>typedef PointSetType::PointsContainerConstIterator itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PointsConstIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-vectorsettype","title":"typedef VectorSetType","text":"<pre><code>typedef itk::VectorContainer&lt;unsigned long,InputVectorType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::VectorSetType;\n</code></pre> <p>VectorSet typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-vectorsetpointer","title":"typedef VectorSetPointer","text":"<pre><code>typedef VectorSetType::Pointer itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::VectorSetPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-imatrixtype","title":"typedef IMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::IMatrixType;\n</code></pre> <p>'I' (identity) matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-triplettype","title":"typedef TripletType","text":"<pre><code>typedef Eigen::Triplet&lt;TScalarType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::TripletType;\n</code></pre> <p>triplets used to fill sparse matrices. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-gmatrixtype","title":"typedef GMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::GMatrixType;\n</code></pre> <p>'G' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-lmatrixtype","title":"typedef LMatrixType","text":"<pre><code>typedef Eigen::SparseMatrix&lt;TScalarType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::LMatrixType;\n</code></pre> <p>'L' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-kmatrixtype","title":"typedef KMatrixType","text":"<pre><code>typedef Eigen::SparseMatrix&lt;TScalarType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::KMatrixType;\n</code></pre> <p>'K' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-pmatrixtype","title":"typedef PMatrixType","text":"<pre><code>typedef Eigen::SparseMatrix&lt;TScalarType&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::PMatrixType;\n</code></pre> <p>'P' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-ymatrixtype","title":"typedef YMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::YMatrixType;\n</code></pre> <p>'Y' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-wmatrixtype","title":"typedef WMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::WMatrixType;\n</code></pre> <p>'W' matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-dmatrixtype","title":"typedef DMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::DMatrixType;\n</code></pre> <p>'D' matrix typedef. Deformation component </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-amatrixtype","title":"typedef AMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::AMatrixType;\n</code></pre> <p>'A' matrix typedef. Rotational part of the Affine component </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-bmatrixtype","title":"typedef BMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType,NDimensions,1&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::BMatrixType;\n</code></pre> <p>'B' matrix typedef. Translational part of the Affine component </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-rowmatrixtype","title":"typedef RowMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType,1,NDimensions&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::RowMatrixType;\n</code></pre> <p>Row matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#typedef-columnmatrixtype","title":"typedef ColumnMatrixType","text":"<pre><code>typedef Eigen::Matrix&lt;TScalarType,NDimensions,1&gt; itk::SparseKernelTransform&lt; TScalarType, NDimensions &gt;::ColumnMatrixType;\n</code></pre> <p>Column matrix typedef. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    SparseKernelTransform ,\n    Transform \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>New macro for creation of through a Smart Pointer </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    SpaceDimension ,\n    unsigned int ,\n    NDimensions \n)\n</code></pre> <p>Dimension of the domain space. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itkgetobjectmacro","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    SourceLandmarks ,\n    PointSetType \n)\n</code></pre> <p>Get the source landmarks list, which we will denote \\( p \\). </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-setsourcelandmarks","title":"function SetSourceLandmarks","text":"<pre><code>virtual void SetSourceLandmarks(\n    PointSetType * \n)\n</code></pre> <p>Set the source landmarks list. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itkgetobjectmacro_1","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    TargetLandmarks ,\n    PointSetType \n)\n</code></pre> <p>Get the target landmarks list, which we will denote \\( q \\). </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-settargetlandmarks","title":"function SetTargetLandmarks","text":"<pre><code>virtual void SetTargetLandmarks(\n    PointSetType * \n)\n</code></pre> <p>Set the target landmarks list. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itkgetobjectmacro_2","title":"function itkGetObjectMacro","text":"<pre><code>itkGetObjectMacro(\n    Displacements ,\n    VectorSetType \n)\n</code></pre> <p>Get the displacements list, which we will denote \\( d \\), where \\( d_i = q_i - p_i \\). </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computewmatrix","title":"function ComputeWMatrix","text":"<pre><code>void ComputeWMatrix(\n    void \n) const\n</code></pre> <p>Compute W matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-transformpoint","title":"function TransformPoint","text":"<pre><code>virtual OutputPointType TransformPoint(\n    const InputPointType &amp; thisPoint\n) const\n</code></pre> <p>Compute L matrix inverse. Compute the position of point in the new space </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-setidentity","title":"function SetIdentity","text":"<pre><code>virtual void SetIdentity()\n</code></pre> <p>Compute the Jacobian Matrix of the transformation at one point Set the Transformation Parameters to be an identity transform </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-setparameters","title":"function SetParameters","text":"<pre><code>virtual void SetParameters(\n    const ParametersType &amp; \n)\n</code></pre> <p>Set the Transformation Parameters and update the internal transformation. The parameters represent the source landmarks. Each landmark point is represented by NDimensions doubles. All the landmarks are concatenated to form one flat Array."},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-setfixedparameters","title":"function SetFixedParameters","text":"<pre><code>virtual void SetFixedParameters(\n    const ParametersType &amp; \n)\n</code></pre> <p>Set Transform Fixed Parameters: To support the transform file writer this function was added to set the target landmarks similar to the SetParameters function setting the source landmarks </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-updateparameters","title":"function UpdateParameters","text":"<pre><code>virtual void UpdateParameters(\n    void \n) const\n</code></pre> <p>Update the Parameters array from the landmarks corrdinates. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-getparameters","title":"function GetParameters","text":"<pre><code>virtual const ParametersType &amp; GetParameters(\n    void \n) const\n</code></pre> <p>Get the Transformation Parameters - Gets the Source Landmarks </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-getfixedparameters","title":"function GetFixedParameters","text":"<pre><code>virtual const ParametersType &amp; GetFixedParameters(\n    void \n) const\n</code></pre> <p>Get Transform Fixed Parameters - Gets the Target Landmarks </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computejacobianwithrespecttoparameters","title":"function ComputeJacobianWithRespectToParameters","text":"<pre><code>virtual void ComputeJacobianWithRespectToParameters(\n    const InputPointType &amp; in,\n    JacobianType &amp; jacobian\n) const\n</code></pre> <p>Reimplemented by: itk::CompactlySupportedRBFSparseKernelTransform::ComputeJacobianWithRespectToParameters</p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-setstiffness","title":"function SetStiffness","text":"<pre><code>inline virtual void SetStiffness(\n    double stiffness\n)\n</code></pre> <p>Stiffness of the spline. A stiffness of zero results in the standard interpolating spline. A non-zero stiffness allows the spline to approximate rather than interpolate the landmarks. Stiffness values are usually rather small, typically in the range of 0.001 to 0.1. The approximating spline formulation is based on the short paper by R. Sprengel, K. Rohr, H. Stiehl. \"Thin-Plate Spline Approximation for Image Registration\". In 18th International Conference of the IEEE Engineering in Medicine and Biology Society. 1996. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-itkgetmacro","title":"function itkGetMacro","text":"<pre><code>itkGetMacro(\n    Stiffness ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-sparsekerneltransform","title":"function SparseKernelTransform","text":"<pre><code>SparseKernelTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-sparsekerneltransform_1","title":"function ~SparseKernelTransform","text":"<pre><code>virtual ~SparseKernelTransform()\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    std::ostream &amp; os,\n    Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computeg","title":"function ComputeG","text":"<pre><code>virtual const GMatrixType &amp; ComputeG(\n    const InputVectorType &amp; landmarkVector\n) const\n</code></pre> <p>Reimplemented by: itk::CompactlySupportedRBFSparseKernelTransform::ComputeG</p> <p>Compute G(x) This is essentially the kernel of the transform. By overriding this method, we can obtain (among others): Elastic body spline Thin plate spline Volume spline </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computereflexiveg","title":"function ComputeReflexiveG","text":"<pre><code>virtual const GMatrixType &amp; ComputeReflexiveG(\n    PointsIterator \n) const\n</code></pre> <p>Compute a G(x) for a point to itself (i.e. for the block diagonal elements of the matrix K. Parameter indicates for which landmark the reflexive G is to be computed. The default implementation for the reflexive contribution is a diagonal matrix where the diagonal elements are the stiffness of the spline. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computedeformationcontribution","title":"function ComputeDeformationContribution","text":"<pre><code>virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint,\n    OutputPointType &amp; result\n) const\n</code></pre> <p>Reimplemented by: itk::CompactlySupportedRBFSparseKernelTransform::ComputeDeformationContribution</p> <p>Compute the contribution of the landmarks weighted by the kernel funcion to the global deformation of the space </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computek","title":"function ComputeK","text":"<pre><code>void ComputeK() const\n</code></pre> <p>Compute K matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computel","title":"function ComputeL","text":"<pre><code>void ComputeL() const\n</code></pre> <p>Compute L matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computep","title":"function ComputeP","text":"<pre><code>void ComputeP() const\n</code></pre> <p>Compute P matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computey","title":"function ComputeY","text":"<pre><code>void ComputeY() const\n</code></pre> <p>Compute Y matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-computed","title":"function ComputeD","text":"<pre><code>void ComputeD() const\n</code></pre> <p>Compute displacements \\( q_i - p_i \\). </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#function-reorganizew","title":"function ReorganizeW","text":"<pre><code>void ReorganizeW(\n    void \n) const\n</code></pre> <p>Warning: This method release the memory of the W Matrix </p> <p>Reorganize the components of W into D (deformable), A (rotation part of affine) and B (translational part of affine ) components. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_sourcelandmarks","title":"variable m_SourceLandmarks","text":"<pre><code>PointSetPointer m_SourceLandmarks;\n</code></pre> <p>The list of source landmarks, denoted 'p'. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_targetlandmarks","title":"variable m_TargetLandmarks","text":"<pre><code>PointSetPointer m_TargetLandmarks;\n</code></pre> <p>The list of target landmarks, denoted 'q'. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_stiffness","title":"variable m_Stiffness","text":"<pre><code>double m_Stiffness;\n</code></pre> <p>Stiffness parameter </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_displacements","title":"variable m_Displacements","text":"<pre><code>VectorSetPointer m_Displacements;\n</code></pre> <p>The list of displacements. d[i] = q[i] - p[i]; </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_lmatrix","title":"variable m_LMatrix","text":"<pre><code>LMatrixType m_LMatrix;\n</code></pre> <p>The L matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_lmatrixinverse","title":"variable m_LMatrixInverse","text":"<pre><code>LMatrixType m_LMatrixInverse;\n</code></pre> <p>The inverse of L, which we also cache. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_kmatrix","title":"variable m_KMatrix","text":"<pre><code>KMatrixType m_KMatrix;\n</code></pre> <p>The K matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_pmatrix","title":"variable m_PMatrix","text":"<pre><code>PMatrixType m_PMatrix;\n</code></pre> <p>The P matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_ymatrix","title":"variable m_YMatrix","text":"<pre><code>YMatrixType m_YMatrix;\n</code></pre> <p>The Y matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_wmatrix","title":"variable m_WMatrix","text":"<pre><code>WMatrixType m_WMatrix;\n</code></pre> <p>The W matrix. </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_dmatrix","title":"variable m_DMatrix","text":"<pre><code>DMatrixType m_DMatrix;\n</code></pre> <p>The Deformation matrix. This is an auxiliary matrix that will hold the Deformation (non-affine) part of the transform. Those are the coefficients that will multiply the Kernel function </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_amatrix","title":"variable m_AMatrix","text":"<pre><code>AMatrixType m_AMatrix;\n</code></pre> <p>Rotatinoal/Shearing part of the Affine component of the Transformation </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_bvector","title":"variable m_BVector","text":"<pre><code>BMatrixType m_BVector;\n</code></pre> <p>Translational part of the Affine component of the Transformation </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_gmatrix","title":"variable m_GMatrix","text":"<pre><code>GMatrixType m_GMatrix;\n</code></pre> <p>The G matrix. It is made mutable because m_GMatrix was made an ivar only to avoid copying the matrix at return time </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_wmatrixcomputed","title":"variable m_WMatrixComputed","text":"<pre><code>bool m_WMatrixComputed;\n</code></pre> <p>Has the W matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_lmatrixcomputed","title":"variable m_LMatrixComputed","text":"<pre><code>bool m_LMatrixComputed;\n</code></pre> <p>Has the L matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_linversecomputed","title":"variable m_LInverseComputed","text":"<pre><code>bool m_LInverseComputed;\n</code></pre> <p>Has the L inverse matrix been computed? </p>"},{"location":"api/Classes/classitk_1_1SparseKernelTransform.html#variable-m_i","title":"variable m_I","text":"<pre><code>IMatrixType m_I;\n</code></pre> <p>Identity matrix. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html","title":"itk::TPGACLevelSetImageFilter","text":"<p>More...</p> <p>Inherits from GeodesicActiveContourLevelSetImageFilter&lt; TInputImage, TFeatureImage, float &gt;</p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#public-types","title":"Public Types","text":"Name typedef TPGACLevelSetImageFilter Self typedef GeodesicActiveContourLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef TInputImage ImageType typedef ImageType::IndexType IndexType typedef Superclass::TimeStepType TimeStepType typedef Superclass::ValueType ValueType typedef Superclass::OutputImageType OutputImageType typedef Superclass::FeatureImageType FeatureImageType"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(TPGACLevelSetImageFilter , GeodesicActiveContourLevelSetImageFilter )"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#protected-functions","title":"Protected Functions","text":"Name ~TPGACLevelSetImageFilter() TPGACLevelSetImageFilter() virtual void PrintSelf(std::ostream &amp; os, Indent indent) const TPGACLevelSetImageFilter(const Self &amp; ) void operator=(const Self &amp; ) virtual ValueType CalculateUpdateValue(const IndexType &amp; idx, const TimeStepType &amp; dt, const ValueType &amp; value, const ValueType &amp; change)"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TInputImage ,\nclass TFeatureImage ,\nclass TOutputPixelType  =float&gt;\nclass itk::TPGACLevelSetImageFilter;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef TPGACLevelSetImageFilter itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::Self;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef GeodesicActiveContourLevelSetImageFilter&lt;TInputImage, TFeatureImage, TOutputPixelType&gt; itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt;Self&gt; itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt;const Self&gt; itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef TInputImage itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::ImageType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-indextype","title":"typedef IndexType","text":"<pre><code>typedef ImageType::IndexType itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::IndexType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-timesteptype","title":"typedef TimeStepType","text":"<pre><code>typedef Superclass::TimeStepType itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::TimeStepType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-valuetype","title":"typedef ValueType","text":"<pre><code>typedef Superclass::ValueType itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::ValueType;\n</code></pre> <p>Inherited typedef from the superclass. </p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-outputimagetype","title":"typedef OutputImageType","text":"<pre><code>typedef Superclass::OutputImageType itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::OutputImageType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#typedef-featureimagetype","title":"typedef FeatureImageType","text":"<pre><code>typedef Superclass::FeatureImageType itk::TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType &gt;::FeatureImageType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory </p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    TPGACLevelSetImageFilter ,\n    GeodesicActiveContourLevelSetImageFilter \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-tpgaclevelsetimagefilter","title":"function ~TPGACLevelSetImageFilter","text":"<pre><code>inline ~TPGACLevelSetImageFilter()\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-tpgaclevelsetimagefilter_1","title":"function TPGACLevelSetImageFilter","text":"<pre><code>TPGACLevelSetImageFilter()\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-printself","title":"function PrintSelf","text":"<pre><code>virtual void PrintSelf(\n    std::ostream &amp; os,\n    Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-tpgaclevelsetimagefilter_2","title":"function TPGACLevelSetImageFilter","text":"<pre><code>TPGACLevelSetImageFilter(\n    const Self &amp; \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-operator","title":"function operator=","text":"<pre><code>void operator=(\n    const Self &amp; \n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1TPGACLevelSetImageFilter.html#function-calculateupdatevalue","title":"function CalculateUpdateValue","text":"<pre><code>inline virtual ValueType CalculateUpdateValue(\n    const IndexType &amp; idx,\n    const TimeStepType &amp; dt,\n    const ValueType &amp; value,\n    const ValueType &amp; change\n)\n</code></pre> <p>Overridden from the parent class to indroduce a constraint on</p> <ul> <li>surface flow under certain conditions. </li> </ul> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html","title":"itk::ThinPlateSplineKernelTransform2","text":"<p>More...</p> <p><code>#include &lt;itkThinPlateSplineKernelTransform2.h&gt;</code></p> <p>Inherits from itk::KernelTransform2&lt; TScalarType, 3 &gt;, itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;, Transform&lt; TScalarType, 3, 3 &gt;</p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#public-types","title":"Public Types","text":"Name typedef ThinPlateSplineKernelTransform2 Self typedef KernelTransform2&lt; TScalarType, NDimensions &gt; Superclass typedef SmartPointer&lt; Self &gt; Pointer typedef SmartPointer&lt; const Self &gt; ConstPointer typedef Superclass::ScalarType ScalarType typedef Superclass::ParametersType ParametersType typedef Superclass::JacobianType JacobianType typedef Superclass::InputPointType InputPointType typedef Superclass::OutputPointType OutputPointType typedef Superclass::InputVectorType InputVectorType typedef Superclass::OutputVectorType OutputVectorType typedef Superclass::InputCovariantVectorType InputCovariantVectorType typedef Superclass::OutputCovariantVectorType OutputCovariantVectorType typedef Superclass::PointsIterator PointsIterator"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#protected-types","title":"Protected Types","text":"Name typedef Superclass::GMatrixType GMatrixType"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(ThinPlateSplineKernelTransform2 , KernelTransform2 ) itkStaticConstMacro(SpaceDimension , unsigned int , Superclass::SpaceDimension ) void SetSigma(double sigma)"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#protected-functions","title":"Protected Functions","text":"Name ThinPlateSplineKernelTransform2() virtual ~ThinPlateSplineKernelTransform2() virtual void ComputeG(const InputVectorType &amp; x, GMatrixType &amp; GMatrix) const virtual void ComputeDeformationContribution(const InputPointType &amp; inputPoint, OutputPointType &amp; result) const"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name typedef Superclass::NumberOfParametersType NumberOfParametersType typedef Superclass::InputVnlVectorType InputVnlVectorType typedef Superclass::OutputVnlVectorType OutputVnlVectorType typedef Superclass::NonZeroJacobianIndicesType NonZeroJacobianIndicesType typedef Superclass::SpatialJacobianType SpatialJacobianType typedef Superclass::JacobianOfSpatialJacobianType JacobianOfSpatialJacobianType typedef Superclass::SpatialHessianType SpatialHessianType typedef Superclass::JacobianOfSpatialHessianType JacobianOfSpatialHessianType typedef Superclass::InternalMatrixType InternalMatrixType typedef DefaultStaticMeshTraits&lt; TScalarType, NDimensions, NDimensions, TScalarType, TScalarType &gt; PointSetTraitsType typedef PointSet&lt; InputPointType, NDimensions, PointSetTraitsType &gt; PointSetType typedef PointSetType::Pointer PointSetPointer typedef PointSetType::PointsContainer PointsContainer typedef PointSetType::PointsContainerConstIterator PointsConstIterator typedef VectorContainer&lt; unsigned long, InputVectorType &gt; VectorSetType typedef VectorSetType::Pointer VectorSetPointer typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; IMatrixType typedef vnl_matrix&lt; TScalarType &gt; LMatrixType typedef vnl_matrix&lt; TScalarType &gt; KMatrixType typedef vnl_matrix&lt; TScalarType &gt; PMatrixType typedef vnl_matrix&lt; TScalarType &gt; YMatrixType typedef vnl_matrix&lt; TScalarType &gt; WMatrixType typedef vnl_matrix&lt; TScalarType &gt; DMatrixType typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; AMatrixType typedef vnl_vector_fixed&lt; TScalarType, NDimensions &gt; BMatrixType typedef vnl_matrix_fixed&lt; TScalarType, 1, NDimensions &gt; RowMatrixType typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, 1 &gt; ColumnMatrixType <p>Protected Types inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name typedef vnl_svd&lt; ScalarType &gt; SVDDecompositionType typedef vnl_qr&lt; ScalarType &gt; QRDecompositionType <p>Public Functions inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name virtual NumberOfParametersType GetNumberOfParameters(void ) const itkGetObjectMacro(SourceLandmarks , PointSetType ) virtual void SetSourceLandmarks(PointSetType * ) itkGetObjectMacro(TargetLandmarks , PointSetType ) virtual void SetTargetLandmarks(PointSetType * ) itkGetObjectMacro(Displacements , VectorSetType ) void ComputeWMatrix(void ) void ComputeLInverse(void ) virtual OutputPointType TransformPoint(const InputPointType &amp; thisPoint) const virtual OutputVectorType TransformVector(const InputVectorType &amp; ) const virtual OutputVnlVectorType TransformVector(const InputVnlVectorType &amp; ) const virtual OutputCovariantVectorType TransformCovariantVector(const InputCovariantVectorType &amp; ) const virtual void GetJacobian(const InputPointType &amp; , JacobianType &amp; , NonZeroJacobianIndicesType &amp; ) const virtual void SetIdentity(void ) virtual void SetParameters(const ParametersType &amp; ) virtual void SetFixedParameters(const ParametersType &amp; ) virtual void UpdateParameters(void ) virtual const ParametersType &amp; GetParameters(void ) const virtual const ParametersType &amp; GetFixedParameters(void ) const virtual void SetStiffness(double stiffness) itkGetMacro(Stiffness , double ) virtual void SetAlpha(TScalarType  itkNotUsedAlpha) virtual TScalarType GetAlpha(void ) const itkSetMacro(PoissonRatio , TScalarType ) virtual const TScalarType GetPoissonRatio(void ) const itkSetMacro(MatrixInversionMethod , std::string ) itkGetConstReferenceMacro(MatrixInversionMethod , std::string ) virtual void GetSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj) const virtual void GetSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh) const virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const <p>Protected Functions inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name KernelTransform2() virtual ~KernelTransform2() void PrintSelf(std::ostream &amp; os, Indent indent) const virtual void ComputeReflexiveG(PointsIterator , GMatrixType &amp; GMatrix) const void ComputeK(void ) void ComputeL(void ) void ComputeP(void ) void ComputeY(void ) void ComputeD(void ) void ReorganizeW(void ) <p>Public Attributes inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name PointSetPointer m_SourceLandmarks PointSetPointer m_TargetLandmarks <p>Protected Attributes inherited from itk::KernelTransform2&lt; TScalarType, 3 &gt;</p> Name double m_Stiffness VectorSetPointer m_Displacements LMatrixType m_LMatrix LMatrixType m_LMatrixInverse KMatrixType m_KMatrix PMatrixType m_PMatrix YMatrixType m_YMatrix WMatrixType m_WMatrix DMatrixType m_DMatrix AMatrixType m_AMatrix BMatrixType m_BVector bool m_WMatrixComputed bool m_LMatrixComputed bool m_LInverseComputed bool m_LMatrixDecompositionComputed SVDDecompositionType * m_LMatrixDecompositionSVD QRDecompositionType * m_LMatrixDecompositionQR IMatrixType m_I NonZeroJacobianIndicesType m_NonZeroJacobianIndices NonZeroJacobianIndicesType m_NonZeroJacobianIndicesTemp bool m_FastComputationPossible <p>Public Types inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name typedef Superclass::ParametersValueType ParametersValueType typedef Superclass::NumberOfParametersType NumberOfParametersType typedef Superclass::DerivativeType DerivativeType typedef Superclass::InputVnlVectorType InputVnlVectorType typedef Superclass::OutputVnlVectorType OutputVnlVectorType typedef Superclass::InverseTransformBaseType InverseTransformBaseType typedef Superclass::InverseTransformBasePointer InverseTransformBasePointer typedef Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt; TransformType typedef TransformType::Pointer TransformTypePointer typedef TransformType::ConstPointer TransformTypeConstPointer typedef std::vector&lt; unsigned long &gt; NonZeroJacobianIndicesType typedef Matrix&lt; ScalarType, OutputSpaceDimension, InputSpaceDimension &gt; SpatialJacobianType typedef std::vector&lt; SpatialJacobianType &gt; JacobianOfSpatialJacobianType typedef FixedArray&lt; Matrix&lt; ScalarType, InputSpaceDimension, InputSpaceDimension &gt;, OutputSpaceDimension &gt; SpatialHessianType typedef std::vector&lt; SpatialHessianType &gt; JacobianOfSpatialHessianType typedef SpatialJacobianType::InternalMatrixType InternalMatrixType typedef OutputCovariantVectorType MovingImageGradientType typedef MovingImageGradientType::ValueType MovingImageGradientValueType <p>Public Functions inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name virtual NumberOfParametersType GetNumberOfNonZeroJacobianIndices(void ) const itkGetConstMacro(HasNonZeroSpatialHessian , bool ) itkGetConstMacro(HasNonZeroJacobianOfSpatialHessian , bool ) virtual void GetJacobian(const InputPointType &amp; ipp, JacobianType &amp; j, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void EvaluateJacobianWithImageGradientProduct(const InputPointType &amp; ipp, const MovingImageGradientType &amp; movingImageGradient, DerivativeType &amp; imageJacobian, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const virtual void GetSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj) const =0 virtual void ComputeJacobianWithRespectToParameters(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const virtual void ComputeJacobianWithRespectToPosition(const InputPointType &amp; itkNotUsedp, JacobianType &amp; itkNotUsedj) const virtual void GetSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh) const =0 virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialJacobian(const InputPointType &amp; ipp, SpatialJacobianType &amp; sj, JacobianOfSpatialJacobianType &amp; jsj, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 virtual void GetJacobianOfSpatialHessian(const InputPointType &amp; ipp, SpatialHessianType &amp; sh, JacobianOfSpatialHessianType &amp; jsh, NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices) const =0 <p>Protected Functions inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name AdvancedTransform() AdvancedTransform(NumberOfParametersType numberOfParameters) virtual ~AdvancedTransform() <p>Protected Attributes inherited from itk::AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;</p> Name bool m_HasNonZeroSpatialHessian bool m_HasNonZeroJacobianOfSpatialHessian"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TScalarType ,\nunsigned int NDimensions =3&gt;\nclass itk::ThinPlateSplineKernelTransform2;\n</code></pre> <p>This class defines the thin plate spline (TPS) transformation. It is implemented in as straightforward a manner as possible from the IEEE TMI paper by Davis, Khotanzad, Flamig, and Harms, Vol. 16 No. 3 June 1997 </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ThinPlateSplineKernelTransform2 itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef KernelTransform2&lt; TScalarType, NDimensions &gt; itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef SmartPointer&lt; Self &gt; itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef SmartPointer&lt; const Self &gt; itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-scalartype","title":"typedef ScalarType","text":"<pre><code>typedef Superclass::ScalarType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::ScalarType;\n</code></pre> <p>Scalar type. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-parameterstype","title":"typedef ParametersType","text":"<pre><code>typedef Superclass::ParametersType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::ParametersType;\n</code></pre> <p>Parameters type. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-jacobiantype","title":"typedef JacobianType","text":"<pre><code>typedef Superclass::JacobianType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::JacobianType;\n</code></pre> <p>Jacobian Type </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-inputpointtype","title":"typedef InputPointType","text":"<pre><code>typedef Superclass::InputPointType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::InputPointType;\n</code></pre> <p>These (rather redundant) typedefs are needed because on SGI, typedefs are not inherited. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-outputpointtype","title":"typedef OutputPointType","text":"<pre><code>typedef Superclass::OutputPointType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::OutputPointType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-inputvectortype","title":"typedef InputVectorType","text":"<pre><code>typedef Superclass::InputVectorType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::InputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-outputvectortype","title":"typedef OutputVectorType","text":"<pre><code>typedef Superclass::OutputVectorType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::OutputVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-inputcovariantvectortype","title":"typedef InputCovariantVectorType","text":"<pre><code>typedef Superclass::InputCovariantVectorType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::InputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-outputcovariantvectortype","title":"typedef OutputCovariantVectorType","text":"<pre><code>typedef Superclass::OutputCovariantVectorType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::OutputCovariantVectorType;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-pointsiterator","title":"typedef PointsIterator","text":"<pre><code>typedef Superclass::PointsIterator itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::PointsIterator;\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#typedef-gmatrixtype","title":"typedef GMatrixType","text":"<pre><code>typedef Superclass::GMatrixType itk::ThinPlateSplineKernelTransform2&lt; TScalarType, NDimensions &gt;::GMatrixType;\n</code></pre> <p>These (rather redundant) typedefs are needed because on SGI, typedefs are not inherited. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>New macro for creation of through a Smart Pointer </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    ThinPlateSplineKernelTransform2 ,\n    KernelTransform2 \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    SpaceDimension ,\n    unsigned int ,\n    Superclass::SpaceDimension \n)\n</code></pre> <p>Dimension of the domain space. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-setsigma","title":"function SetSigma","text":"<pre><code>inline void SetSigma(\n    double sigma\n)\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-thinplatesplinekerneltransform2","title":"function ThinPlateSplineKernelTransform2","text":"<pre><code>inline ThinPlateSplineKernelTransform2()\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-thinplatesplinekerneltransform2_1","title":"function ~ThinPlateSplineKernelTransform2","text":"<pre><code>inline virtual ~ThinPlateSplineKernelTransform2()\n</code></pre>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-computeg","title":"function ComputeG","text":"<pre><code>virtual void ComputeG(\n    const InputVectorType &amp; x,\n    GMatrixType &amp; GMatrix\n) const\n</code></pre> <p>Reimplements: itk::KernelTransform2::ComputeG</p> <p>Compute G(x) For the thin plate spline, this is: G(x) = r(x)*I \\( G(x) = r(x)*I \\) where r(x) = Euclidean norm = sqrt[x1^2 + x2^2 + x3^2]  I = identity matrix. </p>"},{"location":"api/Classes/classitk_1_1ThinPlateSplineKernelTransform2.html#function-computedeformationcontribution","title":"function ComputeDeformationContribution","text":"<pre><code>virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint,\n    OutputPointType &amp; result\n) const\n</code></pre> <p>Reimplements: itk::KernelTransform2::ComputeDeformationContribution</p> <p>Compute the contribution of the landmarks weighted by the kernel function to the global deformation of the space. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classmat3d.html","title":"mat3d","text":""},{"location":"api/Classes/classmat3d.html#public-functions","title":"Public Functions","text":"Name mat3d() mat3d(double a00, double a01, double a02, double a10, double a11, double a12, double a20, double a21, double a22) double * operator[](int i) double &amp; operator()(int i, int j) mat3d operator*(mat3d &amp; m) mat3d &amp; operator*=(mat3d &amp; m) mat3d &amp; operator+=(mat3d &amp; m) mat3d &amp; operator-=(mat3d &amp; m) mat3d &amp; operator/=(const double f) vec3d operator*(vec3d b) double det() const double Invert() mat3d inverse() const void zero() void unit() mat3d transpose()"},{"location":"api/Classes/classmat3d.html#protected-attributes","title":"Protected Attributes","text":"Name double m_data"},{"location":"api/Classes/classmat3d.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmat3d.html#function-mat3d","title":"function mat3d","text":"<pre><code>inline mat3d()\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-mat3d_1","title":"function mat3d","text":"<pre><code>mat3d(\n    double a00,\n    double a01,\n    double a02,\n    double a10,\n    double a11,\n    double a12,\n    double a20,\n    double a21,\n    double a22\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator","title":"function operator[]","text":"<pre><code>inline double * operator[](\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_1","title":"function operator()","text":"<pre><code>inline double &amp; operator()(\n    int i,\n    int j\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_2","title":"function operator*","text":"<pre><code>inline mat3d operator*(\n    mat3d &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_3","title":"function operator*=","text":"<pre><code>inline mat3d &amp; operator*=(\n    mat3d &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_4","title":"function operator+=","text":"<pre><code>inline mat3d &amp; operator+=(\n    mat3d &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator-","title":"function operator-=","text":"<pre><code>inline mat3d &amp; operator-=(\n    mat3d &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_5","title":"function operator/=","text":"<pre><code>inline mat3d &amp; operator/=(\n    const double f\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-operator_6","title":"function operator*","text":"<pre><code>inline vec3d operator*(\n    vec3d b\n)\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-det","title":"function det","text":"<pre><code>inline double det() const\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-invert","title":"function Invert","text":"<pre><code>double Invert()\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-inverse","title":"function inverse","text":"<pre><code>mat3d inverse() const\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-zero","title":"function zero","text":"<pre><code>inline void zero()\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-unit","title":"function unit","text":"<pre><code>inline void unit()\n</code></pre>"},{"location":"api/Classes/classmat3d.html#function-transpose","title":"function transpose","text":"<pre><code>mat3d transpose()\n</code></pre>"},{"location":"api/Classes/classmat3d.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classmat3d.html#variable-m_data","title":"variable m_data","text":"<pre><code>double m_data;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classmatrix.html","title":"matrix","text":""},{"location":"api/Classes/classmatrix.html#public-functions","title":"Public Functions","text":"Name matrix(int r, int c) ~matrix() void zero() double * operator[](int i) double &amp; operator()(int i, int j) bool solve(vector&lt; double &gt; &amp; x, vector&lt; double &gt; &amp; b) bool lsq_solve(vector&lt; double &gt; &amp; x, vector&lt; double &gt; &amp; b) bool eigen_vectors(matrix &amp; Eigen, vector&lt; double &gt; &amp; eigen_values) int Rows() void mult_transpose(vector&lt; double &gt; &amp; x, vector&lt; double &gt; &amp; y) void mult_transpose_self(matrix &amp; AAt)"},{"location":"api/Classes/classmatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmatrix.html#function-matrix","title":"function matrix","text":"<pre><code>matrix(\n    int r,\n    int c\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-matrix_1","title":"function ~matrix","text":"<pre><code>inline ~matrix()\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-zero","title":"function zero","text":"<pre><code>void zero()\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-operator","title":"function operator[]","text":"<pre><code>inline double * operator[](\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-operator_1","title":"function operator()","text":"<pre><code>inline double &amp; operator()(\n    int i,\n    int j\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-solve","title":"function solve","text":"<pre><code>bool solve(\n    vector&lt; double &gt; &amp; x,\n    vector&lt; double &gt; &amp; b\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-lsq_solve","title":"function lsq_solve","text":"<pre><code>bool lsq_solve(\n    vector&lt; double &gt; &amp; x,\n    vector&lt; double &gt; &amp; b\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-eigen_vectors","title":"function eigen_vectors","text":"<pre><code>bool eigen_vectors(\n    matrix &amp; Eigen,\n    vector&lt; double &gt; &amp; eigen_values\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-rows","title":"function Rows","text":"<pre><code>inline int Rows()\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-mult_transpose","title":"function mult_transpose","text":"<pre><code>void mult_transpose(\n    vector&lt; double &gt; &amp; x,\n    vector&lt; double &gt; &amp; y\n)\n</code></pre>"},{"location":"api/Classes/classmatrix.html#function-mult_transpose_self","title":"function mult_transpose_self","text":"<pre><code>void mult_transpose_self(\n    matrix &amp; AAt\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classmeshFIM.html","title":"meshFIM","text":""},{"location":"api/Classes/classmeshFIM.html#public-types","title":"Public Types","text":"Name enum LabelType typedef int VoxelIndexType typedef int index"},{"location":"api/Classes/classmeshFIM.html#public-functions","title":"Public Functions","text":"Name void ComputeDistanceToLandmarksGivenTriangleInfo(TriMesh * mesh, const char * infilename, const char * outfilename) void computeFIM(TriMesh * mesh, const char * vertT_filename) void GetFeatureValues(point x, std::vector&lt; float &gt; &amp; vals) void ReadFaceIndexMap(const char * infilename) void ReadFeatureFromFile(const char * infilename) void ReadFeatureGradientFromFile(const char * infilename) point GetFeatureDerivative(point p, int fIndex) void need_abs_curvatures() void need_edge_lengths() void need_speed() void need_oneringfaces() void need_kdtree() void SetMesh(TriMesh * mesh) void SetStopDistance(float d) void setSpeedType(int st) meshFIM() ~meshFIM()"},{"location":"api/Classes/classmeshFIM.html#public-attributes","title":"Public Attributes","text":"Name TriMesh * m_meshPtr int NumComputation float imageOrigin float imageSpacing int imageSize int imageIndex std::vector&lt; Color &gt; colors"},{"location":"api/Classes/classmeshFIM.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classmeshFIM.html#enum-labeltype","title":"enum LabelType","text":"Enumerator Value Description MaskPoint SeedPoint ActivePoint FarPoint StopPoint AlivePoint ToBeAlivePoint"},{"location":"api/Classes/classmeshFIM.html#typedef-voxelindextype","title":"typedef VoxelIndexType","text":"<pre><code>typedef int meshFIM::VoxelIndexType;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#typedef-index","title":"typedef index","text":"<pre><code>typedef int meshFIM::index;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmeshFIM.html#function-computedistancetolandmarksgiventriangleinfo","title":"function ComputeDistanceToLandmarksGivenTriangleInfo","text":"<pre><code>void ComputeDistanceToLandmarksGivenTriangleInfo(\n    TriMesh * mesh,\n    const char * infilename,\n    const char * outfilename\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-computefim","title":"function computeFIM","text":"<pre><code>void computeFIM(\n    TriMesh * mesh,\n    const char * vertT_filename\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-getfeaturevalues","title":"function GetFeatureValues","text":"<pre><code>void GetFeatureValues(\n    point x,\n    std::vector&lt; float &gt; &amp; vals\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-readfaceindexmap","title":"function ReadFaceIndexMap","text":"<pre><code>void ReadFaceIndexMap(\n    const char * infilename\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-readfeaturefromfile","title":"function ReadFeatureFromFile","text":"<pre><code>void ReadFeatureFromFile(\n    const char * infilename\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-readfeaturegradientfromfile","title":"function ReadFeatureGradientFromFile","text":"<pre><code>void ReadFeatureGradientFromFile(\n    const char * infilename\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-getfeaturederivative","title":"function GetFeatureDerivative","text":"<pre><code>point GetFeatureDerivative(\n    point p,\n    int fIndex\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-need_abs_curvatures","title":"function need_abs_curvatures","text":"<pre><code>void need_abs_curvatures()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-need_edge_lengths","title":"function need_edge_lengths","text":"<pre><code>void need_edge_lengths()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-need_speed","title":"function need_speed","text":"<pre><code>void need_speed()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-need_oneringfaces","title":"function need_oneringfaces","text":"<pre><code>void need_oneringfaces()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-need_kdtree","title":"function need_kdtree","text":"<pre><code>void need_kdtree()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-setmesh","title":"function SetMesh","text":"<pre><code>void SetMesh(\n    TriMesh * mesh\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-setstopdistance","title":"function SetStopDistance","text":"<pre><code>inline void SetStopDistance(\n    float d\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-setspeedtype","title":"function setSpeedType","text":"<pre><code>inline void setSpeedType(\n    int st\n)\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-meshfim","title":"function meshFIM","text":"<pre><code>inline meshFIM()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#function-meshfim_1","title":"function ~meshFIM","text":"<pre><code>inline ~meshFIM()\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classmeshFIM.html#variable-m_meshptr","title":"variable m_meshPtr","text":"<pre><code>TriMesh * m_meshPtr;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-numcomputation","title":"variable NumComputation","text":"<pre><code>int NumComputation;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-imageorigin","title":"variable imageOrigin","text":"<pre><code>float imageOrigin;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-imagespacing","title":"variable imageSpacing","text":"<pre><code>float imageSpacing;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-imagesize","title":"variable imageSize","text":"<pre><code>int imageSize;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-imageindex","title":"variable imageIndex","text":"<pre><code>int imageIndex;\n</code></pre>"},{"location":"api/Classes/classmeshFIM.html#variable-colors","title":"variable colors","text":"<pre><code>std::vector&lt; Color &gt; colors;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html","title":"monailabel::MonaiLabelJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-slots","title":"Public Slots","text":"Name void onUploadSampleClicked() void onRunSegmentationClicked() void onSubmitLabelClicked()"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-signals","title":"Public Signals","text":"Name void triggerUpdateView() void triggerClientInitialized(bool success) void triggerUploadSampleCompleted() void triggerSegmentationCompleted() void triggerSubmitLabelCompleted()"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-functions","title":"Public Functions","text":"Name MonaiLabelJob(QSharedPointer&lt; Session &gt; session, const std::string &amp; server_url, const std::string &amp; client_id, const std::string &amp; strategy, const std::string &amp; model_type) ~MonaiLabelJob() void setServer(const std::string &amp; server_url) void setModelType(const std::string &amp; model_type) const std::string &amp; getServer() void setClientId(const std::string &amp; client_id =\"\") const std::string &amp; getClientId() void initializeClient() std::shared_ptr&lt; py::object &gt; getClient() const py::dict getInfo() std::string getModelName(std::string modelType) std::vector&lt; std::string &gt; getModelNames(const std::string &amp; model_type) std::string getSessionId() py::dict getParamsFromConfig(std::string section, std::string name) py::dict nextSample(std::string strategy, py::dict params) py::tuple infer(std::string model, std::string image_in, py::dict params, std::string label_in, std::string file, std::string session_id) py::dict saveLabel(std::string image_in, std::string label_in, py::dict params) py::dict uploadImage(std::string image_in, std::string image_id) void updateShapes() void runSegmentationModel() virtual void run() overriderun the job virtual QString name() overrideget the name of the job void python_message(std::string str) void setCurrentSampleNumber(int n)"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-attributes","title":"Public Attributes","text":"Name const std::string MONAI_RESULT_EXTENSION const std::string MONAI_RESULT_DTYPE"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#slot-onuploadsampleclicked","title":"slot onUploadSampleClicked","text":"<pre><code>void onUploadSampleClicked()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#slot-onrunsegmentationclicked","title":"slot onRunSegmentationClicked","text":"<pre><code>void onRunSegmentationClicked()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#slot-onsubmitlabelclicked","title":"slot onSubmitLabelClicked","text":"<pre><code>void onSubmitLabelClicked()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#signal-triggerupdateview","title":"signal triggerUpdateView","text":"<pre><code>void triggerUpdateView()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#signal-triggerclientinitialized","title":"signal triggerClientInitialized","text":"<pre><code>void triggerClientInitialized(\n    bool success\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#signal-triggeruploadsamplecompleted","title":"signal triggerUploadSampleCompleted","text":"<pre><code>void triggerUploadSampleCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#signal-triggersegmentationcompleted","title":"signal triggerSegmentationCompleted","text":"<pre><code>void triggerSegmentationCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#signal-triggersubmitlabelcompleted","title":"signal triggerSubmitLabelCompleted","text":"<pre><code>void triggerSubmitLabelCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-monailabeljob","title":"function MonaiLabelJob","text":"<pre><code>MonaiLabelJob(\n    QSharedPointer&lt; Session &gt; session,\n    const std::string &amp; server_url,\n    const std::string &amp; client_id,\n    const std::string &amp; strategy,\n    const std::string &amp; model_type\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-monailabeljob_1","title":"function ~MonaiLabelJob","text":"<pre><code>~MonaiLabelJob()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-setserver","title":"function setServer","text":"<pre><code>void setServer(\n    const std::string &amp; server_url\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-setmodeltype","title":"function setModelType","text":"<pre><code>void setModelType(\n    const std::string &amp; model_type\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getserver","title":"function getServer","text":"<pre><code>inline const std::string &amp; getServer()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-setclientid","title":"function setClientId","text":"<pre><code>void setClientId(\n    const std::string &amp; client_id =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getclientid","title":"function getClientId","text":"<pre><code>inline const std::string &amp; getClientId()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-initializeclient","title":"function initializeClient","text":"<pre><code>void initializeClient()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getclient","title":"function getClient","text":"<pre><code>inline std::shared_ptr&lt; py::object &gt; getClient() const\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getinfo","title":"function getInfo","text":"<pre><code>py::dict getInfo()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getmodelname","title":"function getModelName","text":"<pre><code>std::string getModelName(\n    std::string modelType\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getmodelnames","title":"function getModelNames","text":"<pre><code>std::vector&lt; std::string &gt; getModelNames(\n    const std::string &amp; model_type\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getsessionid","title":"function getSessionId","text":"<pre><code>std::string getSessionId()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-getparamsfromconfig","title":"function getParamsFromConfig","text":"<pre><code>py::dict getParamsFromConfig(\n    std::string section,\n    std::string name\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-nextsample","title":"function nextSample","text":"<pre><code>py::dict nextSample(\n    std::string strategy,\n    py::dict params\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-infer","title":"function infer","text":"<pre><code>py::tuple infer(\n    std::string model,\n    std::string image_in,\n    py::dict params,\n    std::string label_in,\n    std::string file,\n    std::string session_id\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-savelabel","title":"function saveLabel","text":"<pre><code>py::dict saveLabel(\n    std::string image_in,\n    std::string label_in,\n    py::dict params\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-uploadimage","title":"function uploadImage","text":"<pre><code>py::dict uploadImage(\n    std::string image_in,\n    std::string image_id\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-updateshapes","title":"function updateShapes","text":"<pre><code>void updateShapes()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-runsegmentationmodel","title":"function runSegmentationModel","text":"<pre><code>void runSegmentationModel()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-python_message","title":"function python_message","text":"<pre><code>void python_message(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#function-setcurrentsamplenumber","title":"function setCurrentSampleNumber","text":"<pre><code>void setCurrentSampleNumber(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#variable-monai_result_extension","title":"variable MONAI_RESULT_EXTENSION","text":"<pre><code>static const std::string MONAI_RESULT_EXTENSION;\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelJob.html#variable-monai_result_dtype","title":"variable MONAI_RESULT_DTYPE","text":"<pre><code>static const std::string MONAI_RESULT_DTYPE;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html","title":"monailabel::MonaiLabelTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-slots","title":"Public Slots","text":"Name void handle_error(QString msg) void onConnectServer() void onServerAddressChanged() void onModelTypeChanged(int index) void triggerUpdateView() void handle_progress(int val, QString message) void handleSampleNumberChanged() void handleClientInitialized(bool success) void handleUploadSampleCompleted() void handleSegmentationCompleted() void handleSubmitLabelCompleted()"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-signals","title":"Public Signals","text":"Name void update_view() void progress(int ) void sampleChanged()"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-functions","title":"Public Functions","text":"Name MonaiLabelTool(Preferences &amp; prefs) ~MonaiLabelTool() void set_session(QSharedPointer&lt; Session &gt; session) void set_app(ShapeWorksStudioApp * app) bool is_active() void loadParamsFromUi() void shutdown() void runSegmentationTool() void resizeEvent(QResizeEvent * event) override int getCurrentSampleNumber() void enable_actions() void activate()"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-attributes","title":"Public Attributes","text":"Name const std::string MONAI_MODE_SEGMENTATION const std::string MONAI_MODE_DEEPGROW const std::string MONAI_MODE_DEEPEDIT const std::string MONAI_SAMPLE_STRATEGY_RANDOM"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handle_error","title":"slot handle_error","text":"<pre><code>void handle_error(\n    QString msg\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-onconnectserver","title":"slot onConnectServer","text":"<pre><code>void onConnectServer()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-onserveraddresschanged","title":"slot onServerAddressChanged","text":"<pre><code>void onServerAddressChanged()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-onmodeltypechanged","title":"slot onModelTypeChanged","text":"<pre><code>void onModelTypeChanged(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-triggerupdateview","title":"slot triggerUpdateView","text":"<pre><code>void triggerUpdateView()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handle_progress","title":"slot handle_progress","text":"<pre><code>void handle_progress(\n    int val,\n    QString message\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handlesamplenumberchanged","title":"slot handleSampleNumberChanged","text":"<pre><code>void handleSampleNumberChanged()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handleclientinitialized","title":"slot handleClientInitialized","text":"<pre><code>void handleClientInitialized(\n    bool success\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handleuploadsamplecompleted","title":"slot handleUploadSampleCompleted","text":"<pre><code>void handleUploadSampleCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handlesegmentationcompleted","title":"slot handleSegmentationCompleted","text":"<pre><code>void handleSegmentationCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#slot-handlesubmitlabelcompleted","title":"slot handleSubmitLabelCompleted","text":"<pre><code>void handleSubmitLabelCompleted()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#signal-samplechanged","title":"signal sampleChanged","text":"<pre><code>void sampleChanged()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-monailabeltool","title":"function MonaiLabelTool","text":"<pre><code>MonaiLabelTool(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-monailabeltool_1","title":"function ~MonaiLabelTool","text":"<pre><code>~MonaiLabelTool()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-set_app","title":"function set_app","text":"<pre><code>void set_app(\n    ShapeWorksStudioApp * app\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-is_active","title":"function is_active","text":"<pre><code>bool is_active()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-loadparamsfromui","title":"function loadParamsFromUi","text":"<pre><code>void loadParamsFromUi()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-shutdown","title":"function shutdown","text":"<pre><code>void shutdown()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-runsegmentationtool","title":"function runSegmentationTool","text":"<pre><code>void runSegmentationTool()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void resizeEvent(\n    QResizeEvent * event\n) override\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-getcurrentsamplenumber","title":"function getCurrentSampleNumber","text":"<pre><code>int getCurrentSampleNumber()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-enable_actions","title":"function enable_actions","text":"<pre><code>void enable_actions()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#function-activate","title":"function activate","text":"<pre><code>void activate()\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#variable-monai_mode_segmentation","title":"variable MONAI_MODE_SEGMENTATION","text":"<pre><code>static const std::string MONAI_MODE_SEGMENTATION;\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#variable-monai_mode_deepgrow","title":"variable MONAI_MODE_DEEPGROW","text":"<pre><code>static const std::string MONAI_MODE_DEEPGROW;\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#variable-monai_mode_deepedit","title":"variable MONAI_MODE_DEEPEDIT","text":"<pre><code>static const std::string MONAI_MODE_DEEPEDIT;\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelTool.html#variable-monai_sample_strategy_random","title":"variable MONAI_SAMPLE_STRATEGY_RANDOM","text":"<pre><code>static const std::string MONAI_SAMPLE_STRATEGY_RANDOM;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html","title":"monailabel::MonaiLabelUtils","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#public-functions","title":"Public Functions","text":"Name bool createDir(const QString &amp; dirPath) bool copySegmentation(const QString &amp; sourcePath, const QString &amp; destinationPath) bool deleteTempFile(const QString &amp; filePath) std::string getFeatureName(QSharedPointer&lt; shapeworks::Session &gt; session) ImageType::Pointer loadNRRD(const std::string &amp; filePath) ImageType::Pointer extractOrganSegmentation(ImageType::Pointer inputImage, int label) void saveNRRD(ImageType::Pointer image, const std::string &amp; outputPath) bool isOrganPresent(ImageType::Pointer image) void processSegmentation(const std::string &amp; segmentationPath, const std::map&lt; int, std::string &gt; &amp; organLabels, const std::string &amp; outputDir, const std::string &amp; sampleId, std::vector&lt; std::string &gt; &amp; organSegmentationPaths)"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-createdir","title":"function createDir","text":"<pre><code>static bool createDir(\n    const QString &amp; dirPath\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-copysegmentation","title":"function copySegmentation","text":"<pre><code>static bool copySegmentation(\n    const QString &amp; sourcePath,\n    const QString &amp; destinationPath\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-deletetempfile","title":"function deleteTempFile","text":"<pre><code>static bool deleteTempFile(\n    const QString &amp; filePath\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-getfeaturename","title":"function getFeatureName","text":"<pre><code>static std::string getFeatureName(\n    QSharedPointer&lt; shapeworks::Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-loadnrrd","title":"function loadNRRD","text":"<pre><code>static ImageType::Pointer loadNRRD(\n    const std::string &amp; filePath\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-extractorgansegmentation","title":"function extractOrganSegmentation","text":"<pre><code>static ImageType::Pointer extractOrganSegmentation(\n    ImageType::Pointer inputImage,\n    int label\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-savenrrd","title":"function saveNRRD","text":"<pre><code>static void saveNRRD(\n    ImageType::Pointer image,\n    const std::string &amp; outputPath\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-isorganpresent","title":"function isOrganPresent","text":"<pre><code>static bool isOrganPresent(\n    ImageType::Pointer image\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1MonaiLabelUtils.html#function-processsegmentation","title":"function processSegmentation","text":"<pre><code>static void processSegmentation(\n    const std::string &amp; segmentationPath,\n    const std::map&lt; int, std::string &gt; &amp; organLabels,\n    const std::string &amp; outputDir,\n    const std::string &amp; sampleId,\n    std::vector&lt; std::string &gt; &amp; organSegmentationPaths\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classmonailabel_1_1UrlValidator.html","title":"monailabel::UrlValidator","text":"<p>Inherits from QValidator</p>"},{"location":"api/Classes/classmonailabel_1_1UrlValidator.html#public-functions","title":"Public Functions","text":"Name UrlValidator(QObject * parent =nullptr) QValidator::State validate(QString &amp; input, int &amp; pos) const override"},{"location":"api/Classes/classmonailabel_1_1UrlValidator.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classmonailabel_1_1UrlValidator.html#function-urlvalidator","title":"function UrlValidator","text":"<pre><code>inline UrlValidator(\n    QObject * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classmonailabel_1_1UrlValidator.html#function-validate","title":"function validate","text":"<pre><code>inline QValidator::State validate(\n    QString &amp; input,\n    int &amp; pos\n) const override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classobject__reader.html","title":"object_reader","text":"<p>More...</p> <p><code>#include &lt;ObjectReader.h&gt;</code></p>"},{"location":"api/Classes/classobject__reader.html#detailed-description","title":"Detailed Description","text":"<pre><code>class object_reader;\n</code></pre> <p>Reads a std::vector of c++ objects. The first integer in the file is assumed to represent the number of transforms in the file. The size of each transform is determined by the templating. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classobject__writer.html","title":"object_writer","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classquatd.html","title":"quatd","text":""},{"location":"api/Classes/classquatd.html#public-functions","title":"Public Functions","text":"Name quatd() quatd(const double angle, vec3d v) quatd(vec3d v1, vec3d v2) quatd(const double qx, const double qy, const double qz, const double qw =1.0) bool operator!=(const quatd &amp; q) quatd operator-() quatd operator+(const quatd &amp; q) const quatd operator-(const quatd &amp; q) const quatd &amp; operator+=(const quatd &amp; q) quatd &amp; operator-=(const quatd &amp; q) quatd operator*(const quatd &amp; q) const quatd &amp; operator*=(const quatd &amp; q) quatd operator*(const double a) const quatd operator/(const double a) const quatd &amp; operator/=(const double a) quatd Conjugate() const double Norm() const void MakeUnit() quatd Inverse() const double DotProduct(const quatd &amp; q) const vec3d GetVector() const double GetAngle() const void RotateVector(vec3d &amp; v) const vec3d operator*(const vec3d &amp; r) mat3d operator*(mat3d m) void RotateVectorP(double * v, double * r) const double dot(quatd &amp; q1, quatd &amp; q2) quatd lerp(quatd &amp; q1, quatd &amp; q2, double t) quatd slerp(quatd &amp; q1, quatd &amp; q2, double t)"},{"location":"api/Classes/classquatd.html#public-attributes","title":"Public Attributes","text":"Name double x double y double z double w"},{"location":"api/Classes/classquatd.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classquatd.html#function-quatd","title":"function quatd","text":"<pre><code>inline quatd()\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-quatd_1","title":"function quatd","text":"<pre><code>inline quatd(\n    const double angle,\n    vec3d v\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-quatd_2","title":"function quatd","text":"<pre><code>inline quatd(\n    vec3d v1,\n    vec3d v2\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-quatd_3","title":"function quatd","text":"<pre><code>inline quatd(\n    const double qx,\n    const double qy,\n    const double qz,\n    const double qw =1.0\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator","title":"function operator!=","text":"<pre><code>inline bool operator!=(\n    const quatd &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator-","title":"function operator-","text":"<pre><code>inline quatd operator-()\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_1","title":"function operator+","text":"<pre><code>inline quatd operator+(\n    const quatd &amp; q\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator-_1","title":"function operator-","text":"<pre><code>inline quatd operator-(\n    const quatd &amp; q\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_2","title":"function operator+=","text":"<pre><code>inline quatd &amp; operator+=(\n    const quatd &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator-_2","title":"function operator-=","text":"<pre><code>inline quatd &amp; operator-=(\n    const quatd &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_3","title":"function operator*","text":"<pre><code>inline quatd operator*(\n    const quatd &amp; q\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_4","title":"function operator*=","text":"<pre><code>inline quatd &amp; operator*=(\n    const quatd &amp; q\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_5","title":"function operator*","text":"<pre><code>inline quatd operator*(\n    const double a\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_6","title":"function operator/","text":"<pre><code>inline quatd operator/(\n    const double a\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_7","title":"function operator/=","text":"<pre><code>inline quatd &amp; operator/=(\n    const double a\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-conjugate","title":"function Conjugate","text":"<pre><code>inline quatd Conjugate() const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-norm","title":"function Norm","text":"<pre><code>inline double Norm() const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-makeunit","title":"function MakeUnit","text":"<pre><code>inline void MakeUnit()\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-inverse","title":"function Inverse","text":"<pre><code>inline quatd Inverse() const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-dotproduct","title":"function DotProduct","text":"<pre><code>inline double DotProduct(\n    const quatd &amp; q\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-getvector","title":"function GetVector","text":"<pre><code>inline vec3d GetVector() const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-getangle","title":"function GetAngle","text":"<pre><code>inline double GetAngle() const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-rotatevector","title":"function RotateVector","text":"<pre><code>inline void RotateVector(\n    vec3d &amp; v\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_8","title":"function operator*","text":"<pre><code>inline vec3d operator*(\n    const vec3d &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-operator_9","title":"function operator*","text":"<pre><code>inline mat3d operator*(\n    mat3d m\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-rotatevectorp","title":"function RotateVectorP","text":"<pre><code>inline void RotateVectorP(\n    double * v,\n    double * r\n) const\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-dot","title":"function dot","text":"<pre><code>static inline double dot(\n    quatd &amp; q1,\n    quatd &amp; q2\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-lerp","title":"function lerp","text":"<pre><code>static inline quatd lerp(\n    quatd &amp; q1,\n    quatd &amp; q2,\n    double t\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#function-slerp","title":"function slerp","text":"<pre><code>static quatd slerp(\n    quatd &amp; q1,\n    quatd &amp; q2,\n    double t\n)\n</code></pre>"},{"location":"api/Classes/classquatd.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classquatd.html#variable-x","title":"variable x","text":"<pre><code>double x;\n</code></pre>"},{"location":"api/Classes/classquatd.html#variable-y","title":"variable y","text":"<pre><code>double y;\n</code></pre>"},{"location":"api/Classes/classquatd.html#variable-z","title":"variable z","text":"<pre><code>double z;\n</code></pre>"},{"location":"api/Classes/classquatd.html#variable-w","title":"variable w","text":"<pre><code>double w;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html","title":"shapeworks::AnalysisTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-types","title":"Public Types","text":"Name enum GroupAnalysisType enum McaMode using Analyze::AlignmentType AlignmentType using itk::Point&lt; double, 3 &gt; PointType"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-slots","title":"Public Slots","text":"Name void on_tabWidget_currentChanged() void handle_analysis_options() void handle_median() void on_mean_button_clicked() void on_group1_button_clicked() void on_group2_button_clicked() void on_difference_button_clicked() void on_pcaSlider_valueChanged() void on_group_slider_valueChanged() void on_pcaModeSpinBox_valueChanged(int i) void handle_pca_animate_state_changed() void handle_pca_timer() void handle_group_animate_state_changed() void handle_group_timer() void handle_reconstruction_complete() void on_reconstructionButton_clicked() void set_feature_map(const std::string &amp; feature_map)Set the currently selected feature map. std::string get_display_feature_map() void group_changed() bool groups_active() bool pca_groups_active() QStringList get_checked_pca_groups() void on_view_open_button_toggled() void on_surface_open_button_toggled() void on_metrics_open_button_toggled() void reconstruction_method_changed() void initialize_mesh_warper() void group_p_values_clicked() void network_analysis_clicked() void handle_eval_thread_complete(ShapeEvaluationJob::JobType job_type, Eigen::VectorXd data) void handle_eval_thread_progress(ShapeEvaluationJob::JobType job_type, float progress) void handle_eval_particle_normals_progress(float progress) void handle_eval_particle_normals_complete(std::vector&lt; bool &gt; good_bad) void handle_group_pvalues_complete() void handle_alignment_changed(int new_alignment) void handle_distance_method_changed() void run_good_bad_particles() void handle_lda_progress(double progress) void handle_lda_complete() void handle_network_analysis_progress(int progress) void handle_network_analysis_complete() void show_difference_to_mean_clicked() void group_analysis_combo_changed() void change_pca_analysis_type() Eigen::VectorXd construct_mean_shape()Compute the mean shape outside of the PCA in case we are using scalars only. void handle_samples_predicted_scalar_options() void samples_table_context_menu() void samples_table_copy_to_clipboard() void mesh_warp_median_clicked() void mesh_warp_sample_changed() void mesh_warp_run_clicked() void handle_tab_changed()"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-signals","title":"Public Signals","text":"Name void update_view() void analysis_mode_changed() void pca_update() void progress(int ) void reconstruction_complete()"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-functions","title":"Public Functions","text":"Name AnalysisTool(Preferences &amp; prefs) ~AnalysisTool() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the session QSharedPointer&lt; Session &gt; get_session()Return the session. void set_app(ShapeWorksStudioApp * app)set the pointer to the application ShapeWorksStudioApp * get_app() void set_active(bool active)Set if this tool is active. bool get_active()Return if this tool is active. bool get_group_difference_mode() std::vector&lt; Shape::Point &gt; get_group_difference_vectors() std::string get_analysis_mode() void set_analysis_mode(std::string mode) void set_labels(QString which, QString value) int get_pca_mode() double get_group_ratio() double get_pca_value() bool pca_animate() McaMode get_mca_level() const int get_sample_number() bool compute_stats() void update_slider() void reset_stats() void enable_actions(bool newly_enabled =false) Particles get_mean_shape_points() ShapeHandle get_mean_shape() Particles get_shape_points(int mode, double value) Particles get_multi_level_shape_points(int mode, double value, McaMode level) ShapeHandle get_mode_shape(int mode, double value) ShapeHandle get_mca_mode_shape(int mode, double value, McaMode level) ShapeHandle get_current_shape() ParticleShapeStatistics get_stats() void load_settings() void store_settings() void shutdown() bool export_variance_graph(QString filename) void compute_shape_evaluations() GroupAnalysisType get_group_analysis_type() bool pca_scalar_only_mode() bool pca_shape_plus_scalar_mode() bool pca_shape_only_mode()"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-attributes","title":"Public Attributes","text":"Name const std::string MODE_ALL_SAMPLES_C const std::string MODE_MEAN_C const std::string MODE_PCA_C const std::string MODE_SINGLE_SAMPLE_C const std::string MODE_REGRESSION_C"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#enum-groupanalysistype","title":"enum GroupAnalysisType","text":"Enumerator Value Description None 0 Pvalues 1 NetworkAnalysis 2 LDA 3"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#enum-mcamode","title":"enum McaMode","text":"Enumerator Value Description Vanilla Within Between"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#using-alignmenttype","title":"using AlignmentType","text":"<pre><code>using shapeworks::AnalysisTool::AlignmentType =  Analyze::AlignmentType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::AnalysisTool::PointType =  itk::Point&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_tabwidget_currentchanged","title":"slot on_tabWidget_currentChanged","text":"<pre><code>void on_tabWidget_currentChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_analysis_options","title":"slot handle_analysis_options","text":"<pre><code>void handle_analysis_options()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_median","title":"slot handle_median","text":"<pre><code>void handle_median()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_mean_button_clicked","title":"slot on_mean_button_clicked","text":"<pre><code>void on_mean_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_group1_button_clicked","title":"slot on_group1_button_clicked","text":"<pre><code>void on_group1_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_group2_button_clicked","title":"slot on_group2_button_clicked","text":"<pre><code>void on_group2_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_difference_button_clicked","title":"slot on_difference_button_clicked","text":"<pre><code>void on_difference_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_pcaslider_valuechanged","title":"slot on_pcaSlider_valueChanged","text":"<pre><code>void on_pcaSlider_valueChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_group_slider_valuechanged","title":"slot on_group_slider_valueChanged","text":"<pre><code>void on_group_slider_valueChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_pcamodespinbox_valuechanged","title":"slot on_pcaModeSpinBox_valueChanged","text":"<pre><code>void on_pcaModeSpinBox_valueChanged(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_pca_animate_state_changed","title":"slot handle_pca_animate_state_changed","text":"<pre><code>void handle_pca_animate_state_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_pca_timer","title":"slot handle_pca_timer","text":"<pre><code>void handle_pca_timer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_group_animate_state_changed","title":"slot handle_group_animate_state_changed","text":"<pre><code>void handle_group_animate_state_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_group_timer","title":"slot handle_group_timer","text":"<pre><code>void handle_group_timer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_reconstruction_complete","title":"slot handle_reconstruction_complete","text":"<pre><code>void handle_reconstruction_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_reconstructionbutton_clicked","title":"slot on_reconstructionButton_clicked","text":"<pre><code>void on_reconstructionButton_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-set_feature_map","title":"slot set_feature_map","text":"<pre><code>void set_feature_map(\n    const std::string &amp; feature_map\n)\n</code></pre> <p>Set the currently selected feature map. </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-get_display_feature_map","title":"slot get_display_feature_map","text":"<pre><code>std::string get_display_feature_map()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-group_changed","title":"slot group_changed","text":"<pre><code>void group_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-groups_active","title":"slot groups_active","text":"<pre><code>bool groups_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-pca_groups_active","title":"slot pca_groups_active","text":"<pre><code>bool pca_groups_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-get_checked_pca_groups","title":"slot get_checked_pca_groups","text":"<pre><code>QStringList get_checked_pca_groups()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_view_open_button_toggled","title":"slot on_view_open_button_toggled","text":"<pre><code>void on_view_open_button_toggled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_surface_open_button_toggled","title":"slot on_surface_open_button_toggled","text":"<pre><code>void on_surface_open_button_toggled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-on_metrics_open_button_toggled","title":"slot on_metrics_open_button_toggled","text":"<pre><code>void on_metrics_open_button_toggled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-reconstruction_method_changed","title":"slot reconstruction_method_changed","text":"<pre><code>void reconstruction_method_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-initialize_mesh_warper","title":"slot initialize_mesh_warper","text":"<pre><code>void initialize_mesh_warper()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-group_p_values_clicked","title":"slot group_p_values_clicked","text":"<pre><code>void group_p_values_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-network_analysis_clicked","title":"slot network_analysis_clicked","text":"<pre><code>void network_analysis_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_eval_thread_complete","title":"slot handle_eval_thread_complete","text":"<pre><code>void handle_eval_thread_complete(\n    ShapeEvaluationJob::JobType job_type,\n    Eigen::VectorXd data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_eval_thread_progress","title":"slot handle_eval_thread_progress","text":"<pre><code>void handle_eval_thread_progress(\n    ShapeEvaluationJob::JobType job_type,\n    float progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_eval_particle_normals_progress","title":"slot handle_eval_particle_normals_progress","text":"<pre><code>void handle_eval_particle_normals_progress(\n    float progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_eval_particle_normals_complete","title":"slot handle_eval_particle_normals_complete","text":"<pre><code>void handle_eval_particle_normals_complete(\n    std::vector&lt; bool &gt; good_bad\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_group_pvalues_complete","title":"slot handle_group_pvalues_complete","text":"<pre><code>void handle_group_pvalues_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_alignment_changed","title":"slot handle_alignment_changed","text":"<pre><code>void handle_alignment_changed(\n    int new_alignment\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_distance_method_changed","title":"slot handle_distance_method_changed","text":"<pre><code>void handle_distance_method_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-run_good_bad_particles","title":"slot run_good_bad_particles","text":"<pre><code>void run_good_bad_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_lda_progress","title":"slot handle_lda_progress","text":"<pre><code>void handle_lda_progress(\n    double progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_lda_complete","title":"slot handle_lda_complete","text":"<pre><code>void handle_lda_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_network_analysis_progress","title":"slot handle_network_analysis_progress","text":"<pre><code>void handle_network_analysis_progress(\n    int progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_network_analysis_complete","title":"slot handle_network_analysis_complete","text":"<pre><code>void handle_network_analysis_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-show_difference_to_mean_clicked","title":"slot show_difference_to_mean_clicked","text":"<pre><code>void show_difference_to_mean_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-group_analysis_combo_changed","title":"slot group_analysis_combo_changed","text":"<pre><code>void group_analysis_combo_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-change_pca_analysis_type","title":"slot change_pca_analysis_type","text":"<pre><code>void change_pca_analysis_type()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-construct_mean_shape","title":"slot construct_mean_shape","text":"<pre><code>Eigen::VectorXd construct_mean_shape()\n</code></pre> <p>Compute the mean shape outside of the PCA in case we are using scalars only. </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_samples_predicted_scalar_options","title":"slot handle_samples_predicted_scalar_options","text":"<pre><code>void handle_samples_predicted_scalar_options()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-samples_table_context_menu","title":"slot samples_table_context_menu","text":"<pre><code>void samples_table_context_menu()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-samples_table_copy_to_clipboard","title":"slot samples_table_copy_to_clipboard","text":"<pre><code>void samples_table_copy_to_clipboard()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-mesh_warp_median_clicked","title":"slot mesh_warp_median_clicked","text":"<pre><code>void mesh_warp_median_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-mesh_warp_sample_changed","title":"slot mesh_warp_sample_changed","text":"<pre><code>void mesh_warp_sample_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-mesh_warp_run_clicked","title":"slot mesh_warp_run_clicked","text":"<pre><code>void mesh_warp_run_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#slot-handle_tab_changed","title":"slot handle_tab_changed","text":"<pre><code>void handle_tab_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#signal-analysis_mode_changed","title":"signal analysis_mode_changed","text":"<pre><code>void analysis_mode_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#signal-pca_update","title":"signal pca_update","text":"<pre><code>void pca_update()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#signal-reconstruction_complete","title":"signal reconstruction_complete","text":"<pre><code>void reconstruction_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-analysistool","title":"function AnalysisTool","text":"<pre><code>AnalysisTool(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-analysistool_1","title":"function ~AnalysisTool","text":"<pre><code>~AnalysisTool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the session </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_session","title":"function get_session","text":"<pre><code>QSharedPointer&lt; Session &gt; get_session()\n</code></pre> <p>Return the session. </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-set_app","title":"function set_app","text":"<pre><code>void set_app(\n    ShapeWorksStudioApp * app\n)\n</code></pre> <p>set the pointer to the application </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_app","title":"function get_app","text":"<pre><code>inline ShapeWorksStudioApp * get_app()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-set_active","title":"function set_active","text":"<pre><code>void set_active(\n    bool active\n)\n</code></pre> <p>Set if this tool is active. </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_active","title":"function get_active","text":"<pre><code>bool get_active()\n</code></pre> <p>Return if this tool is active. </p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_group_difference_mode","title":"function get_group_difference_mode","text":"<pre><code>bool get_group_difference_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_group_difference_vectors","title":"function get_group_difference_vectors","text":"<pre><code>std::vector&lt; Shape::Point &gt; get_group_difference_vectors()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_analysis_mode","title":"function get_analysis_mode","text":"<pre><code>std::string get_analysis_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-set_analysis_mode","title":"function set_analysis_mode","text":"<pre><code>void set_analysis_mode(\n    std::string mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-set_labels","title":"function set_labels","text":"<pre><code>void set_labels(\n    QString which,\n    QString value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_pca_mode","title":"function get_pca_mode","text":"<pre><code>int get_pca_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_group_ratio","title":"function get_group_ratio","text":"<pre><code>double get_group_ratio()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_pca_value","title":"function get_pca_value","text":"<pre><code>double get_pca_value()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-pca_animate","title":"function pca_animate","text":"<pre><code>bool pca_animate()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_mca_level","title":"function get_mca_level","text":"<pre><code>McaMode get_mca_level() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_sample_number","title":"function get_sample_number","text":"<pre><code>int get_sample_number()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-compute_stats","title":"function compute_stats","text":"<pre><code>bool compute_stats()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-update_slider","title":"function update_slider","text":"<pre><code>void update_slider()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-reset_stats","title":"function reset_stats","text":"<pre><code>void reset_stats()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-enable_actions","title":"function enable_actions","text":"<pre><code>void enable_actions(\n    bool newly_enabled =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_mean_shape_points","title":"function get_mean_shape_points","text":"<pre><code>Particles get_mean_shape_points()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_mean_shape","title":"function get_mean_shape","text":"<pre><code>ShapeHandle get_mean_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_shape_points","title":"function get_shape_points","text":"<pre><code>Particles get_shape_points(\n    int mode,\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_multi_level_shape_points","title":"function get_multi_level_shape_points","text":"<pre><code>Particles get_multi_level_shape_points(\n    int mode,\n    double value,\n    McaMode level\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_mode_shape","title":"function get_mode_shape","text":"<pre><code>ShapeHandle get_mode_shape(\n    int mode,\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_mca_mode_shape","title":"function get_mca_mode_shape","text":"<pre><code>ShapeHandle get_mca_mode_shape(\n    int mode,\n    double value,\n    McaMode level\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_current_shape","title":"function get_current_shape","text":"<pre><code>ShapeHandle get_current_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_stats","title":"function get_stats","text":"<pre><code>ParticleShapeStatistics get_stats()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-load_settings","title":"function load_settings","text":"<pre><code>void load_settings()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-store_settings","title":"function store_settings","text":"<pre><code>void store_settings()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-shutdown","title":"function shutdown","text":"<pre><code>void shutdown()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-export_variance_graph","title":"function export_variance_graph","text":"<pre><code>bool export_variance_graph(\n    QString filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-compute_shape_evaluations","title":"function compute_shape_evaluations","text":"<pre><code>void compute_shape_evaluations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-get_group_analysis_type","title":"function get_group_analysis_type","text":"<pre><code>GroupAnalysisType get_group_analysis_type()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-pca_scalar_only_mode","title":"function pca_scalar_only_mode","text":"<pre><code>bool pca_scalar_only_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-pca_shape_plus_scalar_mode","title":"function pca_shape_plus_scalar_mode","text":"<pre><code>bool pca_shape_plus_scalar_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#function-pca_shape_only_mode","title":"function pca_shape_only_mode","text":"<pre><code>bool pca_shape_only_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#variable-mode_all_samples_c","title":"variable MODE_ALL_SAMPLES_C","text":"<pre><code>static const std::string MODE_ALL_SAMPLES_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#variable-mode_mean_c","title":"variable MODE_MEAN_C","text":"<pre><code>static const std::string MODE_MEAN_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#variable-mode_pca_c","title":"variable MODE_PCA_C","text":"<pre><code>static const std::string MODE_PCA_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#variable-mode_single_sample_c","title":"variable MODE_SINGLE_SAMPLE_C","text":"<pre><code>static const std::string MODE_SINGLE_SAMPLE_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisTool.html#variable-mode_regression_c","title":"variable MODE_REGRESSION_C","text":"<pre><code>static const std::string MODE_REGRESSION_C;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html","title":"shapeworks::AnalysisUtils","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html#public-functions","title":"Public Functions","text":"Name ParticleSystemEvaluation get_local_particle_system(Session * session, int domain) void create_plot(JKQTPlotter * plot, Eigen::VectorXd data, QString title, QString x_label, QString y_label) void create_box_plot(JKQTPlotter * plot, Eigen::VectorXd data, QString title, QString x_label, QColor color =Qt::blue)"},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html#function-get_local_particle_system","title":"function get_local_particle_system","text":"<pre><code>static ParticleSystemEvaluation get_local_particle_system(\n    Session * session,\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html#function-create_plot","title":"function create_plot","text":"<pre><code>static void create_plot(\n    JKQTPlotter * plot,\n    Eigen::VectorXd data,\n    QString title,\n    QString x_label,\n    QString y_label\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1AnalysisUtils.html#function-create_box_plot","title":"function create_box_plot","text":"<pre><code>static void create_box_plot(\n    JKQTPlotter * plot,\n    Eigen::VectorXd data,\n    QString title,\n    QString x_label,\n    QColor color =Qt::blue\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html","title":"shapeworks::Analyze","text":"<p>High level analyze API.  More...</p> <p><code>#include &lt;Analyze.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#public-types","title":"Public Types","text":"Name enum AlignmentType"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#public-functions","title":"Public Functions","text":"Name Analyze(ProjectHandle project) void run_offline_analysis(std::string outfile, float range, float steps)Run offline analysis, saving results to outfile. ShapeList get_shapes()Return the list of shapes. int get_num_subjects()Return the number of subjects. int get_num_modes()Return the number of modes. int get_num_particles()Return the number of particles. Particles get_mean_shape_points()Return the mean shape. ShapeHandle get_mean_shape()Return the mean shape. Particles get_group_shape_particles(double ratio) ShapeHandle get_group_shape(double ratio) Particles get_shape_points(int mode, double value)Return the particles for a given mode and value. ShapeHandle get_mode_shape(int mode, double value)Return the shape for a given mode and value. bool groups_active() ShapeHandle create_shape_from_points(Particles points) Eigen::VectorXd get_subject_features(int subject, std::string feature_name) void set_group_selection(std::string group_name, std::string group1, std::string group2) ParticleSystemEvaluation get_local_particle_system(int domain)"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Analyze;\n</code></pre> <p>High level analyze API. </p> <p>The Analyze class operates on a Project. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Analyze.html#enum-alignmenttype","title":"enum AlignmentType","text":"Enumerator Value Description Global -2 Local -1"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-analyze","title":"function Analyze","text":"<pre><code>Analyze(\n    ProjectHandle project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-run_offline_analysis","title":"function run_offline_analysis","text":"<pre><code>void run_offline_analysis(\n    std::string outfile,\n    float range,\n    float steps\n)\n</code></pre> <p>Run offline analysis, saving results to outfile. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_shapes","title":"function get_shapes","text":"<pre><code>ShapeList get_shapes()\n</code></pre> <p>Return the list of shapes. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_num_subjects","title":"function get_num_subjects","text":"<pre><code>int get_num_subjects()\n</code></pre> <p>Return the number of subjects. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_num_modes","title":"function get_num_modes","text":"<pre><code>int get_num_modes()\n</code></pre> <p>Return the number of modes. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_num_particles","title":"function get_num_particles","text":"<pre><code>int get_num_particles()\n</code></pre> <p>Return the number of particles. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_mean_shape_points","title":"function get_mean_shape_points","text":"<pre><code>Particles get_mean_shape_points()\n</code></pre> <p>Return the mean shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_mean_shape","title":"function get_mean_shape","text":"<pre><code>ShapeHandle get_mean_shape()\n</code></pre> <p>Return the mean shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_group_shape_particles","title":"function get_group_shape_particles","text":"<pre><code>Particles get_group_shape_particles(\n    double ratio\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_group_shape","title":"function get_group_shape","text":"<pre><code>ShapeHandle get_group_shape(\n    double ratio\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_shape_points","title":"function get_shape_points","text":"<pre><code>Particles get_shape_points(\n    int mode,\n    double value\n)\n</code></pre> <p>Return the particles for a given mode and value. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_mode_shape","title":"function get_mode_shape","text":"<pre><code>ShapeHandle get_mode_shape(\n    int mode,\n    double value\n)\n</code></pre> <p>Return the shape for a given mode and value. </p>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-groups_active","title":"function groups_active","text":"<pre><code>inline bool groups_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-create_shape_from_points","title":"function create_shape_from_points","text":"<pre><code>ShapeHandle create_shape_from_points(\n    Particles points\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_subject_features","title":"function get_subject_features","text":"<pre><code>Eigen::VectorXd get_subject_features(\n    int subject,\n    std::string feature_name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-set_group_selection","title":"function set_group_selection","text":"<pre><code>void set_group_selection(\n    std::string group_name,\n    std::string group1,\n    std::string group2\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Analyze.html#function-get_local_particle_system","title":"function get_local_particle_system","text":"<pre><code>ParticleSystemEvaluation get_local_particle_system(\n    int domain\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1AnalyzeCommandGroup.html","title":"shapeworks::AnalyzeCommandGroup","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1AnalyzeCommandGroup.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1AnalyzeCommandGroup.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1AnalyzeCommandGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1AnalyzeCommandGroup.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html","title":"shapeworks::ColorMap","text":""},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#public-functions","title":"Public Functions","text":"Name void construct_lookup_table(vtkSmartPointer&lt; vtkLookupTable &gt; lut) void set_discrete_mode(bool discrete_mode) void set_reverse_mode(bool reverse_mode) vtkColor3ub convert(QColor color)"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#public-attributes","title":"Public Attributes","text":"Name QString name_ vtkSmartPointer&lt; vtkColorSeries &gt; color_series_"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#function-construct_lookup_table","title":"function construct_lookup_table","text":"<pre><code>void construct_lookup_table(\n    vtkSmartPointer&lt; vtkLookupTable &gt; lut\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#function-set_discrete_mode","title":"function set_discrete_mode","text":"<pre><code>inline void set_discrete_mode(\n    bool discrete_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#function-set_reverse_mode","title":"function set_reverse_mode","text":"<pre><code>inline void set_reverse_mode(\n    bool reverse_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#function-convert","title":"function convert","text":"<pre><code>static vtkColor3ub convert(\n    QColor color\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#variable-name_","title":"variable name_","text":"<pre><code>QString name_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMap.html#variable-color_series_","title":"variable color_series_","text":"<pre><code>vtkSmartPointer&lt; vtkColorSeries &gt; color_series_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html","title":"shapeworks::ColorMaps","text":"<p>Inherits from std::vector&lt; ColorMap &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html#public-functions","title":"Public Functions","text":"Name ColorMaps() vtkSmartPointer&lt; vtkColorSeries &gt; get_color_series(int index) ColorMap get_color_map(int index)"},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html#function-colormaps","title":"function ColorMaps","text":"<pre><code>ColorMaps()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html#function-get_color_series","title":"function get_color_series","text":"<pre><code>inline vtkSmartPointer&lt; vtkColorSeries &gt; get_color_series(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ColorMaps.html#function-get_color_map","title":"function get_color_map","text":"<pre><code>inline ColorMap get_color_map(\n    int index\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Command.html","title":"shapeworks::Command","text":"<p>Inherited by shapeworks::AnalyzeCommandGroup, shapeworks::DeepSSMCommandGroup, shapeworks::GroomCommandGroup, shapeworks::ImageCommand, shapeworks::MeshCommand, shapeworks::OptimizeCommandGroup, shapeworks::ParticleSystemCommand, shapeworks::ProjectCommandGroup, shapeworks::ShapeworksCommand</p>"},{"location":"api/Classes/classshapeworks_1_1Command.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value"},{"location":"api/Classes/classshapeworks_1_1Command.html#protected-functions","title":"Protected Functions","text":"Name virtual void buildParser()"},{"location":"api/Classes/classshapeworks_1_1Command.html#protected-attributes","title":"Protected Attributes","text":"Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1Command.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Command.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type()\n</code></pre> <p>Reimplemented by: shapeworks::ImageCommand::type, shapeworks::MeshCommand::type, shapeworks::OptimizeCommandGroup::type, shapeworks::GroomCommandGroup::type, shapeworks::AnalyzeCommandGroup::type, shapeworks::ProjectCommandGroup::type, shapeworks::ParticleSystemCommand::type, shapeworks::DeepSSMCommandGroup::type, shapeworks::ShapeworksCommand::type</p>"},{"location":"api/Classes/classshapeworks_1_1Command.html#function-name","title":"function name","text":"<pre><code>inline const std::string name() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Command.html#function-usage","title":"function usage","text":"<pre><code>inline const std::string usage() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Command.html#function-desc","title":"function desc","text":"<pre><code>inline const std::string desc() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Command.html#function-parse_args","title":"function parse_args","text":"<pre><code>std::vector&lt; std::string &gt; parse_args(\n    const std::vector&lt; std::string &gt; &amp; arguments\n)\n</code></pre> <p>parses the arguments for this command, saving them in the parser and returning the leftovers </p>"},{"location":"api/Classes/classshapeworks_1_1Command.html#function-run","title":"function run","text":"<pre><code>int run(\n    SharedCommandData &amp; sharedData\n)\n</code></pre> <p>calls execute for this command using the parsed args, returning system exit value </p>"},{"location":"api/Classes/classshapeworks_1_1Command.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Command.html#function-buildparser","title":"function buildParser","text":"<pre><code>virtual void buildParser()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Command.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Command.html#variable-parser","title":"variable parser","text":"<pre><code>optparse::OptionParser parser;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html","title":"shapeworks::CompareSettings","text":""},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#public-functions","title":"Public Functions","text":"Name DisplayMode get_display_mode() bool get_mean_shape_checked()"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#public-attributes","title":"Public Attributes","text":"Name bool compare_enabled_ bool surface_distance_mode_ bool original_checked_ bool groomed_checked_ bool reconstructed_checked_ bool mean_shape_checked_ float opacity_"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#function-get_display_mode","title":"function get_display_mode","text":"<pre><code>inline DisplayMode get_display_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#function-get_mean_shape_checked","title":"function get_mean_shape_checked","text":"<pre><code>inline bool get_mean_shape_checked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-compare_enabled_","title":"variable compare_enabled_","text":"<pre><code>bool compare_enabled_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-surface_distance_mode_","title":"variable surface_distance_mode_","text":"<pre><code>bool surface_distance_mode_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-original_checked_","title":"variable original_checked_","text":"<pre><code>bool original_checked_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-groomed_checked_","title":"variable groomed_checked_","text":"<pre><code>bool groomed_checked_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-reconstructed_checked_","title":"variable reconstructed_checked_","text":"<pre><code>bool reconstructed_checked_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-mean_shape_checked_","title":"variable mean_shape_checked_","text":"<pre><code>bool mean_shape_checked_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareSettings.html#variable-opacity_","title":"variable opacity_","text":"<pre><code>float opacity_ = 1.0;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html","title":"shapeworks::CompareWidget","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#public-signals","title":"Public Signals","text":"Name void settings_changed()"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#public-functions","title":"Public Functions","text":"Name CompareWidget(QWidget * parent =nullptr) ~CompareWidget() CompareSettings get_settings() void set_available(DisplayMode mode, bool available) void set_mean_shape_available(bool available) bool check_any_available()"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#signal-settings_changed","title":"signal settings_changed","text":"<pre><code>void settings_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-comparewidget","title":"function CompareWidget","text":"<pre><code>explicit CompareWidget(\n    QWidget * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-comparewidget_1","title":"function ~CompareWidget","text":"<pre><code>~CompareWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-get_settings","title":"function get_settings","text":"<pre><code>CompareSettings get_settings()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-set_available","title":"function set_available","text":"<pre><code>void set_available(\n    DisplayMode mode,\n    bool available\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-set_mean_shape_available","title":"function set_mean_shape_available","text":"<pre><code>void set_mean_shape_available(\n    bool available\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CompareWidget.html#function-check_any_available","title":"function check_any_available","text":"<pre><code>bool check_any_available()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html","title":"shapeworks::Constraint","text":"<p>More...</p> <p><code>#include &lt;Constraint.h&gt;</code></p> <p>Inherited by shapeworks::FreeFormConstraint, shapeworks::PlaneConstraint</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#public-functions","title":"Public Functions","text":"Name bool isViolated(const vnl_vector&lt; double &gt; &amp; pt) constReturns if pt in vnl_vector format is violated by the constraint. virtual bool isViolated(const Eigen::Vector3d &amp; pt) const =0Returns if pt in Eigen format is violated by the constraint. virtual void print() const =0Prints the constraint neatly. void setMus(std::vector&lt; double &gt; inmu)Initializes mu. std::vector&lt; double &gt; getMus()Gets mu. virtual Eigen::Vector3d constraintGradient(const Eigen::Vector3d &amp; pt) const =0Returns the gradient of the constraint. virtual double constraintEval(const Eigen::Vector3d &amp; pt) const =0Returns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. void updateMu(const Eigen::Vector3d &amp; pt, double C, size_t index)Updates the value of mu according to the augmented lagrangian update. Eigen::Vector3d lagragianGradient(const Eigen::Vector3d &amp; pt, double C, size_t index) constComputes the lagrangian gradient based on lagrangian inequality equations. NOTE: Not actually lagrangian. We are using quadratic penalty and not lagrangian because it works better."},{"location":"api/Classes/classshapeworks_1_1Constraint.html#protected-functions","title":"Protected Functions","text":"Name int sgn(double val)Returns the sign of the double."},{"location":"api/Classes/classshapeworks_1_1Constraint.html#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; double &gt; mus_ Mu is the lagrangian momentum term."},{"location":"api/Classes/classshapeworks_1_1Constraint.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Constraint;\n</code></pre> <p>This class is the general constraint class. Each instance represents a single constraint, either cutting-plane, sphere or free-form. They all inherit from this class. This class containts all the infrastructure to handle gradients and evaluations, which is shared among all constraint types. NOTE: Not actually using the augmented lagrangian. We are using quadratic penalty and not lagrangian because it works better. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-isviolated","title":"function isViolated","text":"<pre><code>inline bool isViolated(\n    const vnl_vector&lt; double &gt; &amp; pt\n) const\n</code></pre> <p>Returns if pt in vnl_vector format is violated by the constraint. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-isviolated_1","title":"function isViolated","text":"<pre><code>virtual bool isViolated(\n    const Eigen::Vector3d &amp; pt\n) const =0\n</code></pre> <p>Returns if pt in Eigen format is violated by the constraint. </p> <p>Reimplemented by: shapeworks::FreeFormConstraint::isViolated, shapeworks::PlaneConstraint::isViolated</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-print","title":"function print","text":"<pre><code>virtual void print() const =0\n</code></pre> <p>Prints the constraint neatly. </p> <p>Reimplemented by: shapeworks::FreeFormConstraint::print, shapeworks::PlaneConstraint::print</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-setmus","title":"function setMus","text":"<pre><code>inline void setMus(\n    std::vector&lt; double &gt; inmu\n)\n</code></pre> <p>Initializes mu. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-getmus","title":"function getMus","text":"<pre><code>inline std::vector&lt; double &gt; getMus()\n</code></pre> <p>Gets mu. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-constraintgradient","title":"function constraintGradient","text":"<pre><code>virtual Eigen::Vector3d constraintGradient(\n    const Eigen::Vector3d &amp; pt\n) const =0\n</code></pre> <p>Returns the gradient of the constraint. </p> <p>Reimplemented by: shapeworks::FreeFormConstraint::constraintGradient, shapeworks::PlaneConstraint::constraintGradient</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-constrainteval","title":"function constraintEval","text":"<pre><code>virtual double constraintEval(\n    const Eigen::Vector3d &amp; pt\n) const =0\n</code></pre> <p>Returns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. </p> <p>Reimplemented by: shapeworks::FreeFormConstraint::constraintEval, shapeworks::PlaneConstraint::constraintEval</p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-updatemu","title":"function updateMu","text":"<pre><code>void updateMu(\n    const Eigen::Vector3d &amp; pt,\n    double C,\n    size_t index\n)\n</code></pre> <p>Updates the value of mu according to the augmented lagrangian update. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-lagragiangradient","title":"function lagragianGradient","text":"<pre><code>Eigen::Vector3d lagragianGradient(\n    const Eigen::Vector3d &amp; pt,\n    double C,\n    size_t index\n) const\n</code></pre> <p>Computes the lagrangian gradient based on lagrangian inequality equations. NOTE: Not actually lagrangian. We are using quadratic penalty and not lagrangian because it works better. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Constraint.html#function-sgn","title":"function sgn","text":"<pre><code>inline int sgn(\n    double val\n)\n</code></pre> <p>Returns the sign of the double. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraint.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Constraint.html#variable-mus_","title":"variable mus_","text":"<pre><code>std::vector&lt; double &gt; mus_;\n</code></pre> <p>Mu is the lagrangian momentum term. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html","title":"shapeworks::Constraints","text":"<p>More...</p> <p><code>#include &lt;Constraints.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#public-types","title":"Public Types","text":"Name using itk::Point&lt; double, 3 &gt; Point3"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#public-functions","title":"Public Functions","text":"Name Constraints()Constraints are inactive when initialized. ~Constraints() void addPlane(const vnl_vector&lt; double &gt; &amp; a, const vnl_vector&lt; double &gt; &amp; b, const vnl_vector&lt; double &gt; &amp; c)Adds a cutting-plane boundary constraint. Constraints are used to isolate areas of interest on shape surfaces. void addFreeFormConstraint(std::shared_ptr&lt; shapeworks::Mesh &gt; mesh)Adds the free-form boundary constraint, or FFC. Constraints are used to isolate areas of interest on shape surfaces. bool transformConstraints(const vnl_matrix_fixed&lt; double, 4, 4 &gt; &amp; transform)Applies transformations to free-form constraints (FFCs) bool transformPlanes(const vnl_matrix_fixed&lt; double, 4, 4 &gt; &amp; transform)Applies transformations to cutting-plane constraints. std::vector&lt; PlaneConstraint &gt; &amp; getPlaneConstraints()Returns the vector that constains all plane constraints, of type PlaneConstraint. See class PlaneConstraint for more info. FreeFormConstraint &amp; getFreeformConstraint()Returns the free form constraint, of type FreeFormConstraint. See class FreeFormConstraint for more info. bool isAnyViolated(const Point3 &amp; pos)Returns true if any constraint is violated by point pos. void printAll()Prints all constraints in a neat format. Make sure to disable multithreading if printing within to optimization to avoid jumbled output. std::string violationReport(const Point3 &amp; pos, size_t index)Prints out a comprehensive violation report with each constraint that is violated and the magnitude of such violation by point pos. Index can be 0 if one does not have the index. std::vector&lt; std::vector&lt; double &gt; &gt; violationReportData(const Point3 &amp; pos)Returns the distance to every cosntraint with [0] plane, [1] sphere, and [2] FFC. vnl_vector_fixed&lt; double, 3 &gt; constraintsLagrangianGradient(const Point3 &amp; pos, const Point3 &amp; prepos, double C, size_t index)Returns the constraint gradient. prepos is the current particle, pos is the particle with an optimization update applied, C can be 1, and index is the index of the particle. void InitializeLagrangianParameters(std::vector&lt; double &gt; mus)Initializes lagrangian parameter mus. void UpdateMus(const Point3 &amp; pos, double C, size_t index)Updates mus, the momentum variable of the augmented lagrangian. bool GetActive()Gets the variable active, which determines whether constraints are being used. void SetActive(bool ac)Sets the variable active, which determines whether constraints are being used. void read(std::string filename)Reads in a constraint json file named filename. void write(std::string filename)Writes out a constraint json file named filename. bool hasConstraints() void clipMesh(Mesh &amp; mesh)Clips the mesh that has been passed into it by the constraints stored in this object."},{"location":"api/Classes/classshapeworks_1_1Constraints.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Constraints;\n</code></pre> <p>This class contains the set of boundary constraints that are appleid to the shapes in the dataset. They are used to isolate areas of interest on shape surfaces/volumes. These boundary constraints currently take the form of cutting planes, cutting spheres (deprecated), or free-form constraints (FFCs). Do not confuse these with the ApplyConstraints function found in the \"domain\" code, they refer to the action of snapping to the surface and do not serve to isolate areas of interest.</p> <p>Please check out Libs/Optimize/Constraints/Constraints for a constraints roadmap </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Constraints.html#using-point3","title":"using Point3","text":"<pre><code>using shapeworks::Constraints::Point3 =  itk::Point&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-constraints","title":"function Constraints","text":"<pre><code>inline Constraints()\n</code></pre> <p>Constraints are inactive when initialized. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-constraints_1","title":"function ~Constraints","text":"<pre><code>inline ~Constraints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-addplane","title":"function addPlane","text":"<pre><code>void addPlane(\n    const vnl_vector&lt; double &gt; &amp; a,\n    const vnl_vector&lt; double &gt; &amp; b,\n    const vnl_vector&lt; double &gt; &amp; c\n)\n</code></pre> <p>Adds a cutting-plane boundary constraint. Constraints are used to isolate areas of interest on shape surfaces. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-addfreeformconstraint","title":"function addFreeFormConstraint","text":"<pre><code>void addFreeFormConstraint(\n    std::shared_ptr&lt; shapeworks::Mesh &gt; mesh\n)\n</code></pre> <p>Adds the free-form boundary constraint, or FFC. Constraints are used to isolate areas of interest on shape surfaces. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-transformconstraints","title":"function transformConstraints","text":"<pre><code>bool transformConstraints(\n    const vnl_matrix_fixed&lt; double, 4, 4 &gt; &amp; transform\n)\n</code></pre> <p>Applies transformations to free-form constraints (FFCs) </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-transformplanes","title":"function transformPlanes","text":"<pre><code>bool transformPlanes(\n    const vnl_matrix_fixed&lt; double, 4, 4 &gt; &amp; transform\n)\n</code></pre> <p>Applies transformations to cutting-plane constraints. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-getplaneconstraints","title":"function getPlaneConstraints","text":"<pre><code>inline std::vector&lt; PlaneConstraint &gt; &amp; getPlaneConstraints()\n</code></pre> <p>Returns the vector that constains all plane constraints, of type PlaneConstraint. See class PlaneConstraint for more info. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-getfreeformconstraint","title":"function getFreeformConstraint","text":"<pre><code>FreeFormConstraint &amp; getFreeformConstraint()\n</code></pre> <p>Returns the free form constraint, of type FreeFormConstraint. See class FreeFormConstraint for more info. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-isanyviolated","title":"function isAnyViolated","text":"<pre><code>bool isAnyViolated(\n    const Point3 &amp; pos\n)\n</code></pre> <p>Returns true if any constraint is violated by point pos. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-printall","title":"function printAll","text":"<pre><code>void printAll()\n</code></pre> <p>Prints all constraints in a neat format. Make sure to disable multithreading if printing within to optimization to avoid jumbled output. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-violationreport","title":"function violationReport","text":"<pre><code>std::string violationReport(\n    const Point3 &amp; pos,\n    size_t index\n)\n</code></pre> <p>Prints out a comprehensive violation report with each constraint that is violated and the magnitude of such violation by point pos. Index can be 0 if one does not have the index. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-violationreportdata","title":"function violationReportData","text":"<pre><code>std::vector&lt; std::vector&lt; double &gt; &gt; violationReportData(\n    const Point3 &amp; pos\n)\n</code></pre> <p>Returns the distance to every cosntraint with [0] plane, [1] sphere, and [2] FFC. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-constraintslagrangiangradient","title":"function constraintsLagrangianGradient","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; constraintsLagrangianGradient(\n    const Point3 &amp; pos,\n    const Point3 &amp; prepos,\n    double C,\n    size_t index\n)\n</code></pre> <p>Returns the constraint gradient. prepos is the current particle, pos is the particle with an optimization update applied, C can be 1, and index is the index of the particle. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-initializelagrangianparameters","title":"function InitializeLagrangianParameters","text":"<pre><code>void InitializeLagrangianParameters(\n    std::vector&lt; double &gt; mus\n)\n</code></pre> <p>Initializes lagrangian parameter mus. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-updatemus","title":"function UpdateMus","text":"<pre><code>void UpdateMus(\n    const Point3 &amp; pos,\n    double C,\n    size_t index\n)\n</code></pre> <p>Updates mus, the momentum variable of the augmented lagrangian. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-getactive","title":"function GetActive","text":"<pre><code>inline bool GetActive()\n</code></pre> <p>Gets the variable active, which determines whether constraints are being used. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-setactive","title":"function SetActive","text":"<pre><code>inline void SetActive(\n    bool ac\n)\n</code></pre> <p>Sets the variable active, which determines whether constraints are being used. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-read","title":"function read","text":"<pre><code>void read(\n    std::string filename\n)\n</code></pre> <p>Reads in a constraint json file named filename. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-write","title":"function write","text":"<pre><code>void write(\n    std::string filename\n)\n</code></pre> <p>Writes out a constraint json file named filename. </p>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-hasconstraints","title":"function hasConstraints","text":"<pre><code>bool hasConstraints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Constraints.html#function-clipmesh","title":"function clipMesh","text":"<pre><code>void clipMesh(\n    Mesh &amp; mesh\n)\n</code></pre> <p>Clips the mesh that has been passed into it by the constraints stored in this object. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html","title":"shapeworks::ContourDomain","text":"<p>Inherits from shapeworks::ParticleDomain</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; ContourDomain &gt; Pointer"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#public-functions","title":"Public Functions","text":"Name ContourDomain() virtual ~ContourDomain() void SetPolyLine(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) virtual DomainType GetDomainType() const override virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const override virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const override virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const override virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const override virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const override virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const override virtual PointType GetValidLocationNear(PointType p) const override virtual double GetMaxDiameter() const override virtual void UpdateZeroCrossingPoint() override virtual double GetCurvature(const PointType &amp; p, int idx) const override virtual double GetSurfaceMeanCurvature() const override virtual double GetSurfaceStdDevCurvature() const override virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const override virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const override virtual const PointType &amp; GetLowerBound() const override virtual const PointType &amp; GetUpperBound() const override virtual PointType GetZeroCrossingPoint() const override virtual double GetSurfaceArea() const override virtual void DeleteImages() override virtual void DeletePartialDerivativeImages() override virtual void InvalidateParticlePosition(int idx) const override virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const override"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ParticleDomain</p> Name using itk::Point&lt; double, 3 &gt; PointType using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const bool IsDomainFixed() const std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ContourDomain::Pointer =  std::shared_ptr&lt;ContourDomain&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-contourdomain","title":"function ContourDomain","text":"<pre><code>inline explicit ContourDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-contourdomain_1","title":"function ~ContourDomain","text":"<pre><code>inline virtual ~ContourDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-setpolyline","title":"function SetPolyLine","text":"<pre><code>void SetPolyLine(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getdomaintype","title":"function GetDomainType","text":"<pre><code>inline virtual DomainType GetDomainType() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetDomainType</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-applyconstraints","title":"function ApplyConstraints","text":"<pre><code>virtual bool ApplyConstraints(\n    PointType &amp; p,\n    int idx,\n    bool dbg =false\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::ApplyConstraints</p> <p>Apply any constraints to the given point location. This should force the point to a position on the surface that satisfies all constraints. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-updateparticleposition","title":"function UpdateParticlePosition","text":"<pre><code>virtual PointType UpdateParticlePosition(\n    const PointType &amp; point,\n    int idx,\n    VectorDoubleType &amp; update\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::UpdateParticlePosition</p> <p>Applies the update to the point and returns the new point position. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-projectvectortosurfacetangent","title":"function ProjectVectorToSurfaceTangent","text":"<pre><code>virtual VectorDoubleType ProjectVectorToSurfaceTangent(\n    VectorDoubleType &amp; gradE,\n    const PointType &amp; pos,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::ProjectVectorToSurfaceTangent</p> <p>Projects the vector to the surface tangent at the point. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-samplenormalatpoint","title":"function SampleNormalAtPoint","text":"<pre><code>inline virtual VectorFloatType SampleNormalAtPoint(\n    const PointType &amp; point,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleNormalAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-samplegradientatpoint","title":"function SampleGradientAtPoint","text":"<pre><code>inline virtual VectorFloatType SampleGradientAtPoint(\n    const PointType &amp; point,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradientAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-samplegradnatpoint","title":"function SampleGradNAtPoint","text":"<pre><code>inline virtual GradNType SampleGradNAtPoint(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradNAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getvalidlocationnear","title":"function GetValidLocationNear","text":"<pre><code>inline virtual PointType GetValidLocationNear(\n    PointType p\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetValidLocationNear</p> <p>GetValidLocation returns a PointType location on the surface. Used for placing the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getmaxdiameter","title":"function GetMaxDiameter","text":"<pre><code>inline virtual double GetMaxDiameter() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetMaxDiameter</p> <p>GetMaxDiameter returns the maximum diameter of the domain and is used for computing sigma </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-updatezerocrossingpoint","title":"function UpdateZeroCrossingPoint","text":"<pre><code>inline virtual void UpdateZeroCrossingPoint() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::UpdateZeroCrossingPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getcurvature","title":"function GetCurvature","text":"<pre><code>inline virtual double GetCurvature(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getsurfacemeancurvature","title":"function GetSurfaceMeanCurvature","text":"<pre><code>inline virtual double GetSurfaceMeanCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceMeanCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getsurfacestddevcurvature","title":"function GetSurfaceStdDevCurvature","text":"<pre><code>inline virtual double GetSurfaceStdDevCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceStdDevCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-distance","title":"function Distance","text":"<pre><code>virtual double Distance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b,\n    VectorDoubleType * out_grad =nullptr\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::Distance</p> <p>Distance between locations is used for computing energy and neighborhoods. Optionally return the gradient of the distance </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-squareddistance","title":"function SquaredDistance","text":"<pre><code>virtual double SquaredDistance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SquaredDistance</p> <p>Squared Distance between locations is used for computing sigma. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getlowerbound","title":"function GetLowerBound","text":"<pre><code>inline virtual const PointType &amp; GetLowerBound() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetLowerBound</p> <p>Gets the minimum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getupperbound","title":"function GetUpperBound","text":"<pre><code>inline virtual const PointType &amp; GetUpperBound() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetUpperBound</p> <p>Gets the maximum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getzerocrossingpoint","title":"function GetZeroCrossingPoint","text":"<pre><code>inline virtual PointType GetZeroCrossingPoint() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetZeroCrossingPoint</p> <p>Get any valid point on the domain. This is used to place the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getsurfacearea","title":"function GetSurfaceArea","text":"<pre><code>inline virtual double GetSurfaceArea() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceArea</p> <p>Use for neighborhood radius. </p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>inline virtual void DeleteImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeleteImages</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-deletepartialderivativeimages","title":"function DeletePartialDerivativeImages","text":"<pre><code>inline virtual void DeletePartialDerivativeImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeletePartialDerivativeImages</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-invalidateparticleposition","title":"function InvalidateParticlePosition","text":"<pre><code>virtual void InvalidateParticlePosition(\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::InvalidateParticlePosition</p>"},{"location":"api/Classes/classshapeworks_1_1ContourDomain.html#function-getpositionaftersplit","title":"function GetPositionAfterSplit","text":"<pre><code>virtual PointType GetPositionAfterSplit(\n    const PointType &amp; pt,\n    const VectorDoubleType &amp; local_direction,\n    const VectorDoubleType &amp; global_direction,\n    double epsilon\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetPositionAfterSplit</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html","title":"shapeworks::CorrespondenceFunction","text":"<p>Correspondence term. </p> <p><code>#include &lt;CorrespondenceFunction.h&gt;</code></p> <p>Inherits from shapeworks::VectorFunction</p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-types","title":"Public Types","text":"Name typedef shapeworks::ShapeMatrix ShapeDataType typedef shapeworks::ShapeGradientMatrix ShapeGradientType typedef ShapeDataType::DataType DataType typedef VectorFunction::VectorType VectorType typedef ParticleSystem::PointType PointType typedef vnl_vector&lt; DataType &gt; vnl_vector_type typedef vnl_matrix&lt; DataType &gt; vnl_matrix_type"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-functions","title":"Public Functions","text":"Name std::shared_ptr&lt; CorrespondenceFunction &gt; New()Factory method for creating instances. void SetShapeData(ShapeDataType * s)Access the shape matrix. ShapeDataType * GetShapeData() const ShapeDataType * GetShapeData() const void SetShapeGradient(ShapeGradientType * s)Access the shape gradient matrix. ShapeGradientType * GetShapeGradient() const ShapeGradientType * GetShapeGradient() const virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; , double &amp; ) const virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep) const virtual double energy(unsigned int a, unsigned int b, const ParticleSystem * c) const virtual void before_iteration() virtual void after_iteration() void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) void SetMinimumVariance(double d) double GetMinimumVariance() const bool GetHoldMinimumVariance() const void SetHoldMinimumVariance(bool b) void SetRecomputeCovarianceInterval(int i) int GetRecomputeCovarianceInterval() const void SetAttributeScales(const std::vector&lt; double &gt; &amp; s) void SetDomainsPerShape(int i) int GetDomainsPerShape() const void SetAttributesPerDomain(const std::vector&lt; int &gt; &amp; i) void UseMeanenergy() void UseEntropy() void SetXYZ(int i, bool val) void SetNormals(int i, bool val) bool CheckForNans(vnl_matrix_type mat) virtual std::shared_ptr&lt; VectorFunction &gt; clone() override CorrespondenceFunction() ~CorrespondenceFunction() override =default"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#protected-functions","title":"Protected Functions","text":"Name CorrespondenceFunction(const CorrespondenceFunction &amp; ) =delete CorrespondenceFunction &amp; operator=(const CorrespondenceFunction &amp; ) =delete virtual void ComputeUpdates(const ParticleSystem * c)"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static int VDimension constexpr static unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#protected-attributes","title":"Protected Attributes","text":"Name ShapeDataType::Pointer m_ShapeData ShapeGradientType::Pointer m_ShapeGradient std::shared_ptr&lt; vnl_matrix_type &gt; m_PointsUpdate double m_MinimumVariance double m_MinimumEigenValue bool m_HoldMinimumVariance int m_RecomputeCovarianceInterval double m_MinimumVarianceDecayConstant int m_Counter std::vector&lt; double &gt; m_AttributeScales int m_DomainsPerShape std::vector&lt; int &gt; m_AttributesPerDomain double m_CurrentEnergy bool m_UseMeanEnergy std::vector&lt; bool &gt; m_UseXYZ std::vector&lt; bool &gt; m_UseNormals std::shared_ptr&lt; vnl_matrix_type &gt; m_points_mean std::shared_ptr&lt; Eigen::MatrixXd &gt; m_InverseCovMatrix int num_dims int num_samples"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::VectorFunction</p> Name virtual void reset_buffers()May be called by the solver class. virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) virtual void set_particle_system(ParticleSystem * p)Some subclasses may require a pointer to the particle system and its domain number. virtual ParticleSystem * get_particle_system() const virtual void set_domain_number(unsigned int i) virtual int get_domain_number() const virtual double get_relative_energy_scaling() const virtual void set_relative_energy_scaling(double r) virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes. <p>Protected Functions inherited from shapeworks::VectorFunction</p> Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete <p>Protected Attributes inherited from shapeworks::VectorFunction</p> Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-shapedatatype","title":"typedef ShapeDataType","text":"<pre><code>typedef shapeworks::ShapeMatrix shapeworks::CorrespondenceFunction::ShapeDataType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-shapegradienttype","title":"typedef ShapeGradientType","text":"<pre><code>typedef shapeworks::ShapeGradientMatrix shapeworks::CorrespondenceFunction::ShapeGradientType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef ShapeDataType::DataType shapeworks::CorrespondenceFunction::DataType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>typedef VectorFunction::VectorType shapeworks::CorrespondenceFunction::VectorType;\n</code></pre> <p>Vector &amp; Point types. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystem::PointType shapeworks::CorrespondenceFunction::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-vnl_vector_type","title":"typedef vnl_vector_type","text":"<pre><code>typedef vnl_vector&lt;DataType&gt; shapeworks::CorrespondenceFunction::vnl_vector_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#typedef-vnl_matrix_type","title":"typedef vnl_matrix_type","text":"<pre><code>typedef vnl_matrix&lt;DataType&gt; shapeworks::CorrespondenceFunction::vnl_matrix_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-new","title":"function New","text":"<pre><code>static inline std::shared_ptr&lt; CorrespondenceFunction &gt; New()\n</code></pre> <p>Factory method for creating instances. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setshapedata","title":"function SetShapeData","text":"<pre><code>inline void SetShapeData(\n    ShapeDataType * s\n)\n</code></pre> <p>Access the shape matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getshapedata","title":"function GetShapeData","text":"<pre><code>inline ShapeDataType * GetShapeData()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getshapedata_1","title":"function GetShapeData","text":"<pre><code>inline const ShapeDataType * GetShapeData() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setshapegradient","title":"function SetShapeGradient","text":"<pre><code>inline void SetShapeGradient(\n    ShapeGradientType * s\n)\n</code></pre> <p>Access the shape gradient matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getshapegradient","title":"function GetShapeGradient","text":"<pre><code>inline ShapeGradientType * GetShapeGradient()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getshapegradient_1","title":"function GetShapeGradient","text":"<pre><code>inline const ShapeGradientType * GetShapeGradient() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; ,\n    double &amp; \n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-energy","title":"function energy","text":"<pre><code>inline virtual double energy(\n    unsigned int a,\n    unsigned int b,\n    const ParticleSystem * c\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::before_iteration</p> <p>Called before each iteration of a solver. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration()\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::after_iteration</p> <p>Called after each iteration of the solver. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setminimumvariancedecay","title":"function SetMinimumVarianceDecay","text":"<pre><code>inline void SetMinimumVarianceDecay(\n    double initial_value,\n    double final_value,\n    double time_period\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setminimumvariance","title":"function SetMinimumVariance","text":"<pre><code>inline void SetMinimumVariance(\n    double d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getminimumvariance","title":"function GetMinimumVariance","text":"<pre><code>inline double GetMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getholdminimumvariance","title":"function GetHoldMinimumVariance","text":"<pre><code>inline bool GetHoldMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setholdminimumvariance","title":"function SetHoldMinimumVariance","text":"<pre><code>inline void SetHoldMinimumVariance(\n    bool b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setrecomputecovarianceinterval","title":"function SetRecomputeCovarianceInterval","text":"<pre><code>inline void SetRecomputeCovarianceInterval(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getrecomputecovarianceinterval","title":"function GetRecomputeCovarianceInterval","text":"<pre><code>inline int GetRecomputeCovarianceInterval() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setattributescales","title":"function SetAttributeScales","text":"<pre><code>inline void SetAttributeScales(\n    const std::vector&lt; double &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. </p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setattributesperdomain","title":"function SetAttributesPerDomain","text":"<pre><code>inline void SetAttributesPerDomain(\n    const std::vector&lt; int &gt; &amp; i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-usemeanenergy","title":"function UseMeanenergy","text":"<pre><code>inline void UseMeanenergy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-useentropy","title":"function UseEntropy","text":"<pre><code>inline void UseEntropy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setxyz","title":"function SetXYZ","text":"<pre><code>inline void SetXYZ(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-setnormals","title":"function SetNormals","text":"<pre><code>inline void SetNormals(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-checkfornans","title":"function CheckForNans","text":"<pre><code>inline bool CheckForNans(\n    vnl_matrix_type mat\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-clone","title":"function clone","text":"<pre><code>inline virtual std::shared_ptr&lt; VectorFunction &gt; clone() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-correspondencefunction","title":"function CorrespondenceFunction","text":"<pre><code>inline CorrespondenceFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-correspondencefunction_1","title":"function ~CorrespondenceFunction","text":"<pre><code>~CorrespondenceFunction() override =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-correspondencefunction_2","title":"function CorrespondenceFunction","text":"<pre><code>CorrespondenceFunction(\n    const CorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-operator","title":"function operator=","text":"<pre><code>CorrespondenceFunction &amp; operator=(\n    const CorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#function-computeupdates","title":"function ComputeUpdates","text":"<pre><code>virtual void ComputeUpdates(\n    const ParticleSystem * c\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static int VDimension = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr static unsigned int Dimension = VDimension;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_shapedata","title":"variable m_ShapeData","text":"<pre><code>ShapeDataType::Pointer m_ShapeData;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_shapegradient","title":"variable m_ShapeGradient","text":"<pre><code>ShapeGradientType::Pointer m_ShapeGradient;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_pointsupdate","title":"variable m_PointsUpdate","text":"<pre><code>std::shared_ptr&lt; vnl_matrix_type &gt; m_PointsUpdate;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_minimumvariance","title":"variable m_MinimumVariance","text":"<pre><code>double m_MinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_minimumeigenvalue","title":"variable m_MinimumEigenValue","text":"<pre><code>double m_MinimumEigenValue;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_holdminimumvariance","title":"variable m_HoldMinimumVariance","text":"<pre><code>bool m_HoldMinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_recomputecovarianceinterval","title":"variable m_RecomputeCovarianceInterval","text":"<pre><code>int m_RecomputeCovarianceInterval;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_minimumvariancedecayconstant","title":"variable m_MinimumVarianceDecayConstant","text":"<pre><code>double m_MinimumVarianceDecayConstant;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_counter","title":"variable m_Counter","text":"<pre><code>int m_Counter;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_attributescales","title":"variable m_AttributeScales","text":"<pre><code>std::vector&lt; double &gt; m_AttributeScales;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_domainspershape","title":"variable m_DomainsPerShape","text":"<pre><code>int m_DomainsPerShape;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_attributesperdomain","title":"variable m_AttributesPerDomain","text":"<pre><code>std::vector&lt; int &gt; m_AttributesPerDomain;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_currentenergy","title":"variable m_CurrentEnergy","text":"<pre><code>double m_CurrentEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_usemeanenergy","title":"variable m_UseMeanEnergy","text":"<pre><code>bool m_UseMeanEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_usexyz","title":"variable m_UseXYZ","text":"<pre><code>std::vector&lt; bool &gt; m_UseXYZ;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_usenormals","title":"variable m_UseNormals","text":"<pre><code>std::vector&lt; bool &gt; m_UseNormals;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_points_mean","title":"variable m_points_mean","text":"<pre><code>std::shared_ptr&lt; vnl_matrix_type &gt; m_points_mean;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-m_inversecovmatrix","title":"variable m_InverseCovMatrix","text":"<pre><code>std::shared_ptr&lt; Eigen::MatrixXd &gt; m_InverseCovMatrix;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-num_dims","title":"variable num_dims","text":"<pre><code>int num_dims;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1CorrespondenceFunction.html#variable-num_samples","title":"variable num_samples","text":"<pre><code>int num_samples;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html","title":"shapeworks::DataTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-slots","title":"Public Slots","text":"Name void delete_button_clicked() void delete_landmarks_clicked() void set_placing_button_clicked(int id) void handle_landmark_mode_changed() void handle_constraints_mode_changed() void constraints_table_right_click(const QPoint &amp; point) void data_table_right_click(const QPoint &amp; point) void copy_ffc_clicked() void table_selection_changed() void subject_notes_changed() void table_data_edited()"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-signals","title":"Public Signals","text":"Name void import_button_clicked()"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-functions","title":"Public Functions","text":"Name DataTool(Preferences &amp; prefs) ~DataTool() void set_session(QSharedPointer&lt; Session &gt; session)Set the pointer to the session. void activate()activate this tool void disable_actions() void enable_actions() void update_table(bool clean =true) void update_landmark_table() void landmark_domain_changed() void constraints_domain_changed() void delete_planes_clicked() void delete_ffc_clicked() void update_notes() std::string get_notes() void store_data()"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-delete_button_clicked","title":"slot delete_button_clicked","text":"<pre><code>void delete_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-delete_landmarks_clicked","title":"slot delete_landmarks_clicked","text":"<pre><code>void delete_landmarks_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-set_placing_button_clicked","title":"slot set_placing_button_clicked","text":"<pre><code>void set_placing_button_clicked(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-handle_landmark_mode_changed","title":"slot handle_landmark_mode_changed","text":"<pre><code>void handle_landmark_mode_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-handle_constraints_mode_changed","title":"slot handle_constraints_mode_changed","text":"<pre><code>void handle_constraints_mode_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-constraints_table_right_click","title":"slot constraints_table_right_click","text":"<pre><code>void constraints_table_right_click(\n    const QPoint &amp; point\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-data_table_right_click","title":"slot data_table_right_click","text":"<pre><code>void data_table_right_click(\n    const QPoint &amp; point\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-copy_ffc_clicked","title":"slot copy_ffc_clicked","text":"<pre><code>void copy_ffc_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-table_selection_changed","title":"slot table_selection_changed","text":"<pre><code>void table_selection_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-subject_notes_changed","title":"slot subject_notes_changed","text":"<pre><code>void subject_notes_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#slot-table_data_edited","title":"slot table_data_edited","text":"<pre><code>void table_data_edited()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DataTool.html#signal-import_button_clicked","title":"signal import_button_clicked","text":"<pre><code>void import_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-datatool","title":"function DataTool","text":"<pre><code>DataTool(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-datatool_1","title":"function ~DataTool","text":"<pre><code>~DataTool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>Set the pointer to the session. </p>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-activate","title":"function activate","text":"<pre><code>void activate()\n</code></pre> <p>activate this tool </p>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-disable_actions","title":"function disable_actions","text":"<pre><code>void disable_actions()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-enable_actions","title":"function enable_actions","text":"<pre><code>void enable_actions()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-update_table","title":"function update_table","text":"<pre><code>void update_table(\n    bool clean =true\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-update_landmark_table","title":"function update_landmark_table","text":"<pre><code>void update_landmark_table()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-landmark_domain_changed","title":"function landmark_domain_changed","text":"<pre><code>void landmark_domain_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-constraints_domain_changed","title":"function constraints_domain_changed","text":"<pre><code>void constraints_domain_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-delete_planes_clicked","title":"function delete_planes_clicked","text":"<pre><code>void delete_planes_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-delete_ffc_clicked","title":"function delete_ffc_clicked","text":"<pre><code>void delete_ffc_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-update_notes","title":"function update_notes","text":"<pre><code>void update_notes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-get_notes","title":"function get_notes","text":"<pre><code>std::string get_notes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DataTool.html#function-store_data","title":"function store_data","text":"<pre><code>void store_data()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMCommandGroup.html","title":"shapeworks::DeepSSMCommandGroup","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMCommandGroup.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1DeepSSMCommandGroup.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1DeepSSMCommandGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMCommandGroup.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html","title":"shapeworks::DeepSSMJob","text":"<p>Qt Wrapper for DeepSSM.  More...</p> <p><code>#include &lt;DeepSSMJob.h&gt;</code></p> <p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#public-types","title":"Public Types","text":"Name enum class JobType enum PrepStep enum class SplitType"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#public-functions","title":"Public Functions","text":"Name DeepSSMJob(std::shared_ptr&lt; Project &gt; project, DeepSSMJob::JobType tool_mode, DeepSSMJob::PrepStep prep_step =DeepSSMJob::NOT_STARTED) ~DeepSSMJob() virtual void run() overriderun the job virtual QString name() overrideget the name of the job void run_prep() void run_augmentation() void run_training() void run_testing() void python_message(std::string str) void set_num_dataloader_workers(int num_workers) int get_num_dataloader_workers() void set_prep_step(DeepSSMJob::PrepStep step) std::vector&lt; int &gt; get_split(ProjectHandle project, DeepSSMJob::SplitType split_type)"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::DeepSSMJob;\n</code></pre> <p>Qt Wrapper for DeepSSM. </p> <p>The DeepSSMJob class wraps the functionality for DeepSSM as a Studio Job object </p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#enum-jobtype","title":"enum JobType","text":"Enumerator Value Description DeepSSM_PrepType 0 DeepSSM_AugmentationType 1 DeepSSM_TrainingType 2 DeepSSM_TestingType 3"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#enum-prepstep","title":"enum PrepStep","text":"Enumerator Value Description NOT_STARTED 0 GROOM_TRAINING 1 OPTIMIZE_TRAINING 2 OPTIMIZE_VALIDATION 3 GROOM_IMAGES 4 DONE 5"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#enum-splittype","title":"enum SplitType","text":"Enumerator Value Description TRAIN VAL TEST"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-deepssmjob","title":"function DeepSSMJob","text":"<pre><code>DeepSSMJob(\n    std::shared_ptr&lt; Project &gt; project,\n    DeepSSMJob::JobType tool_mode,\n    DeepSSMJob::PrepStep prep_step =DeepSSMJob::NOT_STARTED\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-deepssmjob_1","title":"function ~DeepSSMJob","text":"<pre><code>~DeepSSMJob()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-run_prep","title":"function run_prep","text":"<pre><code>void run_prep()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-run_augmentation","title":"function run_augmentation","text":"<pre><code>void run_augmentation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-run_training","title":"function run_training","text":"<pre><code>void run_training()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-run_testing","title":"function run_testing","text":"<pre><code>void run_testing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-python_message","title":"function python_message","text":"<pre><code>void python_message(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-set_num_dataloader_workers","title":"function set_num_dataloader_workers","text":"<pre><code>void set_num_dataloader_workers(\n    int num_workers\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-get_num_dataloader_workers","title":"function get_num_dataloader_workers","text":"<pre><code>int get_num_dataloader_workers()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-set_prep_step","title":"function set_prep_step","text":"<pre><code>inline void set_prep_step(\n    DeepSSMJob::PrepStep step\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMJob.html#function-get_split","title":"function get_split","text":"<pre><code>static std::vector&lt; int &gt; get_split(\n    ProjectHandle project,\n    DeepSSMJob::SplitType split_type\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html","title":"shapeworks::DeepSSMParameters","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#public-functions","title":"Public Functions","text":"Name DeepSSMParameters(ProjectHandle project) void save_to_project() int get_aug_num_samples() void set_aug_num_samples(int num_samples) int get_aug_num_dims() void set_aug_num_dims(int num_dims) int get_training_num_dims() void set_training_num_dims(int num_dims) double get_aug_percent_variability() void set_aug_percent_variability(double percent_variability) std::string get_aug_sampler_type() void set_aug_sampler_type(std::string sampler_type) int get_training_epochs() void set_training_epochs(int epochs) double get_training_learning_rate() void set_training_learning_rate(double rate) bool get_training_decay_learning_rate() void set_training_decay_learning_rate(bool decay) bool get_training_fine_tuning() void set_training_fine_tuning(bool fine_tuning) int get_training_fine_tuning_epochs() void set_training_fine_tuning_epochs(int epochs) double get_training_fine_tuning_learning_rate() void set_training_fine_tuning_learning_rate(double rate) int get_training_batch_size() void set_training_batch_size(int batch_size) double get_training_split() void set_training_split(double value) double get_validation_split() void set_validation_split(double value) double get_testing_split() void set_testing_split(double value) bool get_prep_step_complete() void set_prep_step_complete(bool value) int get_prep_stage() void set_prep_stage(int stage) bool get_aug_step_complete() void set_aug_step_complete(bool value) std::string get_aug_message() void set_aug_message(std::string message) bool get_training_step_complete() void set_training_step_complete(bool value) std::string get_training_message() void set_training_message(std::string message) std::vector&lt; double &gt; get_spacing() void set_spacing(std::vector&lt; double &gt; spacing) std::string get_loss_function() void set_loss_function(std::string loss_function) bool get_tl_net_enabled() void set_tl_net_enabled(bool enabled) int get_tl_net_ae_epochs() void set_tl_net_ae_epochs(int num_epochs) int get_tl_net_tf_epochs() void set_tl_net_tf_epochs(int num_epochs) int get_tl_net_joint_epochs() void set_tl_net_joint_epochs(int num_epochs) double get_tl_net_alpha() void set_tl_net_alpha(double alpha) double get_tl_net_a_ae() void set_tl_net_a_ae(double a_ae) double get_tl_net_c_ae() void set_tl_net_c_ae(double c_ae) double get_tl_net_a_lat() void set_tl_net_a_lat(double a_lat) double get_tl_net_c_lat() void set_tl_net_c_lat(double c_lat) void restore_split_defaults() void restore_augmentation_defaults() void restore_training_defaults() void restore_defaults()"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#public-attributes","title":"Public Attributes","text":"Name const std::string DEEPSSM_SAMPLER_GAUSSIAN_C const std::string DEEPSSM_SAMPLER_MIXTURE_C const std::string DEEPSSM_SAMPLER_KDE_C"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-deepssmparameters","title":"function DeepSSMParameters","text":"<pre><code>explicit DeepSSMParameters(\n    ProjectHandle project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-save_to_project","title":"function save_to_project","text":"<pre><code>void save_to_project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_num_samples","title":"function get_aug_num_samples","text":"<pre><code>int get_aug_num_samples()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_num_samples","title":"function set_aug_num_samples","text":"<pre><code>void set_aug_num_samples(\n    int num_samples\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_num_dims","title":"function get_aug_num_dims","text":"<pre><code>int get_aug_num_dims()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_num_dims","title":"function set_aug_num_dims","text":"<pre><code>void set_aug_num_dims(\n    int num_dims\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_num_dims","title":"function get_training_num_dims","text":"<pre><code>int get_training_num_dims()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_num_dims","title":"function set_training_num_dims","text":"<pre><code>void set_training_num_dims(\n    int num_dims\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_percent_variability","title":"function get_aug_percent_variability","text":"<pre><code>double get_aug_percent_variability()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_percent_variability","title":"function set_aug_percent_variability","text":"<pre><code>void set_aug_percent_variability(\n    double percent_variability\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_sampler_type","title":"function get_aug_sampler_type","text":"<pre><code>std::string get_aug_sampler_type()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_sampler_type","title":"function set_aug_sampler_type","text":"<pre><code>void set_aug_sampler_type(\n    std::string sampler_type\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_epochs","title":"function get_training_epochs","text":"<pre><code>int get_training_epochs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_epochs","title":"function set_training_epochs","text":"<pre><code>void set_training_epochs(\n    int epochs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_learning_rate","title":"function get_training_learning_rate","text":"<pre><code>double get_training_learning_rate()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_learning_rate","title":"function set_training_learning_rate","text":"<pre><code>void set_training_learning_rate(\n    double rate\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_decay_learning_rate","title":"function get_training_decay_learning_rate","text":"<pre><code>bool get_training_decay_learning_rate()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_decay_learning_rate","title":"function set_training_decay_learning_rate","text":"<pre><code>void set_training_decay_learning_rate(\n    bool decay\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_fine_tuning","title":"function get_training_fine_tuning","text":"<pre><code>bool get_training_fine_tuning()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_fine_tuning","title":"function set_training_fine_tuning","text":"<pre><code>void set_training_fine_tuning(\n    bool fine_tuning\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_fine_tuning_epochs","title":"function get_training_fine_tuning_epochs","text":"<pre><code>int get_training_fine_tuning_epochs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_fine_tuning_epochs","title":"function set_training_fine_tuning_epochs","text":"<pre><code>void set_training_fine_tuning_epochs(\n    int epochs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_fine_tuning_learning_rate","title":"function get_training_fine_tuning_learning_rate","text":"<pre><code>double get_training_fine_tuning_learning_rate()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_fine_tuning_learning_rate","title":"function set_training_fine_tuning_learning_rate","text":"<pre><code>void set_training_fine_tuning_learning_rate(\n    double rate\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_batch_size","title":"function get_training_batch_size","text":"<pre><code>int get_training_batch_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_batch_size","title":"function set_training_batch_size","text":"<pre><code>void set_training_batch_size(\n    int batch_size\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_split","title":"function get_training_split","text":"<pre><code>double get_training_split()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_split","title":"function set_training_split","text":"<pre><code>void set_training_split(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_validation_split","title":"function get_validation_split","text":"<pre><code>double get_validation_split()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_validation_split","title":"function set_validation_split","text":"<pre><code>void set_validation_split(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_testing_split","title":"function get_testing_split","text":"<pre><code>double get_testing_split()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_testing_split","title":"function set_testing_split","text":"<pre><code>void set_testing_split(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_prep_step_complete","title":"function get_prep_step_complete","text":"<pre><code>bool get_prep_step_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_prep_step_complete","title":"function set_prep_step_complete","text":"<pre><code>void set_prep_step_complete(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_prep_stage","title":"function get_prep_stage","text":"<pre><code>int get_prep_stage()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_prep_stage","title":"function set_prep_stage","text":"<pre><code>void set_prep_stage(\n    int stage\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_step_complete","title":"function get_aug_step_complete","text":"<pre><code>bool get_aug_step_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_step_complete","title":"function set_aug_step_complete","text":"<pre><code>void set_aug_step_complete(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_aug_message","title":"function get_aug_message","text":"<pre><code>std::string get_aug_message()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_aug_message","title":"function set_aug_message","text":"<pre><code>void set_aug_message(\n    std::string message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_step_complete","title":"function get_training_step_complete","text":"<pre><code>bool get_training_step_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_step_complete","title":"function set_training_step_complete","text":"<pre><code>void set_training_step_complete(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_training_message","title":"function get_training_message","text":"<pre><code>std::string get_training_message()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_training_message","title":"function set_training_message","text":"<pre><code>void set_training_message(\n    std::string message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_spacing","title":"function get_spacing","text":"<pre><code>std::vector&lt; double &gt; get_spacing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_spacing","title":"function set_spacing","text":"<pre><code>void set_spacing(\n    std::vector&lt; double &gt; spacing\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_loss_function","title":"function get_loss_function","text":"<pre><code>std::string get_loss_function()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_loss_function","title":"function set_loss_function","text":"<pre><code>void set_loss_function(\n    std::string loss_function\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_enabled","title":"function get_tl_net_enabled","text":"<pre><code>bool get_tl_net_enabled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_enabled","title":"function set_tl_net_enabled","text":"<pre><code>void set_tl_net_enabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_ae_epochs","title":"function get_tl_net_ae_epochs","text":"<pre><code>int get_tl_net_ae_epochs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_ae_epochs","title":"function set_tl_net_ae_epochs","text":"<pre><code>void set_tl_net_ae_epochs(\n    int num_epochs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_tf_epochs","title":"function get_tl_net_tf_epochs","text":"<pre><code>int get_tl_net_tf_epochs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_tf_epochs","title":"function set_tl_net_tf_epochs","text":"<pre><code>void set_tl_net_tf_epochs(\n    int num_epochs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_joint_epochs","title":"function get_tl_net_joint_epochs","text":"<pre><code>int get_tl_net_joint_epochs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_joint_epochs","title":"function set_tl_net_joint_epochs","text":"<pre><code>void set_tl_net_joint_epochs(\n    int num_epochs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_alpha","title":"function get_tl_net_alpha","text":"<pre><code>double get_tl_net_alpha()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_alpha","title":"function set_tl_net_alpha","text":"<pre><code>void set_tl_net_alpha(\n    double alpha\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_a_ae","title":"function get_tl_net_a_ae","text":"<pre><code>double get_tl_net_a_ae()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_a_ae","title":"function set_tl_net_a_ae","text":"<pre><code>void set_tl_net_a_ae(\n    double a_ae\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_c_ae","title":"function get_tl_net_c_ae","text":"<pre><code>double get_tl_net_c_ae()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_c_ae","title":"function set_tl_net_c_ae","text":"<pre><code>void set_tl_net_c_ae(\n    double c_ae\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_a_lat","title":"function get_tl_net_a_lat","text":"<pre><code>double get_tl_net_a_lat()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_a_lat","title":"function set_tl_net_a_lat","text":"<pre><code>void set_tl_net_a_lat(\n    double a_lat\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-get_tl_net_c_lat","title":"function get_tl_net_c_lat","text":"<pre><code>double get_tl_net_c_lat()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-set_tl_net_c_lat","title":"function set_tl_net_c_lat","text":"<pre><code>void set_tl_net_c_lat(\n    double c_lat\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-restore_split_defaults","title":"function restore_split_defaults","text":"<pre><code>void restore_split_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-restore_augmentation_defaults","title":"function restore_augmentation_defaults","text":"<pre><code>void restore_augmentation_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-restore_training_defaults","title":"function restore_training_defaults","text":"<pre><code>void restore_training_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#function-restore_defaults","title":"function restore_defaults","text":"<pre><code>void restore_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#variable-deepssm_sampler_gaussian_c","title":"variable DEEPSSM_SAMPLER_GAUSSIAN_C","text":"<pre><code>static const std::string DEEPSSM_SAMPLER_GAUSSIAN_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#variable-deepssm_sampler_mixture_c","title":"variable DEEPSSM_SAMPLER_MIXTURE_C","text":"<pre><code>static const std::string DEEPSSM_SAMPLER_MIXTURE_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMParameters.html#variable-deepssm_sampler_kde_c","title":"variable DEEPSSM_SAMPLER_KDE_C","text":"<pre><code>static const std::string DEEPSSM_SAMPLER_KDE_C;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html","title":"shapeworks::DeepSSMTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-slots","title":"Public Slots","text":"Name void run_clicked() void run_prep_clicked(int step) void restore_defaults() void handle_thread_complete() void handle_progress(int val, QString message) void handle_error(QString msg) void tab_changed(int tab) void update_panels() void update_split() void handle_new_mesh() void training_fine_tuning_changed()"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-signals","title":"Public Signals","text":"Name void update_view() void progress(int )"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-functions","title":"Public Functions","text":"Name DeepSSMTool(Preferences &amp; prefs) ~DeepSSMTool() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the session void set_app(ShapeWorksStudioApp * app)set the pointer to the application bool is_active()Return if this tool is active. void load_params() void store_params() void shutdown() ShapeList get_shapes() void resizeEvent(QResizeEvent * event) override std::string get_display_feature()"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-run_clicked","title":"slot run_clicked","text":"<pre><code>void run_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-run_prep_clicked","title":"slot run_prep_clicked","text":"<pre><code>void run_prep_clicked(\n    int step\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-restore_defaults","title":"slot restore_defaults","text":"<pre><code>void restore_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-handle_thread_complete","title":"slot handle_thread_complete","text":"<pre><code>void handle_thread_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-handle_progress","title":"slot handle_progress","text":"<pre><code>void handle_progress(\n    int val,\n    QString message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-handle_error","title":"slot handle_error","text":"<pre><code>void handle_error(\n    QString msg\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-tab_changed","title":"slot tab_changed","text":"<pre><code>void tab_changed(\n    int tab\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-update_panels","title":"slot update_panels","text":"<pre><code>void update_panels()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-update_split","title":"slot update_split","text":"<pre><code>void update_split()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-handle_new_mesh","title":"slot handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#slot-training_fine_tuning_changed","title":"slot training_fine_tuning_changed","text":"<pre><code>void training_fine_tuning_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-deepssmtool","title":"function DeepSSMTool","text":"<pre><code>DeepSSMTool(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-deepssmtool_1","title":"function ~DeepSSMTool","text":"<pre><code>~DeepSSMTool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the session </p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-set_app","title":"function set_app","text":"<pre><code>void set_app(\n    ShapeWorksStudioApp * app\n)\n</code></pre> <p>set the pointer to the application </p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-is_active","title":"function is_active","text":"<pre><code>bool is_active()\n</code></pre> <p>Return if this tool is active. </p>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-load_params","title":"function load_params","text":"<pre><code>void load_params()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-store_params","title":"function store_params","text":"<pre><code>void store_params()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-shutdown","title":"function shutdown","text":"<pre><code>void shutdown()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-get_shapes","title":"function get_shapes","text":"<pre><code>ShapeList get_shapes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void resizeEvent(\n    QResizeEvent * event\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DeepSSMTool.html#function-get_display_feature","title":"function get_display_feature","text":"<pre><code>std::string get_display_feature()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html","title":"shapeworks::DisentangledCorrespondenceFunction","text":"<p>More...</p> <p><code>#include &lt;DisentangledCorrespondenceFunction.h&gt;</code></p> <p>Inherits from shapeworks::VectorFunction</p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-types","title":"Public Types","text":"Name typedef LegacyShapeMatrix ShapeMatrixType typedef ShapeMatrixType::DataType DataType typedef VectorFunction::VectorType VectorType typedef ParticleSystem::PointType PointType typedef vnl_vector&lt; DataType &gt; vnl_vector_type typedef vnl_matrix&lt; DataType &gt; vnl_matrix_type typedef std::shared_ptr&lt; std::vector&lt; vnl_matrix_type &gt; &gt; shared_vnl_matrix_array_type"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-functions","title":"Public Functions","text":"Name std::shared_ptr&lt; DisentangledCorrespondenceFunction &gt; New()Factory method for creating instances. virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; , double &amp; ) const virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep) const virtual double energy(unsigned int a, unsigned int b, const ParticleSystem * c) const void WriteModes(const std::string &amp; , int ) const void SetShapeMatrix(ShapeMatrixType * s) ShapeMatrixType * GetShapeMatrix() const ShapeMatrixType * GetShapeMatrix() const virtual void before_iteration() virtual void after_iteration() override void SetMinimumVariance(double d) double GetMinimumVariance() const void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) bool GetMinimumVarianceDecayConstant() const void PrintShapeMatrix() void UseMeanenergy() void UseEntropy() bool GetHoldMinimumVariance() const void SetHoldMinimumVariance(bool b) void SetRecomputeCovarianceInterval(int i) int GetRecomputeCovarianceInterval() const virtual std::shared_ptr&lt; VectorFunction &gt; clone() override DisentangledCorrespondenceFunction() ~DisentangledCorrespondenceFunction() override =default"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#protected-functions","title":"Protected Functions","text":"Name DisentangledCorrespondenceFunction(const DisentangledCorrespondenceFunction &amp; ) =delete DisentangledCorrespondenceFunction &amp; operator=(const DisentangledCorrespondenceFunction &amp; ) =delete virtual void ComputeCovarianceMatrices() void Initialize()"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static unsigned int VDimension constexpr static unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#protected-attributes","title":"Protected Attributes","text":"Name ShapeMatrixType::Pointer m_ShapeMatrix double m_MinimumVariance double m_MinimumEigenValue std::vector&lt; double &gt; m_MinimumEigenValue_time_cohort std::vector&lt; double &gt; m_MinimumEigenValue_shape_cohort double m_CurrentEnergy bool m_HoldMinimumVariance double m_MinimumVarianceDecayConstant int m_RecomputeCovarianceInterval int m_Counter bool m_UseMeanEnergy std::shared_ptr&lt; std::vector&lt; Eigen::MatrixXd &gt; &gt; m_InverseCovMatrices_time_cohort std::shared_ptr&lt; std::vector&lt; Eigen::MatrixXd &gt; &gt; m_InverseCovMatrices_shape_cohort shared_vnl_matrix_array_type m_points_mean_time_cohort shared_vnl_matrix_array_type m_points_mean_shape_cohort shared_vnl_matrix_array_type m_Time_PointsUpdate shared_vnl_matrix_array_type m_Shape_PointsUpdate"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::VectorFunction</p> Name virtual void reset_buffers()May be called by the solver class. virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) virtual void set_particle_system(ParticleSystem * p)Some subclasses may require a pointer to the particle system and its domain number. virtual ParticleSystem * get_particle_system() const virtual void set_domain_number(unsigned int i) virtual int get_domain_number() const virtual double get_relative_energy_scaling() const virtual void set_relative_energy_scaling(double r) virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes. <p>Protected Functions inherited from shapeworks::VectorFunction</p> Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete <p>Protected Attributes inherited from shapeworks::VectorFunction</p> Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::DisentangledCorrespondenceFunction;\n</code></pre> <p>This class implements the Correspondence Term where the entropy computation is disentangled across time and shape domain, and builds a Sapatiotemporal SSM. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-shapematrixtype","title":"typedef ShapeMatrixType","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::DisentangledCorrespondenceFunction::ShapeMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef ShapeMatrixType::DataType shapeworks::DisentangledCorrespondenceFunction::DataType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>typedef VectorFunction::VectorType shapeworks::DisentangledCorrespondenceFunction::VectorType;\n</code></pre> <p>Vector &amp; Point types. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystem::PointType shapeworks::DisentangledCorrespondenceFunction::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-vnl_vector_type","title":"typedef vnl_vector_type","text":"<pre><code>typedef vnl_vector&lt;DataType&gt; shapeworks::DisentangledCorrespondenceFunction::vnl_vector_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-vnl_matrix_type","title":"typedef vnl_matrix_type","text":"<pre><code>typedef vnl_matrix&lt;DataType&gt; shapeworks::DisentangledCorrespondenceFunction::vnl_matrix_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#typedef-shared_vnl_matrix_array_type","title":"typedef shared_vnl_matrix_array_type","text":"<pre><code>typedef std::shared_ptr&lt;std::vector&lt;vnl_matrix_type&gt; &gt; shapeworks::DisentangledCorrespondenceFunction::shared_vnl_matrix_array_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-new","title":"function New","text":"<pre><code>static inline std::shared_ptr&lt; DisentangledCorrespondenceFunction &gt; New()\n</code></pre> <p>Factory method for creating instances. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; ,\n    double &amp; \n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-energy","title":"function energy","text":"<pre><code>inline virtual double energy(\n    unsigned int a,\n    unsigned int b,\n    const ParticleSystem * c\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-writemodes","title":"function WriteModes","text":"<pre><code>void WriteModes(\n    const std::string &amp; ,\n    int \n) const\n</code></pre> <p>Write the first n modes to +- 3 std dev and the mean of the model described by the covariance matrix. The string argument is a prefix to the file names. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-setshapematrix","title":"function SetShapeMatrix","text":"<pre><code>inline void SetShapeMatrix(\n    ShapeMatrixType * s\n)\n</code></pre> <p>Access the shape matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getshapematrix","title":"function GetShapeMatrix","text":"<pre><code>inline ShapeMatrixType * GetShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getshapematrix_1","title":"function GetShapeMatrix","text":"<pre><code>inline const ShapeMatrixType * GetShapeMatrix() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::before_iteration</p> <p>Called before each iteration of a solver. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::after_iteration</p> <p>Called after each iteration of the solver. </p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-setminimumvariance","title":"function SetMinimumVariance","text":"<pre><code>inline void SetMinimumVariance(\n    double d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getminimumvariance","title":"function GetMinimumVariance","text":"<pre><code>inline double GetMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-setminimumvariancedecay","title":"function SetMinimumVarianceDecay","text":"<pre><code>inline void SetMinimumVarianceDecay(\n    double initial_value,\n    double final_value,\n    double time_period\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getminimumvariancedecayconstant","title":"function GetMinimumVarianceDecayConstant","text":"<pre><code>inline bool GetMinimumVarianceDecayConstant() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-printshapematrix","title":"function PrintShapeMatrix","text":"<pre><code>inline void PrintShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-usemeanenergy","title":"function UseMeanenergy","text":"<pre><code>inline void UseMeanenergy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-useentropy","title":"function UseEntropy","text":"<pre><code>inline void UseEntropy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getholdminimumvariance","title":"function GetHoldMinimumVariance","text":"<pre><code>inline bool GetHoldMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-setholdminimumvariance","title":"function SetHoldMinimumVariance","text":"<pre><code>inline void SetHoldMinimumVariance(\n    bool b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-setrecomputecovarianceinterval","title":"function SetRecomputeCovarianceInterval","text":"<pre><code>inline void SetRecomputeCovarianceInterval(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-getrecomputecovarianceinterval","title":"function GetRecomputeCovarianceInterval","text":"<pre><code>inline int GetRecomputeCovarianceInterval() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-clone","title":"function clone","text":"<pre><code>inline virtual std::shared_ptr&lt; VectorFunction &gt; clone() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-disentangledcorrespondencefunction","title":"function DisentangledCorrespondenceFunction","text":"<pre><code>inline DisentangledCorrespondenceFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-disentangledcorrespondencefunction_1","title":"function ~DisentangledCorrespondenceFunction","text":"<pre><code>~DisentangledCorrespondenceFunction() override =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-disentangledcorrespondencefunction_2","title":"function DisentangledCorrespondenceFunction","text":"<pre><code>DisentangledCorrespondenceFunction(\n    const DisentangledCorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-operator","title":"function operator=","text":"<pre><code>DisentangledCorrespondenceFunction &amp; operator=(\n    const DisentangledCorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-computecovariancematrices","title":"function ComputeCovarianceMatrices","text":"<pre><code>virtual void ComputeCovarianceMatrices()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#function-initialize","title":"function Initialize","text":"<pre><code>inline void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static unsigned int VDimension = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr static unsigned int Dimension = VDimension;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_shapematrix","title":"variable m_ShapeMatrix","text":"<pre><code>ShapeMatrixType::Pointer m_ShapeMatrix;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_minimumvariance","title":"variable m_MinimumVariance","text":"<pre><code>double m_MinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_minimumeigenvalue","title":"variable m_MinimumEigenValue","text":"<pre><code>double m_MinimumEigenValue;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_minimumeigenvalue_time_cohort","title":"variable m_MinimumEigenValue_time_cohort","text":"<pre><code>std::vector&lt; double &gt; m_MinimumEigenValue_time_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_minimumeigenvalue_shape_cohort","title":"variable m_MinimumEigenValue_shape_cohort","text":"<pre><code>std::vector&lt; double &gt; m_MinimumEigenValue_shape_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_currentenergy","title":"variable m_CurrentEnergy","text":"<pre><code>double m_CurrentEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_holdminimumvariance","title":"variable m_HoldMinimumVariance","text":"<pre><code>bool m_HoldMinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_minimumvariancedecayconstant","title":"variable m_MinimumVarianceDecayConstant","text":"<pre><code>double m_MinimumVarianceDecayConstant;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_recomputecovarianceinterval","title":"variable m_RecomputeCovarianceInterval","text":"<pre><code>int m_RecomputeCovarianceInterval;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_counter","title":"variable m_Counter","text":"<pre><code>int m_Counter;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_usemeanenergy","title":"variable m_UseMeanEnergy","text":"<pre><code>bool m_UseMeanEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_inversecovmatrices_time_cohort","title":"variable m_InverseCovMatrices_time_cohort","text":"<pre><code>std::shared_ptr&lt; std::vector&lt; Eigen::MatrixXd &gt; &gt; m_InverseCovMatrices_time_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_inversecovmatrices_shape_cohort","title":"variable m_InverseCovMatrices_shape_cohort","text":"<pre><code>std::shared_ptr&lt; std::vector&lt; Eigen::MatrixXd &gt; &gt; m_InverseCovMatrices_shape_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_points_mean_time_cohort","title":"variable m_points_mean_time_cohort","text":"<pre><code>shared_vnl_matrix_array_type m_points_mean_time_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_points_mean_shape_cohort","title":"variable m_points_mean_shape_cohort","text":"<pre><code>shared_vnl_matrix_array_type m_points_mean_shape_cohort;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_time_pointsupdate","title":"variable m_Time_PointsUpdate","text":"<pre><code>shared_vnl_matrix_array_type m_Time_PointsUpdate;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DisentangledCorrespondenceFunction.html#variable-m_shape_pointsupdate","title":"variable m_Shape_PointsUpdate","text":"<pre><code>shared_vnl_matrix_array_type m_Shape_PointsUpdate;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html","title":"shapeworks::DualVectorFunction","text":"<p>More...</p> <p><code>#include &lt;DualVectorFunction.h&gt;</code></p> <p>Inherits from shapeworks::VectorFunction</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-types","title":"Public Types","text":"Name using VectorFunction::VectorType VectorType Type of vectors."},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-functions","title":"Public Functions","text":"Name std::shared_ptr&lt; DualVectorFunction &gt; New()Factory method for creating instances. virtual VectorType evaluate(unsigned int idx, unsigned int d, const ParticleSystem * system, double &amp; maxmove) const override double EnergyA(unsigned int idx, unsigned int d, const ParticleSystem * system) const virtual double EnergyB(unsigned int idx, unsigned int d, const ParticleSystem * system) const virtual double energy(unsigned int idx, unsigned int d, const ParticleSystem * system) const virtual VectorType evaluate(unsigned int idx, unsigned int d, const ParticleSystem * system, double &amp; maxmove, double &amp; energy) const virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) virtual void after_iteration() overrideThis method is called by a solver after each iteration. virtual void before_iteration() overrideThis method is called by a solver before each iteration. virtual void set_particle_system(ParticleSystem * p) overrideSome subclasses may require a pointer to the particle system and its domain number. virtual void set_domain_number(unsigned int i) override void set_function_a(std::shared_ptr&lt; VectorFunction &gt; o) std::shared_ptr&lt; VectorFunction &gt; get_function_a() std::shared_ptr&lt; VectorFunction &gt; get_function_b() void set_function_b(std::shared_ptr&lt; VectorFunction &gt; o) void set_a_on()Turn each term on and off. void set_a_off() void set_a_on(bool s) bool get_a_on() const void set_b_on() void set_b_off() void set_b_on(bool s) bool get_b_on() const virtual void set_relative_energy_scaling(double r) overrideThe relative scaling scales the gradient B relative to A. By default this value is 1.0. virtual double get_relative_energy_scaling() const override void set_relative_gradient_scaling(double r) double get_relative_gradient_scaling() const double get_average_grad_mag_a() const double get_average_grad_mag_b() const double get_average_energy_a() const double get_average_energy_b() const virtual std::shared_ptr&lt; VectorFunction &gt; clone() override DualVectorFunction() ~DualVectorFunction() override =default"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#protected-functions","title":"Protected Functions","text":"Name DualVectorFunction(const DualVectorFunction &amp; ) =delete DualVectorFunction &amp; operator=(const DualVectorFunction &amp; ) =delete"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static int VDimension constexpr static unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#protected-attributes","title":"Protected Attributes","text":"Name bool a_on_ bool b_on_ double relative_gradient_scaling_ double relative_energy_scaling_ double average_grad_mag_a_ double average_grad_mag_b_ double average_energy_a_ double average_energy_b_ double counter_ std::shared_ptr&lt; VectorFunction &gt; function_a_ std::shared_ptr&lt; VectorFunction &gt; function_b_"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::VectorFunction</p> Name virtual void reset_buffers()May be called by the solver class. virtual ParticleSystem * get_particle_system() const virtual int get_domain_number() const virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes. <p>Protected Functions inherited from shapeworks::VectorFunction</p> Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete <p>Protected Attributes inherited from shapeworks::VectorFunction</p> Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::DualVectorFunction;\n</code></pre> <p>This class combines the results of evaluating 2 VectorFunction and presents the interface of a single function evaluation. Optionally, only the first function can be used by calling SetLinkOff(). </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::DualVectorFunction::VectorType =  VectorFunction::VectorType;\n</code></pre> <p>Type of vectors. </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-new","title":"function New","text":"<pre><code>static inline std::shared_ptr&lt; DualVectorFunction &gt; New()\n</code></pre> <p>Factory method for creating instances. </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int idx,\n    unsigned int d,\n    const ParticleSystem * system,\n    double &amp; maxmove\n) const override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-energya","title":"function EnergyA","text":"<pre><code>inline double EnergyA(\n    unsigned int idx,\n    unsigned int d,\n    const ParticleSystem * system\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-energyb","title":"function EnergyB","text":"<pre><code>inline virtual double EnergyB(\n    unsigned int idx,\n    unsigned int d,\n    const ParticleSystem * system\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-energy","title":"function energy","text":"<pre><code>inline virtual double energy(\n    unsigned int idx,\n    unsigned int d,\n    const ParticleSystem * system\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int idx,\n    unsigned int d,\n    const ParticleSystem * system,\n    double &amp; maxmove,\n    double &amp; energy\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-before_evaluate","title":"function before_evaluate","text":"<pre><code>inline virtual void before_evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * \n)\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::before_evaluate</p> <p>This method may be called to set up the state of the function object before a call to evaluate. It is necessary in order to initialize certain constants and variables that may be used for calculating the energy as well as the gradients. Typically this is only necessary for the adaptive gradient descent algorithm. </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration() override\n</code></pre> <p>This method is called by a solver after each iteration. </p> <p>Reimplements: shapeworks::VectorFunction::after_iteration</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration() override\n</code></pre> <p>This method is called by a solver before each iteration. </p> <p>Reimplements: shapeworks::VectorFunction::before_iteration</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_particle_system","title":"function set_particle_system","text":"<pre><code>inline virtual void set_particle_system(\n    ParticleSystem * p\n) override\n</code></pre> <p>Some subclasses may require a pointer to the particle system and its domain number. </p> <p>Reimplements: shapeworks::VectorFunction::set_particle_system</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_domain_number","title":"function set_domain_number","text":"<pre><code>inline virtual void set_domain_number(\n    unsigned int i\n) override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::set_domain_number</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_function_a","title":"function set_function_a","text":"<pre><code>inline void set_function_a(\n    std::shared_ptr&lt; VectorFunction &gt; o\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_function_a","title":"function get_function_a","text":"<pre><code>inline std::shared_ptr&lt; VectorFunction &gt; get_function_a()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_function_b","title":"function get_function_b","text":"<pre><code>inline std::shared_ptr&lt; VectorFunction &gt; get_function_b()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_function_b","title":"function set_function_b","text":"<pre><code>inline void set_function_b(\n    std::shared_ptr&lt; VectorFunction &gt; o\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_a_on","title":"function set_a_on","text":"<pre><code>inline void set_a_on()\n</code></pre> <p>Turn each term on and off. </p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_a_off","title":"function set_a_off","text":"<pre><code>inline void set_a_off()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_a_on_1","title":"function set_a_on","text":"<pre><code>inline void set_a_on(\n    bool s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_a_on","title":"function get_a_on","text":"<pre><code>inline bool get_a_on() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_b_on","title":"function set_b_on","text":"<pre><code>inline void set_b_on()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_b_off","title":"function set_b_off","text":"<pre><code>inline void set_b_off()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_b_on_1","title":"function set_b_on","text":"<pre><code>inline void set_b_on(\n    bool s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_b_on","title":"function get_b_on","text":"<pre><code>inline bool get_b_on() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_relative_energy_scaling","title":"function set_relative_energy_scaling","text":"<pre><code>inline virtual void set_relative_energy_scaling(\n    double r\n) override\n</code></pre> <p>The relative scaling scales the gradient B relative to A. By default this value is 1.0. </p> <p>Reimplements: shapeworks::VectorFunction::set_relative_energy_scaling</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_relative_energy_scaling","title":"function get_relative_energy_scaling","text":"<pre><code>inline virtual double get_relative_energy_scaling() const override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::get_relative_energy_scaling</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-set_relative_gradient_scaling","title":"function set_relative_gradient_scaling","text":"<pre><code>inline void set_relative_gradient_scaling(\n    double r\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_relative_gradient_scaling","title":"function get_relative_gradient_scaling","text":"<pre><code>inline double get_relative_gradient_scaling() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_average_grad_mag_a","title":"function get_average_grad_mag_a","text":"<pre><code>inline double get_average_grad_mag_a() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_average_grad_mag_b","title":"function get_average_grad_mag_b","text":"<pre><code>inline double get_average_grad_mag_b() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_average_energy_a","title":"function get_average_energy_a","text":"<pre><code>inline double get_average_energy_a() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-get_average_energy_b","title":"function get_average_energy_b","text":"<pre><code>inline double get_average_energy_b() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-clone","title":"function clone","text":"<pre><code>inline virtual std::shared_ptr&lt; VectorFunction &gt; clone() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-dualvectorfunction","title":"function DualVectorFunction","text":"<pre><code>inline DualVectorFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-dualvectorfunction_1","title":"function ~DualVectorFunction","text":"<pre><code>~DualVectorFunction() override =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-dualvectorfunction_2","title":"function DualVectorFunction","text":"<pre><code>DualVectorFunction(\n    const DualVectorFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#function-operator","title":"function operator=","text":"<pre><code>DualVectorFunction &amp; operator=(\n    const DualVectorFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static int VDimension = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr static unsigned int Dimension = VDimension;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-a_on_","title":"variable a_on_","text":"<pre><code>bool a_on_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-b_on_","title":"variable b_on_","text":"<pre><code>bool b_on_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-relative_gradient_scaling_","title":"variable relative_gradient_scaling_","text":"<pre><code>double relative_gradient_scaling_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-relative_energy_scaling_","title":"variable relative_energy_scaling_","text":"<pre><code>double relative_energy_scaling_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-average_grad_mag_a_","title":"variable average_grad_mag_a_","text":"<pre><code>double average_grad_mag_a_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-average_grad_mag_b_","title":"variable average_grad_mag_b_","text":"<pre><code>double average_grad_mag_b_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-average_energy_a_","title":"variable average_energy_a_","text":"<pre><code>double average_energy_a_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-average_energy_b_","title":"variable average_energy_b_","text":"<pre><code>double average_energy_b_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-counter_","title":"variable counter_","text":"<pre><code>double counter_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-function_a_","title":"variable function_a_","text":"<pre><code>std::shared_ptr&lt; VectorFunction &gt; function_a_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1DualVectorFunction.html#variable-function_b_","title":"variable function_b_","text":"<pre><code>std::shared_ptr&lt; VectorFunction &gt; function_b_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html","title":"shapeworks::EarlyStopping","text":""},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-types","title":"Public Types","text":"Name typedef ParticleSystem::PointType PointType"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-functions","title":"Public Functions","text":"Name EarlyStopping() void SetConfigParams(int frequency, int window_size, double threshold, EarlyStoppingStrategy strategy =EarlyStoppingStrategy::RelativeDifference, double ema_alpha =0.2, bool enable_logging =false, const std::string &amp; logger_name =\"\", int warmup_iters =1000) void reset() void update(int iteration, const ParticleSystem * p) bool ShouldStop() const bool SetControlShapes(const ParticleSystem * p) Eigen::MatrixXd GetTestShapes(const ParticleSystem * p)"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-attributes","title":"Public Attributes","text":"Name constexpr static int VDimension"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystem::PointType shapeworks::EarlyStopping::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-earlystopping","title":"function EarlyStopping","text":"<pre><code>EarlyStopping()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-setconfigparams","title":"function SetConfigParams","text":"<pre><code>void SetConfigParams(\n    int frequency,\n    int window_size,\n    double threshold,\n    EarlyStoppingStrategy strategy =EarlyStoppingStrategy::RelativeDifference,\n    double ema_alpha =0.2,\n    bool enable_logging =false,\n    const std::string &amp; logger_name =\"\",\n    int warmup_iters =1000\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-update","title":"function update","text":"<pre><code>void update(\n    int iteration,\n    const ParticleSystem * p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-shouldstop","title":"function ShouldStop","text":"<pre><code>bool ShouldStop() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-setcontrolshapes","title":"function SetControlShapes","text":"<pre><code>bool SetControlShapes(\n    const ParticleSystem * p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#function-gettestshapes","title":"function GetTestShapes","text":"<pre><code>Eigen::MatrixXd GetTestShapes(\n    const ParticleSystem * p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1EarlyStopping.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static int VDimension = 3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1EigenUtils.html","title":"shapeworks::EigenUtils","text":""},{"location":"api/Classes/classshapeworks_1_1EigenUtils.html#public-functions","title":"Public Functions","text":"Name std::pair&lt; double, double &gt; compute_mean_and_stddev(const Eigen::MatrixXd &amp; matrix, int row_index)"},{"location":"api/Classes/classshapeworks_1_1EigenUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1EigenUtils.html#function-compute_mean_and_stddev","title":"function compute_mean_and_stddev","text":"<pre><code>static std::pair&lt; double, double &gt; compute_mean_and_stddev(\n    const Eigen::MatrixXd &amp; matrix,\n    int row_index\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html","title":"shapeworks::ExcelProjectReader","text":"<p>Excel file format reader for Project.  More...</p> <p><code>#include &lt;ExcelProjectReader.h&gt;</code></p> <p>Inherits from shapeworks::ProjectReader</p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#public-functions","title":"Public Functions","text":"Name ExcelProjectReader(Project &amp; project) ~ExcelProjectReader() virtual bool read_project(std::string filename) overrideRead a project from a file. virtual StringMap get_parameters(std::string name) override virtual StringMultiMap get_multi_parameters(std::string name) override"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ProjectReader</p> Name using project::types::StringMapList StringMapList using project::types::StringMap StringMap using project::types::StringList StringList using project::types::StringMultiMap StringMultiMap <p>Public Functions inherited from shapeworks::ProjectReader</p> Name ProjectReader(Project &amp; project)Constructor. virtual ~ProjectReader() =defaultDestructor. <p>Protected Functions inherited from shapeworks::ProjectReader</p> Name void load_subjects(StringMapList list)Load subjects from string map list. void load_parameters() void load_parameter(std::string name, StringMap map) void load_landmark_definitions(StringMapList list) bool contains(StringMap map, std::string key) StringList get_keys(StringMap map) <p>Protected Attributes inherited from shapeworks::ProjectReader</p> Name Project &amp; project_"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ExcelProjectReader;\n</code></pre> <p>Excel file format reader for Project. </p> <p>This class enables reader of Project objects from XLSX file format </p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#function-excelprojectreader","title":"function ExcelProjectReader","text":"<pre><code>ExcelProjectReader(\n    Project &amp; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#function-excelprojectreader_1","title":"function ~ExcelProjectReader","text":"<pre><code>~ExcelProjectReader()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#function-read_project","title":"function read_project","text":"<pre><code>virtual bool read_project(\n    std::string filename\n) override\n</code></pre> <p>Read a project from a file. </p> <p>Reimplements: shapeworks::ProjectReader::read_project</p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>virtual StringMap get_parameters(\n    std::string name\n) override\n</code></pre> <p>Reimplements: shapeworks::ProjectReader::get_parameters</p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectReader.html#function-get_multi_parameters","title":"function get_multi_parameters","text":"<pre><code>virtual StringMultiMap get_multi_parameters(\n    std::string name\n) override\n</code></pre> <p>Reimplements: shapeworks::ProjectReader::get_multi_parameters</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectWriter.html","title":"shapeworks::ExcelProjectWriter","text":"<p>Excel file format writer for Project.  More...</p> <p><code>#include &lt;ExcelProjectWriter.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectWriter.html#public-functions","title":"Public Functions","text":"Name bool write_project(Project &amp; project, const std::string &amp; filename)"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectWriter.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ExcelProjectWriter;\n</code></pre> <p>Excel file format writer for Project. </p> <p>This class enables writing of Project objects to Excel file format </p>"},{"location":"api/Classes/classshapeworks_1_1ExcelProjectWriter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ExcelProjectWriter.html#function-write_project","title":"function write_project","text":"<pre><code>static bool write_project(\n    Project &amp; project,\n    const std::string &amp; filename\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Executable.html","title":"shapeworks::Executable","text":""},{"location":"api/Classes/classshapeworks_1_1Executable.html#public-functions","title":"Public Functions","text":"Name Executable() void addCommand(Command &amp; command) int run(int argc, char const *const * argv)"},{"location":"api/Classes/classshapeworks_1_1Executable.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Executable.html#function-executable","title":"function Executable","text":"<pre><code>Executable()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Executable.html#function-addcommand","title":"function addCommand","text":"<pre><code>void addCommand(\n    Command &amp; command\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Executable.html#function-run","title":"function run","text":"<pre><code>int run(\n    int argc,\n    char const *const * argv\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ExportImageDialog.html","title":"shapeworks::ExportImageDialog","text":"<p>More...</p> <p><code>#include &lt;ExportImageDialog.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1ExportImageDialog.html#public-functions","title":"Public Functions","text":"Name ExportImageDialog(QWidget * parent, Preferences &amp; prefs, QSharedPointer&lt; AnalysisTool &gt; analysis_tool, QSharedPointer&lt; Visualizer &gt; visualizer, bool pca_mode)"},{"location":"api/Classes/classshapeworks_1_1ExportImageDialog.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ExportImageDialog;\n</code></pre> <p>The ExportImageDialog is a QDialog that implements the user interface for exporting images </p>"},{"location":"api/Classes/classshapeworks_1_1ExportImageDialog.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ExportImageDialog.html#function-exportimagedialog","title":"function ExportImageDialog","text":"<pre><code>ExportImageDialog(\n    QWidget * parent,\n    Preferences &amp; prefs,\n    QSharedPointer&lt; AnalysisTool &gt; analysis_tool,\n    QSharedPointer&lt; Visualizer &gt; visualizer,\n    bool pca_mode\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html","title":"shapeworks::ExportUtils","text":"<p>Export utilities for Studio. </p> <p><code>#include &lt;ExportUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#public-functions","title":"Public Functions","text":"Name QString get_save_filename(ShapeWorksStudioApp * parent, QString title, QString filetypes, QString default_ext) void export_all_subjects_particle_scalars(ShapeWorksStudioApp * parent, QSharedPointer&lt; Session &gt; session) bool write_scalars(ShapeWorksStudioApp * app, vtkSmartPointer&lt; vtkPolyData &gt; poly_data, QString filename) bool write_particle_scalars(ShapeWorksStudioApp * app, std::shared_ptr&lt; Shape &gt; shape, QString filename) bool write_pca_scores(ShapeWorksStudioApp * app, ParticleShapeStatistics * stats, QString filename) QString get_mesh_file_filter()"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-get_save_filename","title":"function get_save_filename","text":"<pre><code>static QString get_save_filename(\n    ShapeWorksStudioApp * parent,\n    QString title,\n    QString filetypes,\n    QString default_ext\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-export_all_subjects_particle_scalars","title":"function export_all_subjects_particle_scalars","text":"<pre><code>static void export_all_subjects_particle_scalars(\n    ShapeWorksStudioApp * parent,\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-write_scalars","title":"function write_scalars","text":"<pre><code>static bool write_scalars(\n    ShapeWorksStudioApp * app,\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    QString filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-write_particle_scalars","title":"function write_particle_scalars","text":"<pre><code>static bool write_particle_scalars(\n    ShapeWorksStudioApp * app,\n    std::shared_ptr&lt; Shape &gt; shape,\n    QString filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-write_pca_scores","title":"function write_pca_scores","text":"<pre><code>static bool write_pca_scores(\n    ShapeWorksStudioApp * app,\n    ParticleShapeStatistics * stats,\n    QString filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ExportUtils.html#function-get_mesh_file_filter","title":"function get_mesh_file_filter","text":"<pre><code>static QString get_mesh_file_filter()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html","title":"shapeworks::FreeFormConstraint","text":"<p>More...</p> <p><code>#include &lt;FreeFormConstraint.h&gt;</code></p> <p>Inherits from shapeworks::Constraint</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#public-functions","title":"Public Functions","text":"Name FreeFormConstraint() void setMesh(std::shared_ptr&lt; shapeworks::Mesh &gt; mesh)Sets the mesh that defines the FFC. std::shared_ptr&lt; shapeworks::Mesh &gt; getMesh()Returns the mesh that defines the FFC. bool readyForOptimize() constPrepares for optimize. virtual bool isViolated(const Eigen::Vector3d &amp; pt) const overrideReturns if pt in Eigen format is violated by the constraint. virtual void print() const overridePrints the constraint neatly. virtual Eigen::Vector3d constraintGradient(const Eigen::Vector3d &amp; pt) const overrideReturns the gradient of the constraint. virtual double constraintEval(const Eigen::Vector3d &amp; pt) const overrideReturns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. void setDefinition(vtkSmartPointer&lt; vtkPolyData &gt; polyData)Set polydata where per-vertex free form constraint definition exists. vtkSmartPointer&lt; vtkPolyData &gt; getDefinition()Get polydata where per-vertex free form constraint definition exists. void applyToPolyData(vtkSmartPointer&lt; vtkPolyData &gt; polyData)Apply the free form constraint to a polydata. std::vector&lt; std::vector&lt; Eigen::Vector3d &gt; &gt; &amp; boundaries() Eigen::Vector3d getQueryPoint() void setQueryPoint(Eigen::Vector3d queryPoint) void computeBoundaries() void setInoutPolyData(vtkSmartPointer&lt; vtkPolyData &gt; polyData)Set the in/out polydata. vtkSmartPointer&lt; vtkPolyData &gt; getInoutPolyData()Get the in/out polydata. void createInoutPolyData()Create the in/out poly data from the definition poly data. bool isSet()Return if this FFC is set or not. void setPainted(bool painted)Set if this FFC has paint on it or not. void reset()Reset to initial state. void computeGradientFields(std::shared_ptr&lt; Mesh &gt; mesh)Compute gradient fields for a mesh. void convertLegacyFFC(vtkSmartPointer&lt; vtkPolyData &gt; polyData)Convert legacy FFC to new format."},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Constraint</p> Name void setMus(std::vector&lt; double &gt; inmu)Initializes mu. std::vector&lt; double &gt; getMus()Gets mu. void updateMu(const Eigen::Vector3d &amp; pt, double C, size_t index)Updates the value of mu according to the augmented lagrangian update. Eigen::Vector3d lagragianGradient(const Eigen::Vector3d &amp; pt, double C, size_t index) constComputes the lagrangian gradient based on lagrangian inequality equations. NOTE: Not actually lagrangian. We are using quadratic penalty and not lagrangian because it works better. <p>Protected Functions inherited from shapeworks::Constraint</p> Name int sgn(double val)Returns the sign of the double. <p>Protected Attributes inherited from shapeworks::Constraint</p> Name std::vector&lt; double &gt; mus_ Mu is the lagrangian momentum term."},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::FreeFormConstraint;\n</code></pre> <p>Encapsulate functionality related to free-form constraints (FFC). Inherits from Constraint. See [Constraint.h] for more information </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-freeformconstraint","title":"function FreeFormConstraint","text":"<pre><code>inline FreeFormConstraint()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-setmesh","title":"function setMesh","text":"<pre><code>inline void setMesh(\n    std::shared_ptr&lt; shapeworks::Mesh &gt; mesh\n)\n</code></pre> <p>Sets the mesh that defines the FFC. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-getmesh","title":"function getMesh","text":"<pre><code>inline std::shared_ptr&lt; shapeworks::Mesh &gt; getMesh()\n</code></pre> <p>Returns the mesh that defines the FFC. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-readyforoptimize","title":"function readyForOptimize","text":"<pre><code>bool readyForOptimize() const\n</code></pre> <p>Prepares for optimize. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-isviolated","title":"function isViolated","text":"<pre><code>virtual bool isViolated(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns if pt in Eigen format is violated by the constraint. </p> <p>Reimplements: shapeworks::Constraint::isViolated</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-print","title":"function print","text":"<pre><code>inline virtual void print() const override\n</code></pre> <p>Prints the constraint neatly. </p> <p>Reimplements: shapeworks::Constraint::print</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-constraintgradient","title":"function constraintGradient","text":"<pre><code>inline virtual Eigen::Vector3d constraintGradient(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns the gradient of the constraint. </p> <p>Reimplements: shapeworks::Constraint::constraintGradient</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-constrainteval","title":"function constraintEval","text":"<pre><code>inline virtual double constraintEval(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. </p> <p>Reimplements: shapeworks::Constraint::constraintEval</p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-setdefinition","title":"function setDefinition","text":"<pre><code>void setDefinition(\n    vtkSmartPointer&lt; vtkPolyData &gt; polyData\n)\n</code></pre> <p>Set polydata where per-vertex free form constraint definition exists. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-getdefinition","title":"function getDefinition","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; getDefinition()\n</code></pre> <p>Get polydata where per-vertex free form constraint definition exists. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-applytopolydata","title":"function applyToPolyData","text":"<pre><code>void applyToPolyData(\n    vtkSmartPointer&lt; vtkPolyData &gt; polyData\n)\n</code></pre> <p>Apply the free form constraint to a polydata. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-boundaries","title":"function boundaries","text":"<pre><code>std::vector&lt; std::vector&lt; Eigen::Vector3d &gt; &gt; &amp; boundaries()\n</code></pre> <p>Deprecated: </p> <p>Access the set of boundaries </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-getquerypoint","title":"function getQueryPoint","text":"<pre><code>inline Eigen::Vector3d getQueryPoint()\n</code></pre> <p>Deprecated: </p> <p>Get query (inside) point </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-setquerypoint","title":"function setQueryPoint","text":"<pre><code>inline void setQueryPoint(\n    Eigen::Vector3d queryPoint\n)\n</code></pre> <p>Deprecated: </p> <p>Set query (inside) point </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-computeboundaries","title":"function computeBoundaries","text":"<pre><code>void computeBoundaries()\n</code></pre> <p>Deprecated: </p> <p>Compute boundaries from definition polydata with ffc_paint scalars </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-setinoutpolydata","title":"function setInoutPolyData","text":"<pre><code>inline void setInoutPolyData(\n    vtkSmartPointer&lt; vtkPolyData &gt; polyData\n)\n</code></pre> <p>Set the in/out polydata. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-getinoutpolydata","title":"function getInoutPolyData","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; getInoutPolyData()\n</code></pre> <p>Get the in/out polydata. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-createinoutpolydata","title":"function createInoutPolyData","text":"<pre><code>void createInoutPolyData()\n</code></pre> <p>Create the in/out poly data from the definition poly data. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-isset","title":"function isSet","text":"<pre><code>bool isSet()\n</code></pre> <p>Return if this FFC is set or not. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-setpainted","title":"function setPainted","text":"<pre><code>void setPainted(\n    bool painted\n)\n</code></pre> <p>Set if this FFC has paint on it or not. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre> <p>Reset to initial state. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-computegradientfields","title":"function computeGradientFields","text":"<pre><code>void computeGradientFields(\n    std::shared_ptr&lt; Mesh &gt; mesh\n)\n</code></pre> <p>Compute gradient fields for a mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1FreeFormConstraint.html#function-convertlegacyffc","title":"function convertLegacyFFC","text":"<pre><code>void convertLegacyFFC(\n    vtkSmartPointer&lt; vtkPolyData &gt; polyData\n)\n</code></pre> <p>Convert legacy FFC to new format. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html","title":"shapeworks::GenericContainer","text":"<p>This class seems to be only a wrapper around std::vector implementing ITK DataObject (for smart pointer?)  More...</p> <p><code>#include &lt;GenericContainer.h&gt;</code></p> <p>Inherits from itk::DataObject</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#public-types","title":"Public Types","text":"Name typedef T DataType typedef GenericContainer Self typedef DataObject Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(GenericContainer , itk::DataObject ) T &amp; operator[](size_t k) T &amp; Get(size_t k) unsigned long int GetSize() const"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#protected-functions","title":"Protected Functions","text":"Name GenericContainer() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const virtual ~GenericContainer()"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::GenericContainer;\n</code></pre> <p>This class seems to be only a wrapper around std::vector implementing ITK DataObject (for smart pointer?) </p> <p>One difference being that the set operator will expand the vector if the index is out of bounds. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef T shapeworks::GenericContainer&lt; T &gt;::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef GenericContainer shapeworks::GenericContainer&lt; T &gt;::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef DataObject shapeworks::GenericContainer&lt; T &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::GenericContainer&lt; T &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::GenericContainer&lt; T &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::GenericContainer&lt; T &gt;::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    GenericContainer ,\n    itk::DataObject \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-operator","title":"function operator[]","text":"<pre><code>inline T &amp; operator[](\n    size_t k\n)\n</code></pre> <p>Returns a reference to the object associated with index k. If the index k does not already exist, this method inserts a new entry for k. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-get","title":"function Get","text":"<pre><code>inline T &amp; Get(\n    size_t k\n)\n</code></pre> <p>Convenience method since all usage of this function is via a pointer, leading ugly syntax like -&gt;operator </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-getsize","title":"function GetSize","text":"<pre><code>inline unsigned long int GetSize() const\n</code></pre> <p>Number of objects in the container. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-genericcontainer","title":"function GenericContainer","text":"<pre><code>inline GenericContainer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainer.html#function-genericcontainer_1","title":"function ~GenericContainer","text":"<pre><code>inline virtual ~GenericContainer()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html","title":"shapeworks::GenericContainerArray","text":"<p>This class appears to be an array of GenericContainers (e.g. std::vector) that implements the Observer interface. The array size tracks the number of domains in the system. E.g. one per domain.  More...</p> <p><code>#include &lt;GenericContainerArray.h&gt;</code></p> <p>Inherits from std::vector&lt; GenericContainer&lt; T &gt;::Pointer &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#public-types","title":"Public Types","text":"Name typedef T DataType typedef GenericContainerArray Self typedef Observer Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(GenericContainerArray , Observer ) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void ZeroAllValues()"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#protected-functions","title":"Protected Functions","text":"Name GenericContainerArray() virtual ~GenericContainerArray() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::GenericContainerArray;\n</code></pre> <p>This class appears to be an array of GenericContainers (e.g. std::vector) that implements the Observer interface. The array size tracks the number of domains in the system. E.g. one per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef T shapeworks::GenericContainerArray&lt; T &gt;::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef GenericContainerArray shapeworks::GenericContainerArray&lt; T &gt;::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Observer shapeworks::GenericContainerArray&lt; T &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::GenericContainerArray&lt; T &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::GenericContainerArray&lt; T &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::GenericContainerArray&lt; T &gt;::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    GenericContainerArray ,\n    Observer \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-zeroallvalues","title":"function ZeroAllValues","text":"<pre><code>inline void ZeroAllValues()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-genericcontainerarray","title":"function GenericContainerArray","text":"<pre><code>inline GenericContainerArray()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-genericcontainerarray_1","title":"function ~GenericContainerArray","text":"<pre><code>inline virtual ~GenericContainerArray()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GenericContainerArray.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html","title":"shapeworks::GradientDescentOptimizer","text":"<p>Optimizes particle system positions using gradient descent.  More...</p> <p><code>#include &lt;GradientDescentOptimizer.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-types","title":"Public Types","text":"Name using VectorFunction::VectorType VectorType Numerical vector type. using ParticleSystem::PointType PointType Point type."},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-functions","title":"Public Functions","text":"Name void start_optimization()Start the optimization. void start_adaptive_gauss_seidel_optimization() void set_early_stopping_config(const EarlyStoppingConfig &amp; config) void initialize_early_stopping_score_function(const ParticleSystem * p) void augmented_lagrangian_constraints(VectorType &amp; gradient, const PointType &amp; pt, const size_t &amp; dom, const double &amp; maximum_update_allowed, size_t index) void stop_optimization()Sets a flag that aborts the start_optimization method after the current iteration. void abort_processing() unsigned int get_number_of_iterations() constGet the number of iterations performed by the solver. void set_number_of_iterations(unsigned int val)Set the number of iterations performed by the solver. void set_verbosity(unsigned int val)Set the verbosity level. unsigned int get_verbosity() constGet the verbosity level. double get_time_step() constEach update is scaled by this value. void set_time_step(double val)Set the time step parameter for the update. unsigned int get_maximum_number_of_iterations() constGet the maximum number of iterations allowed. void set_maximum_number_of_iterations(unsigned int val)Set the maximum number of iterations allowed. double get_tolerance() constGet the precision/tolerance of the solution. void set_tolerance(double val)Set the precision/tolerance of the solution. ParticleSystem * get_particle_system()Get the ParticleSystem modified by this optimizer. const ParticleSystem * get_particle_system() constGet the ParticleSystem modified by this optimizer (const version) void set_particle_system(ParticleSystem * val)Set the ParticleSystem modified by this optimizer. std::shared_ptr&lt; VectorFunction &gt; get_gradient_function()Get the gradient function used by this optimizer. std::shared_ptr&lt; const VectorFunction &gt; get_gradient_function() constGet the gradient function used by this optimizer (const version) void set_gradient_function(std::shared_ptr&lt; VectorFunction &gt; val)Set the gradient function used by this optimizer. void set_initialization_mode(bool b)Determines if this is an initialization (true) or an optimization (false) void set_check_iterations(size_t si)Sets the number of iterations when we check for convergence. void set_initialization_start_scaling_factor(double si)Sets the scaling factor at the beginning of the initialization. void set_iteration_callback(std::function&lt; void()&gt; callback)Set a callback to be called after each iteration. std::function&lt; void()&gt; get_iteration_callback() constGet the current iteration callback. GradientDescentOptimizer()Constructor. ~GradientDescentOptimizer() =defaultDestructor."},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-attributes","title":"Public Attributes","text":"Name constexpr unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::GradientDescentOptimizer;\n</code></pre> <p>Optimizes particle system positions using gradient descent. </p> <p>This class optimizes a list of particle system positions with respect to a specified energy function using a simple gradient descent strategy. A function which computes the gradient of the function with respect to particle position must be specified. The optimization performs Jacobi updates (each particle position is changed as soon as its new position is computed). </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::GradientDescentOptimizer::VectorType =  VectorFunction::VectorType;\n</code></pre> <p>Numerical vector type. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::GradientDescentOptimizer::PointType =  ParticleSystem::PointType;\n</code></pre> <p>Point type. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-start_optimization","title":"function start_optimization","text":"<pre><code>inline void start_optimization()\n</code></pre> <p>Start the optimization. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-start_adaptive_gauss_seidel_optimization","title":"function start_adaptive_gauss_seidel_optimization","text":"<pre><code>void start_adaptive_gauss_seidel_optimization()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_early_stopping_config","title":"function set_early_stopping_config","text":"<pre><code>void set_early_stopping_config(\n    const EarlyStoppingConfig &amp; config\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-initialize_early_stopping_score_function","title":"function initialize_early_stopping_score_function","text":"<pre><code>void initialize_early_stopping_score_function(\n    const ParticleSystem * p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-augmented_lagrangian_constraints","title":"function augmented_lagrangian_constraints","text":"<pre><code>void augmented_lagrangian_constraints(\n    VectorType &amp; gradient,\n    const PointType &amp; pt,\n    const size_t &amp; dom,\n    const double &amp; maximum_update_allowed,\n    size_t index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-stop_optimization","title":"function stop_optimization","text":"<pre><code>inline void stop_optimization()\n</code></pre> <p>Sets a flag that aborts the start_optimization method after the current iteration. </p> <p>Stop the optimization </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-abort_processing","title":"function abort_processing","text":"<pre><code>inline void abort_processing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_number_of_iterations","title":"function get_number_of_iterations","text":"<pre><code>inline unsigned int get_number_of_iterations() const\n</code></pre> <p>Get the number of iterations performed by the solver. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_number_of_iterations","title":"function set_number_of_iterations","text":"<pre><code>inline void set_number_of_iterations(\n    unsigned int val\n)\n</code></pre> <p>Set the number of iterations performed by the solver. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_verbosity","title":"function set_verbosity","text":"<pre><code>inline void set_verbosity(\n    unsigned int val\n)\n</code></pre> <p>Set the verbosity level. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_verbosity","title":"function get_verbosity","text":"<pre><code>inline unsigned int get_verbosity() const\n</code></pre> <p>Get the verbosity level. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_time_step","title":"function get_time_step","text":"<pre><code>inline double get_time_step() const\n</code></pre> <p>Each update is scaled by this value. </p> <p>Get the time step parameter for the update </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_time_step","title":"function set_time_step","text":"<pre><code>inline void set_time_step(\n    double val\n)\n</code></pre> <p>Set the time step parameter for the update. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_maximum_number_of_iterations","title":"function get_maximum_number_of_iterations","text":"<pre><code>inline unsigned int get_maximum_number_of_iterations() const\n</code></pre> <p>Get the maximum number of iterations allowed. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_maximum_number_of_iterations","title":"function set_maximum_number_of_iterations","text":"<pre><code>inline void set_maximum_number_of_iterations(\n    unsigned int val\n)\n</code></pre> <p>Set the maximum number of iterations allowed. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_tolerance","title":"function get_tolerance","text":"<pre><code>inline double get_tolerance() const\n</code></pre> <p>Get the precision/tolerance of the solution. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_tolerance","title":"function set_tolerance","text":"<pre><code>inline void set_tolerance(\n    double val\n)\n</code></pre> <p>Set the precision/tolerance of the solution. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_particle_system","title":"function get_particle_system","text":"<pre><code>inline ParticleSystem * get_particle_system()\n</code></pre> <p>Get the ParticleSystem modified by this optimizer. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_particle_system_1","title":"function get_particle_system","text":"<pre><code>inline const ParticleSystem * get_particle_system() const\n</code></pre> <p>Get the ParticleSystem modified by this optimizer (const version) </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_particle_system","title":"function set_particle_system","text":"<pre><code>inline void set_particle_system(\n    ParticleSystem * val\n)\n</code></pre> <p>Set the ParticleSystem modified by this optimizer. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_gradient_function","title":"function get_gradient_function","text":"<pre><code>inline std::shared_ptr&lt; VectorFunction &gt; get_gradient_function()\n</code></pre> <p>Get the gradient function used by this optimizer. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_gradient_function_1","title":"function get_gradient_function","text":"<pre><code>inline std::shared_ptr&lt; const VectorFunction &gt; get_gradient_function() const\n</code></pre> <p>Get the gradient function used by this optimizer (const version) </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_gradient_function","title":"function set_gradient_function","text":"<pre><code>inline void set_gradient_function(\n    std::shared_ptr&lt; VectorFunction &gt; val\n)\n</code></pre> <p>Set the gradient function used by this optimizer. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_initialization_mode","title":"function set_initialization_mode","text":"<pre><code>inline void set_initialization_mode(\n    bool b\n)\n</code></pre> <p>Determines if this is an initialization (true) or an optimization (false) </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_check_iterations","title":"function set_check_iterations","text":"<pre><code>inline void set_check_iterations(\n    size_t si\n)\n</code></pre> <p>Sets the number of iterations when we check for convergence. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_initialization_start_scaling_factor","title":"function set_initialization_start_scaling_factor","text":"<pre><code>inline void set_initialization_start_scaling_factor(\n    double si\n)\n</code></pre> <p>Sets the scaling factor at the beginning of the initialization. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-set_iteration_callback","title":"function set_iteration_callback","text":"<pre><code>inline void set_iteration_callback(\n    std::function&lt; void()&gt; callback\n)\n</code></pre> <p>Set a callback to be called after each iteration. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-get_iteration_callback","title":"function get_iteration_callback","text":"<pre><code>inline std::function&lt; void()&gt; get_iteration_callback() const\n</code></pre> <p>Get the current iteration callback. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-gradientdescentoptimizer","title":"function GradientDescentOptimizer","text":"<pre><code>GradientDescentOptimizer()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#function-gradientdescentoptimizer_1","title":"function ~GradientDescentOptimizer","text":"<pre><code>~GradientDescentOptimizer() =default\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GradientDescentOptimizer.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr unsigned int Dimension = 3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html","title":"shapeworks::Groom","text":"<p>High level groom API.  More...</p> <p><code>#include &lt;Groom.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#public-functions","title":"Public Functions","text":"Name Groom(ProjectHandle project) bool run()Run the grooming. void abort()Set abort as soon as possible. bool get_aborted()Return if grooming was aborted. double compute_landmark_distance(vtkSmartPointer&lt; vtkPoints &gt; one, vtkSmartPointer&lt; vtkPoints &gt; two)Util to compute square distance between paired landmarks. vtkSmartPointer&lt; vtkMatrix4x4 &gt; compute_landmark_transform(vtkSmartPointer&lt; vtkPoints &gt; source, vtkSmartPointer&lt; vtkPoints &gt; target)Util to compute landmark transform."},{"location":"api/Classes/classshapeworks_1_1Groom.html#protected-attributes","title":"Protected Attributes","text":"Name std::atomic&lt; float &gt; progress_ std::atomic&lt; int &gt; total_ops_ std::atomic&lt; int &gt; progress_counter_"},{"location":"api/Classes/classshapeworks_1_1Groom.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Groom;\n</code></pre> <p>High level groom API. </p> <p>The Groom class operates on a Project. It is used by Studio and other tools to perform Grooming operations. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-groom","title":"function Groom","text":"<pre><code>Groom(\n    ProjectHandle project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-run","title":"function run","text":"<pre><code>bool run()\n</code></pre> <p>Run the grooming. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-abort","title":"function abort","text":"<pre><code>void abort()\n</code></pre> <p>Set abort as soon as possible. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-get_aborted","title":"function get_aborted","text":"<pre><code>bool get_aborted()\n</code></pre> <p>Return if grooming was aborted. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-compute_landmark_distance","title":"function compute_landmark_distance","text":"<pre><code>static double compute_landmark_distance(\n    vtkSmartPointer&lt; vtkPoints &gt; one,\n    vtkSmartPointer&lt; vtkPoints &gt; two\n)\n</code></pre> <p>Util to compute square distance between paired landmarks. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#function-compute_landmark_transform","title":"function compute_landmark_transform","text":"<pre><code>static vtkSmartPointer&lt; vtkMatrix4x4 &gt; compute_landmark_transform(\n    vtkSmartPointer&lt; vtkPoints &gt; source,\n    vtkSmartPointer&lt; vtkPoints &gt; target\n)\n</code></pre> <p>Util to compute landmark transform. </p>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Groom.html#variable-progress_","title":"variable progress_","text":"<pre><code>std::atomic&lt; float &gt; progress_ = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#variable-total_ops_","title":"variable total_ops_","text":"<pre><code>std::atomic&lt; int &gt; total_ops_ = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Groom.html#variable-progress_counter_","title":"variable progress_counter_","text":"<pre><code>std::atomic&lt; int &gt; progress_counter_ = 0;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GroomCommandGroup.html","title":"shapeworks::GroomCommandGroup","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1GroomCommandGroup.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1GroomCommandGroup.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1GroomCommandGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomCommandGroup.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html","title":"shapeworks::GroomParameters","text":"<p>More...</p> <p><code>#include &lt;GroomParameters.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-classes","title":"Public Classes","text":"Name struct SharedBoundary"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-types","title":"Public Types","text":"Name enum class MeshSmoothingOption enum class AlignmentOption"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-functions","title":"Public Functions","text":"Name GroomParameters(ProjectHandle project, std::string domain_name =\"\") void set_domain_name(std::string domain_name) void save_to_project() std::string get_groom_output_prefix() void set_groom_output_prefix(std::string prefix) bool get_groom_all_domains_the_same() void set_groom_all_domains_the_same(bool value) bool get_alignment_enabled() void set_alignment_enabled(bool value) std::string get_alignment_method() void set_alignment_method(std::string method) int get_alignment_reference() void set_alignment_reference(int reference) int get_alignment_reference_chosen() void set_alignment_reference_chosen(int reference) int get_alignment_subset_size() void set_alignment_subset_size(int size) bool get_isolate_tool() void set_isolate_tool(bool value) bool get_fill_holes_tool() void set_fill_holes_tool(bool value) bool get_fill_mesh_holes_tool() void set_fill_mesh_holes_tool(bool value) bool get_auto_pad_tool() void set_auto_pad_tool(bool value) int get_padding_amount() void set_padding_amount(int padding_amount) bool get_antialias_tool() void set_antialias_tool(bool value) int get_antialias_iterations() void set_antialias_iterations(int iterations) bool get_blur_tool() void set_blur_tool(bool value) double get_blur_amount() void set_blur_amount(double blur_amount) bool get_fast_marching() void set_fast_marching(bool value) bool get_mesh_smooth() void set_mesh_smooth(bool value) std::string get_mesh_smoothing_method() void set_mesh_smoothing_method(std::string method) int get_mesh_vtk_laplacian_iterations() void set_mesh_vtk_laplacian_iterations(int iterations) double get_mesh_vtk_laplacian_relaxation() void set_mesh_vtk_laplacian_relaxation(double relaxation) int get_mesh_vtk_windowed_sinc_iterations() void set_mesh_vtk_windowed_sinc_iterations(int iterations) double get_mesh_vtk_windowed_sinc_passband() void set_mesh_vtk_windowed_sinc_passband(double passband) bool get_use_icp() bool get_use_center() bool get_use_landmarks() bool get_crop() void set_crop(bool crop) bool get_convert_to_mesh() void set_convert_to_mesh(bool value) bool get_reflect() void set_reflect(bool reflect) std::string get_reflect_column() void set_reflect_column(std::string column) std::string get_reflect_choice() void set_reflect_choice(std::string choice) std::string get_reflect_axis() void set_reflect_axis(std::string axies) bool get_resample() void set_resample(bool resample) bool get_isotropic() void set_isotropic(bool isotropic) double get_iso_spacing() void set_iso_spacing(double spacing) std::vector&lt; double &gt; get_spacing() void set_spacing(std::vector&lt; double &gt; spacing) bool get_remesh() void set_remesh(bool remesh) bool get_remesh_percent_mode() void set_remesh_percent_mode(bool mode) double get_remesh_percent() void set_remesh_percent(double percent) int get_remesh_num_vertices() void set_remesh_num_vertices(int num_vertices) double get_remesh_gradation() void set_remesh_gradation(double gradation) bool get_skip_grooming() void set_skip_grooming(bool skip) bool get_shared_boundaries_enabled() void set_shared_boundaries_enabled(bool enabled) std::vector&lt; SharedBoundary &gt; get_shared_boundaries() void set_shared_boundaries(const std::vector&lt; SharedBoundary &gt; &amp; boundaries) void add_shared_boundary(const std::string &amp; first_domain, const std::string &amp; second_domain, double tolerance) void remove_shared_boundary(size_t index) void clear_shared_boundaries() void restore_defaults() Parameters get_parameters() const"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-attributes","title":"Public Attributes","text":"Name const std::string GROOM_SMOOTH_VTK_LAPLACIAN_C const std::string GROOM_SMOOTH_VTK_WINDOWED_SINC_C const std::string GROOM_ALIGNMENT_CENTER_C const std::string GROOM_ALIGNMENT_ICP_C const std::string GROOM_ALIGNMENT_LANDMARK_C"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::GroomParameters;\n</code></pre> <p>This class encapsulated processing of Groom parameters </p>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#enum-meshsmoothingoption","title":"enum MeshSmoothingOption","text":"Enumerator Value Description laplacian sinc"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#enum-alignmentoption","title":"enum AlignmentOption","text":"Enumerator Value Description none center icp"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-groomparameters","title":"function GroomParameters","text":"<pre><code>explicit GroomParameters(\n    ProjectHandle project,\n    std::string domain_name =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_domain_name","title":"function set_domain_name","text":"<pre><code>void set_domain_name(\n    std::string domain_name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-save_to_project","title":"function save_to_project","text":"<pre><code>void save_to_project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_groom_output_prefix","title":"function get_groom_output_prefix","text":"<pre><code>std::string get_groom_output_prefix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_groom_output_prefix","title":"function set_groom_output_prefix","text":"<pre><code>void set_groom_output_prefix(\n    std::string prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_groom_all_domains_the_same","title":"function get_groom_all_domains_the_same","text":"<pre><code>bool get_groom_all_domains_the_same()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_groom_all_domains_the_same","title":"function set_groom_all_domains_the_same","text":"<pre><code>void set_groom_all_domains_the_same(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_alignment_enabled","title":"function get_alignment_enabled","text":"<pre><code>bool get_alignment_enabled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_alignment_enabled","title":"function set_alignment_enabled","text":"<pre><code>void set_alignment_enabled(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_alignment_method","title":"function get_alignment_method","text":"<pre><code>std::string get_alignment_method()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_alignment_method","title":"function set_alignment_method","text":"<pre><code>void set_alignment_method(\n    std::string method\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_alignment_reference","title":"function get_alignment_reference","text":"<pre><code>int get_alignment_reference()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_alignment_reference","title":"function set_alignment_reference","text":"<pre><code>void set_alignment_reference(\n    int reference\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_alignment_reference_chosen","title":"function get_alignment_reference_chosen","text":"<pre><code>int get_alignment_reference_chosen()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_alignment_reference_chosen","title":"function set_alignment_reference_chosen","text":"<pre><code>void set_alignment_reference_chosen(\n    int reference\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_alignment_subset_size","title":"function get_alignment_subset_size","text":"<pre><code>int get_alignment_subset_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_alignment_subset_size","title":"function set_alignment_subset_size","text":"<pre><code>void set_alignment_subset_size(\n    int size\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_isolate_tool","title":"function get_isolate_tool","text":"<pre><code>bool get_isolate_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_isolate_tool","title":"function set_isolate_tool","text":"<pre><code>void set_isolate_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_fill_holes_tool","title":"function get_fill_holes_tool","text":"<pre><code>bool get_fill_holes_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_fill_holes_tool","title":"function set_fill_holes_tool","text":"<pre><code>void set_fill_holes_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_fill_mesh_holes_tool","title":"function get_fill_mesh_holes_tool","text":"<pre><code>bool get_fill_mesh_holes_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_fill_mesh_holes_tool","title":"function set_fill_mesh_holes_tool","text":"<pre><code>void set_fill_mesh_holes_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_auto_pad_tool","title":"function get_auto_pad_tool","text":"<pre><code>bool get_auto_pad_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_auto_pad_tool","title":"function set_auto_pad_tool","text":"<pre><code>void set_auto_pad_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_padding_amount","title":"function get_padding_amount","text":"<pre><code>int get_padding_amount()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_padding_amount","title":"function set_padding_amount","text":"<pre><code>void set_padding_amount(\n    int padding_amount\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_antialias_tool","title":"function get_antialias_tool","text":"<pre><code>bool get_antialias_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_antialias_tool","title":"function set_antialias_tool","text":"<pre><code>void set_antialias_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_antialias_iterations","title":"function get_antialias_iterations","text":"<pre><code>int get_antialias_iterations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_antialias_iterations","title":"function set_antialias_iterations","text":"<pre><code>void set_antialias_iterations(\n    int iterations\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_blur_tool","title":"function get_blur_tool","text":"<pre><code>bool get_blur_tool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_blur_tool","title":"function set_blur_tool","text":"<pre><code>void set_blur_tool(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_blur_amount","title":"function get_blur_amount","text":"<pre><code>double get_blur_amount()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_blur_amount","title":"function set_blur_amount","text":"<pre><code>void set_blur_amount(\n    double blur_amount\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_fast_marching","title":"function get_fast_marching","text":"<pre><code>bool get_fast_marching()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_fast_marching","title":"function set_fast_marching","text":"<pre><code>void set_fast_marching(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_smooth","title":"function get_mesh_smooth","text":"<pre><code>bool get_mesh_smooth()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_smooth","title":"function set_mesh_smooth","text":"<pre><code>void set_mesh_smooth(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_smoothing_method","title":"function get_mesh_smoothing_method","text":"<pre><code>std::string get_mesh_smoothing_method()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_smoothing_method","title":"function set_mesh_smoothing_method","text":"<pre><code>void set_mesh_smoothing_method(\n    std::string method\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_vtk_laplacian_iterations","title":"function get_mesh_vtk_laplacian_iterations","text":"<pre><code>int get_mesh_vtk_laplacian_iterations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_vtk_laplacian_iterations","title":"function set_mesh_vtk_laplacian_iterations","text":"<pre><code>void set_mesh_vtk_laplacian_iterations(\n    int iterations\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_vtk_laplacian_relaxation","title":"function get_mesh_vtk_laplacian_relaxation","text":"<pre><code>double get_mesh_vtk_laplacian_relaxation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_vtk_laplacian_relaxation","title":"function set_mesh_vtk_laplacian_relaxation","text":"<pre><code>void set_mesh_vtk_laplacian_relaxation(\n    double relaxation\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_vtk_windowed_sinc_iterations","title":"function get_mesh_vtk_windowed_sinc_iterations","text":"<pre><code>int get_mesh_vtk_windowed_sinc_iterations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_vtk_windowed_sinc_iterations","title":"function set_mesh_vtk_windowed_sinc_iterations","text":"<pre><code>void set_mesh_vtk_windowed_sinc_iterations(\n    int iterations\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_mesh_vtk_windowed_sinc_passband","title":"function get_mesh_vtk_windowed_sinc_passband","text":"<pre><code>double get_mesh_vtk_windowed_sinc_passband()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_mesh_vtk_windowed_sinc_passband","title":"function set_mesh_vtk_windowed_sinc_passband","text":"<pre><code>void set_mesh_vtk_windowed_sinc_passband(\n    double passband\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_use_icp","title":"function get_use_icp","text":"<pre><code>bool get_use_icp()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_use_center","title":"function get_use_center","text":"<pre><code>bool get_use_center()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_use_landmarks","title":"function get_use_landmarks","text":"<pre><code>bool get_use_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_crop","title":"function get_crop","text":"<pre><code>bool get_crop()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_crop","title":"function set_crop","text":"<pre><code>void set_crop(\n    bool crop\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_convert_to_mesh","title":"function get_convert_to_mesh","text":"<pre><code>bool get_convert_to_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_convert_to_mesh","title":"function set_convert_to_mesh","text":"<pre><code>void set_convert_to_mesh(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_reflect","title":"function get_reflect","text":"<pre><code>bool get_reflect()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_reflect","title":"function set_reflect","text":"<pre><code>void set_reflect(\n    bool reflect\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_reflect_column","title":"function get_reflect_column","text":"<pre><code>std::string get_reflect_column()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_reflect_column","title":"function set_reflect_column","text":"<pre><code>void set_reflect_column(\n    std::string column\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_reflect_choice","title":"function get_reflect_choice","text":"<pre><code>std::string get_reflect_choice()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_reflect_choice","title":"function set_reflect_choice","text":"<pre><code>void set_reflect_choice(\n    std::string choice\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_reflect_axis","title":"function get_reflect_axis","text":"<pre><code>std::string get_reflect_axis()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_reflect_axis","title":"function set_reflect_axis","text":"<pre><code>void set_reflect_axis(\n    std::string axies\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_resample","title":"function get_resample","text":"<pre><code>bool get_resample()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_resample","title":"function set_resample","text":"<pre><code>void set_resample(\n    bool resample\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_isotropic","title":"function get_isotropic","text":"<pre><code>bool get_isotropic()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_isotropic","title":"function set_isotropic","text":"<pre><code>void set_isotropic(\n    bool isotropic\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_iso_spacing","title":"function get_iso_spacing","text":"<pre><code>double get_iso_spacing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_iso_spacing","title":"function set_iso_spacing","text":"<pre><code>void set_iso_spacing(\n    double spacing\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_spacing","title":"function get_spacing","text":"<pre><code>std::vector&lt; double &gt; get_spacing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_spacing","title":"function set_spacing","text":"<pre><code>void set_spacing(\n    std::vector&lt; double &gt; spacing\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_remesh","title":"function get_remesh","text":"<pre><code>bool get_remesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_remesh","title":"function set_remesh","text":"<pre><code>void set_remesh(\n    bool remesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_remesh_percent_mode","title":"function get_remesh_percent_mode","text":"<pre><code>bool get_remesh_percent_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_remesh_percent_mode","title":"function set_remesh_percent_mode","text":"<pre><code>void set_remesh_percent_mode(\n    bool mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_remesh_percent","title":"function get_remesh_percent","text":"<pre><code>double get_remesh_percent()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_remesh_percent","title":"function set_remesh_percent","text":"<pre><code>void set_remesh_percent(\n    double percent\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_remesh_num_vertices","title":"function get_remesh_num_vertices","text":"<pre><code>int get_remesh_num_vertices()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_remesh_num_vertices","title":"function set_remesh_num_vertices","text":"<pre><code>void set_remesh_num_vertices(\n    int num_vertices\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_remesh_gradation","title":"function get_remesh_gradation","text":"<pre><code>double get_remesh_gradation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_remesh_gradation","title":"function set_remesh_gradation","text":"<pre><code>void set_remesh_gradation(\n    double gradation\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_skip_grooming","title":"function get_skip_grooming","text":"<pre><code>bool get_skip_grooming()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_skip_grooming","title":"function set_skip_grooming","text":"<pre><code>void set_skip_grooming(\n    bool skip\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_shared_boundaries_enabled","title":"function get_shared_boundaries_enabled","text":"<pre><code>bool get_shared_boundaries_enabled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_shared_boundaries_enabled","title":"function set_shared_boundaries_enabled","text":"<pre><code>void set_shared_boundaries_enabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_shared_boundaries","title":"function get_shared_boundaries","text":"<pre><code>std::vector&lt; SharedBoundary &gt; get_shared_boundaries()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-set_shared_boundaries","title":"function set_shared_boundaries","text":"<pre><code>void set_shared_boundaries(\n    const std::vector&lt; SharedBoundary &gt; &amp; boundaries\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-add_shared_boundary","title":"function add_shared_boundary","text":"<pre><code>void add_shared_boundary(\n    const std::string &amp; first_domain,\n    const std::string &amp; second_domain,\n    double tolerance\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-remove_shared_boundary","title":"function remove_shared_boundary","text":"<pre><code>void remove_shared_boundary(\n    size_t index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-clear_shared_boundaries","title":"function clear_shared_boundaries","text":"<pre><code>void clear_shared_boundaries()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-restore_defaults","title":"function restore_defaults","text":"<pre><code>void restore_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>inline Parameters get_parameters() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#variable-groom_smooth_vtk_laplacian_c","title":"variable GROOM_SMOOTH_VTK_LAPLACIAN_C","text":"<pre><code>static const std::string GROOM_SMOOTH_VTK_LAPLACIAN_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#variable-groom_smooth_vtk_windowed_sinc_c","title":"variable GROOM_SMOOTH_VTK_WINDOWED_SINC_C","text":"<pre><code>static const std::string GROOM_SMOOTH_VTK_WINDOWED_SINC_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#variable-groom_alignment_center_c","title":"variable GROOM_ALIGNMENT_CENTER_C","text":"<pre><code>static const std::string GROOM_ALIGNMENT_CENTER_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#variable-groom_alignment_icp_c","title":"variable GROOM_ALIGNMENT_ICP_C","text":"<pre><code>static const std::string GROOM_ALIGNMENT_ICP_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomParameters.html#variable-groom_alignment_landmark_c","title":"variable GROOM_ALIGNMENT_LANDMARK_C","text":"<pre><code>static const std::string GROOM_ALIGNMENT_LANDMARK_C;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html","title":"shapeworks::GroomTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-slots","title":"Public Slots","text":"Name void on_antialias_checkbox_stateChanged(int state) void on_blur_checkbox_stateChanged(int state) void on_autopad_checkbox_stateChanged(int state) void skip_grooming_toggled() void on_restore_defaults_clicked() void update_ui() void domain_changed() void alignment_checkbox_changed(int state) void alignment_option_changed(int index) void reflect_checkbox_changed(int state) void reflect_column_changed(int index) void reflect_choice_changed(int index) void reflect_axis_changed(int index) void on_run_groom_button_clicked()Run groom tool. void handle_thread_complete() void handle_progress(int val) void handle_error(QString msg) void add_shared_boundary_clicked() void delete_shared_boundary_clicked()"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-signals","title":"Public Signals","text":"Name void groom_start() void groom_complete() void progress(int )"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-functions","title":"Public Functions","text":"Name GroomTool(Preferences &amp; prefs, Telemetry &amp; telemetry) ~GroomTool() void set_session(QSharedPointer&lt; Session &gt; session)Set the pointer to the session. void activate()activate this tool void load_params()Load params from project. void store_params()Store params to project. void disable_actions()Disable action buttons. void enable_actions()Enable action buttons. void shutdown_threads()shut down any running threads"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-on_antialias_checkbox_statechanged","title":"slot on_antialias_checkbox_stateChanged","text":"<pre><code>void on_antialias_checkbox_stateChanged(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-on_blur_checkbox_statechanged","title":"slot on_blur_checkbox_stateChanged","text":"<pre><code>void on_blur_checkbox_stateChanged(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-on_autopad_checkbox_statechanged","title":"slot on_autopad_checkbox_stateChanged","text":"<pre><code>void on_autopad_checkbox_stateChanged(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-skip_grooming_toggled","title":"slot skip_grooming_toggled","text":"<pre><code>void skip_grooming_toggled()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-on_restore_defaults_clicked","title":"slot on_restore_defaults_clicked","text":"<pre><code>void on_restore_defaults_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-update_ui","title":"slot update_ui","text":"<pre><code>void update_ui()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-domain_changed","title":"slot domain_changed","text":"<pre><code>void domain_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-alignment_checkbox_changed","title":"slot alignment_checkbox_changed","text":"<pre><code>void alignment_checkbox_changed(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-alignment_option_changed","title":"slot alignment_option_changed","text":"<pre><code>void alignment_option_changed(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-reflect_checkbox_changed","title":"slot reflect_checkbox_changed","text":"<pre><code>void reflect_checkbox_changed(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-reflect_column_changed","title":"slot reflect_column_changed","text":"<pre><code>void reflect_column_changed(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-reflect_choice_changed","title":"slot reflect_choice_changed","text":"<pre><code>void reflect_choice_changed(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-reflect_axis_changed","title":"slot reflect_axis_changed","text":"<pre><code>void reflect_axis_changed(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-on_run_groom_button_clicked","title":"slot on_run_groom_button_clicked","text":"<pre><code>void on_run_groom_button_clicked()\n</code></pre> <p>Run groom tool. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-handle_thread_complete","title":"slot handle_thread_complete","text":"<pre><code>void handle_thread_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-handle_progress","title":"slot handle_progress","text":"<pre><code>void handle_progress(\n    int val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-handle_error","title":"slot handle_error","text":"<pre><code>void handle_error(\n    QString msg\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-add_shared_boundary_clicked","title":"slot add_shared_boundary_clicked","text":"<pre><code>void add_shared_boundary_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#slot-delete_shared_boundary_clicked","title":"slot delete_shared_boundary_clicked","text":"<pre><code>void delete_shared_boundary_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#signal-groom_start","title":"signal groom_start","text":"<pre><code>void groom_start()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#signal-groom_complete","title":"signal groom_complete","text":"<pre><code>void groom_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-groomtool","title":"function GroomTool","text":"<pre><code>GroomTool(\n    Preferences &amp; prefs,\n    Telemetry &amp; telemetry\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-groomtool_1","title":"function ~GroomTool","text":"<pre><code>~GroomTool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>Set the pointer to the session. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-activate","title":"function activate","text":"<pre><code>void activate()\n</code></pre> <p>activate this tool </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-load_params","title":"function load_params","text":"<pre><code>void load_params()\n</code></pre> <p>Load params from project. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-store_params","title":"function store_params","text":"<pre><code>void store_params()\n</code></pre> <p>Store params to project. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-disable_actions","title":"function disable_actions","text":"<pre><code>void disable_actions()\n</code></pre> <p>Disable action buttons. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-enable_actions","title":"function enable_actions","text":"<pre><code>void enable_actions()\n</code></pre> <p>Enable action buttons. </p>"},{"location":"api/Classes/classshapeworks_1_1GroomTool.html#function-shutdown_threads","title":"function shutdown_threads","text":"<pre><code>void shutdown_threads()\n</code></pre> <p>shut down any running threads </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html","title":"shapeworks::GroupPvalueJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#public-functions","title":"Public Functions","text":"Name GroupPvalueJob(ParticleShapeStatistics stats) virtual void run() overriderun the job virtual QString name() overrideget the name of the job Eigen::VectorXd get_group_pvalues()"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#function-grouppvaluejob","title":"function GroupPvalueJob","text":"<pre><code>GroupPvalueJob(\n    ParticleShapeStatistics stats\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1GroupPvalueJob.html#function-get_group_pvalues","title":"function get_group_pvalues","text":"<pre><code>Eigen::VectorXd get_group_pvalues()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Image.html","title":"shapeworks::Image","text":"<p>Module: Image Classes</p> <p>More...</p> <p><code>#include &lt;Image.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#public-types","title":"Public Types","text":"Name enum InterpolationType using float PixelType using itk::Image&lt; PixelType, 3 &gt; ImageType using itk::StatisticsImageFilter&lt; ImageType &gt;::Pointer StatsPtr using itk::ImageRegionIterator&lt; ImageType &gt; ImageIterator using itk::LinearInterpolateImageFunction&lt; ImageType &gt; InterpolatorType"},{"location":"api/Classes/classshapeworks_1_1Image.html#public-functions","title":"Public Functions","text":"Name Image(const Dims dims) Image(const std::string &amp; pathname) Image(ImageType::Pointer imagePtr) Image(const vtkSmartPointer&lt; vtkImageData &gt; vtkImage) Image(Image &amp;&amp; img) Image(const Image &amp; img) Image &amp; operator=(const Image &amp; img) Image &amp; operator=(Image &amp;&amp; img)lvalue assignment operator operator ImageType::Pointer()rvalue assignment operator ImageType::Pointer getITKImage() const vtkSmartPointer&lt; vtkImageData &gt; getVTKImage() constcreates a VTK filter for the given image Image &amp; operator-()negation operator Image operator+(const Image &amp; other) constplus operator to add two images Image &amp; operator+=(const Image &amp; other) Image operator-(const Image &amp; other) constminus operator to add two images Image &amp; operator-=(const Image &amp; other) Image operator*(const Image &amp; other) constmultiply operator to multiply two images Image operator*(const PixelType x) constmultiply operator to scale contents of an image Image &amp; operator*=(const PixelType x) Image operator/(const PixelType x) constdivide operator to scale contents of an image Image &amp; operator/=(const PixelType x) Image operator+(const PixelType x) constplus operator to shift contents of an image Image &amp; operator+=(const PixelType x) Image operator-(const PixelType x) constminus operator to shift contents of an image Image &amp; operator-=(const PixelType x) Image &amp; antialias(unsigned iterations =50, double maxRMSErr =0.01f, int layers =3)antialiases image Image &amp; recenter() Image &amp; resample(const TransformPtr transform, const Point3 origin, const Dims dims, const Vector3 spacing, const ImageType::DirectionType direction, InterpolationType interp =NearestNeighbor) Image &amp; resample(const Vector &amp; physicalSpacing, InterpolationType interp =Linear)resamples image using new physical spacing, updating logical dims to keep all image data for this spacing Image &amp; resample(double isoSpacing =1.0, InterpolationType interp =Linear)resamples image using isotropic physical spacing Image &amp; resize(Dims logicalDims, InterpolationType interp =Linear) Image &amp; pad(int padding, PixelType value =0.0)pads an image by same number of voxels in all directions with constant value Image &amp; pad(int padx, int pady, int padz, PixelType value =0.0)pads an image by desired number of voxels in each direction with constant value Image &amp; pad(IndexRegion &amp; region, PixelType value =0.0)pads an image to include the given region with constant value Image &amp; translate(const Vector3 &amp; v)helper to simply translate image Image &amp; scale(const Vector3 &amp; v)helper to simply scale image around center (not origin) Image &amp; rotate(const double angle, const Vector3 &amp; axis)helper to simply rotate around axis through center (not origin) by given angle (in radians) Image &amp; rotate(const double angle, Axis axis)helper to simply rotate around axis through center (not origin) by given angle (in radians) TransformPtr createCenterOfMassTransform()creates a transform that translates center of mass to center of image TransformPtr createRigidRegistrationTransform(const Image &amp; target_dt, float isoValue =0.0, unsigned iterations =20) Image &amp; applyTransform(const TransformPtr transform, InterpolationType interp =Linear)applies the given transformation to the image by using resampling filter Image &amp; applyTransform(const TransformPtr transform, const Point3 origin, const Dims dims, const Vector3 spacing, const ImageType::DirectionType direction, InterpolationType interp =NearestNeighbor) Image &amp; applyTransform(const TransformPtr transform, const Image &amp; referenceImage, InterpolationType interp =Linear)applies the given transformation to the image by using resampling filter with reference image Image &amp; extractLabel(const PixelType label =1.0) Image &amp; closeHoles(const PixelType foreground =0.0)closes holes in a given volume, default foreground value assumes a binary volume Image &amp; binarize(PixelType minVal =0.0, PixelType maxVal =std::numeric_limits&lt; PixelType &gt;::max(), PixelType innerVal =1.0, PixelType outerVal =0.0)threholds image into binary label based on upper and lower intensity bounds given by user Image &amp; computeDT(PixelType isoValue =0.0)computes distance transform volume from a (preferably antialiased) binary image using the specified isovalue Image &amp; applyCurvatureFilter(unsigned iterations =10)denoises an image using curvature driven flow using curvature flow image filter Image &amp; applyGradientFilter()computes gradient magnitude at each pixel using gradient magnitude filter Image &amp; applySigmoidFilter(double alpha =10.0, double beta =10.0)computes sigmoid function pixel-wise using sigmoid image filter Image &amp; applyTPLevelSetFilter(const Image &amp; featureImage, double scaling =20.0)segements structures in images using topology preserving geodesic active contour level set filter Image &amp; topologyPreservingSmooth(float scaling =20.0, float sigmoidAlpha =10.5, float sigmoidBeta =10.0) Image &amp; applyIntensityFilter(double minVal, double maxVal)applies intensity windowing image filter Image &amp; gaussianBlur(double sigma =0.0)applies gaussian blur with given sigma Image &amp; crop(PhysicalRegion region, const int padding =0)crops the image down to the given region, with optional padding added Image &amp; fitRegion(PhysicalRegion region, const PixelType value =0.0)crops (or pads) the image to fit the given region Image &amp; clip(const Plane plane, const PixelType val =0.0)clips an image using a cutting plane Image &amp; reflect(const Axis &amp; axis) Image &amp; setOrigin(Point3 origin =Point3({0, 0, 0}))sets the image origin in physical space to the given value Image &amp; setSpacing(Vector3 spacing)sets the image spacing to the given value Image &amp; setCoordsys(ImageType::DirectionType coordsys)sets the coordinate system in which this image lives in physical space Image &amp; isolate()isolate the largest object in a binary segmentation Dims dims() constlogical dimensions of the image Point3 size() constphysical dimensions of the image (dims * spacing) double get_largest_dimension_size() constlargest dimension size Vector spacing() constphysical spacing of the image double get_minimum_spacing() constminimum physical spacing of the image Point3 origin() constphysical coordinates of image origin Point3 center() constphysical coordinates of center of this image ImageType::DirectionType coordsys() constreturn coordinate system in which this image lives in physical space Point3 centerOfMass(PixelType minVal =0.0, PixelType maxVal =1.0) constreturns average physical coordinate of pixels in range (minval, maxval] PixelType min()minimum of image PixelType max()maximum of image PixelType mean()mean of image PixelType std()standard deviation of image IndexRegion logicalBoundingBox() constbounding box of complete image in logical (index) space PhysicalRegion physicalBoundingBox() constbounding box of complete image in physical space PhysicalRegion physicalBoundingBox(PixelType isovalue) constbounding box of largest region of data &gt;= the given isoValue in physical space PhysicalRegion logicalToPhysical(IndexRegion region) constconverts a bounding box in logical (index) space to this image's index coordinates IndexRegion physicalToLogical(PhysicalRegion region) constconverts a bounding box in physical space to this image's logical (index) coordinates Point3 logicalToPhysical(const Coord &amp; c) constconverts from pixel coordinates to physical space Coord physicalToLogical(const Point3 &amp; p) constconverts from a physical coordinate to a logical coordinate bool isInside(const Point3 &amp; p) constchecks if a given point is inside the image ImageIterator iterator()creates an image iterator and returns it bool compare(const Image &amp; other, bool verifyall =true, double tolerance =0.0, double precision =1e-6) constcompares this with another image using the region of interest filter bool operator==(const Image &amp; other) constcompares this with another image using the region of interest filter Image &amp; write(const std::string &amp; filename, bool compressed =true)writes image, format specified by filename extension Mesh toMesh(PixelType isovalue) constconverts image to mesh Image::PixelType evaluate(Point p)Evaluates the image at a given position. void paintSphere(Point p, double radius, PixelType value)Paints a sphere in the image. void paintCircle(Point p, double radius, unsigned int axis, PixelType value)Paints a circle in the image. bool isPainted() constReturns if the image has been painted. Image &amp; fill(PixelType value)fill with value bool isDistanceTransform() constReturn if the image is a distance transform. std::vector&lt; std::string &gt; getSupportedTypes()Return supported file types. bool isSupportedType(const std::string &amp; filename)Return if the file type is supported."},{"location":"api/Classes/classshapeworks_1_1Image.html#friends","title":"Friends","text":"Name struct SharedCommandData"},{"location":"api/Classes/classshapeworks_1_1Image.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Image;\n</code></pre> <p>This class represents a 3D image volume and operations that can be performed on images. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Image.html#enum-interpolationtype","title":"enum InterpolationType","text":"Enumerator Value Description Linear NearestNeighbor"},{"location":"api/Classes/classshapeworks_1_1Image.html#using-pixeltype","title":"using PixelType","text":"<pre><code>using shapeworks::Image::PixelType =  float;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::Image::ImageType =  itk::Image&lt;PixelType, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#using-statsptr","title":"using StatsPtr","text":"<pre><code>using shapeworks::Image::StatsPtr =  itk::StatisticsImageFilter&lt;ImageType&gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#using-imageiterator","title":"using ImageIterator","text":"<pre><code>using shapeworks::Image::ImageIterator =  itk::ImageRegionIterator&lt;ImageType&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#using-interpolatortype","title":"using InterpolatorType","text":"<pre><code>using shapeworks::Image::InterpolatorType =  itk::LinearInterpolateImageFunction&lt;ImageType&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image","title":"function Image","text":"<pre><code>explicit Image(\n    const Dims dims\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image_1","title":"function Image","text":"<pre><code>inline explicit Image(\n    const std::string &amp; pathname\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image_2","title":"function Image","text":"<pre><code>inline explicit Image(\n    ImageType::Pointer imagePtr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image_3","title":"function Image","text":"<pre><code>explicit Image(\n    const vtkSmartPointer&lt; vtkImageData &gt; vtkImage\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image_4","title":"function Image","text":"<pre><code>inline Image(\n    Image &amp;&amp; img\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-image_5","title":"function Image","text":"<pre><code>inline Image(\n    const Image &amp; img\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator","title":"function operator=","text":"<pre><code>Image &amp; operator=(\n    const Image &amp; img\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_1","title":"function operator=","text":"<pre><code>Image &amp; operator=(\n    Image &amp;&amp; img\n)\n</code></pre> <p>lvalue assignment operator </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-imagetypepointer","title":"function operator ImageType::Pointer","text":"<pre><code>inline operator ImageType::Pointer()\n</code></pre> <p>rvalue assignment operator </p> <p>return this as an ITK image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-getitkimage","title":"function getITKImage","text":"<pre><code>inline ImageType::Pointer getITKImage() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-getvtkimage","title":"function getVTKImage","text":"<pre><code>vtkSmartPointer&lt; vtkImageData &gt; getVTKImage() const\n</code></pre> <p>creates a VTK filter for the given image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-","title":"function operator-","text":"<pre><code>Image &amp; operator-()\n</code></pre> <p>negation operator </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_2","title":"function operator+","text":"<pre><code>Image operator+(\n    const Image &amp; other\n) const\n</code></pre> <p>plus operator to add two images </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_3","title":"function operator+=","text":"<pre><code>Image &amp; operator+=(\n    const Image &amp; other\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-_1","title":"function operator-","text":"<pre><code>Image operator-(\n    const Image &amp; other\n) const\n</code></pre> <p>minus operator to add two images </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-_2","title":"function operator-=","text":"<pre><code>Image &amp; operator-=(\n    const Image &amp; other\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_4","title":"function operator*","text":"<pre><code>Image operator*(\n    const Image &amp; other\n) const\n</code></pre> <p>multiply operator to multiply two images </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_5","title":"function operator*","text":"<pre><code>Image operator*(\n    const PixelType x\n) const\n</code></pre> <p>multiply operator to scale contents of an image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_6","title":"function operator*=","text":"<pre><code>Image &amp; operator*=(\n    const PixelType x\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_7","title":"function operator/","text":"<pre><code>Image operator/(\n    const PixelType x\n) const\n</code></pre> <p>divide operator to scale contents of an image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_8","title":"function operator/=","text":"<pre><code>Image &amp; operator/=(\n    const PixelType x\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_9","title":"function operator+","text":"<pre><code>Image operator+(\n    const PixelType x\n) const\n</code></pre> <p>plus operator to shift contents of an image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_10","title":"function operator+=","text":"<pre><code>Image &amp; operator+=(\n    const PixelType x\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-_3","title":"function operator-","text":"<pre><code>Image operator-(\n    const PixelType x\n) const\n</code></pre> <p>minus operator to shift contents of an image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator-_4","title":"function operator-=","text":"<pre><code>Image &amp; operator-=(\n    const PixelType x\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-antialias","title":"function antialias","text":"<pre><code>Image &amp; antialias(\n    unsigned iterations =50,\n    double maxRMSErr =0.01f,\n    int layers =3\n)\n</code></pre> <p>antialiases image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-recenter","title":"function recenter","text":"<pre><code>Image &amp; recenter()\n</code></pre> <p>helper identical to setOrigin(image.center()) changing origin (in the image header) to physcial center of the image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-resample","title":"function resample","text":"<pre><code>Image &amp; resample(\n    const TransformPtr transform,\n    const Point3 origin,\n    const Dims dims,\n    const Vector3 spacing,\n    const ImageType::DirectionType direction,\n    InterpolationType interp =NearestNeighbor\n)\n</code></pre> <p>resamples by applying transform then sampling from given origin along direction axes at spacing physical units per pixel for dims pixels using specified interpolator </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-resample_1","title":"function resample","text":"<pre><code>Image &amp; resample(\n    const Vector &amp; physicalSpacing,\n    InterpolationType interp =Linear\n)\n</code></pre> <p>resamples image using new physical spacing, updating logical dims to keep all image data for this spacing </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-resample_2","title":"function resample","text":"<pre><code>Image &amp; resample(\n    double isoSpacing =1.0,\n    InterpolationType interp =Linear\n)\n</code></pre> <p>resamples image using isotropic physical spacing </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-resize","title":"function resize","text":"<pre><code>Image &amp; resize(\n    Dims logicalDims,\n    InterpolationType interp =Linear\n)\n</code></pre> <p>changes logical image size, computing new physical spacing based on this size (i.e., physical image size remains the same) </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-pad","title":"function pad","text":"<pre><code>Image &amp; pad(\n    int padding,\n    PixelType value =0.0\n)\n</code></pre> <p>pads an image by same number of voxels in all directions with constant value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-pad_1","title":"function pad","text":"<pre><code>Image &amp; pad(\n    int padx,\n    int pady,\n    int padz,\n    PixelType value =0.0\n)\n</code></pre> <p>pads an image by desired number of voxels in each direction with constant value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-pad_2","title":"function pad","text":"<pre><code>Image &amp; pad(\n    IndexRegion &amp; region,\n    PixelType value =0.0\n)\n</code></pre> <p>pads an image to include the given region with constant value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-translate","title":"function translate","text":"<pre><code>Image &amp; translate(\n    const Vector3 &amp; v\n)\n</code></pre> <p>helper to simply translate image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-scale","title":"function scale","text":"<pre><code>Image &amp; scale(\n    const Vector3 &amp; v\n)\n</code></pre> <p>helper to simply scale image around center (not origin) </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-rotate","title":"function rotate","text":"<pre><code>Image &amp; rotate(\n    const double angle,\n    const Vector3 &amp; axis\n)\n</code></pre> <p>helper to simply rotate around axis through center (not origin) by given angle (in radians) </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-rotate_1","title":"function rotate","text":"<pre><code>Image &amp; rotate(\n    const double angle,\n    Axis axis\n)\n</code></pre> <p>helper to simply rotate around axis through center (not origin) by given angle (in radians) </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-createcenterofmasstransform","title":"function createCenterOfMassTransform","text":"<pre><code>TransformPtr createCenterOfMassTransform()\n</code></pre> <p>creates a transform that translates center of mass to center of image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-createrigidregistrationtransform","title":"function createRigidRegistrationTransform","text":"<pre><code>TransformPtr createRigidRegistrationTransform(\n    const Image &amp; target_dt,\n    float isoValue =0.0,\n    unsigned iterations =20\n)\n</code></pre> <p>creates transform to target image using iterative closest point (ICP) registration; images MUST be distance transforms; isovalue is used to create meshes from these distance transform images, which are then passed to ICP for the given number of iterations </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applytransform","title":"function applyTransform","text":"<pre><code>Image &amp; applyTransform(\n    const TransformPtr transform,\n    InterpolationType interp =Linear\n)\n</code></pre> <p>applies the given transformation to the image by using resampling filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applytransform_1","title":"function applyTransform","text":"<pre><code>Image &amp; applyTransform(\n    const TransformPtr transform,\n    const Point3 origin,\n    const Dims dims,\n    const Vector3 spacing,\n    const ImageType::DirectionType direction,\n    InterpolationType interp =NearestNeighbor\n)\n</code></pre> <p>applies the given transformation to the image by using resampling filter with new origin, dims, spacing and direction values </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applytransform_2","title":"function applyTransform","text":"<pre><code>Image &amp; applyTransform(\n    const TransformPtr transform,\n    const Image &amp; referenceImage,\n    InterpolationType interp =Linear\n)\n</code></pre> <p>applies the given transformation to the image by using resampling filter with reference image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-extractlabel","title":"function extractLabel","text":"<pre><code>Image &amp; extractLabel(\n    const PixelType label =1.0\n)\n</code></pre> <p>extracts/isolates a specific voxel label from a given multi-label volume and outputs the corresponding binary image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-closeholes","title":"function closeHoles","text":"<pre><code>Image &amp; closeHoles(\n    const PixelType foreground =0.0\n)\n</code></pre> <p>closes holes in a given volume, default foreground value assumes a binary volume </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-binarize","title":"function binarize","text":"<pre><code>Image &amp; binarize(\n    PixelType minVal =0.0,\n    PixelType maxVal =std::numeric_limits&lt; PixelType &gt;::max(),\n    PixelType innerVal =1.0,\n    PixelType outerVal =0.0\n)\n</code></pre> <p>threholds image into binary label based on upper and lower intensity bounds given by user </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-computedt","title":"function computeDT","text":"<pre><code>Image &amp; computeDT(\n    PixelType isoValue =0.0\n)\n</code></pre> <p>computes distance transform volume from a (preferably antialiased) binary image using the specified isovalue </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applycurvaturefilter","title":"function applyCurvatureFilter","text":"<pre><code>Image &amp; applyCurvatureFilter(\n    unsigned iterations =10\n)\n</code></pre> <p>denoises an image using curvature driven flow using curvature flow image filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applygradientfilter","title":"function applyGradientFilter","text":"<pre><code>Image &amp; applyGradientFilter()\n</code></pre> <p>computes gradient magnitude at each pixel using gradient magnitude filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applysigmoidfilter","title":"function applySigmoidFilter","text":"<pre><code>Image &amp; applySigmoidFilter(\n    double alpha =10.0,\n    double beta =10.0\n)\n</code></pre> <p>computes sigmoid function pixel-wise using sigmoid image filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applytplevelsetfilter","title":"function applyTPLevelSetFilter","text":"<pre><code>Image &amp; applyTPLevelSetFilter(\n    const Image &amp; featureImage,\n    double scaling =20.0\n)\n</code></pre> <p>segements structures in images using topology preserving geodesic active contour level set filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-topologypreservingsmooth","title":"function topologyPreservingSmooth","text":"<pre><code>Image &amp; topologyPreservingSmooth(\n    float scaling =20.0,\n    float sigmoidAlpha =10.5,\n    float sigmoidBeta =10.0\n)\n</code></pre> <p>creates a feature image (by applying gradient then sigmoid filters), then passes it to the TPLevelSet filter [curvature flow filter is often applied to the image before this filter] </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-applyintensityfilter","title":"function applyIntensityFilter","text":"<pre><code>Image &amp; applyIntensityFilter(\n    double minVal,\n    double maxVal\n)\n</code></pre> <p>applies intensity windowing image filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-gaussianblur","title":"function gaussianBlur","text":"<pre><code>Image &amp; gaussianBlur(\n    double sigma =0.0\n)\n</code></pre> <p>applies gaussian blur with given sigma </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-crop","title":"function crop","text":"<pre><code>Image &amp; crop(\n    PhysicalRegion region,\n    const int padding =0\n)\n</code></pre> <p>crops the image down to the given region, with optional padding added </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-fitregion","title":"function fitRegion","text":"<pre><code>Image &amp; fitRegion(\n    PhysicalRegion region,\n    const PixelType value =0.0\n)\n</code></pre> <p>crops (or pads) the image to fit the given region </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-clip","title":"function clip","text":"<pre><code>Image &amp; clip(\n    const Plane plane,\n    const PixelType val =0.0\n)\n</code></pre> <p>clips an image using a cutting plane </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-reflect","title":"function reflect","text":"<pre><code>Image &amp; reflect(\n    const Axis &amp; axis\n)\n</code></pre> <p>reflect image around the plane specified by the logical center and the given normal (ex: &lt;1,0,0&gt; reflects across YZ-plane). </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-setorigin","title":"function setOrigin","text":"<pre><code>Image &amp; setOrigin(\n    Point3 origin =Point3({0, 0, 0})\n)\n</code></pre> <p>sets the image origin in physical space to the given value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-setspacing","title":"function setSpacing","text":"<pre><code>Image &amp; setSpacing(\n    Vector3 spacing\n)\n</code></pre> <p>sets the image spacing to the given value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-setcoordsys","title":"function setCoordsys","text":"<pre><code>Image &amp; setCoordsys(\n    ImageType::DirectionType coordsys\n)\n</code></pre> <p>sets the coordinate system in which this image lives in physical space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-isolate","title":"function isolate","text":"<pre><code>Image &amp; isolate()\n</code></pre> <p>isolate the largest object in a binary segmentation </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-dims","title":"function dims","text":"<pre><code>inline Dims dims() const\n</code></pre> <p>logical dimensions of the image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-size","title":"function size","text":"<pre><code>inline Point3 size() const\n</code></pre> <p>physical dimensions of the image (dims * spacing) </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-get_largest_dimension_size","title":"function get_largest_dimension_size","text":"<pre><code>double get_largest_dimension_size() const\n</code></pre> <p>largest dimension size </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-spacing","title":"function spacing","text":"<pre><code>inline Vector spacing() const\n</code></pre> <p>physical spacing of the image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-get_minimum_spacing","title":"function get_minimum_spacing","text":"<pre><code>double get_minimum_spacing() const\n</code></pre> <p>minimum physical spacing of the image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-origin","title":"function origin","text":"<pre><code>inline Point3 origin() const\n</code></pre> <p>physical coordinates of image origin </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-center","title":"function center","text":"<pre><code>inline Point3 center() const\n</code></pre> <p>physical coordinates of center of this image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-coordsys","title":"function coordsys","text":"<pre><code>inline ImageType::DirectionType coordsys() const\n</code></pre> <p>return coordinate system in which this image lives in physical space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-centerofmass","title":"function centerOfMass","text":"<pre><code>Point3 centerOfMass(\n    PixelType minVal =0.0,\n    PixelType maxVal =1.0\n) const\n</code></pre> <p>returns average physical coordinate of pixels in range (minval, maxval] </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-min","title":"function min","text":"<pre><code>PixelType min()\n</code></pre> <p>minimum of image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-max","title":"function max","text":"<pre><code>PixelType max()\n</code></pre> <p>maximum of image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-mean","title":"function mean","text":"<pre><code>PixelType mean()\n</code></pre> <p>mean of image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-std","title":"function std","text":"<pre><code>PixelType std()\n</code></pre> <p>standard deviation of image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-logicalboundingbox","title":"function logicalBoundingBox","text":"<pre><code>IndexRegion logicalBoundingBox() const\n</code></pre> <p>bounding box of complete image in logical (index) space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-physicalboundingbox","title":"function physicalBoundingBox","text":"<pre><code>PhysicalRegion physicalBoundingBox() const\n</code></pre> <p>bounding box of complete image in physical space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-physicalboundingbox_1","title":"function physicalBoundingBox","text":"<pre><code>PhysicalRegion physicalBoundingBox(\n    PixelType isovalue\n) const\n</code></pre> <p>bounding box of largest region of data &gt;= the given isoValue in physical space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-logicaltophysical","title":"function logicalToPhysical","text":"<pre><code>PhysicalRegion logicalToPhysical(\n    IndexRegion region\n) const\n</code></pre> <p>converts a bounding box in logical (index) space to this image's index coordinates </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-physicaltological","title":"function physicalToLogical","text":"<pre><code>IndexRegion physicalToLogical(\n    PhysicalRegion region\n) const\n</code></pre> <p>converts a bounding box in physical space to this image's logical (index) coordinates </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-logicaltophysical_1","title":"function logicalToPhysical","text":"<pre><code>Point3 logicalToPhysical(\n    const Coord &amp; c\n) const\n</code></pre> <p>converts from pixel coordinates to physical space </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-physicaltological_1","title":"function physicalToLogical","text":"<pre><code>Coord physicalToLogical(\n    const Point3 &amp; p\n) const\n</code></pre> <p>converts from a physical coordinate to a logical coordinate </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-isinside","title":"function isInside","text":"<pre><code>bool isInside(\n    const Point3 &amp; p\n) const\n</code></pre> <p>checks if a given point is inside the image </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-iterator","title":"function iterator","text":"<pre><code>ImageIterator iterator()\n</code></pre> <p>creates an image iterator and returns it </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-compare","title":"function compare","text":"<pre><code>bool compare(\n    const Image &amp; other,\n    bool verifyall =true,\n    double tolerance =0.0,\n    double precision =1e-6\n) const\n</code></pre> <p>compares this with another image using the region of interest filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-operator_11","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const Image &amp; other\n) const\n</code></pre> <p>compares this with another image using the region of interest filter </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-write","title":"function write","text":"<pre><code>Image &amp; write(\n    const std::string &amp; filename,\n    bool compressed =true\n)\n</code></pre> <p>writes image, format specified by filename extension </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-tomesh","title":"function toMesh","text":"<pre><code>Mesh toMesh(\n    PixelType isovalue\n) const\n</code></pre> <p>converts image to mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-evaluate","title":"function evaluate","text":"<pre><code>Image::PixelType evaluate(\n    Point p\n)\n</code></pre> <p>Evaluates the image at a given position. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-paintsphere","title":"function paintSphere","text":"<pre><code>void paintSphere(\n    Point p,\n    double radius,\n    PixelType value\n)\n</code></pre> <p>Paints a sphere in the image. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-paintcircle","title":"function paintCircle","text":"<pre><code>void paintCircle(\n    Point p,\n    double radius,\n    unsigned int axis,\n    PixelType value\n)\n</code></pre> <p>Paints a circle in the image. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-ispainted","title":"function isPainted","text":"<pre><code>inline bool isPainted() const\n</code></pre> <p>Returns if the image has been painted. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-fill","title":"function fill","text":"<pre><code>Image &amp; fill(\n    PixelType value\n)\n</code></pre> <p>fill with value </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-isdistancetransform","title":"function isDistanceTransform","text":"<pre><code>bool isDistanceTransform() const\n</code></pre> <p>Return if the image is a distance transform. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-getsupportedtypes","title":"function getSupportedTypes","text":"<pre><code>static inline std::vector&lt; std::string &gt; getSupportedTypes()\n</code></pre> <p>Return supported file types. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#function-issupportedtype","title":"function isSupportedType","text":"<pre><code>static inline bool isSupportedType(\n    const std::string &amp; filename\n)\n</code></pre> <p>Return if the file type is supported. </p>"},{"location":"api/Classes/classshapeworks_1_1Image.html#friends_1","title":"Friends","text":""},{"location":"api/Classes/classshapeworks_1_1Image.html#friend-sharedcommanddata","title":"friend SharedCommandData","text":"<pre><code>friend struct SharedCommandData(\n    SharedCommandData \n);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageCommand.html","title":"shapeworks::ImageCommand","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1ImageCommand.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1ImageCommand.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1ImageCommand.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageCommand.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html","title":"shapeworks::ImageDomain","text":"<p>More...</p> <p>Inherits from shapeworks::ParticleRegionDomain, shapeworks::ParticleDomain</p> <p>Inherited by shapeworks::ImageDomainWithGradients&lt; T &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; ImageDomain &gt; Pointer using itk::Image&lt; T, DIMENSION &gt; ImageType using ParticleRegionDomain::PointType PointType"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#public-functions","title":"Public Functions","text":"Name void SetImage(ImageType * I, double narrow_band) virtual double GetSurfaceArea() const override PointType GetOrigin() const ImageType::SizeType GetSize() const ImageType::SpacingType GetSpacing() const ImageType::RegionType::IndexType GetIndex() const virtual PointType GetValidLocationNear(PointType p) const override T Sample(const PointType &amp; p) const virtual double GetMaxDiameter() const override virtual void DeleteImages() override virtual void UpdateZeroCrossingPoint() override"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#protected-functions","title":"Protected Functions","text":"Name openvdb::FloatGrid::Ptr GetVDBImage() const ImageDomain() virtual ~ImageDomain() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const openvdb::math::Transform::Ptr transform() const openvdb::Vec3R ToVDBCoord(const PointType &amp; p) const"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::ParticleRegionDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p) const virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound) <p>Protected Functions inherited from shapeworks::ParticleRegionDomain</p> Name ParticleRegionDomain() virtual ~ParticleRegionDomain() bool IsInsideBuffer(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleDomain</p> Name using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const =0 virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual void DeletePartialDerivativeImages() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::ImageDomain;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ImageDomain&lt; T &gt;::Pointer =  std::shared_ptr&lt;ImageDomain&gt;;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::ImageDomain&lt; T &gt;::ImageType =  itk::Image&lt;T, DIMENSION&gt;;\n</code></pre> <p>Type of the ITK image used by this class. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::ImageDomain&lt; T &gt;::PointType =  ParticleRegionDomain::PointType;\n</code></pre> <p>Point type of the domain (not the image). </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-setimage","title":"function SetImage","text":"<pre><code>inline void SetImage(\n    ImageType * I,\n    double narrow_band\n)\n</code></pre> <p>Set/Get the itk::Image specifying the particle domain. The set method modifies the parent class LowerBound and UpperBound. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getsurfacearea","title":"function GetSurfaceArea","text":"<pre><code>inline virtual double GetSurfaceArea() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceArea</p> <p>Use for neighborhood radius. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getorigin","title":"function GetOrigin","text":"<pre><code>inline PointType GetOrigin() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getsize","title":"function GetSize","text":"<pre><code>inline ImageType::SizeType GetSize() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getspacing","title":"function GetSpacing","text":"<pre><code>inline ImageType::SpacingType GetSpacing() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getindex","title":"function GetIndex","text":"<pre><code>inline ImageType::RegionType::IndexType GetIndex() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getvalidlocationnear","title":"function GetValidLocationNear","text":"<pre><code>inline virtual PointType GetValidLocationNear(\n    PointType p\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetValidLocationNear</p> <p>GetValidLocation returns a PointType location on the surface. Used for placing the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-sample","title":"function Sample","text":"<pre><code>inline T Sample(\n    const PointType &amp; p\n) const\n</code></pre> <p>Sample the image at a point. This method performs bounds checking. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getmaxdiameter","title":"function GetMaxDiameter","text":"<pre><code>inline virtual double GetMaxDiameter() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetMaxDiameter</p> <p>GetMaxDiameter returns the maximum diameter of the domain and is used for computing sigma </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>inline virtual void DeleteImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeleteImages</p> <p>Reimplemented by: shapeworks::ImageDomainWithGradients::DeleteImages, shapeworks::ImageDomainWithGradN::DeleteImages</p> <p>Used when a domain is fixed. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-updatezerocrossingpoint","title":"function UpdateZeroCrossingPoint","text":"<pre><code>inline virtual void UpdateZeroCrossingPoint() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::UpdateZeroCrossingPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-getvdbimage","title":"function GetVDBImage","text":"<pre><code>inline openvdb::FloatGrid::Ptr GetVDBImage() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-imagedomain","title":"function ImageDomain","text":"<pre><code>inline ImageDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-imagedomain_1","title":"function ~ImageDomain","text":"<pre><code>inline virtual ~ImageDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-transform","title":"function transform","text":"<pre><code>inline openvdb::math::Transform::Ptr transform() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomain.html#function-tovdbcoord","title":"function ToVDBCoord","text":"<pre><code>inline openvdb::Vec3R ToVDBCoord(\n    const PointType &amp; p\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html","title":"shapeworks::ImageDomainWithCurvature","text":"<p>More...</p> <p>Inherits from shapeworks::ImageDomainWithGradN&lt; T &gt;, shapeworks::ImageDomainWithGradients&lt; T &gt;, shapeworks::ImageDomain&lt; T &gt;, shapeworks::ParticleRegionDomain, shapeworks::ParticleDomain</p> <p>Inherited by shapeworks::ImplicitSurfaceDomain&lt; T &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#public-types","title":"Public Types","text":"Name typedef ImageDomainWithGradN&lt; T &gt; Superclass typedef Superclass::PointType PointType typedef Superclass::ImageType ImageType typedef Superclass::VnlMatrixType VnlMatrixType"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#public-functions","title":"Public Functions","text":"Name void SetImage(ImageType * I, double narrow_band) virtual double GetCurvature(const PointType &amp; p, int idx) const override virtual double GetSurfaceMeanCurvature() const override virtual double GetSurfaceStdDevCurvature() const override"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#protected-functions","title":"Protected Functions","text":"Name ImageDomainWithCurvature() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const virtual ~ImageDomainWithCurvature()"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name using std::shared_ptr&lt; ImageDomainWithGradN &gt; Pointer typedef Superclass::GradNType GradNType <p>Public Functions inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const override virtual void DeletePartialDerivativeImages() override virtual void DeleteImages() override <p>Protected Functions inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name ImageDomainWithGradN() virtual ~ImageDomainWithGradN() <p>Public Types inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name using std::shared_ptr&lt; ImageDomainWithGradients&lt; T &gt; &gt; Pointer typedef itk::FixedArray&lt; T, DIMENSION &gt; VectorType typedef vnl_vector_fixed&lt; T, DIMENSION &gt; VnlVectorType <p>Public Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(const PointType &amp; p, int idx) const virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(const PointType &amp; p, int idx) const vnl_vector_fixed&lt; double, DIMENSION &gt; ProjectVectorToSurfaceTangent(vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; gradE, const PointType &amp; pos, int idx) const override virtual void DeleteImages() override <p>Protected Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name ImageDomainWithGradients() virtual ~ImageDomainWithGradients() openvdb::VectorGrid::Ptr GetVDBGradient() <p>Public Types inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name using std::shared_ptr&lt; ImageDomain &gt; Pointer <p>Public Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name virtual double GetSurfaceArea() const override PointType GetOrigin() const ImageType::SizeType GetSize() const ImageType::SpacingType GetSpacing() const ImageType::RegionType::IndexType GetIndex() const virtual PointType GetValidLocationNear(PointType p) const override T Sample(const PointType &amp; p) const virtual double GetMaxDiameter() const override virtual void DeleteImages() override virtual void UpdateZeroCrossingPoint() override <p>Protected Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name openvdb::FloatGrid::Ptr GetVDBImage() const ImageDomain() virtual ~ImageDomain() openvdb::math::Transform::Ptr transform() const openvdb::Vec3R ToVDBCoord(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleRegionDomain</p> Name using std::shared_ptr&lt; ParticleRegionDomain &gt; Pointer <p>Public Functions inherited from shapeworks::ParticleRegionDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p) const virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound) <p>Protected Functions inherited from shapeworks::ParticleRegionDomain</p> Name ParticleRegionDomain() virtual ~ParticleRegionDomain() bool IsInsideBuffer(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleDomain</p> Name typedef std::shared_ptr&lt; ParticleDomain &gt; Pointer using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const =0 virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void DeleteImages() =0 virtual void DeletePartialDerivativeImages() =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::ImageDomainWithCurvature;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef ImageDomainWithGradN&lt;T&gt; shapeworks::ImageDomainWithCurvature&lt; T &gt;::Superclass;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef Superclass::PointType shapeworks::ImageDomainWithCurvature&lt; T &gt;::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef Superclass::ImageType shapeworks::ImageDomainWithCurvature&lt; T &gt;::ImageType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#typedef-vnlmatrixtype","title":"typedef VnlMatrixType","text":"<pre><code>typedef Superclass::VnlMatrixType shapeworks::ImageDomainWithCurvature&lt; T &gt;::VnlMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-setimage","title":"function SetImage","text":"<pre><code>inline void SetImage(\n    ImageType * I,\n    double narrow_band\n)\n</code></pre> <p>Set/Get the itk::Image specifying the particle domain. The set method modifies the parent class LowerBound and UpperBound. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-getcurvature","title":"function GetCurvature","text":"<pre><code>inline virtual double GetCurvature(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-getsurfacemeancurvature","title":"function GetSurfaceMeanCurvature","text":"<pre><code>inline virtual double GetSurfaceMeanCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceMeanCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-getsurfacestddevcurvature","title":"function GetSurfaceStdDevCurvature","text":"<pre><code>inline virtual double GetSurfaceStdDevCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceStdDevCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-imagedomainwithcurvature","title":"function ImageDomainWithCurvature","text":"<pre><code>inline ImageDomainWithCurvature()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithCurvature.html#function-imagedomainwithcurvature_1","title":"function ~ImageDomainWithCurvature","text":"<pre><code>inline virtual ~ImageDomainWithCurvature()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html","title":"shapeworks::ImageDomainWithGradN","text":"<p>More...</p> <p>Inherits from shapeworks::ImageDomainWithGradients&lt; T &gt;, shapeworks::ImageDomain&lt; T &gt;, shapeworks::ParticleRegionDomain, shapeworks::ParticleDomain</p> <p>Inherited by shapeworks::ImageDomainWithCurvature&lt; T &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#public-types","title":"Public Types","text":"Name typedef ImageDomainWithGradients&lt; T &gt; Superclass using std::shared_ptr&lt; ImageDomainWithGradN &gt; Pointer typedef Superclass::PointType PointType typedef Superclass::ImageType ImageType typedef Superclass::GradNType GradNType typedef Superclass::GradNType VnlMatrixType"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#public-functions","title":"Public Functions","text":"Name void SetImage(ImageType * I, double narrow_band) virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const override virtual void DeletePartialDerivativeImages() override virtual void DeleteImages() override"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#protected-functions","title":"Protected Functions","text":"Name ImageDomainWithGradN() virtual ~ImageDomainWithGradN() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name typedef itk::FixedArray&lt; T, DIMENSION &gt; VectorType typedef vnl_vector_fixed&lt; T, DIMENSION &gt; VnlVectorType <p>Public Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(const PointType &amp; p, int idx) const virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(const PointType &amp; p, int idx) const vnl_vector_fixed&lt; double, DIMENSION &gt; ProjectVectorToSurfaceTangent(vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; gradE, const PointType &amp; pos, int idx) const override <p>Protected Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name ImageDomainWithGradients() virtual ~ImageDomainWithGradients() openvdb::VectorGrid::Ptr GetVDBGradient() <p>Public Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name virtual double GetSurfaceArea() const override PointType GetOrigin() const ImageType::SizeType GetSize() const ImageType::SpacingType GetSpacing() const ImageType::RegionType::IndexType GetIndex() const virtual PointType GetValidLocationNear(PointType p) const override T Sample(const PointType &amp; p) const virtual double GetMaxDiameter() const override virtual void UpdateZeroCrossingPoint() override <p>Protected Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name openvdb::FloatGrid::Ptr GetVDBImage() const ImageDomain() virtual ~ImageDomain() openvdb::math::Transform::Ptr transform() const openvdb::Vec3R ToVDBCoord(const PointType &amp; p) const <p>Public Functions inherited from shapeworks::ParticleRegionDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p) const virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound) <p>Protected Functions inherited from shapeworks::ParticleRegionDomain</p> Name ParticleRegionDomain() virtual ~ParticleRegionDomain() bool IsInsideBuffer(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleDomain</p> Name using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const =0 virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::ImageDomainWithGradN;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef ImageDomainWithGradients&lt;T&gt; shapeworks::ImageDomainWithGradN&lt; T &gt;::Superclass;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ImageDomainWithGradN&lt; T &gt;::Pointer =  std::shared_ptr&lt;ImageDomainWithGradN&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef Superclass::PointType shapeworks::ImageDomainWithGradN&lt; T &gt;::PointType;\n</code></pre> <p>Point type of the domain (not necessarily of the image). </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef Superclass::ImageType shapeworks::ImageDomainWithGradN&lt; T &gt;::ImageType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#typedef-gradntype","title":"typedef GradNType","text":"<pre><code>typedef Superclass::GradNType shapeworks::ImageDomainWithGradN&lt; T &gt;::GradNType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#typedef-vnlmatrixtype","title":"typedef VnlMatrixType","text":"<pre><code>typedef Superclass::GradNType shapeworks::ImageDomainWithGradN&lt; T &gt;::VnlMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-setimage","title":"function SetImage","text":"<pre><code>inline void SetImage(\n    ImageType * I,\n    double narrow_band\n)\n</code></pre> <p>Set/Get the itk::Image specifying the particle domain. The set method modifies the parent class LowerBound and UpperBound. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-samplegradnatpoint","title":"function SampleGradNAtPoint","text":"<pre><code>inline virtual GradNType SampleGradNAtPoint(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradNAtPoint</p> <p>Sample the GradN at a point. This method performs no bounds checking. To check bounds, use IsInsideBuffer. SampleGradN returns a vnl matrix of size VDimension x VDimension. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-deletepartialderivativeimages","title":"function DeletePartialDerivativeImages","text":"<pre><code>inline virtual void DeletePartialDerivativeImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeletePartialDerivativeImages</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>inline virtual void DeleteImages() override\n</code></pre> <p>Reimplements: shapeworks::ImageDomainWithGradients::DeleteImages</p> <p>Used when a domain is fixed. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-imagedomainwithgradn","title":"function ImageDomainWithGradN","text":"<pre><code>inline ImageDomainWithGradN()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-imagedomainwithgradn_1","title":"function ~ImageDomainWithGradN","text":"<pre><code>inline virtual ~ImageDomainWithGradN()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradN.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html","title":"shapeworks::ImageDomainWithGradients","text":"<p>More...</p> <p>Inherits from shapeworks::ImageDomain&lt; T &gt;, shapeworks::ParticleRegionDomain, shapeworks::ParticleDomain</p> <p>Inherited by shapeworks::ImageDomainWithGradN&lt; T &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; ImageDomainWithGradients&lt; T &gt; &gt; Pointer typedef ImageDomain&lt; T &gt;::PointType PointType typedef ImageDomain&lt; T &gt;::ImageType ImageType typedef itk::FixedArray&lt; T, DIMENSION &gt; VectorType typedef vnl_vector_fixed&lt; T, DIMENSION &gt; VnlVectorType"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#public-functions","title":"Public Functions","text":"Name void SetImage(ImageType * I, double narrow_band) virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(const PointType &amp; p, int idx) const virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(const PointType &amp; p, int idx) const vnl_vector_fixed&lt; double, DIMENSION &gt; ProjectVectorToSurfaceTangent(vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; gradE, const PointType &amp; pos, int idx) const override virtual void DeleteImages() override"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#protected-functions","title":"Protected Functions","text":"Name ImageDomainWithGradients() virtual ~ImageDomainWithGradients() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const openvdb::VectorGrid::Ptr GetVDBGradient()"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name virtual double GetSurfaceArea() const override PointType GetOrigin() const ImageType::SizeType GetSize() const ImageType::SpacingType GetSpacing() const ImageType::RegionType::IndexType GetIndex() const virtual PointType GetValidLocationNear(PointType p) const override T Sample(const PointType &amp; p) const virtual double GetMaxDiameter() const override virtual void UpdateZeroCrossingPoint() override <p>Protected Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name openvdb::FloatGrid::Ptr GetVDBImage() const ImageDomain() virtual ~ImageDomain() openvdb::math::Transform::Ptr transform() const openvdb::Vec3R ToVDBCoord(const PointType &amp; p) const <p>Public Functions inherited from shapeworks::ParticleRegionDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p) const virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound) <p>Protected Functions inherited from shapeworks::ParticleRegionDomain</p> Name ParticleRegionDomain() virtual ~ParticleRegionDomain() bool IsInsideBuffer(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleDomain</p> Name using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const =0 virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void DeletePartialDerivativeImages() =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::ImageDomainWithGradients;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ImageDomainWithGradients&lt; T &gt;::Pointer =  std::shared_ptr&lt;ImageDomainWithGradients&lt;T&gt; &gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ImageDomain&lt;T&gt;::PointType shapeworks::ImageDomainWithGradients&lt; T &gt;::PointType;\n</code></pre> <p>Point type of the domain (not necessarily of the image). </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef ImageDomain&lt;T&gt;::ImageType shapeworks::ImageDomainWithGradients&lt; T &gt;::ImageType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>typedef itk::FixedArray&lt;T, DIMENSION&gt; shapeworks::ImageDomainWithGradients&lt; T &gt;::VectorType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#typedef-vnlvectortype","title":"typedef VnlVectorType","text":"<pre><code>typedef vnl_vector_fixed&lt;T, DIMENSION&gt; shapeworks::ImageDomainWithGradients&lt; T &gt;::VnlVectorType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-setimage","title":"function SetImage","text":"<pre><code>inline void SetImage(\n    ImageType * I,\n    double narrow_band\n)\n</code></pre> <p>Set/Get the itk::Image specifying the particle domain. The set method modifies the parent class LowerBound and UpperBound. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-samplegradientatpoint","title":"function SampleGradientAtPoint","text":"<pre><code>inline virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(\n    const PointType &amp; p,\n    int idx\n) const\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradientAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-samplenormalatpoint","title":"function SampleNormalAtPoint","text":"<pre><code>inline virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(\n    const PointType &amp; p,\n    int idx\n) const\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleNormalAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-projectvectortosurfacetangent","title":"function ProjectVectorToSurfaceTangent","text":"<pre><code>inline vnl_vector_fixed&lt; double, DIMENSION &gt; ProjectVectorToSurfaceTangent(\n    vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; gradE,\n    const PointType &amp; pos,\n    int idx\n) const override\n</code></pre> <p>This method is called by an optimizer after a call to Evaluate and may be used to apply any constraints the resulting vector, such as a projection to the surface tangent plane. Returns true if the gradient was modified. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>inline virtual void DeleteImages() override\n</code></pre> <p>Reimplements: shapeworks::ImageDomain::DeleteImages</p> <p>Reimplemented by: shapeworks::ImageDomainWithGradN::DeleteImages</p> <p>Used when a domain is fixed. </p>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-imagedomainwithgradients","title":"function ImageDomainWithGradients","text":"<pre><code>inline ImageDomainWithGradients()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-imagedomainwithgradients_1","title":"function ~ImageDomainWithGradients","text":"<pre><code>inline virtual ~ImageDomainWithGradients()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageDomainWithGradients.html#function-getvdbgradient","title":"function GetVDBGradient","text":"<pre><code>inline openvdb::VectorGrid::Ptr GetVDBGradient()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html","title":"shapeworks::ImageLabel","text":"<p>An extention of QLabel especially for scaled images. </p> <p><code>#include &lt;ImageLabel.h&gt;</code></p> <p>Inherits from QLabel</p>"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#public-functions","title":"Public Functions","text":"Name ImageLabel(QWidget * parent) void setPixmap(const QPixmap &amp; pixmap)"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#protected-functions","title":"Protected Functions","text":"Name void resizeEvent(QResizeEvent * reisze_event) override"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#function-imagelabel","title":"function ImageLabel","text":"<pre><code>inline ImageLabel(\n    QWidget * parent\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#function-setpixmap","title":"function setPixmap","text":"<pre><code>inline void setPixmap(\n    const QPixmap &amp; pixmap\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageLabel.html#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void resizeEvent(\n    QResizeEvent * reisze_event\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html","title":"shapeworks::ImageUtils","text":"<p>Helper functions for image. </p> <p><code>#include &lt;ImageUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#public-types","title":"Public Types","text":"Name using itk::ThinPlateSplineKernelTransform&lt; double, 3 &gt; TPSTransform"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#public-functions","title":"Public Functions","text":"Name PhysicalRegion boundingBox(const std::vector&lt; std::string &gt; &amp; filenames, Image::PixelType isoValue =1.0)calculate bounding box for images using the region of data &lt;= the given isoValue PhysicalRegion boundingBox(const std::vector&lt; std::reference_wrapper&lt; const Image &gt; &gt; &amp; images, Image::PixelType isoValue =1.0)calculate bounding box for shapework images using the region of data &lt;= the given isoValue TPSTransform::Pointer createWarpTransform(const std::string &amp; source_landmarks_file, const std::string &amp; target_landmarks_file, const int stride =1) void register_itk_factories() ImageType::Pointer make_axis_aligned(ImageType::Pointer input)"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#using-tpstransform","title":"using TPSTransform","text":"<pre><code>using shapeworks::ImageUtils::TPSTransform =  itk::ThinPlateSplineKernelTransform&lt;double, 3&gt;;\n</code></pre> <p>computes a thin plate spline (TSP) transform from the source to the target landmarks (in the given files) using every stride points </p>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#function-boundingbox","title":"function boundingBox","text":"<pre><code>static PhysicalRegion boundingBox(\n    const std::vector&lt; std::string &gt; &amp; filenames,\n    Image::PixelType isoValue =1.0\n)\n</code></pre> <p>calculate bounding box for images using the region of data &lt;= the given isoValue </p>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#function-boundingbox_1","title":"function boundingBox","text":"<pre><code>static PhysicalRegion boundingBox(\n    const std::vector&lt; std::reference_wrapper&lt; const Image &gt; &gt; &amp; images,\n    Image::PixelType isoValue =1.0\n)\n</code></pre> <p>calculate bounding box for shapework images using the region of data &lt;= the given isoValue </p>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#function-createwarptransform","title":"function createWarpTransform","text":"<pre><code>static TPSTransform::Pointer createWarpTransform(\n    const std::string &amp; source_landmarks_file,\n    const std::string &amp; target_landmarks_file,\n    const int stride =1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#function-register_itk_factories","title":"function register_itk_factories","text":"<pre><code>static void register_itk_factories()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImageUtils.html#function-make_axis_aligned","title":"function make_axis_aligned","text":"<pre><code>static ImageType::Pointer make_axis_aligned(\n    ImageType::Pointer input\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html","title":"shapeworks::ImplicitSurfaceDomain","text":"<p>More...</p> <p>Inherits from shapeworks::ImageDomainWithCurvature&lt; T &gt;, shapeworks::ImageDomainWithGradN&lt; T &gt;, shapeworks::ImageDomainWithGradients&lt; T &gt;, shapeworks::ImageDomain&lt; T &gt;, shapeworks::ParticleRegionDomain, shapeworks::ParticleDomain</p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#public-types","title":"Public Types","text":"Name typedef ImageDomainWithCurvature&lt; T &gt; Superclass typedef std::shared_ptr&lt; ImplicitSurfaceDomain &gt; Pointer typedef Superclass::ImageType ImageType typedef Superclass::PointType PointType"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#public-functions","title":"Public Functions","text":"Name virtual void SetTolerance(const T _Tolerance) virtual T GetTolerance() virtual shapeworks::DomainType GetDomainType() const override virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const override PointType UpdateParticlePosition(const PointType &amp; point, int idx, vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; update) const override virtual PointType GetZeroCrossingPoint() const override ImplicitSurfaceDomain() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const virtual ~ImplicitSurfaceDomain()"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ImageDomainWithCurvature&lt; T &gt;</p> Name typedef Superclass::VnlMatrixType VnlMatrixType <p>Public Functions inherited from shapeworks::ImageDomainWithCurvature&lt; T &gt;</p> Name void SetImage(ImageType * I, double narrow_band) virtual double GetCurvature(const PointType &amp; p, int idx) const override virtual double GetSurfaceMeanCurvature() const override virtual double GetSurfaceStdDevCurvature() const override <p>Protected Functions inherited from shapeworks::ImageDomainWithCurvature&lt; T &gt;</p> Name ImageDomainWithCurvature() virtual ~ImageDomainWithCurvature() <p>Public Types inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name typedef Superclass::GradNType GradNType typedef Superclass::GradNType VnlMatrixType <p>Public Functions inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name void SetImage(ImageType * I, double narrow_band) virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const override virtual void DeletePartialDerivativeImages() override virtual void DeleteImages() override <p>Protected Functions inherited from shapeworks::ImageDomainWithGradN&lt; T &gt;</p> Name ImageDomainWithGradN() virtual ~ImageDomainWithGradN() <p>Public Types inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name typedef itk::FixedArray&lt; T, DIMENSION &gt; VectorType typedef vnl_vector_fixed&lt; T, DIMENSION &gt; VnlVectorType <p>Public Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name void SetImage(ImageType * I, double narrow_band) virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(const PointType &amp; p, int idx) const virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(const PointType &amp; p, int idx) const vnl_vector_fixed&lt; double, DIMENSION &gt; ProjectVectorToSurfaceTangent(vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; gradE, const PointType &amp; pos, int idx) const override virtual void DeleteImages() override <p>Protected Functions inherited from shapeworks::ImageDomainWithGradients&lt; T &gt;</p> Name ImageDomainWithGradients() virtual ~ImageDomainWithGradients() openvdb::VectorGrid::Ptr GetVDBGradient() <p>Public Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name void SetImage(ImageType * I, double narrow_band) virtual double GetSurfaceArea() const override PointType GetOrigin() const ImageType::SizeType GetSize() const ImageType::SpacingType GetSpacing() const ImageType::RegionType::IndexType GetIndex() const virtual PointType GetValidLocationNear(PointType p) const override T Sample(const PointType &amp; p) const virtual double GetMaxDiameter() const override virtual void DeleteImages() override virtual void UpdateZeroCrossingPoint() override <p>Protected Functions inherited from shapeworks::ImageDomain&lt; T &gt;</p> Name openvdb::FloatGrid::Ptr GetVDBImage() const ImageDomain() virtual ~ImageDomain() openvdb::math::Transform::Ptr transform() const openvdb::Vec3R ToVDBCoord(const PointType &amp; p) const <p>Public Functions inherited from shapeworks::ParticleRegionDomain</p> Name virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound) <p>Protected Functions inherited from shapeworks::ParticleRegionDomain</p> Name ParticleRegionDomain() virtual ~ParticleRegionDomain() bool IsInsideBuffer(const PointType &amp; p) const <p>Public Types inherited from shapeworks::ParticleDomain</p> Name using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void DeleteImages() =0 virtual void DeletePartialDerivativeImages() =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass shapeworks::ImplicitSurfaceDomain;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef ImageDomainWithCurvature&lt;T&gt; shapeworks::ImplicitSurfaceDomain&lt; T &gt;::Superclass;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef std::shared_ptr&lt;ImplicitSurfaceDomain&gt; shapeworks::ImplicitSurfaceDomain&lt; T &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef Superclass::ImageType shapeworks::ImplicitSurfaceDomain&lt; T &gt;::ImageType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef Superclass::PointType shapeworks::ImplicitSurfaceDomain&lt; T &gt;::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-settolerance","title":"function SetTolerance","text":"<pre><code>inline virtual void SetTolerance(\n    const T _Tolerance\n)\n</code></pre> <p>Set/Get the precision of the projection operation. The resulting projection will be within the specified tolerance. </p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-gettolerance","title":"function GetTolerance","text":"<pre><code>inline virtual T GetTolerance()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-getdomaintype","title":"function GetDomainType","text":"<pre><code>inline virtual shapeworks::DomainType GetDomainType() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetDomainType</p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-applyconstraints","title":"function ApplyConstraints","text":"<pre><code>inline virtual bool ApplyConstraints(\n    PointType &amp; p,\n    int idx,\n    bool dbg =false\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::ApplyConstraints</p> <p>Apply any constraints to the given point location. This method constrains points to lie within the given domain and on a given implicit surface. If the point is not already on the surface, it is projected back to the surface using a Newton-Raphson iteration. IMPORTANT: This method returns the true/false value of its superclass, and does not indicate changes only due to projection. This is done for speed: we typically will only want to know if a point tried to move outside of the bounding box domain, since movement off the surface will be very common. Consider subclassing this method to add a check for significant differences in the input and output points. </p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-updateparticleposition","title":"function UpdateParticlePosition","text":"<pre><code>inline PointType UpdateParticlePosition(\n    const PointType &amp; point,\n    int idx,\n    vnl_vector_fixed&lt; double, DIMENSION &gt; &amp; update\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-getzerocrossingpoint","title":"function GetZeroCrossingPoint","text":"<pre><code>inline virtual PointType GetZeroCrossingPoint() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetZeroCrossingPoint</p> <p>Get any valid point on the domain. This is used to place the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-implicitsurfacedomain","title":"function ImplicitSurfaceDomain","text":"<pre><code>inline ImplicitSurfaceDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ImplicitSurfaceDomain.html#function-implicitsurfacedomain_1","title":"function ~ImplicitSurfaceDomain","text":"<pre><code>inline virtual ~ImplicitSurfaceDomain()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html","title":"shapeworks::IndexRegion","text":"<p>Indices into a 3d region of memory (can be negative, e.g., for the purpose of padding an image) </p> <p><code>#include &lt;Region.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#public-functions","title":"Public Functions","text":"Name IndexRegion() =default IndexRegion(const IndexRegion &amp; ) =default IndexRegion(const Dims &amp; dims) IndexRegion(const Coord &amp; _min, const Coord &amp; _max) bool operator==(const IndexRegion &amp; other) const bool valid() constverified min/max do not create an inverted or an empty region Coord origin() const Dims size() const IndexRegion &amp; pad(int padding)uniformly grows or shrinks the region by the specified amount"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#public-attributes","title":"Public Attributes","text":"Name Coord min Coord max"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-indexregion","title":"function IndexRegion","text":"<pre><code>IndexRegion() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-indexregion_1","title":"function IndexRegion","text":"<pre><code>IndexRegion(\n    const IndexRegion &amp; \n) =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-indexregion_2","title":"function IndexRegion","text":"<pre><code>inline IndexRegion(\n    const Dims &amp; dims\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-indexregion_3","title":"function IndexRegion","text":"<pre><code>inline IndexRegion(\n    const Coord &amp; _min,\n    const Coord &amp; _max\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-operator","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const IndexRegion &amp; other\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-valid","title":"function valid","text":"<pre><code>inline bool valid() const\n</code></pre> <p>verified min/max do not create an inverted or an empty region </p>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-origin","title":"function origin","text":"<pre><code>inline Coord origin() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-size","title":"function size","text":"<pre><code>inline Dims size() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#function-pad","title":"function pad","text":"<pre><code>IndexRegion &amp; pad(\n    int padding\n)\n</code></pre> <p>uniformly grows or shrinks the region by the specified amount </p>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#variable-min","title":"variable min","text":"<pre><code>Coord min {1000000000, 1000000000, 1000000000};\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1IndexRegion.html#variable-max","title":"variable max","text":"<pre><code>Coord max {-1000000000, -1000000000, -1000000000};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Job.html","title":"shapeworks::Job","text":"<p>Inherits from QObject</p> <p>Inherited by monailabel::MonaiLabelJob, shapeworks::DeepSSMJob, shapeworks::GroupPvalueJob, shapeworks::NetworkAnalysisJob, shapeworks::ParticleAreaJob, shapeworks::ParticleNormalEvaluationJob, shapeworks::ShapeEvaluationJob, shapeworks::ShapeScalarJob, shapeworks::StatsGroupLDAJob</p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#public-signals","title":"Public Signals","text":"Name void progress(double , QString  =\"\") void finished()"},{"location":"api/Classes/classshapeworks_1_1Job.html#public-functions","title":"Public Functions","text":"Name Job() virtual ~Job() virtual void run() =0run the job virtual QString name() =0get the name of the job virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1Job.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Job.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    double ,\n    QString  =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Job.html#signal-finished","title":"signal finished","text":"<pre><code>void finished()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Job.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Job.html#function-job","title":"function Job","text":"<pre><code>Job()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-job_1","title":"function ~Job","text":"<pre><code>virtual ~Job()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-run","title":"function run","text":"<pre><code>virtual void run() =0\n</code></pre> <p>run the job </p> <p>Reimplemented by: shapeworks::DeepSSMJob::run, shapeworks::ShapeEvaluationJob::run, shapeworks::GroupPvalueJob::run, shapeworks::NetworkAnalysisJob::run, shapeworks::ParticleAreaJob::run, shapeworks::ParticleNormalEvaluationJob::run, shapeworks::ShapeScalarJob::run, shapeworks::StatsGroupLDAJob::run, monailabel::MonaiLabelJob::run</p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-name","title":"function name","text":"<pre><code>virtual QString name() =0\n</code></pre> <p>get the name of the job </p> <p>Reimplemented by: shapeworks::DeepSSMJob::name, shapeworks::ShapeEvaluationJob::name, shapeworks::GroupPvalueJob::name, shapeworks::NetworkAnalysisJob::name, shapeworks::ParticleAreaJob::name, shapeworks::ParticleNormalEvaluationJob::name, shapeworks::ShapeScalarJob::name, shapeworks::StatsGroupLDAJob::name, monailabel::MonaiLabelJob::name</p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-get_completion_message","title":"function get_completion_message","text":"<pre><code>virtual QString get_completion_message()\n</code></pre> <p>get a message to display when the job is complete </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-get_abort_message","title":"function get_abort_message","text":"<pre><code>virtual QString get_abort_message()\n</code></pre> <p>get a message to display when the job is aborted </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-start_timer","title":"function start_timer","text":"<pre><code>void start_timer()\n</code></pre> <p>start the timer </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-timer_elapsed","title":"function timer_elapsed","text":"<pre><code>qint64 timer_elapsed()\n</code></pre> <p>how much time has elapsed since the timer was started </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-set_complete","title":"function set_complete","text":"<pre><code>inline void set_complete(\n    bool complete\n)\n</code></pre> <p>set the job as complete </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-is_complete","title":"function is_complete","text":"<pre><code>inline bool is_complete() const\n</code></pre> <p>is the job complete? </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-abort","title":"function abort","text":"<pre><code>inline void abort()\n</code></pre> <p>abort the job </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-is_aborted","title":"function is_aborted","text":"<pre><code>inline bool is_aborted() const\n</code></pre> <p>was the job aborted? </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-set_quiet_mode","title":"function set_quiet_mode","text":"<pre><code>inline void set_quiet_mode(\n    bool quiet\n)\n</code></pre> <p>set to quiet mode (no progress messages) </p>"},{"location":"api/Classes/classshapeworks_1_1Job.html#function-get_quiet_mode","title":"function get_quiet_mode","text":"<pre><code>inline bool get_quiet_mode()\n</code></pre> <p>get quiet mode </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html","title":"shapeworks::JsonProjectReader","text":"<p>JSON file format reader for Project.  More...</p> <p><code>#include &lt;JsonProjectReader.h&gt;</code></p> <p>Inherits from shapeworks::ProjectReader</p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#public-functions","title":"Public Functions","text":"Name JsonProjectReader(Project &amp; project) ~JsonProjectReader() virtual bool read_project(std::string filename) overrideRead a project from a file. virtual StringMap get_parameters(std::string name) override virtual StringMultiMap get_multi_parameters(std::string name) override"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ProjectReader</p> Name using project::types::StringMapList StringMapList using project::types::StringMap StringMap using project::types::StringList StringList using project::types::StringMultiMap StringMultiMap <p>Public Functions inherited from shapeworks::ProjectReader</p> Name ProjectReader(Project &amp; project)Constructor. virtual ~ProjectReader() =defaultDestructor. <p>Protected Functions inherited from shapeworks::ProjectReader</p> Name void load_subjects(StringMapList list)Load subjects from string map list. void load_parameters() void load_parameter(std::string name, StringMap map) void load_landmark_definitions(StringMapList list) bool contains(StringMap map, std::string key) StringList get_keys(StringMap map) <p>Protected Attributes inherited from shapeworks::ProjectReader</p> Name Project &amp; project_"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::JsonProjectReader;\n</code></pre> <p>JSON file format reader for Project. </p> <p>This class enables reader of Project objects from JSON file format </p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#function-jsonprojectreader","title":"function JsonProjectReader","text":"<pre><code>JsonProjectReader(\n    Project &amp; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#function-jsonprojectreader_1","title":"function ~JsonProjectReader","text":"<pre><code>~JsonProjectReader()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#function-read_project","title":"function read_project","text":"<pre><code>virtual bool read_project(\n    std::string filename\n) override\n</code></pre> <p>Read a project from a file. </p> <p>Reimplements: shapeworks::ProjectReader::read_project</p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>virtual StringMap get_parameters(\n    std::string name\n) override\n</code></pre> <p>Reimplements: shapeworks::ProjectReader::get_parameters</p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectReader.html#function-get_multi_parameters","title":"function get_multi_parameters","text":"<pre><code>virtual StringMultiMap get_multi_parameters(\n    std::string name\n) override\n</code></pre> <p>Reimplements: shapeworks::ProjectReader::get_multi_parameters</p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectWriter.html","title":"shapeworks::JsonProjectWriter","text":"<p>JSON file format writer for Project.  More...</p> <p><code>#include &lt;JsonProjectWriter.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectWriter.html#public-functions","title":"Public Functions","text":"Name bool write_project(Project &amp; project, std::string filename)"},{"location":"api/Classes/classshapeworks_1_1JsonProjectWriter.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::JsonProjectWriter;\n</code></pre> <p>JSON file format writer for Project. </p> <p>This class enables writing of Project objects to JSON file format </p>"},{"location":"api/Classes/classshapeworks_1_1JsonProjectWriter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1JsonProjectWriter.html#function-write_project","title":"function write_project","text":"<pre><code>static bool write_project(\n    Project &amp; project,\n    std::string filename\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html","title":"shapeworks::KeyboardShortcuts","text":"<p>More...</p> <p><code>#include &lt;KeyboardShortcuts.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html#public-functions","title":"Public Functions","text":"Name KeyboardShortcuts(QWidget * parent)constructor virtual ~KeyboardShortcuts()destructor"},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::KeyboardShortcuts;\n</code></pre> <p>The KeyboardShortcuts is a QDialog that implements the dialog for displaying the keyboard shortcuts </p>"},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html#function-keyboardshortcuts","title":"function KeyboardShortcuts","text":"<pre><code>KeyboardShortcuts(\n    QWidget * parent\n)\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classshapeworks_1_1KeyboardShortcuts.html#function-keyboardshortcuts_1","title":"function ~KeyboardShortcuts","text":"<pre><code>virtual ~KeyboardShortcuts()\n</code></pre> <p>destructor </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html","title":"shapeworks::LandmarkDefinition","text":"<p>Landmark class containing properties of each landmark. </p> <p><code>#include &lt;Project.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#public-attributes","title":"Public Attributes","text":"Name std::string domain_ int domain_id_ int landmark_id std::string name_ bool visible_ std::string color_ std::string comment_"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-domain_","title":"variable domain_","text":"<pre><code>std::string domain_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-domain_id_","title":"variable domain_id_","text":"<pre><code>int domain_id_ = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-landmark_id","title":"variable landmark_id","text":"<pre><code>int landmark_id = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-name_","title":"variable name_","text":"<pre><code>std::string name_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-visible_","title":"variable visible_","text":"<pre><code>bool visible_ = true;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-color_","title":"variable color_","text":"<pre><code>std::string color_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkDefinition.html#variable-comment_","title":"variable comment_","text":"<pre><code>std::string comment_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html","title":"shapeworks::LandmarkItemDelegate","text":"<p>Inherits from QStyledItemDelegate</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#public-signals","title":"Public Signals","text":"Name void button_clicked(int row)"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#public-functions","title":"Public Functions","text":"Name LandmarkItemDelegate(QObject * parent =0) void paint(QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const override QWidget * createEditor(QWidget * parent, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const override void setEditorData(QWidget * editor, const QModelIndex &amp; index) const override void setModelData(QWidget * editor, QAbstractItemModel * model, const QModelIndex &amp; index) const override QSize sizeHint(const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const override void updateEditorGeometry(QWidget * editor, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const override void set_button_text(std::string button_text) void set_model(std::shared_ptr&lt; LandmarkTableModel &gt; model)"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#signal-button_clicked","title":"signal button_clicked","text":"<pre><code>void button_clicked(\n    int row\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-landmarkitemdelegate","title":"function LandmarkItemDelegate","text":"<pre><code>LandmarkItemDelegate(\n    QObject * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-paint","title":"function paint","text":"<pre><code>void paint(\n    QPainter * painter,\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-createeditor","title":"function createEditor","text":"<pre><code>QWidget * createEditor(\n    QWidget * parent,\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-seteditordata","title":"function setEditorData","text":"<pre><code>void setEditorData(\n    QWidget * editor,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-setmodeldata","title":"function setModelData","text":"<pre><code>void setModelData(\n    QWidget * editor,\n    QAbstractItemModel * model,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-sizehint","title":"function sizeHint","text":"<pre><code>QSize sizeHint(\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-updateeditorgeometry","title":"function updateEditorGeometry","text":"<pre><code>void updateEditorGeometry(\n    QWidget * editor,\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-set_button_text","title":"function set_button_text","text":"<pre><code>void set_button_text(\n    std::string button_text\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkItemDelegate.html#function-set_model","title":"function set_model","text":"<pre><code>void set_model(\n    std::shared_ptr&lt; LandmarkTableModel &gt; model\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html","title":"shapeworks::LandmarkTableModel","text":"<p>Inherits from QAbstractTableModel</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#public-slots","title":"Public Slots","text":"Name void new_landmark()create a new landmark void handle_click(const QModelIndex &amp; index)Handler for when table cells are clicked. void handle_double_click(const QModelIndex &amp; index)Handler for when table cells are double clicked. void handle_header_click(int index)Handle header click."},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#public-functions","title":"Public Functions","text":"Name LandmarkTableModel(QObject * parent =0)Constructor. virtual ~LandmarkTableModel()Destructor. void set_session(QSharedPointer&lt; Session &gt; session)Attach to a session. void store_landmarks()Store landmarks back to project. void set_active_domain(int domain)Set the currently active domain. void update_table()Update the table of landmarks from the project. void update_cells()Update table cells. void remove_rows(const std::vector&lt; int &gt; &amp; rows)Remove landmarks with specified row indices. void toggle_visible()Toggle tri-state button for visibility in horizontal header. void set_placing_landmark(int row)Set the currently placing landmark. void delete_landmarks(const QModelIndexList &amp; list)delete the selected landmarks int rowCount(const QModelIndex &amp; index) const overrideQAbstractTableModel::rowCount implementation. int columnCount(const QModelIndex &amp; index) const overrideQAbstractTableModel::columnCount implementation. QVariant data(const QModelIndex &amp; index, int role) const overrideQAbstractTableModel::data implementation. bool setData(const QModelIndex &amp; index, const QVariant &amp; value, int role) overrideQAbstractTableModel::setData implementation. QVariant headerData(int section, Qt::Orientation orientation, int role) const overrideQAbstractTableModel::headerData implementation. Qt::ItemFlags flags(const QModelIndex &amp; index) const overrideQAbstractTableModel::flags implementation."},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#slot-new_landmark","title":"slot new_landmark","text":"<pre><code>void new_landmark()\n</code></pre> <p>create a new landmark </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#slot-handle_click","title":"slot handle_click","text":"<pre><code>void handle_click(\n    const QModelIndex &amp; index\n)\n</code></pre> <p>Handler for when table cells are clicked. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#slot-handle_double_click","title":"slot handle_double_click","text":"<pre><code>void handle_double_click(\n    const QModelIndex &amp; index\n)\n</code></pre> <p>Handler for when table cells are double clicked. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#slot-handle_header_click","title":"slot handle_header_click","text":"<pre><code>void handle_header_click(\n    int index\n)\n</code></pre> <p>Handle header click. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-landmarktablemodel","title":"function LandmarkTableModel","text":"<pre><code>LandmarkTableModel(\n    QObject * parent =0\n)\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-landmarktablemodel_1","title":"function ~LandmarkTableModel","text":"<pre><code>virtual ~LandmarkTableModel()\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>Attach to a session. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-store_landmarks","title":"function store_landmarks","text":"<pre><code>void store_landmarks()\n</code></pre> <p>Store landmarks back to project. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-set_active_domain","title":"function set_active_domain","text":"<pre><code>void set_active_domain(\n    int domain\n)\n</code></pre> <p>Set the currently active domain. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-update_table","title":"function update_table","text":"<pre><code>void update_table()\n</code></pre> <p>Update the table of landmarks from the project. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-update_cells","title":"function update_cells","text":"<pre><code>void update_cells()\n</code></pre> <p>Update table cells. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-remove_rows","title":"function remove_rows","text":"<pre><code>void remove_rows(\n    const std::vector&lt; int &gt; &amp; rows\n)\n</code></pre> <p>Remove landmarks with specified row indices. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-toggle_visible","title":"function toggle_visible","text":"<pre><code>void toggle_visible()\n</code></pre> <p>Toggle tri-state button for visibility in horizontal header. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-set_placing_landmark","title":"function set_placing_landmark","text":"<pre><code>void set_placing_landmark(\n    int row\n)\n</code></pre> <p>Set the currently placing landmark. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-delete_landmarks","title":"function delete_landmarks","text":"<pre><code>void delete_landmarks(\n    const QModelIndexList &amp; list\n)\n</code></pre> <p>delete the selected landmarks </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-rowcount","title":"function rowCount","text":"<pre><code>int rowCount(\n    const QModelIndex &amp; index\n) const override\n</code></pre> <p>QAbstractTableModel::rowCount implementation. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-columncount","title":"function columnCount","text":"<pre><code>int columnCount(\n    const QModelIndex &amp; index\n) const override\n</code></pre> <p>QAbstractTableModel::columnCount implementation. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-data","title":"function data","text":"<pre><code>QVariant data(\n    const QModelIndex &amp; index,\n    int role\n) const override\n</code></pre> <p>QAbstractTableModel::data implementation. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-setdata","title":"function setData","text":"<pre><code>bool setData(\n    const QModelIndex &amp; index,\n    const QVariant &amp; value,\n    int role\n) override\n</code></pre> <p>QAbstractTableModel::setData implementation. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-headerdata","title":"function headerData","text":"<pre><code>QVariant headerData(\n    int section,\n    Qt::Orientation orientation,\n    int role\n) const override\n</code></pre> <p>QAbstractTableModel::headerData implementation. </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkTableModel.html#function-flags","title":"function flags","text":"<pre><code>Qt::ItemFlags flags(\n    const QModelIndex &amp; index\n) const override\n</code></pre> <p>QAbstractTableModel::flags implementation. </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html","title":"shapeworks::LandmarkWidget","text":"<p>LandmarkWidget.  More...</p> <p><code>#include &lt;LandmarkWidget.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#public-functions","title":"Public Functions","text":"Name LandmarkWidget(Viewer * viewer) ~LandmarkWidget() void update_landmarks() void store_positions() void update_glyph_properties() void clear_landmark_handles()"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::LandmarkWidget;\n</code></pre> <p>LandmarkWidget. </p> <p>Widget to display and manipulate landmarks </p>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-landmarkwidget","title":"function LandmarkWidget","text":"<pre><code>LandmarkWidget(\n    Viewer * viewer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-landmarkwidget_1","title":"function ~LandmarkWidget","text":"<pre><code>~LandmarkWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-update_landmarks","title":"function update_landmarks","text":"<pre><code>void update_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-store_positions","title":"function store_positions","text":"<pre><code>void store_positions()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-update_glyph_properties","title":"function update_glyph_properties","text":"<pre><code>void update_glyph_properties()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LandmarkWidget.html#function-clear_landmark_handles","title":"function clear_landmark_handles","text":"<pre><code>void clear_landmark_handles()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html","title":"shapeworks::LegacyCorrespondenceFunction","text":"<p>Inherits from shapeworks::VectorFunction</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-types","title":"Public Types","text":"Name typedef LegacyShapeMatrix ShapeMatrixType typedef ShapeMatrixType::DataType DataType typedef VectorFunction::VectorType VectorType typedef ParticleSystem::PointType PointType typedef vnl_vector&lt; DataType &gt; vnl_vector_type typedef vnl_matrix&lt; DataType &gt; vnl_matrix_type"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-functions","title":"Public Functions","text":"Name std::shared_ptr&lt; LegacyCorrespondenceFunction &gt; New()Factory method for creating instances. virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; , double &amp; ) const virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep) const virtual double energy(unsigned int a, unsigned int b, const ParticleSystem * c) const void WriteModes(const std::string &amp; , int ) const void SetShapeMatrix(ShapeMatrixType * s) ShapeMatrixType * GetShapeMatrix() const ShapeMatrixType * GetShapeMatrix() const virtual void before_iteration() virtual void after_iteration() override void SetMinimumVariance(double d) double GetMinimumVariance() const void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) bool GetMinimumVarianceDecayConstant() const void PrintShapeMatrix() void UseMeanenergy() void UseEntropy() bool GetHoldMinimumVariance() const void SetHoldMinimumVariance(bool b) void SetRecomputeCovarianceInterval(int i) int GetRecomputeCovarianceInterval() const virtual std::shared_ptr&lt; VectorFunction &gt; clone() override LegacyCorrespondenceFunction() ~LegacyCorrespondenceFunction() override =default"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#protected-functions","title":"Protected Functions","text":"Name LegacyCorrespondenceFunction(const LegacyCorrespondenceFunction &amp; ) =delete LegacyCorrespondenceFunction &amp; operator=(const LegacyCorrespondenceFunction &amp; ) =delete virtual void ComputeCovarianceMatrix()"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static unsigned int VDimension constexpr static unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#protected-attributes","title":"Protected Attributes","text":"Name ShapeMatrixType::Pointer m_ShapeMatrix std::shared_ptr&lt; vnl_matrix_type &gt; m_PointsUpdate double m_MinimumVariance double m_MinimumEigenValue double m_CurrentEnergy bool m_HoldMinimumVariance double m_MinimumVarianceDecayConstant int m_RecomputeCovarianceInterval int m_Counter bool m_UseMeanEnergy std::shared_ptr&lt; vnl_matrix_type &gt; m_points_mean std::shared_ptr&lt; Eigen::MatrixXd &gt; m_InverseCovMatrix"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::VectorFunction</p> Name virtual void reset_buffers()May be called by the solver class. virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) virtual void set_particle_system(ParticleSystem * p)Some subclasses may require a pointer to the particle system and its domain number. virtual ParticleSystem * get_particle_system() const virtual void set_domain_number(unsigned int i) virtual int get_domain_number() const virtual double get_relative_energy_scaling() const virtual void set_relative_energy_scaling(double r) virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes. <p>Protected Functions inherited from shapeworks::VectorFunction</p> Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete <p>Protected Attributes inherited from shapeworks::VectorFunction</p> Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-shapematrixtype","title":"typedef ShapeMatrixType","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::LegacyCorrespondenceFunction::ShapeMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef ShapeMatrixType::DataType shapeworks::LegacyCorrespondenceFunction::DataType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>typedef VectorFunction::VectorType shapeworks::LegacyCorrespondenceFunction::VectorType;\n</code></pre> <p>Vector &amp; Point types. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystem::PointType shapeworks::LegacyCorrespondenceFunction::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-vnl_vector_type","title":"typedef vnl_vector_type","text":"<pre><code>typedef vnl_vector&lt;DataType&gt; shapeworks::LegacyCorrespondenceFunction::vnl_vector_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#typedef-vnl_matrix_type","title":"typedef vnl_matrix_type","text":"<pre><code>typedef vnl_matrix&lt;DataType&gt; shapeworks::LegacyCorrespondenceFunction::vnl_matrix_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-new","title":"function New","text":"<pre><code>static inline std::shared_ptr&lt; LegacyCorrespondenceFunction &gt; New()\n</code></pre> <p>Factory method for creating instances. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; ,\n    double &amp; \n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-energy","title":"function energy","text":"<pre><code>inline virtual double energy(\n    unsigned int a,\n    unsigned int b,\n    const ParticleSystem * c\n) const\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-writemodes","title":"function WriteModes","text":"<pre><code>void WriteModes(\n    const std::string &amp; ,\n    int \n) const\n</code></pre> <p>Write the first n modes to +- 3 std dev and the mean of the model described by the covariance matrix. The string argument is a prefix to the file names. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-setshapematrix","title":"function SetShapeMatrix","text":"<pre><code>inline void SetShapeMatrix(\n    ShapeMatrixType * s\n)\n</code></pre> <p>Access the shape matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getshapematrix","title":"function GetShapeMatrix","text":"<pre><code>inline ShapeMatrixType * GetShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getshapematrix_1","title":"function GetShapeMatrix","text":"<pre><code>inline const ShapeMatrixType * GetShapeMatrix() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::before_iteration</p> <p>Called before each iteration of a solver. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::after_iteration</p> <p>Called after each iteration of the solver. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-setminimumvariance","title":"function SetMinimumVariance","text":"<pre><code>inline void SetMinimumVariance(\n    double d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getminimumvariance","title":"function GetMinimumVariance","text":"<pre><code>inline double GetMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-setminimumvariancedecay","title":"function SetMinimumVarianceDecay","text":"<pre><code>inline void SetMinimumVarianceDecay(\n    double initial_value,\n    double final_value,\n    double time_period\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getminimumvariancedecayconstant","title":"function GetMinimumVarianceDecayConstant","text":"<pre><code>inline bool GetMinimumVarianceDecayConstant() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-printshapematrix","title":"function PrintShapeMatrix","text":"<pre><code>inline void PrintShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-usemeanenergy","title":"function UseMeanenergy","text":"<pre><code>inline void UseMeanenergy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-useentropy","title":"function UseEntropy","text":"<pre><code>inline void UseEntropy()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getholdminimumvariance","title":"function GetHoldMinimumVariance","text":"<pre><code>inline bool GetHoldMinimumVariance() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-setholdminimumvariance","title":"function SetHoldMinimumVariance","text":"<pre><code>inline void SetHoldMinimumVariance(\n    bool b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-setrecomputecovarianceinterval","title":"function SetRecomputeCovarianceInterval","text":"<pre><code>inline void SetRecomputeCovarianceInterval(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-getrecomputecovarianceinterval","title":"function GetRecomputeCovarianceInterval","text":"<pre><code>inline int GetRecomputeCovarianceInterval() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-clone","title":"function clone","text":"<pre><code>inline virtual std::shared_ptr&lt; VectorFunction &gt; clone() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-legacycorrespondencefunction","title":"function LegacyCorrespondenceFunction","text":"<pre><code>inline LegacyCorrespondenceFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-legacycorrespondencefunction_1","title":"function ~LegacyCorrespondenceFunction","text":"<pre><code>~LegacyCorrespondenceFunction() override =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-legacycorrespondencefunction_2","title":"function LegacyCorrespondenceFunction","text":"<pre><code>LegacyCorrespondenceFunction(\n    const LegacyCorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-operator","title":"function operator=","text":"<pre><code>LegacyCorrespondenceFunction &amp; operator=(\n    const LegacyCorrespondenceFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#function-computecovariancematrix","title":"function ComputeCovarianceMatrix","text":"<pre><code>virtual void ComputeCovarianceMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static unsigned int VDimension = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr static unsigned int Dimension = VDimension;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_shapematrix","title":"variable m_ShapeMatrix","text":"<pre><code>ShapeMatrixType::Pointer m_ShapeMatrix;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_pointsupdate","title":"variable m_PointsUpdate","text":"<pre><code>std::shared_ptr&lt; vnl_matrix_type &gt; m_PointsUpdate;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_minimumvariance","title":"variable m_MinimumVariance","text":"<pre><code>double m_MinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_minimumeigenvalue","title":"variable m_MinimumEigenValue","text":"<pre><code>double m_MinimumEigenValue;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_currentenergy","title":"variable m_CurrentEnergy","text":"<pre><code>double m_CurrentEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_holdminimumvariance","title":"variable m_HoldMinimumVariance","text":"<pre><code>bool m_HoldMinimumVariance;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_minimumvariancedecayconstant","title":"variable m_MinimumVarianceDecayConstant","text":"<pre><code>double m_MinimumVarianceDecayConstant;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_recomputecovarianceinterval","title":"variable m_RecomputeCovarianceInterval","text":"<pre><code>int m_RecomputeCovarianceInterval;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_counter","title":"variable m_Counter","text":"<pre><code>int m_Counter;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_usemeanenergy","title":"variable m_UseMeanEnergy","text":"<pre><code>bool m_UseMeanEnergy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_points_mean","title":"variable m_points_mean","text":"<pre><code>std::shared_ptr&lt; vnl_matrix_type &gt; m_points_mean;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyCorrespondenceFunction.html#variable-m_inversecovmatrix","title":"variable m_InverseCovMatrix","text":"<pre><code>std::shared_ptr&lt; Eigen::MatrixXd &gt; m_InverseCovMatrix;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html","title":"shapeworks::LegacyShapeMatrix","text":"<p>Inherits from vnl_matrix&lt; double &gt;, shapeworks::Observer</p> <p>Inherited by shapeworks::LinearRegressionShapeMatrix, shapeworks::MixedEffectsShapeMatrix</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#public-types","title":"Public Types","text":"Name typedef double DataType typedef LegacyShapeMatrix Self typedef Observer Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) virtual Observer void DomainAddEventCallback(Object * , const itk::EventObject &amp; e) virtual void ResizeMatrix(int rs, int cs) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void PrintMatrix() bool CheckForNans() void SetDomainsPerShape(int i) int GetDomainsPerShape() const virtual void before_iteration() virtual void after_iteration() virtual void SetMatrix(const vnl_matrix&lt; double &gt; &amp; m)"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#protected-functions","title":"Protected Functions","text":"Name LegacyShapeMatrix() virtual ~LegacyShapeMatrix() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#protected-attributes","title":"Protected Attributes","text":"Name int m_DomainsPerShape"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name itkTypeMacro(Observer , DataObject ) virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef double shapeworks::LegacyShapeMatrix::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::LegacyShapeMatrix::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Observer shapeworks::LegacyShapeMatrix::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::LegacyShapeMatrix::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::LegacyShapeMatrix::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::LegacyShapeMatrix::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual Observer void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::DomainAddEventCallback</p> <p>Reimplemented by: shapeworks::LinearRegressionShapeMatrix::DomainAddEventCallback, shapeworks::MixedEffectsShapeMatrix::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-resizematrix","title":"function ResizeMatrix","text":"<pre><code>inline virtual void ResizeMatrix(\n    int rs,\n    int cs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionAddEventCallback</p> <p>Reimplemented by: shapeworks::LinearRegressionShapeMatrix::PositionAddEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionSetEventCallback</p> <p>Reimplemented by: shapeworks::LinearRegressionShapeMatrix::PositionSetEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionRemoveEventCallback</p> <p>Reimplemented by: shapeworks::LinearRegressionShapeMatrix::PositionRemoveEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-printmatrix","title":"function PrintMatrix","text":"<pre><code>inline void PrintMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-checkfornans","title":"function CheckForNans","text":"<pre><code>inline bool CheckForNans()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. This can only be safely done before shapes are initialized with points! </p>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-setmatrix","title":"function SetMatrix","text":"<pre><code>inline virtual void SetMatrix(\n    const vnl_matrix&lt; double &gt; &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-legacyshapematrix","title":"function LegacyShapeMatrix","text":"<pre><code>inline LegacyShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-legacyshapematrix_1","title":"function ~LegacyShapeMatrix","text":"<pre><code>inline virtual ~LegacyShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LegacyShapeMatrix.html#variable-m_domainspershape","title":"variable m_DomainsPerShape","text":"<pre><code>int m_DomainsPerShape;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html","title":"shapeworks::Lightbox","text":"<p>Display multiple Viewers in a tiled display.  More...</p> <p><code>#include &lt;Lightbox.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-slots","title":"Public Slots","text":"Name void handle_timer_callback()"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-signals","title":"Public Signals","text":"Name void right_click(int index)"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-functions","title":"Public Functions","text":"Name Lightbox() ~Lightbox() void set_shapes(ShapeList shapes) ShapeList get_shapes() void set_interactor(vtkRenderWindowInteractor * interactor) void set_render_window(vtkRenderWindow * render_window) void set_tile_layout(int width, int height) void setup_renderers() int get_num_rows() int get_num_rows_visible() void set_start_row(int row) ViewerList get_viewers() void redraw() void handle_pick(int * click_pos, bool one, bool ctrl, vtkRenderer * renderer) void handle_hover(int * click_pos) void handle_key(int * click_pos, std::string key) void handle_right_click(int * click_pos, vtkRenderer * renderer)Handle a right click that did not involve any movement. void set_glyph_lut(vtkSmartPointer&lt; vtkLookupTable &gt; lut) void set_session(QSharedPointer&lt; Session &gt; session) void set_visualizer(Visualizer * visualizer) bool render_window_ready() void clear_renderers() std::array&lt; double, 3 &gt; initPos() void handle_new_mesh() void reset_camera() void reset_camera_clipping_range() void set_orientation_marker(Preferences::OrientationMarkerType type, Preferences::OrientationMarkerCorner corner) void set_orientation_marker_viewport() void update_feature_range() void update_interactor_style() void set_shared_brightness_and_contrast(double brightness, double contrast) vtkRenderWindow * get_render_window() int get_start_shape()"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Lightbox;\n</code></pre> <p>Display multiple Viewers in a tiled display. </p> <p>The LightBox class displays multiple Viewers in a tiled display </p>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#slot-handle_timer_callback","title":"slot handle_timer_callback","text":"<pre><code>void handle_timer_callback()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#signal-right_click","title":"signal right_click","text":"<pre><code>void right_click(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-lightbox","title":"function Lightbox","text":"<pre><code>Lightbox()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-lightbox_1","title":"function ~Lightbox","text":"<pre><code>~Lightbox()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_shapes","title":"function set_shapes","text":"<pre><code>void set_shapes(\n    ShapeList shapes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_shapes","title":"function get_shapes","text":"<pre><code>ShapeList get_shapes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_interactor","title":"function set_interactor","text":"<pre><code>void set_interactor(\n    vtkRenderWindowInteractor * interactor\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_render_window","title":"function set_render_window","text":"<pre><code>void set_render_window(\n    vtkRenderWindow * render_window\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_tile_layout","title":"function set_tile_layout","text":"<pre><code>void set_tile_layout(\n    int width,\n    int height\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-setup_renderers","title":"function setup_renderers","text":"<pre><code>void setup_renderers()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_num_rows","title":"function get_num_rows","text":"<pre><code>int get_num_rows()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_num_rows_visible","title":"function get_num_rows_visible","text":"<pre><code>int get_num_rows_visible()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_start_row","title":"function set_start_row","text":"<pre><code>void set_start_row(\n    int row\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_viewers","title":"function get_viewers","text":"<pre><code>ViewerList get_viewers()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-redraw","title":"function redraw","text":"<pre><code>void redraw()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-handle_pick","title":"function handle_pick","text":"<pre><code>void handle_pick(\n    int * click_pos,\n    bool one,\n    bool ctrl,\n    vtkRenderer * renderer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-handle_hover","title":"function handle_hover","text":"<pre><code>void handle_hover(\n    int * click_pos\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-handle_key","title":"function handle_key","text":"<pre><code>void handle_key(\n    int * click_pos,\n    std::string key\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-handle_right_click","title":"function handle_right_click","text":"<pre><code>void handle_right_click(\n    int * click_pos,\n    vtkRenderer * renderer\n)\n</code></pre> <p>Handle a right click that did not involve any movement. </p>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_glyph_lut","title":"function set_glyph_lut","text":"<pre><code>void set_glyph_lut(\n    vtkSmartPointer&lt; vtkLookupTable &gt; lut\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_visualizer","title":"function set_visualizer","text":"<pre><code>void set_visualizer(\n    Visualizer * visualizer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-render_window_ready","title":"function render_window_ready","text":"<pre><code>inline bool render_window_ready()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-clear_renderers","title":"function clear_renderers","text":"<pre><code>void clear_renderers()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-initpos","title":"function initPos","text":"<pre><code>std::array&lt; double, 3 &gt; initPos()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-handle_new_mesh","title":"function handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-reset_camera","title":"function reset_camera","text":"<pre><code>void reset_camera()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-reset_camera_clipping_range","title":"function reset_camera_clipping_range","text":"<pre><code>void reset_camera_clipping_range()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_orientation_marker","title":"function set_orientation_marker","text":"<pre><code>void set_orientation_marker(\n    Preferences::OrientationMarkerType type,\n    Preferences::OrientationMarkerCorner corner\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_orientation_marker_viewport","title":"function set_orientation_marker_viewport","text":"<pre><code>void set_orientation_marker_viewport()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-update_feature_range","title":"function update_feature_range","text":"<pre><code>void update_feature_range()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-update_interactor_style","title":"function update_interactor_style","text":"<pre><code>void update_interactor_style()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-set_shared_brightness_and_contrast","title":"function set_shared_brightness_and_contrast","text":"<pre><code>void set_shared_brightness_and_contrast(\n    double brightness,\n    double contrast\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_render_window","title":"function get_render_window","text":"<pre><code>vtkRenderWindow * get_render_window()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Lightbox.html#function-get_start_shape","title":"function get_start_shape","text":"<pre><code>int get_start_shape()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html","title":"shapeworks::LinearRegressionShapeMatrix","text":"<p>Inherits from shapeworks::LegacyShapeMatrix, vnl_matrix&lt; double &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#public-types","title":"Public Types","text":"Name typedef double DataType typedef LinearRegressionShapeMatrix Self typedef LegacyShapeMatrix Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(LinearRegressionShapeMatrix , LegacyShapeMatrix ) void UpdateMeanMatrix() vnl_vector&lt; double &gt; ComputeMean(double k) const void ResizeParameters(unsigned int n) virtual void ResizeMeanMatrix(int rs, int cs) void ResizeExplanatory(unsigned int n) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; e) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void SetDomainsPerShape(int i) int GetDomainsPerShape() const void SetExplanatory(std::vector&lt; double &gt; v) void SetExplanatory(unsigned int i, double q) const double &amp; GetExplanatory(unsigned int i) const double &amp; GetExplanatory(unsigned int i) const vnl_vector&lt; double &gt; &amp; GetSlope() const const vnl_vector&lt; double &gt; &amp; GetIntercept() const void SetSlope(const std::vector&lt; double &gt; &amp; v) void SetIntercept(const std::vector&lt; double &gt; &amp; v) void EstimateParameters() void Initialize() virtual void BeforeIteration() void SetRegressionInterval(int i) int GetRegressionInterval() const"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#protected-functions","title":"Protected Functions","text":"Name LinearRegressionShapeMatrix() virtual ~LinearRegressionShapeMatrix() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::LegacyShapeMatrix</p> Name virtual void ResizeMatrix(int rs, int cs) void PrintMatrix() bool CheckForNans() virtual void before_iteration() virtual void after_iteration() virtual void SetMatrix(const vnl_matrix&lt; double &gt; &amp; m) <p>Protected Functions inherited from shapeworks::LegacyShapeMatrix</p> Name LegacyShapeMatrix() virtual ~LegacyShapeMatrix() <p>Protected Attributes inherited from shapeworks::LegacyShapeMatrix</p> Name int m_DomainsPerShape <p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef double shapeworks::LinearRegressionShapeMatrix::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef LinearRegressionShapeMatrix shapeworks::LinearRegressionShapeMatrix::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::LinearRegressionShapeMatrix::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::LinearRegressionShapeMatrix::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::LinearRegressionShapeMatrix::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::LinearRegressionShapeMatrix::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    LinearRegressionShapeMatrix ,\n    LegacyShapeMatrix \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-updatemeanmatrix","title":"function UpdateMeanMatrix","text":"<pre><code>inline void UpdateMeanMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-computemean","title":"function ComputeMean","text":"<pre><code>inline vnl_vector&lt; double &gt; ComputeMean(\n    double k\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-resizeparameters","title":"function ResizeParameters","text":"<pre><code>inline void ResizeParameters(\n    unsigned int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-resizemeanmatrix","title":"function ResizeMeanMatrix","text":"<pre><code>inline virtual void ResizeMeanMatrix(\n    int rs,\n    int cs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-resizeexplanatory","title":"function ResizeExplanatory","text":"<pre><code>inline void ResizeExplanatory(\n    unsigned int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. This can only be safely done before shapes are initialized with points! </p>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setexplanatory","title":"function SetExplanatory","text":"<pre><code>inline void SetExplanatory(\n    std::vector&lt; double &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setexplanatory_1","title":"function SetExplanatory","text":"<pre><code>inline void SetExplanatory(\n    unsigned int i,\n    double q\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getexplanatory","title":"function GetExplanatory","text":"<pre><code>inline const double &amp; GetExplanatory(\n    unsigned int i\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getexplanatory_1","title":"function GetExplanatory","text":"<pre><code>inline double &amp; GetExplanatory(\n    unsigned int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getslope","title":"function GetSlope","text":"<pre><code>inline const vnl_vector&lt; double &gt; &amp; GetSlope() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getintercept","title":"function GetIntercept","text":"<pre><code>inline const vnl_vector&lt; double &gt; &amp; GetIntercept() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setslope","title":"function SetSlope","text":"<pre><code>inline void SetSlope(\n    const std::vector&lt; double &gt; &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setintercept","title":"function SetIntercept","text":"<pre><code>inline void SetIntercept(\n    const std::vector&lt; double &gt; &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-estimateparameters","title":"function EstimateParameters","text":"<pre><code>inline void EstimateParameters()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-initialize","title":"function Initialize","text":"<pre><code>inline void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-beforeiteration","title":"function BeforeIteration","text":"<pre><code>inline virtual void BeforeIteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-setregressioninterval","title":"function SetRegressionInterval","text":"<pre><code>inline void SetRegressionInterval(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-getregressioninterval","title":"function GetRegressionInterval","text":"<pre><code>inline int GetRegressionInterval() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-linearregressionshapematrix","title":"function LinearRegressionShapeMatrix","text":"<pre><code>inline LinearRegressionShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-linearregressionshapematrix_1","title":"function ~LinearRegressionShapeMatrix","text":"<pre><code>inline virtual ~LinearRegressionShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LinearRegressionShapeMatrix.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1LogWindow.html","title":"shapeworks::LogWindow","text":"<p>Log Window.  More...</p> <p><code>#include &lt;LogWindow.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1LogWindow.html#public-functions","title":"Public Functions","text":"Name LogWindow(QWidget * parent =0) void add_message(MessageType message_type, QString message)add a message to the history"},{"location":"api/Classes/classshapeworks_1_1LogWindow.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::LogWindow;\n</code></pre> <p>Log Window. </p> <p>This dialog displays the history of messages (e.g. status bar messages) </p>"},{"location":"api/Classes/classshapeworks_1_1LogWindow.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1LogWindow.html#function-logwindow","title":"function LogWindow","text":"<pre><code>LogWindow(\n    QWidget * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1LogWindow.html#function-add_message","title":"function add_message","text":"<pre><code>void add_message(\n    MessageType message_type,\n    QString message\n)\n</code></pre> <p>add a message to the history </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html","title":"shapeworks::Logging","text":"<p>Module: Common Classes</p> <p>ShapeWorks Logging Library.  More...</p> <p><code>#include &lt;Logging.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#public-functions","title":"Public Functions","text":"Name Logging &amp; Instance()Return the singleton instance. void open_file_log(const std::string &amp; filename)Create a file log. bool check_log_open() constReturn if the log is open. std::string get_log_filename() constReturn the log filename. void log_message(const std::string &amp; message, const int line, const char * file) constLog a message, use SW_LOG macro. void log_only(const std::string &amp; message, const int line, const char * file, const char * function) constLog a message, use SW_LOG_ONLY macro. void log_stack(const std::string &amp; message) constLog a stack trace message, use SW_LOG_STACK macro. void log_error(const std::string &amp; message, const int line, const char * file) constLog an error, use SW_ERROR macro. void show_message(const std::string &amp; message, const int line, const char * file) constLog a message, use SW_MESSAGE macro. void show_status(const std::string &amp; message, const int line, const char * file) constLog a message, use SW_STATUS macro. void show_progress(double value, const std::string &amp; message)Display progress (0-100) void log_debug(const std::string &amp; message, const int line, const char * file, const char * function) constLog a debug message, use SW_DEBUG macro. void log_warning(const std::string &amp; message, const int line, const char * file) constLog a warning message, use SW_WARN macro. void close_log()Close the log, use SW_CLOSE_LOG macro. void set_error_callback(const std::function&lt; void(std::string)&gt; &amp; callback)Set an error callback function to be called whenever an error is raised. void set_message_callback(const std::function&lt; void(std::string)&gt; &amp; callback)Set a message callback function to be called whenever an message is posted. void set_warning_callback(const std::function&lt; void(std::string)&gt; &amp; callback)Set a warning callback function to be called whenever a warning is posted. void set_debug_callback(const std::function&lt; void(std::string)&gt; &amp; callback)Set a debug message callback function to be called whenever a debug message is posted. void set_status_callback(const std::function&lt; void(std::string)&gt; &amp; callback)Set a status callback function to be called whenever a status message is posted. void set_progress_callback(const std::function&lt; void(double, std::string)&gt; &amp; callback)Set a progress callback function to be called whenever a progress update is posted."},{"location":"api/Classes/classshapeworks_1_1Logging.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Logging;\n</code></pre> <p>ShapeWorks Logging Library. </p> <p>The Logging class supports univeral console and file logging.</p> <p>To use the ShapeWorks logging library, use the pre-defined macros:</p> <p>Normal log message: </p> <pre><code>SW_LOG(\"message\")\n</code></pre> <p>Warning: </p> <pre><code>SW_WARN(\"warning\")\n</code></pre> <p>Error: </p> <pre><code>SW_ERROR(\"error\")\n</code></pre> <p>Debug: </p> <pre><code>SW_DEBUG(\"debug\")\n</code></pre> <p>Output (assuming it was line 25 of Analyze.cpp and SW_LOG_LEVEL=debug): </p> <pre><code>[2022-08-18 11:40:01.021] [debug] [Analyze.cpp|25] debug\n</code></pre> <p>The logging macros using the fmt library. Read more here:</p> <p>https://github.com/fmtlib/fmt</p> <p>Example: </p> <pre><code>int mode = 10;\ndouble eigen_value = 42.3;\nSW_LOG(\"eigen value [{}]: {:.2f}\", mode, eigen_value);\n</code></pre> <p>Output: </p> <pre><code>[2022-08-18 11:37:42.613] [info] eigen value [10]: 42.32\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-instance","title":"function Instance","text":"<pre><code>static Logging &amp; Instance()\n</code></pre> <p>Return the singleton instance. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-open_file_log","title":"function open_file_log","text":"<pre><code>void open_file_log(\n    const std::string &amp; filename\n)\n</code></pre> <p>Create a file log. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-check_log_open","title":"function check_log_open","text":"<pre><code>bool check_log_open() const\n</code></pre> <p>Return if the log is open. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-get_log_filename","title":"function get_log_filename","text":"<pre><code>std::string get_log_filename() const\n</code></pre> <p>Return the log filename. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_message","title":"function log_message","text":"<pre><code>void log_message(\n    const std::string &amp; message,\n    const int line,\n    const char * file\n) const\n</code></pre> <p>Log a message, use SW_LOG macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_only","title":"function log_only","text":"<pre><code>void log_only(\n    const std::string &amp; message,\n    const int line,\n    const char * file,\n    const char * function\n) const\n</code></pre> <p>Log a message, use SW_LOG_ONLY macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_stack","title":"function log_stack","text":"<pre><code>void log_stack(\n    const std::string &amp; message\n) const\n</code></pre> <p>Log a stack trace message, use SW_LOG_STACK macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_error","title":"function log_error","text":"<pre><code>void log_error(\n    const std::string &amp; message,\n    const int line,\n    const char * file\n) const\n</code></pre> <p>Log an error, use SW_ERROR macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-show_message","title":"function show_message","text":"<pre><code>void show_message(\n    const std::string &amp; message,\n    const int line,\n    const char * file\n) const\n</code></pre> <p>Log a message, use SW_MESSAGE macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-show_status","title":"function show_status","text":"<pre><code>void show_status(\n    const std::string &amp; message,\n    const int line,\n    const char * file\n) const\n</code></pre> <p>Log a message, use SW_STATUS macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-show_progress","title":"function show_progress","text":"<pre><code>void show_progress(\n    double value,\n    const std::string &amp; message\n)\n</code></pre> <p>Display progress (0-100) </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_debug","title":"function log_debug","text":"<pre><code>void log_debug(\n    const std::string &amp; message,\n    const int line,\n    const char * file,\n    const char * function\n) const\n</code></pre> <p>Log a debug message, use SW_DEBUG macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-log_warning","title":"function log_warning","text":"<pre><code>void log_warning(\n    const std::string &amp; message,\n    const int line,\n    const char * file\n) const\n</code></pre> <p>Log a warning message, use SW_WARN macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-close_log","title":"function close_log","text":"<pre><code>void close_log()\n</code></pre> <p>Close the log, use SW_CLOSE_LOG macro. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_error_callback","title":"function set_error_callback","text":"<pre><code>void set_error_callback(\n    const std::function&lt; void(std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set an error callback function to be called whenever an error is raised. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_message_callback","title":"function set_message_callback","text":"<pre><code>void set_message_callback(\n    const std::function&lt; void(std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set a message callback function to be called whenever an message is posted. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_warning_callback","title":"function set_warning_callback","text":"<pre><code>void set_warning_callback(\n    const std::function&lt; void(std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set a warning callback function to be called whenever a warning is posted. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_debug_callback","title":"function set_debug_callback","text":"<pre><code>void set_debug_callback(\n    const std::function&lt; void(std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set a debug message callback function to be called whenever a debug message is posted. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_status_callback","title":"function set_status_callback","text":"<pre><code>void set_status_callback(\n    const std::function&lt; void(std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set a status callback function to be called whenever a status message is posted. </p>"},{"location":"api/Classes/classshapeworks_1_1Logging.html#function-set_progress_callback","title":"function set_progress_callback","text":"<pre><code>void set_progress_callback(\n    const std::function&lt; void(double, std::string)&gt; &amp; callback\n)\n</code></pre> <p>Set a progress callback function to be called whenever a progress update is posted. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MatrixContainer.html","title":"shapeworks::MatrixContainer","text":""},{"location":"api/Classes/classshapeworks_1_1MatrixContainer.html#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd matrix_"},{"location":"api/Classes/classshapeworks_1_1MatrixContainer.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MatrixContainer.html#variable-matrix_","title":"variable matrix_","text":"<pre><code>Eigen::MatrixXd matrix_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html","title":"shapeworks::MeanCurvatureContainer","text":"<p>More...</p> <p>Inherits from shapeworks::GenericContainerArray&lt; TNumericType &gt;, std::vector&lt; GenericContainer&lt; T &gt;::Pointer &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#public-types","title":"Public Types","text":"Name typedef TNumericType NumericType typedef MeanCurvatureContainer Self typedef GenericContainerArray&lt; TNumericType &gt; Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer typedef ParticleSystem ParticleSystemType typedef ParticleSystemType::PointType PointType typedef vnl_vector_fixed&lt; TNumericType, VDimension &gt; VnlVectorType"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(MeanCurvatureContainer , GenericContainerArray ) void SetVerbosity(unsigned int val) unsigned int GetVerbosity() virtual void PositionAddEventCallback(itk::Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(itk::Object * o, const itk::EventObject &amp; e) virtual void DomainAddEventCallback(itk::Object * o, const itk::EventObject &amp; e) void ComputeMeanCurvature(const ParticleSystemType * system, unsigned int idx, unsigned int dom) virtual void ComputeCurvatureStatistics(const ParticleSystemType * , unsigned int d) double GetMeanCurvature(int d) double GetCurvatureStandardDeviation(int d)"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#protected-functions","title":"Protected Functions","text":"Name MeanCurvatureContainer() virtual ~MeanCurvatureContainer() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::GenericContainerArray&lt; TNumericType &gt;</p> Name typedef T DataType <p>Public Functions inherited from shapeworks::GenericContainerArray&lt; TNumericType &gt;</p> Name virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void ZeroAllValues() <p>Protected Functions inherited from shapeworks::GenericContainerArray&lt; TNumericType &gt;</p> Name GenericContainerArray() virtual ~GenericContainerArray() <p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TNumericType ,\nunsigned int VDimension&gt;\nclass shapeworks::MeanCurvatureContainer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-numerictype","title":"typedef NumericType","text":"<pre><code>typedef TNumericType shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::NumericType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef MeanCurvatureContainer shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef GenericContainerArray&lt;TNumericType&gt; shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-particlesystemtype","title":"typedef ParticleSystemType","text":"<pre><code>typedef ParticleSystem shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::ParticleSystemType;\n</code></pre> <p>Numeric types. </p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystemType::PointType shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#typedef-vnlvectortype","title":"typedef VnlVectorType","text":"<pre><code>typedef vnl_vector_fixed&lt;TNumericType, VDimension&gt; shapeworks::MeanCurvatureContainer&lt; TNumericType, VDimension &gt;::VnlVectorType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    MeanCurvatureContainer ,\n    GenericContainerArray \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-setverbosity","title":"function SetVerbosity","text":"<pre><code>inline void SetVerbosity(\n    unsigned int val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-getverbosity","title":"function GetVerbosity","text":"<pre><code>inline unsigned int GetVerbosity()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    itk::Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    itk::Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    itk::Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-computemeancurvature","title":"function ComputeMeanCurvature","text":"<pre><code>inline void ComputeMeanCurvature(\n    const ParticleSystemType * system,\n    unsigned int idx,\n    unsigned int dom\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-computecurvaturestatistics","title":"function ComputeCurvatureStatistics","text":"<pre><code>virtual void ComputeCurvatureStatistics(\n    const ParticleSystemType * ,\n    unsigned int d\n)\n</code></pre> <p>Compute the mean and std deviation of the curvature on the image surface. </p>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-getmeancurvature","title":"function GetMeanCurvature","text":"<pre><code>inline double GetMeanCurvature(\n    int d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-getcurvaturestandarddeviation","title":"function GetCurvatureStandardDeviation","text":"<pre><code>inline double GetCurvatureStandardDeviation(\n    int d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-meancurvaturecontainer","title":"function MeanCurvatureContainer","text":"<pre><code>inline MeanCurvatureContainer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-meancurvaturecontainer_1","title":"function ~MeanCurvatureContainer","text":"<pre><code>inline virtual ~MeanCurvatureContainer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeanCurvatureContainer.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html","title":"shapeworks::Mesh","text":"<p>Module: Mesh Classes</p> <p>More...</p> <p><code>#include &lt;Mesh.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#public-types","title":"Public Types","text":"Name enum FieldType enum AlignmentType enum DistanceMethod enum CurvatureType enum SubdivisionType"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#public-functions","title":"Public Functions","text":"Name Mesh(const std::string &amp; pathname) void set_id(int id) int get_id() const Mesh(vtkSmartPointer&lt; vtkPolyData &gt; meshPtr) Mesh(const Mesh &amp; orig) Mesh(Mesh &amp;&amp; orig) Mesh &amp; operator=(const Mesh &amp; orig) Mesh(const Eigen::MatrixXd &amp; points, const Eigen::MatrixXi &amp; faces) Mesh &amp; operator=(Mesh &amp;&amp; orig) Mesh &amp; operator+=(const Mesh &amp; otherMesh)append two meshes vtkSmartPointer&lt; vtkPolyData &gt; getVTKMesh() constreturn the current mesh Mesh &amp; write(const std::string &amp; pathname, bool binaryFile =false)writes mesh, format specified by filename extension Mesh &amp; coverage(const Mesh &amp; otherMesh, bool allowBackIntersections =true, double angleThreshold =0, double backSearchRadius =0)determines coverage between current mesh and another mesh (e.g. acetabular cup / femoral head) Mesh &amp; smooth(int iterations =0, double relaxation =0.0)applies laplacian smoothing Mesh &amp; smoothSinc(int iterations =0, double passband =0.0)applies vtk windowed sinc smoothing Mesh &amp; remesh(int numVertices, double adaptivity =1.0)applies remeshing using approximated centroidal voronoi diagrams for a given number of vertices and adaptivity Mesh &amp; remeshPercent(double percentage, double adaptivity =1.0)applies remeshing using approximated centroidal voronoi diagrams for a given percentage of vertices and adaptivity Mesh &amp; invertNormals()handle flipping normals Mesh &amp; reflect(const Axis &amp; axis, const Vector3 &amp; origin =makeVector({0.0, 0.0, 0.0}))reflect meshes with respect to a specified center and specific axis MeshTransform createTransform(const Mesh &amp; target, AlignmentType align =Similarity, unsigned iterations =10) Mesh &amp; applyTransform(const MeshTransform transform)applies the given transformation to the mesh Mesh &amp; rotate(const double angle, const Axis axis)applies the given rotation to the given axis Mesh &amp; fillHoles(double hole_size =1000.0)finds holes in a mesh and closes them Mesh &amp; clean()clean mesh Mesh &amp; probeVolume(const Image &amp; image)samples image data values at point locations specified by image Mesh &amp; clip(const Plane plane)clips a mesh using a cutting plane Mesh &amp; translate(const Vector3 &amp; v)helper to translate mesh Mesh &amp; scale(const Vector3 &amp; v)helper to scale mesh PhysicalRegion boundingBox() constcomputes bounding box of current mesh Mesh &amp; fixElement()fix element winding of mesh Mesh &amp; fixNonManifold()Attempt to fix non-manifold edges. Mesh &amp; extractLargestComponent()Extract the largest connected component from the mesh. bool detectNonManifold()Detect if mesh contain non-manifold edges. bool detectTriangular()Detect if mesh is triangular;. std::vector&lt; Field &gt; distance(const Mesh &amp; target, const DistanceMethod method =PointToCell) const Mesh &amp; clipClosedSurface(const Plane plane)clips a mesh using a cutting plane resulting in a closed surface Mesh &amp; computeNormals()computes and adds oriented point and cell normals Point3 closestPoint(const Point3 point, double &amp; distance, vtkIdType &amp; face_id) const int closestPointId(const Point3 point) constreturns closest point id in this mesh to the given point in space bool isPointInside(const Point3 point) constreturns if the given point is inside the mesh double geodesicDistance(int source, int target) constcomputes geodesic distance between two vertices (specified by their indices) on mesh Field geodesicDistance(const Point3 landmark) constcomputes geodesic distance between a point (landmark) and each vertex on mesh Field geodesicDistance(const std::vector&lt; Point3 &gt; curve) constcomputes geodesic distance between a set of points (curve) and each vertex on mesh Field curvature(const CurvatureType type =Principal) constcomputes curvature using principal (default) or gaussian or mean algorithms void computeFieldGradient(const std::string &amp; field) constcompute the gradient of a scalar field for all vertices Eigen::Vector3d computeFieldGradientAtPoint(const std::string &amp; field, const Point3 &amp; query) constcompute the gradient of a scalar field at a point double interpolateFieldAtPoint(const std::string &amp; field, const Point3 &amp; query) constinterpolate a scalar field at a given point Mesh &amp; applySubdivisionFilter(const SubdivisionType type =Butterfly, int subdivision =1)applies subdivision filter (butterfly (default) or loop) Image toImage(PhysicalRegion region =PhysicalRegion(), Point3 spacing =Point3({1., 1., 1.})) constrasterizes specified region to create binary image of desired dims (default: unit spacing) Image toDistanceTransform(PhysicalRegion region =PhysicalRegion(), const Point3 spacing =Point3({1., 1., 1.}), const Dims padding =Dims({1, 1, 1})) constconverts specified region to distance transform image (default: unit spacing) with (logical) padding Mesh &amp; computeThickness(Image &amp; image, Image * dt =nullptr, double max_dist =10000, double median_radius =5.0, std::string distance_mesh =\"\")assign cortical thickness values from mesh points Mesh &amp; computeLandmarkGeodesics(const std::vector&lt; Point3 &gt; &amp; landmarks)compute geodesic distances to landmarks and assign as fields Point3 center() constcenter of mesh Point3 centerOfMass() constcenter of mass of mesh int numPoints() constnumber of points int numFaces() constnumber of faces Eigen::MatrixXd points() constmatrix with number of points with (x,y,z) coordinates of each point Eigen::MatrixXi faces() constmatrix with number of faces with indices of the three points from which each face is composed Point3 getPoint(int id) const(x,y,z) coordinates of vertex at given index IPoint3 getFace(int id) constreturn indices of the three points with which the face at the given index is composed std::vector&lt; std::string &gt; getFieldNames() constprint all field names in mesh Mesh &amp; setField(const std::string name, Array array, const FieldType type)sets the given field for points or faces with array (*does not copy array's values) Field getField(const std::string &amp; name, const FieldType type) constgets a pointer to the requested field of points or faces, null if field doesn't exist void setFieldValue(const std::string &amp; name, int idx, double value)sets the given index of field to value double getFieldValue(const std::string &amp; name, int idx) constgets the value at the given index of field (NOTE: returns first component of vector fields) Eigen::VectorXd getMultiFieldValue(const std::string &amp; name, int idx) constgets the multi value at the given index of [vertex] field bool compareAllPoints(const Mesh &amp; other_mesh) constcompare if values of the points in two (corresponding) meshes are (eps)equal bool compareAllFaces(const Mesh &amp; other_mesh) constcompare if face indices in two (corresponding) meshes are equal bool compareAllFields(const Mesh &amp; other_mesh, const double eps =1e4) constcompare if all fields in two meshes are (eps)equal bool compareField(const Mesh &amp; other_mesh, const std::string &amp; name1, const std::string &amp; name2 =\"\", const double eps =-1.0) constcompare field of meshes to be (eps)equal (same field for both if only one specified) bool compare(const Mesh &amp; other_mesh, const double eps =-1.0) constcompare meshes bool operator==(const Mesh &amp; other) constcompare meshes double getFFCValue(Eigen::Vector3d query) constGets values for FFCs. Eigen::Vector3d getFFCGradient(Eigen::Vector3d query) constGets gradients for FFCs. vtkSmartPointer&lt; vtkPoints &gt; getIGLMesh(Eigen::MatrixXd &amp; V, Eigen::MatrixXi &amp; F) constFormats mesh into an IGL format. vtkSmartPointer&lt; vtkPolyData &gt; clipByField(const std::string &amp; name, double value)Clips the mesh according to a field value. vtkSmartPointer&lt; vtkStaticCellLocator &gt; getCellLocator() constReturns the cell locator. int getClosestFace(const Point3 &amp; point) const Eigen::Vector3d computeBarycentricCoordinates(const Eigen::Vector3d &amp; pt, int face) constComputes baricentric coordinates given a query point and a face number. void interpolate_scalars_to_mesh(std::string name, Eigen::VectorXd positions, Eigen::VectorXd scalar_values) std::string checkIntegrity() const std::vector&lt; std::string &gt; getSupportedTypes()Return supported file types."},{"location":"api/Classes/classshapeworks_1_1Mesh.html#friends","title":"Friends","text":"Name struct SharedCommandData"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Mesh;\n</code></pre> <p>This class encapsulates a Mesh and operations that can be performed on meshes </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Mesh.html#enum-fieldtype","title":"enum FieldType","text":"Enumerator Value Description Point Face"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#enum-alignmenttype","title":"enum AlignmentType","text":"Enumerator Value Description Rigid Similarity Affine"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#enum-distancemethod","title":"enum DistanceMethod","text":"Enumerator Value Description PointToPoint PointToCell"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#enum-curvaturetype","title":"enum CurvatureType","text":"Enumerator Value Description Principal Gaussian Mean"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#enum-subdivisiontype","title":"enum SubdivisionType","text":"Enumerator Value Description Butterfly Loop"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-mesh","title":"function Mesh","text":"<pre><code>Mesh(\n    const std::string &amp; pathname\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-set_id","title":"function set_id","text":"<pre><code>inline void set_id(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-get_id","title":"function get_id","text":"<pre><code>inline int get_id() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-mesh_1","title":"function Mesh","text":"<pre><code>inline Mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; meshPtr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-mesh_2","title":"function Mesh","text":"<pre><code>inline Mesh(\n    const Mesh &amp; orig\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-mesh_3","title":"function Mesh","text":"<pre><code>inline Mesh(\n    Mesh &amp;&amp; orig\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-operator","title":"function operator=","text":"<pre><code>inline Mesh &amp; operator=(\n    const Mesh &amp; orig\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-mesh_4","title":"function Mesh","text":"<pre><code>Mesh(\n    const Eigen::MatrixXd &amp; points,\n    const Eigen::MatrixXi &amp; faces\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-operator_1","title":"function operator=","text":"<pre><code>inline Mesh &amp; operator=(\n    Mesh &amp;&amp; orig\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-operator_2","title":"function operator+=","text":"<pre><code>Mesh &amp; operator+=(\n    const Mesh &amp; otherMesh\n)\n</code></pre> <p>append two meshes </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getvtkmesh","title":"function getVTKMesh","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; getVTKMesh() const\n</code></pre> <p>return the current mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-write","title":"function write","text":"<pre><code>Mesh &amp; write(\n    const std::string &amp; pathname,\n    bool binaryFile =false\n)\n</code></pre> <p>writes mesh, format specified by filename extension </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-coverage","title":"function coverage","text":"<pre><code>Mesh &amp; coverage(\n    const Mesh &amp; otherMesh,\n    bool allowBackIntersections =true,\n    double angleThreshold =0,\n    double backSearchRadius =0\n)\n</code></pre> <p>determines coverage between current mesh and another mesh (e.g. acetabular cup / femoral head) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-smooth","title":"function smooth","text":"<pre><code>Mesh &amp; smooth(\n    int iterations =0,\n    double relaxation =0.0\n)\n</code></pre> <p>applies laplacian smoothing </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-smoothsinc","title":"function smoothSinc","text":"<pre><code>Mesh &amp; smoothSinc(\n    int iterations =0,\n    double passband =0.0\n)\n</code></pre> <p>applies vtk windowed sinc smoothing </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-remesh","title":"function remesh","text":"<pre><code>Mesh &amp; remesh(\n    int numVertices,\n    double adaptivity =1.0\n)\n</code></pre> <p>applies remeshing using approximated centroidal voronoi diagrams for a given number of vertices and adaptivity </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-remeshpercent","title":"function remeshPercent","text":"<pre><code>Mesh &amp; remeshPercent(\n    double percentage,\n    double adaptivity =1.0\n)\n</code></pre> <p>applies remeshing using approximated centroidal voronoi diagrams for a given percentage of vertices and adaptivity </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-invertnormals","title":"function invertNormals","text":"<pre><code>Mesh &amp; invertNormals()\n</code></pre> <p>handle flipping normals </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-reflect","title":"function reflect","text":"<pre><code>Mesh &amp; reflect(\n    const Axis &amp; axis,\n    const Vector3 &amp; origin =makeVector({0.0, 0.0, 0.0})\n)\n</code></pre> <p>reflect meshes with respect to a specified center and specific axis </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-createtransform","title":"function createTransform","text":"<pre><code>MeshTransform createTransform(\n    const Mesh &amp; target,\n    AlignmentType align =Similarity,\n    unsigned iterations =10\n)\n</code></pre> <p>creates transform to target mesh using specified AlignmentType (Mesh::Rigid, Mesh::Similarity, Mesh::Affine) for specified number of iterations </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-applytransform","title":"function applyTransform","text":"<pre><code>Mesh &amp; applyTransform(\n    const MeshTransform transform\n)\n</code></pre> <p>applies the given transformation to the mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-rotate","title":"function rotate","text":"<pre><code>Mesh &amp; rotate(\n    const double angle,\n    const Axis axis\n)\n</code></pre> <p>applies the given rotation to the given axis </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-fillholes","title":"function fillHoles","text":"<pre><code>Mesh &amp; fillHoles(\n    double hole_size =1000.0\n)\n</code></pre> <p>finds holes in a mesh and closes them </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-clean","title":"function clean","text":"<pre><code>Mesh &amp; clean()\n</code></pre> <p>clean mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-probevolume","title":"function probeVolume","text":"<pre><code>Mesh &amp; probeVolume(\n    const Image &amp; image\n)\n</code></pre> <p>samples image data values at point locations specified by image </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-clip","title":"function clip","text":"<pre><code>Mesh &amp; clip(\n    const Plane plane\n)\n</code></pre> <p>clips a mesh using a cutting plane </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-translate","title":"function translate","text":"<pre><code>Mesh &amp; translate(\n    const Vector3 &amp; v\n)\n</code></pre> <p>helper to translate mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-scale","title":"function scale","text":"<pre><code>Mesh &amp; scale(\n    const Vector3 &amp; v\n)\n</code></pre> <p>helper to scale mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-boundingbox","title":"function boundingBox","text":"<pre><code>PhysicalRegion boundingBox() const\n</code></pre> <p>computes bounding box of current mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-fixelement","title":"function fixElement","text":"<pre><code>Mesh &amp; fixElement()\n</code></pre> <p>fix element winding of mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-fixnonmanifold","title":"function fixNonManifold","text":"<pre><code>Mesh &amp; fixNonManifold()\n</code></pre> <p>Attempt to fix non-manifold edges. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-extractlargestcomponent","title":"function extractLargestComponent","text":"<pre><code>Mesh &amp; extractLargestComponent()\n</code></pre> <p>Extract the largest connected component from the mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-detectnonmanifold","title":"function detectNonManifold","text":"<pre><code>bool detectNonManifold()\n</code></pre> <p>Detect if mesh contain non-manifold edges. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-detecttriangular","title":"function detectTriangular","text":"<pre><code>bool detectTriangular()\n</code></pre> <p>Detect if mesh is triangular;. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-distance","title":"function distance","text":"<pre><code>std::vector&lt; Field &gt; distance(\n    const Mesh &amp; target,\n    const DistanceMethod method =PointToCell\n) const\n</code></pre> <p>Computes distance from each vertex to closest cell or point in target mesh, specified as PointToCell (default) or PointToPoint. Returns Fields containing distance to target and ids of the associated cells or points. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-clipclosedsurface","title":"function clipClosedSurface","text":"<pre><code>Mesh &amp; clipClosedSurface(\n    const Plane plane\n)\n</code></pre> <p>clips a mesh using a cutting plane resulting in a closed surface </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computenormals","title":"function computeNormals","text":"<pre><code>Mesh &amp; computeNormals()\n</code></pre> <p>computes and adds oriented point and cell normals </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-closestpoint","title":"function closestPoint","text":"<pre><code>Point3 closestPoint(\n    const Point3 point,\n    double &amp; distance,\n    vtkIdType &amp; face_id\n) const\n</code></pre> <p>Returns closest point on this mesh to the given point in space. In addition, returns by reference:</p> <ul> <li>the distance of the point in space from this mesh</li> <li>the face_id containing the closest point </li> </ul>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-closestpointid","title":"function closestPointId","text":"<pre><code>int closestPointId(\n    const Point3 point\n) const\n</code></pre> <p>returns closest point id in this mesh to the given point in space </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-ispointinside","title":"function isPointInside","text":"<pre><code>bool isPointInside(\n    const Point3 point\n) const\n</code></pre> <p>returns if the given point is inside the mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-geodesicdistance","title":"function geodesicDistance","text":"<pre><code>double geodesicDistance(\n    int source,\n    int target\n) const\n</code></pre> <p>computes geodesic distance between two vertices (specified by their indices) on mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-geodesicdistance_1","title":"function geodesicDistance","text":"<pre><code>Field geodesicDistance(\n    const Point3 landmark\n) const\n</code></pre> <p>computes geodesic distance between a point (landmark) and each vertex on mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-geodesicdistance_2","title":"function geodesicDistance","text":"<pre><code>Field geodesicDistance(\n    const std::vector&lt; Point3 &gt; curve\n) const\n</code></pre> <p>computes geodesic distance between a set of points (curve) and each vertex on mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-curvature","title":"function curvature","text":"<pre><code>Field curvature(\n    const CurvatureType type =Principal\n) const\n</code></pre> <p>computes curvature using principal (default) or gaussian or mean algorithms </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computefieldgradient","title":"function computeFieldGradient","text":"<pre><code>void computeFieldGradient(\n    const std::string &amp; field\n) const\n</code></pre> <p>compute the gradient of a scalar field for all vertices </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computefieldgradientatpoint","title":"function computeFieldGradientAtPoint","text":"<pre><code>Eigen::Vector3d computeFieldGradientAtPoint(\n    const std::string &amp; field,\n    const Point3 &amp; query\n) const\n</code></pre> <p>compute the gradient of a scalar field at a point </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-interpolatefieldatpoint","title":"function interpolateFieldAtPoint","text":"<pre><code>double interpolateFieldAtPoint(\n    const std::string &amp; field,\n    const Point3 &amp; query\n) const\n</code></pre> <p>interpolate a scalar field at a given point </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-applysubdivisionfilter","title":"function applySubdivisionFilter","text":"<pre><code>Mesh &amp; applySubdivisionFilter(\n    const SubdivisionType type =Butterfly,\n    int subdivision =1\n)\n</code></pre> <p>applies subdivision filter (butterfly (default) or loop) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-toimage","title":"function toImage","text":"<pre><code>Image toImage(\n    PhysicalRegion region =PhysicalRegion(),\n    Point3 spacing =Point3({1., 1., 1.})\n) const\n</code></pre> <p>rasterizes specified region to create binary image of desired dims (default: unit spacing) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-todistancetransform","title":"function toDistanceTransform","text":"<pre><code>Image toDistanceTransform(\n    PhysicalRegion region =PhysicalRegion(),\n    const Point3 spacing =Point3({1., 1., 1.}),\n    const Dims padding =Dims({1, 1, 1})\n) const\n</code></pre> <p>converts specified region to distance transform image (default: unit spacing) with (logical) padding </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computethickness","title":"function computeThickness","text":"<pre><code>Mesh &amp; computeThickness(\n    Image &amp; image,\n    Image * dt =nullptr,\n    double max_dist =10000,\n    double median_radius =5.0,\n    std::string distance_mesh =\"\"\n)\n</code></pre> <p>assign cortical thickness values from mesh points </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computelandmarkgeodesics","title":"function computeLandmarkGeodesics","text":"<pre><code>Mesh &amp; computeLandmarkGeodesics(\n    const std::vector&lt; Point3 &gt; &amp; landmarks\n)\n</code></pre> <p>compute geodesic distances to landmarks and assign as fields </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-center","title":"function center","text":"<pre><code>Point3 center() const\n</code></pre> <p>center of mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-centerofmass","title":"function centerOfMass","text":"<pre><code>Point3 centerOfMass() const\n</code></pre> <p>center of mass of mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-numpoints","title":"function numPoints","text":"<pre><code>inline int numPoints() const\n</code></pre> <p>number of points </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-numfaces","title":"function numFaces","text":"<pre><code>inline int numFaces() const\n</code></pre> <p>number of faces </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-points","title":"function points","text":"<pre><code>Eigen::MatrixXd points() const\n</code></pre> <p>matrix with number of points with (x,y,z) coordinates of each point </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-faces","title":"function faces","text":"<pre><code>Eigen::MatrixXi faces() const\n</code></pre> <p>matrix with number of faces with indices of the three points from which each face is composed </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getpoint","title":"function getPoint","text":"<pre><code>Point3 getPoint(\n    int id\n) const\n</code></pre> <p>(x,y,z) coordinates of vertex at given index </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getface","title":"function getFace","text":"<pre><code>IPoint3 getFace(\n    int id\n) const\n</code></pre> <p>return indices of the three points with which the face at the given index is composed </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getfieldnames","title":"function getFieldNames","text":"<pre><code>std::vector&lt; std::string &gt; getFieldNames() const\n</code></pre> <p>print all field names in mesh </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-setfield","title":"function setField","text":"<pre><code>Mesh &amp; setField(\n    const std::string name,\n    Array array,\n    const FieldType type\n)\n</code></pre> <p>sets the given field for points or faces with array (*does not copy array's values) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getfield","title":"function getField","text":"<pre><code>Field getField(\n    const std::string &amp; name,\n    const FieldType type\n) const\n</code></pre> <p>gets a pointer to the requested field of points or faces, null if field doesn't exist </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-setfieldvalue","title":"function setFieldValue","text":"<pre><code>void setFieldValue(\n    const std::string &amp; name,\n    int idx,\n    double value\n)\n</code></pre> <p>sets the given index of field to value </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getfieldvalue","title":"function getFieldValue","text":"<pre><code>double getFieldValue(\n    const std::string &amp; name,\n    int idx\n) const\n</code></pre> <p>gets the value at the given index of field (NOTE: returns first component of vector fields) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getmultifieldvalue","title":"function getMultiFieldValue","text":"<pre><code>Eigen::VectorXd getMultiFieldValue(\n    const std::string &amp; name,\n    int idx\n) const\n</code></pre> <p>gets the multi value at the given index of [vertex] field </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-compareallpoints","title":"function compareAllPoints","text":"<pre><code>bool compareAllPoints(\n    const Mesh &amp; other_mesh\n) const\n</code></pre> <p>compare if values of the points in two (corresponding) meshes are (eps)equal </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-compareallfaces","title":"function compareAllFaces","text":"<pre><code>bool compareAllFaces(\n    const Mesh &amp; other_mesh\n) const\n</code></pre> <p>compare if face indices in two (corresponding) meshes are equal </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-compareallfields","title":"function compareAllFields","text":"<pre><code>bool compareAllFields(\n    const Mesh &amp; other_mesh,\n    const double eps =1e4\n) const\n</code></pre> <p>compare if all fields in two meshes are (eps)equal </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-comparefield","title":"function compareField","text":"<pre><code>bool compareField(\n    const Mesh &amp; other_mesh,\n    const std::string &amp; name1,\n    const std::string &amp; name2 =\"\",\n    const double eps =-1.0\n) const\n</code></pre> <p>compare field of meshes to be (eps)equal (same field for both if only one specified) </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-compare","title":"function compare","text":"<pre><code>bool compare(\n    const Mesh &amp; other_mesh,\n    const double eps =-1.0\n) const\n</code></pre> <p>compare meshes </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-operator_3","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const Mesh &amp; other\n) const\n</code></pre> <p>compare meshes </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getffcvalue","title":"function getFFCValue","text":"<pre><code>double getFFCValue(\n    Eigen::Vector3d query\n) const\n</code></pre> <p>Gets values for FFCs. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getffcgradient","title":"function getFFCGradient","text":"<pre><code>Eigen::Vector3d getFFCGradient(\n    Eigen::Vector3d query\n) const\n</code></pre> <p>Gets gradients for FFCs. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getiglmesh","title":"function getIGLMesh","text":"<pre><code>vtkSmartPointer&lt; vtkPoints &gt; getIGLMesh(\n    Eigen::MatrixXd &amp; V,\n    Eigen::MatrixXi &amp; F\n) const\n</code></pre> <p>Formats mesh into an IGL format. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-clipbyfield","title":"function clipByField","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; clipByField(\n    const std::string &amp; name,\n    double value\n)\n</code></pre> <p>Clips the mesh according to a field value. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getcelllocator","title":"function getCellLocator","text":"<pre><code>inline vtkSmartPointer&lt; vtkStaticCellLocator &gt; getCellLocator() const\n</code></pre> <p>Returns the cell locator. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getclosestface","title":"function getClosestFace","text":"<pre><code>int getClosestFace(\n    const Point3 &amp; point\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-computebarycentriccoordinates","title":"function computeBarycentricCoordinates","text":"<pre><code>Eigen::Vector3d computeBarycentricCoordinates(\n    const Eigen::Vector3d &amp; pt,\n    int face\n) const\n</code></pre> <p>Computes baricentric coordinates given a query point and a face number. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-interpolate_scalars_to_mesh","title":"function interpolate_scalars_to_mesh","text":"<pre><code>void interpolate_scalars_to_mesh(\n    std::string name,\n    Eigen::VectorXd positions,\n    Eigen::VectorXd scalar_values\n)\n</code></pre> <p>Interpolates scalar values at points (e.g. correspondence points) to the mesh, assign/create a field with the given name </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-checkintegrity","title":"function checkIntegrity","text":"<pre><code>std::string checkIntegrity() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#function-getsupportedtypes","title":"function getSupportedTypes","text":"<pre><code>static inline std::vector&lt; std::string &gt; getSupportedTypes()\n</code></pre> <p>Return supported file types. </p>"},{"location":"api/Classes/classshapeworks_1_1Mesh.html#friends_1","title":"Friends","text":""},{"location":"api/Classes/classshapeworks_1_1Mesh.html#friend-sharedcommanddata","title":"friend SharedCommandData","text":"<pre><code>friend struct SharedCommandData(\n    SharedCommandData \n);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html","title":"shapeworks::MeshCache","text":"<p>Thread safe cache for meshes index by shape.  More...</p> <p><code>#include &lt;MeshCache.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#public-functions","title":"Public Functions","text":"Name MeshCache() void set_cache_enabled(bool enabled) void set_memory_percent(int percent) MeshHandle get_mesh(const MeshWorkItem &amp; vector) void insert_mesh(const MeshWorkItem &amp; item, MeshHandle mesh) void clear()"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshCache;\n</code></pre> <p>Thread safe cache for meshes index by shape. </p> <p>The MeshCache implements a std::map keyed by shape (list of points) with MeshHandle values. It is thread-safe and can be used from any thread. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-meshcache","title":"function MeshCache","text":"<pre><code>MeshCache()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-set_cache_enabled","title":"function set_cache_enabled","text":"<pre><code>inline void set_cache_enabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-set_memory_percent","title":"function set_memory_percent","text":"<pre><code>inline void set_memory_percent(\n    int percent\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-get_mesh","title":"function get_mesh","text":"<pre><code>MeshHandle get_mesh(\n    const MeshWorkItem &amp; vector\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-insert_mesh","title":"function insert_mesh","text":"<pre><code>void insert_mesh(\n    const MeshWorkItem &amp; item,\n    MeshHandle mesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshCache.html#function-clear","title":"function clear","text":"<pre><code>void clear()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshCommand.html","title":"shapeworks::MeshCommand","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1MeshCommand.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1MeshCommand.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1MeshCommand.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshCommand.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html","title":"shapeworks::MeshDomain","text":"<p>Inherits from shapeworks::ParticleDomain</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; MeshDomain &gt; Pointer"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#public-functions","title":"Public Functions","text":"Name virtual DomainType GetDomainType() const override virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const override bool ApplyVectorConstraints(VectorDoubleType &amp; gradE, const PointType &amp; pos) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const override virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const override virtual void InvalidateParticlePosition(int idx) const override virtual double GetCurvature(const PointType &amp; p, int idx) const override virtual double GetSurfaceMeanCurvature() const override virtual double GetSurfaceStdDevCurvature() const override virtual const PointType &amp; GetLowerBound() const override virtual const PointType &amp; GetUpperBound() const override virtual PointType GetZeroCrossingPoint() const override virtual PointType GetValidLocationNear(PointType p) const override virtual double GetSurfaceArea() const override virtual double GetMaxDiameter() const override virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(const PointType &amp; point, int idx) const override virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(const PointType &amp; point, int idx) const override virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const override double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, vnl_vector_fixed&lt; double, DIMENSION &gt; * out_grad =nullptr) const override virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const override virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const override virtual void DeleteImages() override virtual void DeletePartialDerivativeImages() override void SetMesh(std::shared_ptr&lt; Surface &gt; mesh_, double geodesic_remesh_percent) std::shared_ptr&lt; Mesh &gt; GetSWMesh() const virtual void UpdateZeroCrossingPoint() override std::shared_ptr&lt; Surface &gt; get_surface() const"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ParticleDomain</p> Name using itk::Point&lt; double, 3 &gt; PointType using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name bool IsDomainFixed() const std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::MeshDomain::Pointer =  std::shared_ptr&lt;MeshDomain&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getdomaintype","title":"function GetDomainType","text":"<pre><code>inline virtual DomainType GetDomainType() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetDomainType</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-applyconstraints","title":"function ApplyConstraints","text":"<pre><code>virtual bool ApplyConstraints(\n    PointType &amp; p,\n    int idx,\n    bool dbg =false\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::ApplyConstraints</p> <p>Apply any constraints to the given point location. This should force the point to a position on the surface that satisfies all constraints. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-applyvectorconstraints","title":"function ApplyVectorConstraints","text":"<pre><code>bool ApplyVectorConstraints(\n    VectorDoubleType &amp; gradE,\n    const PointType &amp; pos\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-projectvectortosurfacetangent","title":"function ProjectVectorToSurfaceTangent","text":"<pre><code>virtual VectorDoubleType ProjectVectorToSurfaceTangent(\n    VectorDoubleType &amp; gradE,\n    const PointType &amp; pos,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::ProjectVectorToSurfaceTangent</p> <p>Projects the vector to the surface tangent at the point. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-updateparticleposition","title":"function UpdateParticlePosition","text":"<pre><code>virtual PointType UpdateParticlePosition(\n    const PointType &amp; point,\n    int idx,\n    VectorDoubleType &amp; update\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::UpdateParticlePosition</p> <p>Applies the update to the point and returns the new point position. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-invalidateparticleposition","title":"function InvalidateParticlePosition","text":"<pre><code>virtual void InvalidateParticlePosition(\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::InvalidateParticlePosition</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getcurvature","title":"function GetCurvature","text":"<pre><code>inline virtual double GetCurvature(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getsurfacemeancurvature","title":"function GetSurfaceMeanCurvature","text":"<pre><code>inline virtual double GetSurfaceMeanCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceMeanCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getsurfacestddevcurvature","title":"function GetSurfaceStdDevCurvature","text":"<pre><code>inline virtual double GetSurfaceStdDevCurvature() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceStdDevCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getlowerbound","title":"function GetLowerBound","text":"<pre><code>inline virtual const PointType &amp; GetLowerBound() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetLowerBound</p> <p>Gets the minimum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getupperbound","title":"function GetUpperBound","text":"<pre><code>inline virtual const PointType &amp; GetUpperBound() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetUpperBound</p> <p>Gets the maximum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getzerocrossingpoint","title":"function GetZeroCrossingPoint","text":"<pre><code>virtual PointType GetZeroCrossingPoint() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetZeroCrossingPoint</p> <p>Get any valid point on the domain. This is used to place the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getvalidlocationnear","title":"function GetValidLocationNear","text":"<pre><code>virtual PointType GetValidLocationNear(\n    PointType p\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetValidLocationNear</p> <p>GetValidLocation returns a PointType location on the surface. Used for placing the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getsurfacearea","title":"function GetSurfaceArea","text":"<pre><code>inline virtual double GetSurfaceArea() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetSurfaceArea</p> <p>Use for neighborhood radius. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getmaxdiameter","title":"function GetMaxDiameter","text":"<pre><code>virtual double GetMaxDiameter() const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetMaxDiameter</p> <p>GetMaxDiameter returns the maximum diameter of the domain and is used for computing sigma </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-samplegradientatpoint","title":"function SampleGradientAtPoint","text":"<pre><code>virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleGradientAtPoint(\n    const PointType &amp; point,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradientAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-samplenormalatpoint","title":"function SampleNormalAtPoint","text":"<pre><code>virtual vnl_vector_fixed&lt; float, DIMENSION &gt; SampleNormalAtPoint(\n    const PointType &amp; point,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleNormalAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-samplegradnatpoint","title":"function SampleGradNAtPoint","text":"<pre><code>virtual GradNType SampleGradNAtPoint(\n    const PointType &amp; p,\n    int idx\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SampleGradNAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-distance","title":"function Distance","text":"<pre><code>double Distance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b,\n    vnl_vector_fixed&lt; double, DIMENSION &gt; * out_grad =nullptr\n) const override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-squareddistance","title":"function SquaredDistance","text":"<pre><code>virtual double SquaredDistance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::SquaredDistance</p> <p>Squared Distance between locations is used for computing sigma. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-iswithindistance","title":"function IsWithinDistance","text":"<pre><code>virtual bool IsWithinDistance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b,\n    double test_dist,\n    double &amp; distance\n) const override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::IsWithinDistance</p> <p>Returns whether or not the two points are separated by the given distance </p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>inline virtual void DeleteImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeleteImages</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-deletepartialderivativeimages","title":"function DeletePartialDerivativeImages","text":"<pre><code>inline virtual void DeletePartialDerivativeImages() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::DeletePartialDerivativeImages</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-setmesh","title":"function SetMesh","text":"<pre><code>void SetMesh(\n    std::shared_ptr&lt; Surface &gt; mesh_,\n    double geodesic_remesh_percent\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-getswmesh","title":"function GetSWMesh","text":"<pre><code>inline std::shared_ptr&lt; Mesh &gt; GetSWMesh() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-updatezerocrossingpoint","title":"function UpdateZeroCrossingPoint","text":"<pre><code>inline virtual void UpdateZeroCrossingPoint() override\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::UpdateZeroCrossingPoint</p>"},{"location":"api/Classes/classshapeworks_1_1MeshDomain.html#function-get_surface","title":"function get_surface","text":"<pre><code>inline std::shared_ptr&lt; Surface &gt; get_surface() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html","title":"shapeworks::MeshGenerator","text":""},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#public-functions","title":"Public Functions","text":"Name MeshGenerator() ~MeshGenerator() MeshHandle build_mesh(const MeshWorkItem &amp; item) MeshHandle build_mesh_from_points(const Eigen::VectorXd &amp; shape, int domain) MeshHandle build_mesh_from_image(ImageType::Pointer image, float iso_value =0.0001) MeshHandle build_mesh_from_file(std::string filename, float iso_value =0.0001) void set_mesh_reconstructors(std::shared_ptr&lt; MeshReconstructors &gt; reconstructors) void set_reconstruction_method(std::string method) std::string get_reconstruction_method()"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#public-attributes","title":"Public Attributes","text":"Name const std::string RECONSTRUCTION_LEGACY_C const std::string RECONSTRUCTION_DISTANCE_TRANSFORM_C const std::string RECONSTRUCTION_MESH_WARPER_C"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-meshgenerator","title":"function MeshGenerator","text":"<pre><code>MeshGenerator()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-meshgenerator_1","title":"function ~MeshGenerator","text":"<pre><code>~MeshGenerator()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-build_mesh","title":"function build_mesh","text":"<pre><code>MeshHandle build_mesh(\n    const MeshWorkItem &amp; item\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-build_mesh_from_points","title":"function build_mesh_from_points","text":"<pre><code>MeshHandle build_mesh_from_points(\n    const Eigen::VectorXd &amp; shape,\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-build_mesh_from_image","title":"function build_mesh_from_image","text":"<pre><code>MeshHandle build_mesh_from_image(\n    ImageType::Pointer image,\n    float iso_value =0.0001\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-build_mesh_from_file","title":"function build_mesh_from_file","text":"<pre><code>MeshHandle build_mesh_from_file(\n    std::string filename,\n    float iso_value =0.0001\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-set_mesh_reconstructors","title":"function set_mesh_reconstructors","text":"<pre><code>void set_mesh_reconstructors(\n    std::shared_ptr&lt; MeshReconstructors &gt; reconstructors\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-set_reconstruction_method","title":"function set_reconstruction_method","text":"<pre><code>void set_reconstruction_method(\n    std::string method\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#function-get_reconstruction_method","title":"function get_reconstruction_method","text":"<pre><code>std::string get_reconstruction_method()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#variable-reconstruction_legacy_c","title":"variable RECONSTRUCTION_LEGACY_C","text":"<pre><code>static const std::string RECONSTRUCTION_LEGACY_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#variable-reconstruction_distance_transform_c","title":"variable RECONSTRUCTION_DISTANCE_TRANSFORM_C","text":"<pre><code>static const std::string RECONSTRUCTION_DISTANCE_TRANSFORM_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGenerator.html#variable-reconstruction_mesh_warper_c","title":"variable RECONSTRUCTION_MESH_WARPER_C","text":"<pre><code>static const std::string RECONSTRUCTION_MESH_WARPER_C;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html","title":"shapeworks::MeshGroup","text":"<p>Representation of a group of meshes.  More...</p> <p><code>#include &lt;MeshGroup.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#public-functions","title":"Public Functions","text":"Name MeshGroup() MeshGroup(unsigned long num_meshes) ~MeshGroup() void set_number_of_meshes(int n) bool valid() void set_mesh(int i, MeshHandle mesh) MeshList &amp; meshes()Return a reference to the list of meshes. vtkSmartPointer&lt; vtkPolyData &gt; get_combined_poly_data()Return polydata of all meshes, combined."},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshGroup;\n</code></pre> <p>Representation of a group of meshes. </p> <p>The MeshGroup class encapsulates a group of meshes (e.g. from a single subject) A subject will have one mesh for each anatomy/domain </p>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-meshgroup","title":"function MeshGroup","text":"<pre><code>MeshGroup()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-meshgroup_1","title":"function MeshGroup","text":"<pre><code>MeshGroup(\n    unsigned long num_meshes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-meshgroup_2","title":"function ~MeshGroup","text":"<pre><code>~MeshGroup()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-set_number_of_meshes","title":"function set_number_of_meshes","text":"<pre><code>void set_number_of_meshes(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-valid","title":"function valid","text":"<pre><code>bool valid()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-set_mesh","title":"function set_mesh","text":"<pre><code>void set_mesh(\n    int i,\n    MeshHandle mesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-meshes","title":"function meshes","text":"<pre><code>MeshList &amp; meshes()\n</code></pre> <p>Return a reference to the list of meshes. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshGroup.html#function-get_combined_poly_data","title":"function get_combined_poly_data","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; get_combined_poly_data()\n</code></pre> <p>Return polydata of all meshes, combined. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html","title":"shapeworks::MeshManager","text":"<p>Class to manage meshes.  More...</p> <p><code>#include &lt;MeshManager.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-slots","title":"Public Slots","text":"Name void handle_thread_complete(const MeshWorkItem &amp; item, MeshHandle mesh) void handle_warper_progress()"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-signals","title":"Public Signals","text":"Name void new_mesh() void error_encountered(QString message) void progress(int ) void status(std::string )"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-functions","title":"Public Functions","text":"Name MeshManager() ~MeshManager() void set_cache_enabled(bool enabled)Set if the cache should be enabled. void set_cache_memory_percent(int percent)Set the memory cache size. void set_parallel_enabled(bool enabled)Set if parallel reconstruction should be enabled. void set_num_threads(int num_threads)Set the number of threads for parallel reconstruction. void generate_mesh(const MeshWorkItem item)generate and cache a mesh for this shape in a different thread MeshHandle get_mesh(const MeshWorkItem &amp; item, bool wait =false)get a mesh for a MeshWorkItem MeshHandle get_mesh(const Eigen::VectorXd &amp; points, int domain, bool wait =false)get a mesh for a set of points std::shared_ptr&lt; SurfaceReconstructor &gt; get_surface_reconstructor(int domain)return the surface reconstructor for a given domain std::shared_ptr&lt; MeshWarper &gt; get_mesh_warper(int domain)return the mesh warper for a given domain std::shared_ptr&lt; MeshGenerator &gt; get_mesh_generator()return the mesh generator void clear_cache()clear the cache"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshManager;\n</code></pre> <p>Class to manage meshes. </p> <p>The MeshManager handles all aspects of mesh generation and caching. It houses the cache and manages threads to work on mesh generation in the background. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#slot-handle_thread_complete","title":"slot handle_thread_complete","text":"<pre><code>void handle_thread_complete(\n    const MeshWorkItem &amp; item,\n    MeshHandle mesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#slot-handle_warper_progress","title":"slot handle_warper_progress","text":"<pre><code>void handle_warper_progress()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#signal-new_mesh","title":"signal new_mesh","text":"<pre><code>void new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#signal-error_encountered","title":"signal error_encountered","text":"<pre><code>void error_encountered(\n    QString message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#signal-status","title":"signal status","text":"<pre><code>void status(\n    std::string \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-meshmanager","title":"function MeshManager","text":"<pre><code>MeshManager()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-meshmanager_1","title":"function ~MeshManager","text":"<pre><code>~MeshManager()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-set_cache_enabled","title":"function set_cache_enabled","text":"<pre><code>void set_cache_enabled(\n    bool enabled\n)\n</code></pre> <p>Set if the cache should be enabled. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-set_cache_memory_percent","title":"function set_cache_memory_percent","text":"<pre><code>void set_cache_memory_percent(\n    int percent\n)\n</code></pre> <p>Set the memory cache size. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-set_parallel_enabled","title":"function set_parallel_enabled","text":"<pre><code>inline void set_parallel_enabled(\n    bool enabled\n)\n</code></pre> <p>Set if parallel reconstruction should be enabled. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-set_num_threads","title":"function set_num_threads","text":"<pre><code>inline void set_num_threads(\n    int num_threads\n)\n</code></pre> <p>Set the number of threads for parallel reconstruction. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-generate_mesh","title":"function generate_mesh","text":"<pre><code>void generate_mesh(\n    const MeshWorkItem item\n)\n</code></pre> <p>generate and cache a mesh for this shape in a different thread </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-get_mesh","title":"function get_mesh","text":"<pre><code>MeshHandle get_mesh(\n    const MeshWorkItem &amp; item,\n    bool wait =false\n)\n</code></pre> <p>get a mesh for a MeshWorkItem</p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-get_mesh_1","title":"function get_mesh","text":"<pre><code>MeshHandle get_mesh(\n    const Eigen::VectorXd &amp; points,\n    int domain,\n    bool wait =false\n)\n</code></pre> <p>get a mesh for a set of points </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-get_surface_reconstructor","title":"function get_surface_reconstructor","text":"<pre><code>std::shared_ptr&lt; SurfaceReconstructor &gt; get_surface_reconstructor(\n    int domain\n)\n</code></pre> <p>return the surface reconstructor for a given domain </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-get_mesh_warper","title":"function get_mesh_warper","text":"<pre><code>std::shared_ptr&lt; MeshWarper &gt; get_mesh_warper(\n    int domain\n)\n</code></pre> <p>return the mesh warper for a given domain </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-get_mesh_generator","title":"function get_mesh_generator","text":"<pre><code>inline std::shared_ptr&lt; MeshGenerator &gt; get_mesh_generator()\n</code></pre> <p>return the mesh generator </p>"},{"location":"api/Classes/classshapeworks_1_1MeshManager.html#function-clear_cache","title":"function clear_cache","text":"<pre><code>void clear_cache()\n</code></pre> <p>clear the cache </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshReader.html","title":"shapeworks::MeshReader","text":"<p>reads mesh (used only by one of the Mesh constructors) </p> <p><code>#include &lt;Mesh.h&gt;</code></p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshReconstructors.html","title":"shapeworks::MeshReconstructors","text":""},{"location":"api/Classes/classshapeworks_1_1MeshReconstructors.html#public-attributes","title":"Public Attributes","text":"Name std::vector&lt; std::shared_ptr&lt; SurfaceReconstructor &gt; &gt; surface_reconstructors_ std::vector&lt; std::shared_ptr&lt; QMeshWarper &gt; &gt; mesh_warpers_"},{"location":"api/Classes/classshapeworks_1_1MeshReconstructors.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshReconstructors.html#variable-surface_reconstructors_","title":"variable surface_reconstructors_","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; SurfaceReconstructor &gt; &gt; surface_reconstructors_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshReconstructors.html#variable-mesh_warpers_","title":"variable mesh_warpers_","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; QMeshWarper &gt; &gt; mesh_warpers_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html","title":"shapeworks::MeshSlice","text":"<p>MeshSlice.  More...</p> <p><code>#include &lt;MeshSlice.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#public-functions","title":"Public Functions","text":"Name MeshSlice(Viewer * viewer) void set_volume(vtkSmartPointer&lt; vtkImageData &gt; volume) bool is_image_loaded() void update_renderer() void update_camera() void handle_key(std::string key)"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshSlice;\n</code></pre> <p>MeshSlice. </p> <p>Provide slice viewing to the Viewer</p>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-meshslice","title":"function MeshSlice","text":"<pre><code>MeshSlice(\n    Viewer * viewer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-set_volume","title":"function set_volume","text":"<pre><code>void set_volume(\n    vtkSmartPointer&lt; vtkImageData &gt; volume\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-is_image_loaded","title":"function is_image_loaded","text":"<pre><code>bool is_image_loaded()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-update_renderer","title":"function update_renderer","text":"<pre><code>void update_renderer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-update_camera","title":"function update_camera","text":"<pre><code>void update_camera()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshSlice.html#function-handle_key","title":"function handle_key","text":"<pre><code>void handle_key(\n    std::string key\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html","title":"shapeworks::MeshUtils","text":"<p>Module: Mesh Classes</p> <p>More...</p> <p><code>#include &lt;MeshUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#public-functions","title":"Public Functions","text":"Name const vtkSmartPointer&lt; vtkMatrix4x4 &gt; createICPTransform(const Mesh source, const Mesh target, Mesh::AlignmentType align, const unsigned iterations =20, bool meshTransform =false)computes a rigid transformation from source to target using vtkIterativeClosestPointTransform Mesh create_mesh_from_file(std::string filename, double iso_value =0.5)Mesh from mesh or image file. Mesh threadSafeReadMesh(std::string filename)Thread safe reading of a mesh, uses a lock. void threadSafeWriteMesh(std::string filename, Mesh mesh)Thread safe writing of a mesh, uses a lock. PhysicalRegion boundingBox(const std::vector&lt; std::string &gt; &amp; filenames, bool center =false)calculate bounding box incrementally for meshes PhysicalRegion boundingBox(const std::vector&lt; std::reference_wrapper&lt; const Mesh &gt; &gt; &amp; meshes, bool center =false)calculate bounding box incrementally for meshes PhysicalRegion boundingBox(const std::vector&lt; Mesh &gt; &amp; meshes, bool center =false)calculate bounding box incrementally for meshes int findReferenceMesh(std::vector&lt; Mesh &gt; &amp; meshes, int random_subset_size =-1)determine the reference mesh Mesh extract_boundary_loop(Mesh mesh)boundary loop extractor for a given mesh std::array&lt; Mesh, 3 &gt; shared_boundary_extractor(const Mesh &amp; mesh_l, const Mesh &amp; mesh_r, double tol)shared boundary extractor for the left and right mesh void generateNormals(const std::vector&lt; std::reference_wrapper&lt; Mesh &gt; &gt; &amp; meshes, bool forceRegen =false)generates and adds normals for points and faces for each mesh in given set of meshes Field computeMeanNormals(const std::vector&lt; std::string &gt; &amp; filenames, bool autoGenerateNormals =true)computes average normals for each point in given set of meshes Field computeMeanNormals(const std::vector&lt; std::reference_wrapper&lt; const Mesh &gt; &gt; &amp; meshes)computes average normals for each point in given set of meshes int evaluate_triangle_position(const double x[3], double closestPoint[3], int &amp; subId, double pcoords[3], double &amp; dist2, double weights[], double pt3[3], double pt1[3], double pt2[3]) vtkSmartPointer&lt; vtkPolyData &gt; clean_mesh(vtkSmartPointer&lt; vtkPolyData &gt; mesh)Clean mesh (merge points and remove degenerate cells) vtkSmartPointer&lt; vtkPolyData &gt; remove_zero_area_triangles(vtkSmartPointer&lt; vtkPolyData &gt; mesh)Remove zero area triangles from a mesh. vtkSmartPointer&lt; vtkPolyData &gt; recreate_mesh(vtkSmartPointer&lt; vtkPolyData &gt; mesh)Recreate mesh, dropping deleted cells. vtkSmartPointer&lt; vtkPolyData &gt; repair_mesh(vtkSmartPointer&lt; vtkPolyData &gt; mesh)Repair mesh: triangulate, extract largest component, clean, fix non-manifold, remove zero-area triangles. void visualizeVectorFieldForFFCs(std::shared_ptr&lt; Mesh &gt; mesh)This function visualizes vector and scalar fields for FFCs. vtkSmartPointer&lt; vtkActor &gt; getArrow(Eigen::Vector3d start, Eigen::Vector3d end)Used as an auxiliary function for vector field visualizations."},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshUtils;\n</code></pre> <p>This class provides helper functions for meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-createicptransform","title":"function createICPTransform","text":"<pre><code>static const vtkSmartPointer&lt; vtkMatrix4x4 &gt; createICPTransform(\n    const Mesh source,\n    const Mesh target,\n    Mesh::AlignmentType align,\n    const unsigned iterations =20,\n    bool meshTransform =false\n)\n</code></pre> <p>computes a rigid transformation from source to target using vtkIterativeClosestPointTransform </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-create_mesh_from_file","title":"function create_mesh_from_file","text":"<pre><code>static Mesh create_mesh_from_file(\n    std::string filename,\n    double iso_value =0.5\n)\n</code></pre> <p>Mesh from mesh or image file. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-threadsafereadmesh","title":"function threadSafeReadMesh","text":"<pre><code>static Mesh threadSafeReadMesh(\n    std::string filename\n)\n</code></pre> <p>Thread safe reading of a mesh, uses a lock. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-threadsafewritemesh","title":"function threadSafeWriteMesh","text":"<pre><code>static void threadSafeWriteMesh(\n    std::string filename,\n    Mesh mesh\n)\n</code></pre> <p>Thread safe writing of a mesh, uses a lock. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-boundingbox","title":"function boundingBox","text":"<pre><code>static PhysicalRegion boundingBox(\n    const std::vector&lt; std::string &gt; &amp; filenames,\n    bool center =false\n)\n</code></pre> <p>calculate bounding box incrementally for meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-boundingbox_1","title":"function boundingBox","text":"<pre><code>static PhysicalRegion boundingBox(\n    const std::vector&lt; std::reference_wrapper&lt; const Mesh &gt; &gt; &amp; meshes,\n    bool center =false\n)\n</code></pre> <p>calculate bounding box incrementally for meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-boundingbox_2","title":"function boundingBox","text":"<pre><code>static PhysicalRegion boundingBox(\n    const std::vector&lt; Mesh &gt; &amp; meshes,\n    bool center =false\n)\n</code></pre> <p>calculate bounding box incrementally for meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-findreferencemesh","title":"function findReferenceMesh","text":"<pre><code>static int findReferenceMesh(\n    std::vector&lt; Mesh &gt; &amp; meshes,\n    int random_subset_size =-1\n)\n</code></pre> <p>determine the reference mesh </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-extract_boundary_loop","title":"function extract_boundary_loop","text":"<pre><code>static Mesh extract_boundary_loop(\n    Mesh mesh\n)\n</code></pre> <p>boundary loop extractor for a given mesh </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-shared_boundary_extractor","title":"function shared_boundary_extractor","text":"<pre><code>static std::array&lt; Mesh, 3 &gt; shared_boundary_extractor(\n    const Mesh &amp; mesh_l,\n    const Mesh &amp; mesh_r,\n    double tol\n)\n</code></pre> <p>shared boundary extractor for the left and right mesh </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-generatenormals","title":"function generateNormals","text":"<pre><code>static void generateNormals(\n    const std::vector&lt; std::reference_wrapper&lt; Mesh &gt; &gt; &amp; meshes,\n    bool forceRegen =false\n)\n</code></pre> <p>generates and adds normals for points and faces for each mesh in given set of meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-computemeannormals","title":"function computeMeanNormals","text":"<pre><code>static Field computeMeanNormals(\n    const std::vector&lt; std::string &gt; &amp; filenames,\n    bool autoGenerateNormals =true\n)\n</code></pre> <p>computes average normals for each point in given set of meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-computemeannormals_1","title":"function computeMeanNormals","text":"<pre><code>static Field computeMeanNormals(\n    const std::vector&lt; std::reference_wrapper&lt; const Mesh &gt; &gt; &amp; meshes\n)\n</code></pre> <p>computes average normals for each point in given set of meshes </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-evaluate_triangle_position","title":"function evaluate_triangle_position","text":"<pre><code>static int evaluate_triangle_position(\n    const double x[3],\n    double closestPoint[3],\n    int &amp; subId,\n    double pcoords[3],\n    double &amp; dist2,\n    double weights[],\n    double pt3[3],\n    double pt1[3],\n    double pt2[3]\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-clean_mesh","title":"function clean_mesh","text":"<pre><code>static vtkSmartPointer&lt; vtkPolyData &gt; clean_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; mesh\n)\n</code></pre> <p>Clean mesh (merge points and remove degenerate cells) </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-remove_zero_area_triangles","title":"function remove_zero_area_triangles","text":"<pre><code>static vtkSmartPointer&lt; vtkPolyData &gt; remove_zero_area_triangles(\n    vtkSmartPointer&lt; vtkPolyData &gt; mesh\n)\n</code></pre> <p>Remove zero area triangles from a mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-recreate_mesh","title":"function recreate_mesh","text":"<pre><code>static vtkSmartPointer&lt; vtkPolyData &gt; recreate_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; mesh\n)\n</code></pre> <p>Recreate mesh, dropping deleted cells. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-repair_mesh","title":"function repair_mesh","text":"<pre><code>static vtkSmartPointer&lt; vtkPolyData &gt; repair_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; mesh\n)\n</code></pre> <p>Repair mesh: triangulate, extract largest component, clean, fix non-manifold, remove zero-area triangles. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-visualizevectorfieldforffcs","title":"function visualizeVectorFieldForFFCs","text":"<pre><code>void visualizeVectorFieldForFFCs(\n    std::shared_ptr&lt; Mesh &gt; mesh\n)\n</code></pre> <p>This function visualizes vector and scalar fields for FFCs. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshUtils.html#function-getarrow","title":"function getArrow","text":"<pre><code>vtkSmartPointer&lt; vtkActor &gt; getArrow(\n    Eigen::Vector3d start,\n    Eigen::Vector3d end\n)\n</code></pre> <p>Used as an auxiliary function for vector field visualizations. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html","title":"shapeworks::MeshWarper","text":"<p>Module: Mesh Classes</p> <p>More...</p> <p><code>#include &lt;MeshWarper.h&gt;</code></p> <p>Inherited by shapeworks::QMeshWarper</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#public-functions","title":"Public Functions","text":"Name void set_reference_mesh(vtkSmartPointer&lt; vtkPolyData &gt; reference_mesh, const Eigen::MatrixXd &amp; reference_particles, const Eigen::MatrixXd &amp; landmarks ={})Set the reference mesh and particles. bool generate_warp()Generate warp, return true on success. bool get_warp_available()Return if the warp is available. bool is_contour() const vtkSmartPointer&lt; vtkPolyData &gt; build_mesh(const Eigen::MatrixXd &amp; particles)Build a mesh for a given set of particles. Eigen::MatrixXd extract_landmarks(vtkSmartPointer&lt; vtkPolyData &gt; warped_mesh)Return the landmarks (matrix [Nx3]) from the warped builded mesh. bool is_contour()Return if set as a contour. std::map&lt; int, int &gt; get_landmarks_map() constReturn the map of landmarks id (Key) to vertice index (Value) std::vector&lt; int &gt; get_good_particle_indices() constReturn the indexes of good particles (those that really control the warping) const Eigen::MatrixXd &amp; get_warp_matrix() constReturn the warp matrix. bool has_bad_particles() constReturn true if warping has removed any bad particle(s) vtkSmartPointer&lt; vtkPolyData &gt; get_reference_mesh()Return the reference mesh which has been cleaned and vertices added. const Eigen::MatrixXd &amp; get_reference_particles() constReturn the reference particles."},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#protected-functions","title":"Protected Functions","text":"Name virtual void update_progress(float p)For overriding to handle progress updates."},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::MeshWarper;\n</code></pre> <p>This class implements mesh warping based on correspondence particles. Correspondence points are embedded into the mesh as new vertices (traingles split). Then a biharmonic deformation is used to warp the mesh to new sets of correspondence particles.</p> <p>It can optionally be used to warp landmarks along with the mesh by embedding them as vertices </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-set_reference_mesh","title":"function set_reference_mesh","text":"<pre><code>void set_reference_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; reference_mesh,\n    const Eigen::MatrixXd &amp; reference_particles,\n    const Eigen::MatrixXd &amp; landmarks ={}\n)\n</code></pre> <p>Set the reference mesh and particles. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-generate_warp","title":"function generate_warp","text":"<pre><code>bool generate_warp()\n</code></pre> <p>Generate warp, return true on success. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_warp_available","title":"function get_warp_available","text":"<pre><code>bool get_warp_available()\n</code></pre> <p>Return if the warp is available. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-is_contour","title":"function is_contour","text":"<pre><code>inline bool is_contour() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-build_mesh","title":"function build_mesh","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; build_mesh(\n    const Eigen::MatrixXd &amp; particles\n)\n</code></pre> <p>Build a mesh for a given set of particles. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-extract_landmarks","title":"function extract_landmarks","text":"<pre><code>Eigen::MatrixXd extract_landmarks(\n    vtkSmartPointer&lt; vtkPolyData &gt; warped_mesh\n)\n</code></pre> <p>Return the landmarks (matrix [Nx3]) from the warped builded mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-is_contour_1","title":"function is_contour","text":"<pre><code>inline bool is_contour()\n</code></pre> <p>Return if set as a contour. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_landmarks_map","title":"function get_landmarks_map","text":"<pre><code>inline std::map&lt; int, int &gt; get_landmarks_map() const\n</code></pre> <p>Return the map of landmarks id (Key) to vertice index (Value) </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_good_particle_indices","title":"function get_good_particle_indices","text":"<pre><code>inline std::vector&lt; int &gt; get_good_particle_indices() const\n</code></pre> <p>Return the indexes of good particles (those that really control the warping) </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_warp_matrix","title":"function get_warp_matrix","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_warp_matrix() const\n</code></pre> <p>Return the warp matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-has_bad_particles","title":"function has_bad_particles","text":"<pre><code>inline bool has_bad_particles() const\n</code></pre> <p>Return true if warping has removed any bad particle(s) </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_reference_mesh","title":"function get_reference_mesh","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; get_reference_mesh()\n</code></pre> <p>Return the reference mesh which has been cleaned and vertices added. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-get_reference_particles","title":"function get_reference_particles","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_reference_particles() const\n</code></pre> <p>Return the reference particles. </p>"},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWarper.html#function-update_progress","title":"function update_progress","text":"<pre><code>inline virtual void update_progress(\n    float p\n)\n</code></pre> <p>For overriding to handle progress updates. </p> <p>Reimplemented by: shapeworks::QMeshWarper::update_progress</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html","title":"shapeworks::MeshWorkItem","text":"<p>Provides concurrent access to a list of shapes to work needing reconstruction. </p> <p><code>#include &lt;MeshWorkQueue.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#public-attributes","title":"Public Attributes","text":"Name std::string filename Eigen::VectorXd points int domain size_t memory_size"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#friends","title":"Friends","text":"Name bool operator&lt;(const MeshWorkItem &amp; a, const MeshWorkItem &amp; b) bool operator==(const MeshWorkItem &amp; a, const MeshWorkItem &amp; b)"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#variable-filename","title":"variable filename","text":"<pre><code>std::string filename;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#variable-points","title":"variable points","text":"<pre><code>Eigen::VectorXd points;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#variable-domain","title":"variable domain","text":"<pre><code>int domain {0};\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#variable-memory_size","title":"variable memory_size","text":"<pre><code>size_t memory_size {0};\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#friends_1","title":"Friends","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#friend-operator","title":"friend operator&lt;","text":"<pre><code>friend bool operator&lt;(\n    const MeshWorkItem &amp; a,\n\n    const MeshWorkItem &amp; b\n);\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkItem.html#friend-operator_1","title":"friend operator==","text":"<pre><code>friend bool operator==(\n    const MeshWorkItem &amp; a,\n\n    const MeshWorkItem &amp; b\n);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html","title":"shapeworks::MeshWorkQueue","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#public-types","title":"Public Types","text":"Name using std::list&lt; MeshWorkItem &gt; WorkList"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#public-functions","title":"Public Functions","text":"Name MeshWorkQueue() ~MeshWorkQueue() void push(const MeshWorkItem &amp; item) MeshWorkItem * get_next_work_item() bool is_inside(const MeshWorkItem &amp; item) void remove(const MeshWorkItem &amp; item) bool is_empty() int size()"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#using-worklist","title":"using WorkList","text":"<pre><code>using shapeworks::MeshWorkQueue::WorkList =  std::list&lt;MeshWorkItem&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-meshworkqueue","title":"function MeshWorkQueue","text":"<pre><code>MeshWorkQueue()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-meshworkqueue_1","title":"function ~MeshWorkQueue","text":"<pre><code>~MeshWorkQueue()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-push","title":"function push","text":"<pre><code>void push(\n    const MeshWorkItem &amp; item\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-get_next_work_item","title":"function get_next_work_item","text":"<pre><code>MeshWorkItem * get_next_work_item()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-is_inside","title":"function is_inside","text":"<pre><code>bool is_inside(\n    const MeshWorkItem &amp; item\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-remove","title":"function remove","text":"<pre><code>void remove(\n    const MeshWorkItem &amp; item\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-is_empty","title":"function is_empty","text":"<pre><code>bool is_empty()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorkQueue.html#function-size","title":"function size","text":"<pre><code>int size()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html","title":"shapeworks::MeshWorker","text":"<p>Inherits from QObject, QRunnable</p>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#public-signals","title":"Public Signals","text":"Name void result_ready(const MeshWorkItem &amp; item, MeshHandle mesh) void finished()"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#public-functions","title":"Public Functions","text":"Name MeshWorker(MeshWorkQueue * queue, std::shared_ptr&lt; MeshGenerator &gt; generator) ~MeshWorker() void run()"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#signal-result_ready","title":"signal result_ready","text":"<pre><code>void result_ready(\n    const MeshWorkItem &amp; item,\n    MeshHandle mesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#signal-finished","title":"signal finished","text":"<pre><code>void finished()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#function-meshworker","title":"function MeshWorker","text":"<pre><code>MeshWorker(\n    MeshWorkQueue * queue,\n    std::shared_ptr&lt; MeshGenerator &gt; generator\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#function-meshworker_1","title":"function ~MeshWorker","text":"<pre><code>~MeshWorker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MeshWorker.html#function-run","title":"function run","text":"<pre><code>void run()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html","title":"shapeworks::MixedEffectsShapeMatrix","text":"<p>Inherits from shapeworks::LegacyShapeMatrix, vnl_matrix&lt; double &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#public-types","title":"Public Types","text":"Name typedef double DataType typedef MixedEffectsShapeMatrix Self typedef LegacyShapeMatrix Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(MixedEffectsShapeMatrix , LegacyShapeMatrix ) void UpdateMeanMatrix() vnl_vector&lt; double &gt; ComputeMean(double k) const void ResizeParameters(unsigned int n) virtual void ResizeMeanMatrix(int rs, int cs) void ResizeExplanatory(unsigned int n) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; e) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void SetDomainsPerShape(int i) int GetDomainsPerShape() const void SetTimeptsPerIndividual(int i) int GetTimeptsPerIndividual() const void SetExplanatory(std::vector&lt; double &gt; v) void SetExplanatory(unsigned int i, double q) const double &amp; GetExplanatory(unsigned int i) const double &amp; GetExplanatory(unsigned int i) const vnl_vector&lt; double &gt; &amp; GetSlope() const const vnl_vector&lt; double &gt; &amp; GetIntercept() const const vnl_matrix&lt; double &gt; &amp; GetSlopeRandom() const const vnl_matrix&lt; double &gt; &amp; GetInterceptRandom() const void SetSlope(const std::vector&lt; double &gt; &amp; v) void SetIntercept(const std::vector&lt; double &gt; &amp; v) void EstimateParameters() void Initialize() virtual void BeforeIteration() void SetRegressionInterval(int i) int GetRegressionInterval() const"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#protected-functions","title":"Protected Functions","text":"Name MixedEffectsShapeMatrix() virtual ~MixedEffectsShapeMatrix() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::LegacyShapeMatrix</p> Name virtual void ResizeMatrix(int rs, int cs) void PrintMatrix() bool CheckForNans() virtual void before_iteration() virtual void after_iteration() virtual void SetMatrix(const vnl_matrix&lt; double &gt; &amp; m) <p>Protected Functions inherited from shapeworks::LegacyShapeMatrix</p> Name LegacyShapeMatrix() virtual ~LegacyShapeMatrix() <p>Protected Attributes inherited from shapeworks::LegacyShapeMatrix</p> Name int m_DomainsPerShape <p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef double shapeworks::MixedEffectsShapeMatrix::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef MixedEffectsShapeMatrix shapeworks::MixedEffectsShapeMatrix::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::MixedEffectsShapeMatrix::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::MixedEffectsShapeMatrix::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::MixedEffectsShapeMatrix::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::MixedEffectsShapeMatrix::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    MixedEffectsShapeMatrix ,\n    LegacyShapeMatrix \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-updatemeanmatrix","title":"function UpdateMeanMatrix","text":"<pre><code>inline void UpdateMeanMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-computemean","title":"function ComputeMean","text":"<pre><code>inline vnl_vector&lt; double &gt; ComputeMean(\n    double k\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-resizeparameters","title":"function ResizeParameters","text":"<pre><code>inline void ResizeParameters(\n    unsigned int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-resizemeanmatrix","title":"function ResizeMeanMatrix","text":"<pre><code>inline virtual void ResizeMeanMatrix(\n    int rs,\n    int cs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-resizeexplanatory","title":"function ResizeExplanatory","text":"<pre><code>inline void ResizeExplanatory(\n    unsigned int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::LegacyShapeMatrix::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. This can only be safely done before shapes are initialized with points! </p>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-settimeptsperindividual","title":"function SetTimeptsPerIndividual","text":"<pre><code>inline void SetTimeptsPerIndividual(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-gettimeptsperindividual","title":"function GetTimeptsPerIndividual","text":"<pre><code>inline int GetTimeptsPerIndividual() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setexplanatory","title":"function SetExplanatory","text":"<pre><code>inline void SetExplanatory(\n    std::vector&lt; double &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setexplanatory_1","title":"function SetExplanatory","text":"<pre><code>inline void SetExplanatory(\n    unsigned int i,\n    double q\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getexplanatory","title":"function GetExplanatory","text":"<pre><code>inline const double &amp; GetExplanatory(\n    unsigned int i\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getexplanatory_1","title":"function GetExplanatory","text":"<pre><code>inline double &amp; GetExplanatory(\n    unsigned int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getslope","title":"function GetSlope","text":"<pre><code>inline const vnl_vector&lt; double &gt; &amp; GetSlope() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getintercept","title":"function GetIntercept","text":"<pre><code>inline const vnl_vector&lt; double &gt; &amp; GetIntercept() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getsloperandom","title":"function GetSlopeRandom","text":"<pre><code>inline const vnl_matrix&lt; double &gt; &amp; GetSlopeRandom() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getinterceptrandom","title":"function GetInterceptRandom","text":"<pre><code>inline const vnl_matrix&lt; double &gt; &amp; GetInterceptRandom() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setslope","title":"function SetSlope","text":"<pre><code>inline void SetSlope(\n    const std::vector&lt; double &gt; &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setintercept","title":"function SetIntercept","text":"<pre><code>inline void SetIntercept(\n    const std::vector&lt; double &gt; &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-estimateparameters","title":"function EstimateParameters","text":"<pre><code>inline void EstimateParameters()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-initialize","title":"function Initialize","text":"<pre><code>inline void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-beforeiteration","title":"function BeforeIteration","text":"<pre><code>inline virtual void BeforeIteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-setregressioninterval","title":"function SetRegressionInterval","text":"<pre><code>inline void SetRegressionInterval(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-getregressioninterval","title":"function GetRegressionInterval","text":"<pre><code>inline int GetRegressionInterval() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-mixedeffectsshapematrix","title":"function MixedEffectsShapeMatrix","text":"<pre><code>inline MixedEffectsShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-mixedeffectsshapematrix_1","title":"function ~MixedEffectsShapeMatrix","text":"<pre><code>inline virtual ~MixedEffectsShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MixedEffectsShapeMatrix.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html","title":"shapeworks::MorphologicalDeviationScore","text":""},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html#public-functions","title":"Public Functions","text":"Name MorphologicalDeviationScore() bool SetControlShapes(const Eigen::MatrixXd &amp; X) Eigen::VectorXd GetMorphoDevScore(const Eigen::MatrixXd &amp; X)"},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html#function-morphologicaldeviationscore","title":"function MorphologicalDeviationScore","text":"<pre><code>MorphologicalDeviationScore()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html#function-setcontrolshapes","title":"function SetControlShapes","text":"<pre><code>bool SetControlShapes(\n    const Eigen::MatrixXd &amp; X\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1MorphologicalDeviationScore.html#function-getmorphodevscore","title":"function GetMorphoDevScore","text":"<pre><code>Eigen::VectorXd GetMorphoDevScore(\n    const Eigen::MatrixXd &amp; X\n)\n</code></pre> <p>Get Mahalanobis-based deviation score for test samples (non-fixed shapes/domains) </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html","title":"shapeworks::NetworkAnalysisJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#public-functions","title":"Public Functions","text":"Name NetworkAnalysisJob(std::shared_ptr&lt; Project &gt; project, std::string target_group, std::string target_feature) virtual void run() overriderun the job virtual QString name() overrideget the name of the job void set_pvalue_of_interest(double pvalue_of_interest) void set_pvalue_threshold(double pvalue_threshold) void set_num_iterations(int num_iterations) Eigen::VectorXd get_tvalues() Eigen::VectorXd get_spm_values()"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-networkanalysisjob","title":"function NetworkAnalysisJob","text":"<pre><code>NetworkAnalysisJob(\n    std::shared_ptr&lt; Project &gt; project,\n    std::string target_group,\n    std::string target_feature\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-set_pvalue_of_interest","title":"function set_pvalue_of_interest","text":"<pre><code>void set_pvalue_of_interest(\n    double pvalue_of_interest\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-set_pvalue_threshold","title":"function set_pvalue_threshold","text":"<pre><code>void set_pvalue_threshold(\n    double pvalue_threshold\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-set_num_iterations","title":"function set_num_iterations","text":"<pre><code>void set_num_iterations(\n    int num_iterations\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-get_tvalues","title":"function get_tvalues","text":"<pre><code>Eigen::VectorXd get_tvalues()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1NetworkAnalysisJob.html#function-get_spm_values","title":"function get_spm_values","text":"<pre><code>Eigen::VectorXd get_spm_values()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html","title":"shapeworks::Observer","text":"<p>This class is an observer interface for classes to monitor for changes to the optimizer (observer pattern) </p> <p><code>#include &lt;Observer.h&gt;</code></p> <p>Inherits from itk::DataObject</p> <p>Inherited by shapeworks::GenericContainerArray&lt; TNumericType &gt;, shapeworks::GenericContainerArray&lt; T &gt;, shapeworks::LegacyShapeMatrix, shapeworks::ShapeGradientMatrix, shapeworks::ShapeMatrix</p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-classes","title":"Public Classes","text":"Name struct DefinedCallbacksStruct"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-types","title":"Public Types","text":"Name typedef Observer Self typedef DataObject Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(Observer , DataObject ) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; ) virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionAddEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; )"},{"location":"api/Classes/classshapeworks_1_1Observer.html#protected-functions","title":"Protected Functions","text":"Name Observer() virtual ~Observer() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-attributes","title":"Public Attributes","text":"Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Observer.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef Observer shapeworks::Observer::Self;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef DataObject shapeworks::Observer::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::Observer::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::Observer::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::Observer::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    Observer ,\n    DataObject \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplemented by: shapeworks::GenericContainerArray::DomainAddEventCallback, shapeworks::GenericContainerArray::DomainAddEventCallback, shapeworks::LegacyShapeMatrix::DomainAddEventCallback, shapeworks::LinearRegressionShapeMatrix::DomainAddEventCallback, shapeworks::MixedEffectsShapeMatrix::DomainAddEventCallback, shapeworks::ShapeGradientMatrix::DomainAddEventCallback, shapeworks::ShapeMatrix::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-transformseteventcallback","title":"function TransformSetEventCallback","text":"<pre><code>inline virtual void TransformSetEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-prefixtransformseteventcallback","title":"function PrefixTransformSetEventCallback","text":"<pre><code>inline virtual void PrefixTransformSetEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplemented by: shapeworks::LegacyShapeMatrix::PositionSetEventCallback, shapeworks::LinearRegressionShapeMatrix::PositionSetEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionSetEventCallback, shapeworks::ShapeGradientMatrix::PositionSetEventCallback, shapeworks::ShapeMatrix::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplemented by: shapeworks::GenericContainerArray::PositionAddEventCallback, shapeworks::GenericContainerArray::PositionAddEventCallback, shapeworks::LegacyShapeMatrix::PositionAddEventCallback, shapeworks::LinearRegressionShapeMatrix::PositionAddEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionAddEventCallback, shapeworks::ShapeGradientMatrix::PositionAddEventCallback, shapeworks::ShapeMatrix::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplemented by: shapeworks::GenericContainerArray::PositionRemoveEventCallback, shapeworks::GenericContainerArray::PositionRemoveEventCallback, shapeworks::LegacyShapeMatrix::PositionRemoveEventCallback, shapeworks::LinearRegressionShapeMatrix::PositionRemoveEventCallback, shapeworks::MixedEffectsShapeMatrix::PositionRemoveEventCallback, shapeworks::ShapeGradientMatrix::PositionRemoveEventCallback, shapeworks::ShapeMatrix::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-observer","title":"function Observer","text":"<pre><code>inline Observer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-observer_1","title":"function ~Observer","text":"<pre><code>inline virtual ~Observer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Observer.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Observer.html#variable-m_definedcallbacks","title":"variable m_DefinedCallbacks","text":"<pre><code>DefinedCallbacksStruct m_DefinedCallbacks;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html","title":"shapeworks::OptimizationVisualizer","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#public-functions","title":"Public Functions","text":"Name void AddMesh(vtkPolyData * mesh, std::shared_ptr&lt; trimesh::TriMesh &gt; tmesh) void IterationCallback(ParticleSystem * particleSystem) void SetWireFrame(bool enabled) void SetSaveScreenshots(bool enabled, std::string path) OptimizationVisualizer() ~OptimizationVisualizer()"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-addmesh","title":"function AddMesh","text":"<pre><code>void AddMesh(\n    vtkPolyData * mesh,\n    std::shared_ptr&lt; trimesh::TriMesh &gt; tmesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-iterationcallback","title":"function IterationCallback","text":"<pre><code>void IterationCallback(\n    ParticleSystem * particleSystem\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-setwireframe","title":"function SetWireFrame","text":"<pre><code>void SetWireFrame(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-setsavescreenshots","title":"function SetSaveScreenshots","text":"<pre><code>void SetSaveScreenshots(\n    bool enabled,\n    std::string path\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-optimizationvisualizer","title":"function OptimizationVisualizer","text":"<pre><code>inline OptimizationVisualizer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizationVisualizer.html#function-optimizationvisualizer_1","title":"function ~OptimizationVisualizer","text":"<pre><code>inline ~OptimizationVisualizer()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html","title":"shapeworks::Optimize","text":"<p>More...</p> <p><code>#include &lt;Optimize.h&gt;</code></p> <p>Inherited by shapeworks::QOptimize</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#public-types","title":"Public Types","text":"Name using itk::Image&lt; float, 3 &gt; ImageType using VectorFunction::VectorType VectorType using Eigen::MatrixXd MatrixType"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#public-functions","title":"Public Functions","text":"Name Optimize()Constructor. virtual ~Optimize()Destructor. bool Run()Run the optimization. bool LoadParameterFile(std::string filename)Load a parameter file. bool SetUpOptimize(ProjectHandle project)Set up this Optimize object using a ShapeWorks project. void SetProject(std::shared_ptr&lt; Project &gt; project)Set the Project object. void SetIterationCallbackFunction(const std::function&lt; void(void)&gt; &amp; f)Set an iteration callback function to be called after each iteration. void AbortOptimization()Abort optimization. bool GetAborted()Return if the optimization was aborted. virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetLocalPoints()Return the local points. virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetGlobalPoints()Return the global points. void SetCutPlanes(std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; cut_planes)Set cutting planes. void SetVerbosity(int verbosity_level)Set the verbosity level (0-5) void SetDomainsPerShape(int domains_per_shape)Set the number of domains per shape. int GetDomainsPerShape()Return the number of domains per shape. void SetDomainType(shapeworks::DomainType type) shapeworks::DomainType GetDomainType() void SetNumberOfParticles(std::vector&lt; int &gt; number_of_particles)Set the numbers of particles (vector of numbers, one for each domain) std::vector&lt; int &gt; GetNumberOfParticles()Return the numbers of particles per domain. void SetTransformFile(std::string filename)Set the transform file. std::string GetTransformFile()Get the transform file. void SetPrefixTransformFile(std::string prefix_transform_file)Set the prefix transform file (TODO: details) std::string GetPrefixTransformFile()Get the prefix transform file. void SetOutputDir(std::string output_dir)Set the output directory. void SetOutputTransformFile(std::string output_transform_file)Set the output transform file. void SetOutputIndividualTransformFiles(bool value)Set whether individual transforms should be written. void SetUseMeshBasedAttributes(bool use_mesh_based_attributes)Set if mesh based attributes should be used. bool GetUseMeshBasedAttributes()Get if mesh based attributes are being used. void SetUseXYZ(std::vector&lt; bool &gt; use_xyz)Set if XYZ is used, one value per domain. void SetUseNormals(std::vector&lt; bool &gt; use_normals)Set if Normals are being used, one value per domain. void SetAttributesPerDomain(std::vector&lt; int &gt; attributes_per_domain)Set the attributes per domain. std::vector&lt; int &gt; GetAttributesPerDomain()Get attributes per domain. void SetDistributionDomainID(int distribution_domain_id)Set the distribution domain ID (TODO: details) int GetDistributionDomainID()Get the distribution domain ID. void SetOutputCuttingPlaneFile(std::string output_cutting_plane_file)Set the output cutting plane file. void SetUseCuttingPlanes(bool use_cutting_planes)Set if using cutting planes. void SetCuttingPlane(unsigned int i, const vnl_vector_fixed&lt; double, 3 &gt; &amp; va, const vnl_vector_fixed&lt; double, 3 &gt; &amp; vb, const vnl_vector_fixed&lt; double, 3 &gt; &amp; vc)Set a given cutting plane for a shape. void SetMeshFFCMode(int mesh_ffc_mode)Set Mesh FFC Mode false/0 = mesh clipping mode, true/1 = mesh augmented lagrangian mode. void SetTimePtsPerSubject(int time_pts_per_subject)Set the number of time points per subject (TODO: details) int GetTimePtsPerSubject()Get the number of time points per subject (TODO: details) void SetOptimizationIterations(int optimization_iterations)Set the number of optimization iterations. void SetOptimizationIterationsCompleted(int optimization_iterations_completed)Set the number of optimization iterations already completed (TODO: details) void SetIterationsPerSplit(int iterations_per_split)Set the number of iterations per split. void SetUseShapeStatisticsInInit(bool use_shape_statistics_in_init)Set if shape statistics should be used in initialization. void SetProcrustesInterval(int procrustes_interval)Set the interval for running procrustes (0 to disable) void SetProcrustesScaling(bool procrustes_scaling)Set if procrustes scaling should be used. void SetProcrustesRotationTranslation(bool procrustes_rotation_translation)Set if procrustes rotation/translation should be used. void SetRelativeWeighting(double relative_weighting)Set the relative weighting (TODO: details) void SetInitialRelativeWeighting(double initial_relative_weighting)Set the initial relative weigting (TODO: details) void SetStartingRegularization(double starting_regularization)Set the starting regularization (TODO: details) void SetEndingRegularization(double ending_regularization)Set the ending regularization (TODO: details) void SetRecomputeRegularizationInterval(int recompute_regularization_interval)Set the interval for recomputing regularization (TODO: details) void SetSaveInitSplits(bool save_init_splits)Set if initialization splits should be saved or not. void SetCheckpointingInterval(int checkpointing_interval)Set the checkpointing interval. void SetKeepCheckpoints(int keep_checkpoints)Set if checkpoints should be kept (0=disable, 1=enable) void SetUseRegression(bool use_regression)Set if regression should be used (TODO: details) void SetUseMixedEffects(bool use_mixed_effects)Set if mixed effects should be used (TODO: details) void SetUseDisentangledSpatiotemporalSSM(bool use_disentangled_ssm_4d)Set if optimization should be done using disentangled spatiotemporal SSM method. bool GetUseDisentangledSpatiotemporalSSM()Returns true if optimization is to be done using disentangled spatiotemporal SSM method. void SetNormalAngle(double normal_angle)For good/bad analysis, set the normal angle to use (TODO: details) void SetPerformGoodBad(bool perform_good_bad)Set if good/bad analysis should be done (TODO: details) void SetLogEnergy(bool log_energy)Set the log energy (TODO: details) void AddImage(ImageType::Pointer image, std::string name =\"\")Set the shape input images. void AddMesh(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void AddContour(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void SetFilenames(const std::vector&lt; std::string &gt; &amp; filenames)Set the shape filenames (TODO: details) void SetPointFiles(const std::vector&lt; std::string &gt; &amp; point_files)Set starting point files (TODO: details) void SetInitialPoints(std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; initial_points)Set initial particle positions (e.g. for fixed subjects) int GetNumShapes()Get number of shapes. void SetAttributeScales(const std::vector&lt; double &gt; &amp; scales)Set attribute scales (TODO: details) void SetFieldAttributes(const std::vector&lt; std::string &gt; &amp; field_attributes)Set the field attributes. void SetParticleFlags(std::vector&lt; int &gt; flags)Set Particle Flags (TODO: details) void SetFixedDomains(std::vector&lt; int &gt; flags)Set Domain Flags (TODO: details) void SetSharedBoundaryEnabled(bool enabled)Shared boundary settings. void SetSharedBoundaryWeight(double weight) void SetEarlyStoppingConfig(EarlyStoppingConfig config)Early Stopping params. const std::vector&lt; int &gt; &amp; GetDomainFlags() void SetFileOutputEnabled(bool enabled)Set if file output is enabled. std::vector&lt; bool &gt; GetUseXYZ()Return if XYZ is used, per shape. std::vector&lt; bool &gt; GetUseNormals()Return if Normals are used, per shape. void SetNarrowBand(double v)Set the narrow band used to be +/- the given value as a multiple of the spacing. double GetNarrowBand()Return the narrow band to be used. void SetUseShapeStatisticsAfter(int num_particles)Set the number of particles when correspondence based multiscale takes over. int GetUseShapeStatisticsAfter()Return the number of particles when correspondence based multiscale takes over. void PrintParamInfo()Print parameter info to stdout. std::shared_ptr&lt; Sampler &gt; GetSampler()Return the Sampler. MatrixContainer GetParticleSystem()Return the particle system as a matrix. void SetPythonFile(std::string filename)Set the python file to run at startup. void SetGeodesicsEnabled(bool is_enabled)Set whether or not geodesics are enabled. bool GetGeodesicsEnabled() const void SetGeodesicsCacheSizeMultiplier(size_t n) void SetGeodesicsRemeshPercent(double percent)Set the remeshing percent for the mesh used for computing geodesics (0-100) OptimizationVisualizer &amp; GetVisualizer() void SetShowVisualizer(bool show) bool GetShowVisualizer() bool GetMeshFFCMode() vnl_vector_fixed&lt; double, 3 &gt; TransformPoint(int domain, vnl_vector_fixed&lt; double, 3 &gt; input)transform a point if necessary void UpdateProgress() void set_particle_format(std::string format)"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#protected-functions","title":"Protected Functions","text":"Name virtual void SetIterationCallback()Set the iteration callback. Derived classes should override to set their own callback. void ComputeTotalIterations() void OptimizerStop() void ReadTransformFile() void ReadPrefixTransformFile(const std::string &amp; s) void InitializeSampler() double GetMinNeighborhoodRadius() void AddSinglePoint() void Initialize() void RunOptimize() void ComputeEnergyAfterIteration() void SetCotanSigma() void WriteTransformFile(int iter =-1) const void WriteTransformFile(std::string iter_prefix) const void WriteTransformFiles(int iter =-1) const void WriteTransformFiles(std::string iter_prefix) const void WritePointFiles(int iter =-1) void WritePointFiles(std::string iter_prefix) void WritePointFilesWithFeatures(int iter =-1) void WritePointFilesWithFeatures(std::string iter_prefix) void WriteEnergyFiles() void WriteSplitFiles(std::string name) void WriteCuttingPlanePoints(int iter =-1) void WriteParameters(std::string output_dir =\"\") void ReportBadParticles() int SetParameters() void WriteModes() void PrintStartMessage(std::string str, unsigned int vlevel =0) const void PrintDoneMessage(unsigned int vlevel =0) const virtual void UpdateExportablePoints() virtual std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; GetProcrustesTransforms() void UpdateProject() std::string GetCheckpointDir()"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#protected-attributes","title":"Protected Attributes","text":"Name std::shared_ptr&lt; Sampler &gt; m_sampler ProcrustesRegistration::Pointer m_procrustes std::shared_ptr&lt; ParticleGoodBadAssessment &gt; m_good_bad unsigned int m_verbosity_level std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_local_points std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_global_points int m_checkpoint_counter int m_procrustes_counter bool m_use_cutting_planes bool m_optimizing bool m_use_regression bool m_use_mixed_effects bool m_use_disentangled_ssm unsigned int m_domains_per_shape shapeworks::DomainType m_domain_type std::vector&lt; int &gt; m_number_of_particles std::string m_transform_file std::string m_prefix_transform_file std::string m_output_dir std::string m_output_transform_file bool m_output_transform_files bool m_mesh_based_attributes std::vector&lt; bool &gt; m_use_xyz std::vector&lt; bool &gt; m_use_normals std::vector&lt; int &gt; m_attributes_per_domain int m_distribution_domain_id std::string m_output_cutting_plane_file bool m_mesh_ffc_mode unsigned int m_timepts_per_subject int m_optimization_iterations int m_optimization_iterations_completed int m_iterations_per_split bool m_use_shape_statistics_in_init unsigned int m_procrustes_interval bool m_procrustes_scaling bool m_procrustes_rotation_translation double m_relative_weighting double m_initial_relative_weighting double m_starting_regularization double m_ending_regularization int m_recompute_regularization_interval bool m_save_init_splits unsigned int m_checkpointing_interval int m_keep_checkpoints double m_cotan_sigma_factor std::vector&lt; int &gt; m_particle_flags std::vector&lt; int &gt; m_domain_flags double m_narrow_band bool m_narrow_band_set bool m_fixed_domains_present int m_use_shape_statistics_after std::string m_python_filename bool m_geodesics_enabled size_t m_geodesic_cache_size_multiplier double m_geodesic_remesh_percent double m_spacing std::vector&lt; std::string &gt; m_filenames int m_num_shapes std::vector&lt; double &gt; m_energy_a std::vector&lt; double &gt; m_energy_b std::vector&lt; double &gt; m_total_energy bool m_log_energy std::string m_str_energy std::vector&lt; std::vector&lt; int &gt; &gt; m_bad_ids double m_normal_angle bool m_perform_good_bad std::vector&lt; int &gt; m_cutting_planes_per_input std::vector&lt; int &gt; m_spheres_per_input bool m_file_output_enabled bool m_aborted std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; m_cut_planes int m_total_iterations int m_iteration_count int m_split_number int current_particle_iterations_ int total_particle_iterations_ std::function&lt; void(void)&gt; iteration_callback_ bool show_visualizer_ shapeworks::OptimizationVisualizer visualizer_ std::string particle_format_ std::shared_ptr&lt; Project &gt; project_ std::chrono::system_clock::time_point m_start_time std::chrono::system_clock::time_point m_last_update_time std::chrono::system_clock::time_point m_last_remaining_update_time std::string m_remaining_time_message"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Optimize;\n</code></pre> <p>Par: Overview of Optimize</p> <p>This class is the top-level API for the optimization library</p> <p>The Optimize class controls all aspect of the particle system library provides a top-level public API for running optimization </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Optimize.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::Optimize::ImageType =  itk::Image&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::Optimize::VectorType =  VectorFunction::VectorType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#using-matrixtype","title":"using MatrixType","text":"<pre><code>using shapeworks::Optimize::MatrixType =  Eigen::MatrixXd;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-optimize","title":"function Optimize","text":"<pre><code>Optimize()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-optimize_1","title":"function ~Optimize","text":"<pre><code>virtual ~Optimize()\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-run","title":"function Run","text":"<pre><code>bool Run()\n</code></pre> <p>Run the optimization. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-loadparameterfile","title":"function LoadParameterFile","text":"<pre><code>bool LoadParameterFile(\n    std::string filename\n)\n</code></pre> <p>Load a parameter file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setupoptimize","title":"function SetUpOptimize","text":"<pre><code>bool SetUpOptimize(\n    ProjectHandle project\n)\n</code></pre> <p>Set up this Optimize object using a ShapeWorks project. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setproject","title":"function SetProject","text":"<pre><code>void SetProject(\n    std::shared_ptr&lt; Project &gt; project\n)\n</code></pre> <p>Set the Project object. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setiterationcallbackfunction","title":"function SetIterationCallbackFunction","text":"<pre><code>inline void SetIterationCallbackFunction(\n    const std::function&lt; void(void)&gt; &amp; f\n)\n</code></pre> <p>Set an iteration callback function to be called after each iteration. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-abortoptimization","title":"function AbortOptimization","text":"<pre><code>void AbortOptimization()\n</code></pre> <p>Abort optimization. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getaborted","title":"function GetAborted","text":"<pre><code>bool GetAborted()\n</code></pre> <p>Return if the optimization was aborted. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getlocalpoints","title":"function GetLocalPoints","text":"<pre><code>virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetLocalPoints()\n</code></pre> <p>Return the local points. </p> <p>Reimplemented by: shapeworks::QOptimize::GetLocalPoints</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getglobalpoints","title":"function GetGlobalPoints","text":"<pre><code>virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetGlobalPoints()\n</code></pre> <p>Return the global points. </p> <p>Reimplemented by: shapeworks::QOptimize::GetGlobalPoints</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setcutplanes","title":"function SetCutPlanes","text":"<pre><code>void SetCutPlanes(\n    std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; cut_planes\n)\n</code></pre> <p>Set cutting planes. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setverbosity","title":"function SetVerbosity","text":"<pre><code>void SetVerbosity(\n    int verbosity_level\n)\n</code></pre> <p>Set the verbosity level (0-5) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>void SetDomainsPerShape(\n    int domains_per_shape\n)\n</code></pre> <p>Set the number of domains per shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>int GetDomainsPerShape()\n</code></pre> <p>Return the number of domains per shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setdomaintype","title":"function SetDomainType","text":"<pre><code>void SetDomainType(\n    shapeworks::DomainType type\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getdomaintype","title":"function GetDomainType","text":"<pre><code>shapeworks::DomainType GetDomainType()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setnumberofparticles","title":"function SetNumberOfParticles","text":"<pre><code>void SetNumberOfParticles(\n    std::vector&lt; int &gt; number_of_particles\n)\n</code></pre> <p>Set the numbers of particles (vector of numbers, one for each domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getnumberofparticles","title":"function GetNumberOfParticles","text":"<pre><code>std::vector&lt; int &gt; GetNumberOfParticles()\n</code></pre> <p>Return the numbers of particles per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-settransformfile","title":"function SetTransformFile","text":"<pre><code>void SetTransformFile(\n    std::string filename\n)\n</code></pre> <p>Set the transform file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-gettransformfile","title":"function GetTransformFile","text":"<pre><code>std::string GetTransformFile()\n</code></pre> <p>Get the transform file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setprefixtransformfile","title":"function SetPrefixTransformFile","text":"<pre><code>void SetPrefixTransformFile(\n    std::string prefix_transform_file\n)\n</code></pre> <p>Set the prefix transform file (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getprefixtransformfile","title":"function GetPrefixTransformFile","text":"<pre><code>std::string GetPrefixTransformFile()\n</code></pre> <p>Get the prefix transform file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoutputdir","title":"function SetOutputDir","text":"<pre><code>void SetOutputDir(\n    std::string output_dir\n)\n</code></pre> <p>Set the output directory. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoutputtransformfile","title":"function SetOutputTransformFile","text":"<pre><code>void SetOutputTransformFile(\n    std::string output_transform_file\n)\n</code></pre> <p>Set the output transform file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoutputindividualtransformfiles","title":"function SetOutputIndividualTransformFiles","text":"<pre><code>void SetOutputIndividualTransformFiles(\n    bool value\n)\n</code></pre> <p>Set whether individual transforms should be written. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusemeshbasedattributes","title":"function SetUseMeshBasedAttributes","text":"<pre><code>void SetUseMeshBasedAttributes(\n    bool use_mesh_based_attributes\n)\n</code></pre> <p>Set if mesh based attributes should be used. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getusemeshbasedattributes","title":"function GetUseMeshBasedAttributes","text":"<pre><code>bool GetUseMeshBasedAttributes()\n</code></pre> <p>Get if mesh based attributes are being used. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusexyz","title":"function SetUseXYZ","text":"<pre><code>void SetUseXYZ(\n    std::vector&lt; bool &gt; use_xyz\n)\n</code></pre> <p>Set if XYZ is used, one value per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusenormals","title":"function SetUseNormals","text":"<pre><code>void SetUseNormals(\n    std::vector&lt; bool &gt; use_normals\n)\n</code></pre> <p>Set if Normals are being used, one value per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setattributesperdomain","title":"function SetAttributesPerDomain","text":"<pre><code>void SetAttributesPerDomain(\n    std::vector&lt; int &gt; attributes_per_domain\n)\n</code></pre> <p>Set the attributes per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getattributesperdomain","title":"function GetAttributesPerDomain","text":"<pre><code>std::vector&lt; int &gt; GetAttributesPerDomain()\n</code></pre> <p>Get attributes per domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setdistributiondomainid","title":"function SetDistributionDomainID","text":"<pre><code>void SetDistributionDomainID(\n    int distribution_domain_id\n)\n</code></pre> <p>Set the distribution domain ID (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getdistributiondomainid","title":"function GetDistributionDomainID","text":"<pre><code>int GetDistributionDomainID()\n</code></pre> <p>Get the distribution domain ID. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoutputcuttingplanefile","title":"function SetOutputCuttingPlaneFile","text":"<pre><code>void SetOutputCuttingPlaneFile(\n    std::string output_cutting_plane_file\n)\n</code></pre> <p>Set the output cutting plane file. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusecuttingplanes","title":"function SetUseCuttingPlanes","text":"<pre><code>void SetUseCuttingPlanes(\n    bool use_cutting_planes\n)\n</code></pre> <p>Set if using cutting planes. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setcuttingplane","title":"function SetCuttingPlane","text":"<pre><code>void SetCuttingPlane(\n    unsigned int i,\n    const vnl_vector_fixed&lt; double, 3 &gt; &amp; va,\n    const vnl_vector_fixed&lt; double, 3 &gt; &amp; vb,\n    const vnl_vector_fixed&lt; double, 3 &gt; &amp; vc\n)\n</code></pre> <p>Set a given cutting plane for a shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setmeshffcmode","title":"function SetMeshFFCMode","text":"<pre><code>inline void SetMeshFFCMode(\n    int mesh_ffc_mode\n)\n</code></pre> <p>Set Mesh FFC Mode false/0 = mesh clipping mode, true/1 = mesh augmented lagrangian mode. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-settimeptspersubject","title":"function SetTimePtsPerSubject","text":"<pre><code>void SetTimePtsPerSubject(\n    int time_pts_per_subject\n)\n</code></pre> <p>Set the number of time points per subject (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-gettimeptspersubject","title":"function GetTimePtsPerSubject","text":"<pre><code>int GetTimePtsPerSubject()\n</code></pre> <p>Get the number of time points per subject (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoptimizationiterations","title":"function SetOptimizationIterations","text":"<pre><code>void SetOptimizationIterations(\n    int optimization_iterations\n)\n</code></pre> <p>Set the number of optimization iterations. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setoptimizationiterationscompleted","title":"function SetOptimizationIterationsCompleted","text":"<pre><code>void SetOptimizationIterationsCompleted(\n    int optimization_iterations_completed\n)\n</code></pre> <p>Set the number of optimization iterations already completed (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setiterationspersplit","title":"function SetIterationsPerSplit","text":"<pre><code>void SetIterationsPerSplit(\n    int iterations_per_split\n)\n</code></pre> <p>Set the number of iterations per split. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setuseshapestatisticsininit","title":"function SetUseShapeStatisticsInInit","text":"<pre><code>void SetUseShapeStatisticsInInit(\n    bool use_shape_statistics_in_init\n)\n</code></pre> <p>Set if shape statistics should be used in initialization. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setprocrustesinterval","title":"function SetProcrustesInterval","text":"<pre><code>void SetProcrustesInterval(\n    int procrustes_interval\n)\n</code></pre> <p>Set the interval for running procrustes (0 to disable) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setprocrustesscaling","title":"function SetProcrustesScaling","text":"<pre><code>void SetProcrustesScaling(\n    bool procrustes_scaling\n)\n</code></pre> <p>Set if procrustes scaling should be used. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setprocrustesrotationtranslation","title":"function SetProcrustesRotationTranslation","text":"<pre><code>void SetProcrustesRotationTranslation(\n    bool procrustes_rotation_translation\n)\n</code></pre> <p>Set if procrustes rotation/translation should be used. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setrelativeweighting","title":"function SetRelativeWeighting","text":"<pre><code>void SetRelativeWeighting(\n    double relative_weighting\n)\n</code></pre> <p>Set the relative weighting (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setinitialrelativeweighting","title":"function SetInitialRelativeWeighting","text":"<pre><code>void SetInitialRelativeWeighting(\n    double initial_relative_weighting\n)\n</code></pre> <p>Set the initial relative weigting (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setstartingregularization","title":"function SetStartingRegularization","text":"<pre><code>void SetStartingRegularization(\n    double starting_regularization\n)\n</code></pre> <p>Set the starting regularization (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setendingregularization","title":"function SetEndingRegularization","text":"<pre><code>void SetEndingRegularization(\n    double ending_regularization\n)\n</code></pre> <p>Set the ending regularization (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setrecomputeregularizationinterval","title":"function SetRecomputeRegularizationInterval","text":"<pre><code>void SetRecomputeRegularizationInterval(\n    int recompute_regularization_interval\n)\n</code></pre> <p>Set the interval for recomputing regularization (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setsaveinitsplits","title":"function SetSaveInitSplits","text":"<pre><code>void SetSaveInitSplits(\n    bool save_init_splits\n)\n</code></pre> <p>Set if initialization splits should be saved or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setcheckpointinginterval","title":"function SetCheckpointingInterval","text":"<pre><code>void SetCheckpointingInterval(\n    int checkpointing_interval\n)\n</code></pre> <p>Set the checkpointing interval. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setkeepcheckpoints","title":"function SetKeepCheckpoints","text":"<pre><code>void SetKeepCheckpoints(\n    int keep_checkpoints\n)\n</code></pre> <p>Set if checkpoints should be kept (0=disable, 1=enable) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setuseregression","title":"function SetUseRegression","text":"<pre><code>void SetUseRegression(\n    bool use_regression\n)\n</code></pre> <p>Set if regression should be used (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusemixedeffects","title":"function SetUseMixedEffects","text":"<pre><code>void SetUseMixedEffects(\n    bool use_mixed_effects\n)\n</code></pre> <p>Set if mixed effects should be used (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setusedisentangledspatiotemporalssm","title":"function SetUseDisentangledSpatiotemporalSSM","text":"<pre><code>void SetUseDisentangledSpatiotemporalSSM(\n    bool use_disentangled_ssm_4d\n)\n</code></pre> <p>Set if optimization should be done using disentangled spatiotemporal SSM method. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getusedisentangledspatiotemporalssm","title":"function GetUseDisentangledSpatiotemporalSSM","text":"<pre><code>bool GetUseDisentangledSpatiotemporalSSM()\n</code></pre> <p>Returns true if optimization is to be done using disentangled spatiotemporal SSM method. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setnormalangle","title":"function SetNormalAngle","text":"<pre><code>void SetNormalAngle(\n    double normal_angle\n)\n</code></pre> <p>For good/bad analysis, set the normal angle to use (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setperformgoodbad","title":"function SetPerformGoodBad","text":"<pre><code>void SetPerformGoodBad(\n    bool perform_good_bad\n)\n</code></pre> <p>Set if good/bad analysis should be done (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setlogenergy","title":"function SetLogEnergy","text":"<pre><code>void SetLogEnergy(\n    bool log_energy\n)\n</code></pre> <p>Set the log energy (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-addimage","title":"function AddImage","text":"<pre><code>void AddImage(\n    ImageType::Pointer image,\n    std::string name =\"\"\n)\n</code></pre> <p>Set the shape input images. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-addmesh","title":"function AddMesh","text":"<pre><code>void AddMesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-addcontour","title":"function AddContour","text":"<pre><code>void AddContour(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setfilenames","title":"function SetFilenames","text":"<pre><code>void SetFilenames(\n    const std::vector&lt; std::string &gt; &amp; filenames\n)\n</code></pre> <p>Set the shape filenames (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setpointfiles","title":"function SetPointFiles","text":"<pre><code>void SetPointFiles(\n    const std::vector&lt; std::string &gt; &amp; point_files\n)\n</code></pre> <p>Set starting point files (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setinitialpoints","title":"function SetInitialPoints","text":"<pre><code>void SetInitialPoints(\n    std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; initial_points\n)\n</code></pre> <p>Set initial particle positions (e.g. for fixed subjects) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getnumshapes","title":"function GetNumShapes","text":"<pre><code>int GetNumShapes()\n</code></pre> <p>Get number of shapes. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setattributescales","title":"function SetAttributeScales","text":"<pre><code>void SetAttributeScales(\n    const std::vector&lt; double &gt; &amp; scales\n)\n</code></pre> <p>Set attribute scales (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setfieldattributes","title":"function SetFieldAttributes","text":"<pre><code>void SetFieldAttributes(\n    const std::vector&lt; std::string &gt; &amp; field_attributes\n)\n</code></pre> <p>Set the field attributes. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setparticleflags","title":"function SetParticleFlags","text":"<pre><code>void SetParticleFlags(\n    std::vector&lt; int &gt; flags\n)\n</code></pre> <p>Set Particle Flags (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setfixeddomains","title":"function SetFixedDomains","text":"<pre><code>void SetFixedDomains(\n    std::vector&lt; int &gt; flags\n)\n</code></pre> <p>Set Domain Flags (TODO: details) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setsharedboundaryenabled","title":"function SetSharedBoundaryEnabled","text":"<pre><code>void SetSharedBoundaryEnabled(\n    bool enabled\n)\n</code></pre> <p>Shared boundary settings. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setsharedboundaryweight","title":"function SetSharedBoundaryWeight","text":"<pre><code>void SetSharedBoundaryWeight(\n    double weight\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setearlystoppingconfig","title":"function SetEarlyStoppingConfig","text":"<pre><code>void SetEarlyStoppingConfig(\n    EarlyStoppingConfig config\n)\n</code></pre> <p>Early Stopping params. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getdomainflags","title":"function GetDomainFlags","text":"<pre><code>const std::vector&lt; int &gt; &amp; GetDomainFlags()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setfileoutputenabled","title":"function SetFileOutputEnabled","text":"<pre><code>void SetFileOutputEnabled(\n    bool enabled\n)\n</code></pre> <p>Set if file output is enabled. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getusexyz","title":"function GetUseXYZ","text":"<pre><code>std::vector&lt; bool &gt; GetUseXYZ()\n</code></pre> <p>Return if XYZ is used, per shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getusenormals","title":"function GetUseNormals","text":"<pre><code>std::vector&lt; bool &gt; GetUseNormals()\n</code></pre> <p>Return if Normals are used, per shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setnarrowband","title":"function SetNarrowBand","text":"<pre><code>void SetNarrowBand(\n    double v\n)\n</code></pre> <p>Set the narrow band used to be +/- the given value as a multiple of the spacing. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getnarrowband","title":"function GetNarrowBand","text":"<pre><code>double GetNarrowBand()\n</code></pre> <p>Return the narrow band to be used. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setuseshapestatisticsafter","title":"function SetUseShapeStatisticsAfter","text":"<pre><code>void SetUseShapeStatisticsAfter(\n    int num_particles\n)\n</code></pre> <p>Set the number of particles when correspondence based multiscale takes over. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getuseshapestatisticsafter","title":"function GetUseShapeStatisticsAfter","text":"<pre><code>int GetUseShapeStatisticsAfter()\n</code></pre> <p>Return the number of particles when correspondence based multiscale takes over. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-printparaminfo","title":"function PrintParamInfo","text":"<pre><code>void PrintParamInfo()\n</code></pre> <p>Print parameter info to stdout. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getsampler","title":"function GetSampler","text":"<pre><code>inline std::shared_ptr&lt; Sampler &gt; GetSampler()\n</code></pre> <p>Return the Sampler. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getparticlesystem","title":"function GetParticleSystem","text":"<pre><code>MatrixContainer GetParticleSystem()\n</code></pre> <p>Return the particle system as a matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setpythonfile","title":"function SetPythonFile","text":"<pre><code>void SetPythonFile(\n    std::string filename\n)\n</code></pre> <p>Set the python file to run at startup. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setgeodesicsenabled","title":"function SetGeodesicsEnabled","text":"<pre><code>void SetGeodesicsEnabled(\n    bool is_enabled\n)\n</code></pre> <p>Set whether or not geodesics are enabled. </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getgeodesicsenabled","title":"function GetGeodesicsEnabled","text":"<pre><code>inline bool GetGeodesicsEnabled() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setgeodesicscachesizemultiplier","title":"function SetGeodesicsCacheSizeMultiplier","text":"<pre><code>void SetGeodesicsCacheSizeMultiplier(\n    size_t n\n)\n</code></pre> <p>Set cache size multiplier for geodesics. The total number of cache entries will be n * number_of_triangles </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setgeodesicsremeshpercent","title":"function SetGeodesicsRemeshPercent","text":"<pre><code>void SetGeodesicsRemeshPercent(\n    double percent\n)\n</code></pre> <p>Set the remeshing percent for the mesh used for computing geodesics (0-100) </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getvisualizer","title":"function GetVisualizer","text":"<pre><code>OptimizationVisualizer &amp; GetVisualizer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setshowvisualizer","title":"function SetShowVisualizer","text":"<pre><code>void SetShowVisualizer(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getshowvisualizer","title":"function GetShowVisualizer","text":"<pre><code>bool GetShowVisualizer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getmeshffcmode","title":"function GetMeshFFCMode","text":"<pre><code>inline bool GetMeshFFCMode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-transformpoint","title":"function TransformPoint","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; TransformPoint(\n    int domain,\n    vnl_vector_fixed&lt; double, 3 &gt; input\n)\n</code></pre> <p>transform a point if necessary </p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-updateprogress","title":"function UpdateProgress","text":"<pre><code>void UpdateProgress()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-set_particle_format","title":"function set_particle_format","text":"<pre><code>inline void set_particle_format(\n    std::string format\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setiterationcallback","title":"function SetIterationCallback","text":"<pre><code>virtual void SetIterationCallback()\n</code></pre> <p>Set the iteration callback. Derived classes should override to set their own callback. </p> <p>Reimplemented by: shapeworks::QOptimize::SetIterationCallback</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-computetotaliterations","title":"function ComputeTotalIterations","text":"<pre><code>void ComputeTotalIterations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-optimizerstop","title":"function OptimizerStop","text":"<pre><code>void OptimizerStop()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-readtransformfile","title":"function ReadTransformFile","text":"<pre><code>void ReadTransformFile()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-readprefixtransformfile","title":"function ReadPrefixTransformFile","text":"<pre><code>void ReadPrefixTransformFile(\n    const std::string &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-initializesampler","title":"function InitializeSampler","text":"<pre><code>void InitializeSampler()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getminneighborhoodradius","title":"function GetMinNeighborhoodRadius","text":"<pre><code>double GetMinNeighborhoodRadius()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-addsinglepoint","title":"function AddSinglePoint","text":"<pre><code>void AddSinglePoint()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-initialize","title":"function Initialize","text":"<pre><code>void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-runoptimize","title":"function RunOptimize","text":"<pre><code>void RunOptimize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-computeenergyafteriteration","title":"function ComputeEnergyAfterIteration","text":"<pre><code>void ComputeEnergyAfterIteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setcotansigma","title":"function SetCotanSigma","text":"<pre><code>void SetCotanSigma()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writetransformfile","title":"function WriteTransformFile","text":"<pre><code>void WriteTransformFile(\n    int iter =-1\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writetransformfile_1","title":"function WriteTransformFile","text":"<pre><code>void WriteTransformFile(\n    std::string iter_prefix\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writetransformfiles","title":"function WriteTransformFiles","text":"<pre><code>void WriteTransformFiles(\n    int iter =-1\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writetransformfiles_1","title":"function WriteTransformFiles","text":"<pre><code>void WriteTransformFiles(\n    std::string iter_prefix\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writepointfiles","title":"function WritePointFiles","text":"<pre><code>void WritePointFiles(\n    int iter =-1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writepointfiles_1","title":"function WritePointFiles","text":"<pre><code>void WritePointFiles(\n    std::string iter_prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writepointfileswithfeatures","title":"function WritePointFilesWithFeatures","text":"<pre><code>void WritePointFilesWithFeatures(\n    int iter =-1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writepointfileswithfeatures_1","title":"function WritePointFilesWithFeatures","text":"<pre><code>void WritePointFilesWithFeatures(\n    std::string iter_prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writeenergyfiles","title":"function WriteEnergyFiles","text":"<pre><code>void WriteEnergyFiles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writesplitfiles","title":"function WriteSplitFiles","text":"<pre><code>void WriteSplitFiles(\n    std::string name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writecuttingplanepoints","title":"function WriteCuttingPlanePoints","text":"<pre><code>void WriteCuttingPlanePoints(\n    int iter =-1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writeparameters","title":"function WriteParameters","text":"<pre><code>void WriteParameters(\n    std::string output_dir =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-reportbadparticles","title":"function ReportBadParticles","text":"<pre><code>void ReportBadParticles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-setparameters","title":"function SetParameters","text":"<pre><code>int SetParameters()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-writemodes","title":"function WriteModes","text":"<pre><code>void WriteModes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-printstartmessage","title":"function PrintStartMessage","text":"<pre><code>void PrintStartMessage(\n    std::string str,\n    unsigned int vlevel =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-printdonemessage","title":"function PrintDoneMessage","text":"<pre><code>void PrintDoneMessage(\n    unsigned int vlevel =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-updateexportablepoints","title":"function UpdateExportablePoints","text":"<pre><code>virtual void UpdateExportablePoints()\n</code></pre> <p>Reimplemented by: shapeworks::QOptimize::UpdateExportablePoints</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getprocrustestransforms","title":"function GetProcrustesTransforms","text":"<pre><code>virtual std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; GetProcrustesTransforms()\n</code></pre> <p>Reimplemented by: shapeworks::QOptimize::GetProcrustesTransforms</p>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-updateproject","title":"function UpdateProject","text":"<pre><code>void UpdateProject()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#function-getcheckpointdir","title":"function GetCheckpointDir","text":"<pre><code>std::string GetCheckpointDir()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_sampler","title":"variable m_sampler","text":"<pre><code>std::shared_ptr&lt; Sampler &gt; m_sampler;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_procrustes","title":"variable m_procrustes","text":"<pre><code>ProcrustesRegistration::Pointer m_procrustes;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_good_bad","title":"variable m_good_bad","text":"<pre><code>std::shared_ptr&lt; ParticleGoodBadAssessment &gt; m_good_bad;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_verbosity_level","title":"variable m_verbosity_level","text":"<pre><code>unsigned int m_verbosity_level = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_local_points","title":"variable m_local_points","text":"<pre><code>std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_local_points;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_global_points","title":"variable m_global_points","text":"<pre><code>std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_global_points;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_checkpoint_counter","title":"variable m_checkpoint_counter","text":"<pre><code>int m_checkpoint_counter = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_procrustes_counter","title":"variable m_procrustes_counter","text":"<pre><code>int m_procrustes_counter = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_cutting_planes","title":"variable m_use_cutting_planes","text":"<pre><code>bool m_use_cutting_planes = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_optimizing","title":"variable m_optimizing","text":"<pre><code>bool m_optimizing = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_regression","title":"variable m_use_regression","text":"<pre><code>bool m_use_regression = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_mixed_effects","title":"variable m_use_mixed_effects","text":"<pre><code>bool m_use_mixed_effects = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_disentangled_ssm","title":"variable m_use_disentangled_ssm","text":"<pre><code>bool m_use_disentangled_ssm = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_domains_per_shape","title":"variable m_domains_per_shape","text":"<pre><code>unsigned int m_domains_per_shape = 1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_domain_type","title":"variable m_domain_type","text":"<pre><code>shapeworks::DomainType m_domain_type = shapeworks::DomainType::Image;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_number_of_particles","title":"variable m_number_of_particles","text":"<pre><code>std::vector&lt; int &gt; m_number_of_particles;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_transform_file","title":"variable m_transform_file","text":"<pre><code>std::string m_transform_file;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_prefix_transform_file","title":"variable m_prefix_transform_file","text":"<pre><code>std::string m_prefix_transform_file;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_output_dir","title":"variable m_output_dir","text":"<pre><code>std::string m_output_dir;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_output_transform_file","title":"variable m_output_transform_file","text":"<pre><code>std::string m_output_transform_file;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_output_transform_files","title":"variable m_output_transform_files","text":"<pre><code>bool m_output_transform_files = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_mesh_based_attributes","title":"variable m_mesh_based_attributes","text":"<pre><code>bool m_mesh_based_attributes = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_xyz","title":"variable m_use_xyz","text":"<pre><code>std::vector&lt; bool &gt; m_use_xyz;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_normals","title":"variable m_use_normals","text":"<pre><code>std::vector&lt; bool &gt; m_use_normals;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_attributes_per_domain","title":"variable m_attributes_per_domain","text":"<pre><code>std::vector&lt; int &gt; m_attributes_per_domain;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_distribution_domain_id","title":"variable m_distribution_domain_id","text":"<pre><code>int m_distribution_domain_id = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_output_cutting_plane_file","title":"variable m_output_cutting_plane_file","text":"<pre><code>std::string m_output_cutting_plane_file;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_mesh_ffc_mode","title":"variable m_mesh_ffc_mode","text":"<pre><code>bool m_mesh_ffc_mode = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_timepts_per_subject","title":"variable m_timepts_per_subject","text":"<pre><code>unsigned int m_timepts_per_subject = 1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_optimization_iterations","title":"variable m_optimization_iterations","text":"<pre><code>int m_optimization_iterations = 2000;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_optimization_iterations_completed","title":"variable m_optimization_iterations_completed","text":"<pre><code>int m_optimization_iterations_completed = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_iterations_per_split","title":"variable m_iterations_per_split","text":"<pre><code>int m_iterations_per_split = 1000;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_shape_statistics_in_init","title":"variable m_use_shape_statistics_in_init","text":"<pre><code>bool m_use_shape_statistics_in_init = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_procrustes_interval","title":"variable m_procrustes_interval","text":"<pre><code>unsigned int m_procrustes_interval = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_procrustes_scaling","title":"variable m_procrustes_scaling","text":"<pre><code>bool m_procrustes_scaling = true;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_procrustes_rotation_translation","title":"variable m_procrustes_rotation_translation","text":"<pre><code>bool m_procrustes_rotation_translation = true;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_relative_weighting","title":"variable m_relative_weighting","text":"<pre><code>double m_relative_weighting = 1.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_initial_relative_weighting","title":"variable m_initial_relative_weighting","text":"<pre><code>double m_initial_relative_weighting = 0.05;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_starting_regularization","title":"variable m_starting_regularization","text":"<pre><code>double m_starting_regularization = 1000;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_ending_regularization","title":"variable m_ending_regularization","text":"<pre><code>double m_ending_regularization = 1.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_recompute_regularization_interval","title":"variable m_recompute_regularization_interval","text":"<pre><code>int m_recompute_regularization_interval = 1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_save_init_splits","title":"variable m_save_init_splits","text":"<pre><code>bool m_save_init_splits = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_checkpointing_interval","title":"variable m_checkpointing_interval","text":"<pre><code>unsigned int m_checkpointing_interval = 50;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_keep_checkpoints","title":"variable m_keep_checkpoints","text":"<pre><code>int m_keep_checkpoints = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_cotan_sigma_factor","title":"variable m_cotan_sigma_factor","text":"<pre><code>double m_cotan_sigma_factor = 5.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_particle_flags","title":"variable m_particle_flags","text":"<pre><code>std::vector&lt; int &gt; m_particle_flags;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_domain_flags","title":"variable m_domain_flags","text":"<pre><code>std::vector&lt; int &gt; m_domain_flags;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_narrow_band","title":"variable m_narrow_band","text":"<pre><code>double m_narrow_band = 0.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_narrow_band_set","title":"variable m_narrow_band_set","text":"<pre><code>bool m_narrow_band_set = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_fixed_domains_present","title":"variable m_fixed_domains_present","text":"<pre><code>bool m_fixed_domains_present = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_use_shape_statistics_after","title":"variable m_use_shape_statistics_after","text":"<pre><code>int m_use_shape_statistics_after = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_python_filename","title":"variable m_python_filename","text":"<pre><code>std::string m_python_filename;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_geodesics_enabled","title":"variable m_geodesics_enabled","text":"<pre><code>bool m_geodesics_enabled = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_geodesic_cache_size_multiplier","title":"variable m_geodesic_cache_size_multiplier","text":"<pre><code>size_t m_geodesic_cache_size_multiplier = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_geodesic_remesh_percent","title":"variable m_geodesic_remesh_percent","text":"<pre><code>double m_geodesic_remesh_percent = 100.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_spacing","title":"variable m_spacing","text":"<pre><code>double m_spacing = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_filenames","title":"variable m_filenames","text":"<pre><code>std::vector&lt; std::string &gt; m_filenames;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_num_shapes","title":"variable m_num_shapes","text":"<pre><code>int m_num_shapes = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_energy_a","title":"variable m_energy_a","text":"<pre><code>std::vector&lt; double &gt; m_energy_a;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_energy_b","title":"variable m_energy_b","text":"<pre><code>std::vector&lt; double &gt; m_energy_b;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_total_energy","title":"variable m_total_energy","text":"<pre><code>std::vector&lt; double &gt; m_total_energy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_log_energy","title":"variable m_log_energy","text":"<pre><code>bool m_log_energy = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_str_energy","title":"variable m_str_energy","text":"<pre><code>std::string m_str_energy;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_bad_ids","title":"variable m_bad_ids","text":"<pre><code>std::vector&lt; std::vector&lt; int &gt; &gt; m_bad_ids;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_normal_angle","title":"variable m_normal_angle","text":"<pre><code>double m_normal_angle = itk::Math::pi / 2.0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_perform_good_bad","title":"variable m_perform_good_bad","text":"<pre><code>bool m_perform_good_bad = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_cutting_planes_per_input","title":"variable m_cutting_planes_per_input","text":"<pre><code>std::vector&lt; int &gt; m_cutting_planes_per_input;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_spheres_per_input","title":"variable m_spheres_per_input","text":"<pre><code>std::vector&lt; int &gt; m_spheres_per_input;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_file_output_enabled","title":"variable m_file_output_enabled","text":"<pre><code>bool m_file_output_enabled = true;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_aborted","title":"variable m_aborted","text":"<pre><code>bool m_aborted = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_cut_planes","title":"variable m_cut_planes","text":"<pre><code>std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; m_cut_planes;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_total_iterations","title":"variable m_total_iterations","text":"<pre><code>int m_total_iterations = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_iteration_count","title":"variable m_iteration_count","text":"<pre><code>int m_iteration_count = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_split_number","title":"variable m_split_number","text":"<pre><code>int m_split_number = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-current_particle_iterations_","title":"variable current_particle_iterations_","text":"<pre><code>int current_particle_iterations_ = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-total_particle_iterations_","title":"variable total_particle_iterations_","text":"<pre><code>int total_particle_iterations_ = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-iteration_callback_","title":"variable iteration_callback_","text":"<pre><code>std::function&lt; void(void)&gt; iteration_callback_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-show_visualizer_","title":"variable show_visualizer_","text":"<pre><code>bool show_visualizer_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-visualizer_","title":"variable visualizer_","text":"<pre><code>shapeworks::OptimizationVisualizer visualizer_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-particle_format_","title":"variable particle_format_","text":"<pre><code>std::string particle_format_ = \"particles\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-project_","title":"variable project_","text":"<pre><code>std::shared_ptr&lt; Project &gt; project_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_start_time","title":"variable m_start_time","text":"<pre><code>std::chrono::system_clock::time_point m_start_time;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_last_update_time","title":"variable m_last_update_time","text":"<pre><code>std::chrono::system_clock::time_point m_last_update_time;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_last_remaining_update_time","title":"variable m_last_remaining_update_time","text":"<pre><code>std::chrono::system_clock::time_point m_last_remaining_update_time;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Optimize.html#variable-m_remaining_time_message","title":"variable m_remaining_time_message","text":"<pre><code>std::string m_remaining_time_message;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeCommandGroup.html","title":"shapeworks::OptimizeCommandGroup","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeCommandGroup.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1OptimizeCommandGroup.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1OptimizeCommandGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeCommandGroup.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html","title":"shapeworks::OptimizeParameterFile","text":"<p>More...</p> <p><code>#include &lt;OptimizeParameterFile.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html#public-functions","title":"Public Functions","text":"Name OptimizeParameterFile() bool load_parameter_file(std::string filename, Optimize * optimize)Load a parameter file and set the values on an Optimize object."},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::OptimizeParameterFile;\n</code></pre> <p>Par: Overview of OptimizeParameterFile</p> <p>Implementation of Optimize library parameter file</p> <p>The OptimizeParameterFile class reads in a parameter file and sets the appropriate values for an Optimize object. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html#function-optimizeparameterfile","title":"function OptimizeParameterFile","text":"<pre><code>OptimizeParameterFile()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameterFile.html#function-load_parameter_file","title":"function load_parameter_file","text":"<pre><code>bool load_parameter_file(\n    std::string filename,\n    Optimize * optimize\n)\n</code></pre> <p>Load a parameter file and set the values on an Optimize object. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html","title":"shapeworks::OptimizeParameters","text":"<p>More...</p> <p><code>#include &lt;OptimizeParameters.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#public-functions","title":"Public Functions","text":"Name OptimizeParameters(ProjectHandle project) void save_to_project() std::string get_optimize_output_prefix() void set_optimize_output_prefix(std::string prefix) std::vector&lt; int &gt; get_number_of_particles() void set_number_of_particles(std::vector&lt; int &gt; number_of_particles) double get_initial_relative_weighting() void set_initial_relative_weighting(double value) double get_relative_weighting() void set_relative_weighting(double value) double get_starting_regularization() void set_starting_regularization(double value) double get_ending_regularization() void set_ending_regularization(double value) int get_iterations_per_split() void set_iterations_per_split(int value) int get_optimization_iterations() void set_optimization_iterations(int value) bool get_use_geodesic_distance() void set_use_geodesic_distance(bool value) int get_geodesic_cache_multiplier() void set_geodesic_cache_multiplier(int value) std::vector&lt; bool &gt; get_use_normals() void set_use_normals(std::vector&lt; bool &gt; use_normals) double get_normals_strength() void set_normals_strength(double value) bool get_use_disentangled_ssm() void set_use_disentangled_ssm(bool value) bool get_use_procrustes() void set_use_procrustes(bool value) bool get_use_procrustes_scaling() void set_use_procrustes_scaling(bool value) bool get_use_procrustes_rotation_translation() void set_use_procrustes_rotation_translation(bool value) int get_procrustes_interval() void set_procrustes_interval(int value) bool get_use_multiscale() void set_use_multiscale(bool value) int get_multiscale_particles() void set_multiscale_particles(int value) double get_narrow_band() void set_narrow_band(double value) int get_verbosity() void set_verbosity(int value) bool get_mesh_ffc_mode() void set_mesh_ffc_mode(bool value) bool get_use_landmarks() void set_use_landmarks(bool value) bool get_use_fixed_subjects() void set_use_fixed_subjects(bool value) std::string get_fixed_subjects_column() void set_fixed_subject_column(std::string column) std::string get_fixed_subjects_choice() void set_fixed_subjects_choice(std::string choice) void set_abort_load(bool value) void set_load_callback(const std::function&lt; void(int)&gt; &amp; f) bool set_up_optimize(Optimize * optimize) bool is_subject_fixed(std::shared_ptr&lt; Subject &gt; subject) int get_checkpoint_interval() void set_checkpoint_interval(int iterations) bool get_save_init_splits() void set_save_init_splits(bool enabled) bool get_keep_checkpoints() void set_keep_checkpoints(bool enabled) std::vector&lt; std::string &gt; get_field_attributes() void set_field_attributes(std::vector&lt; std::string &gt; attributes) std::vector&lt; double &gt; get_field_attribute_weights() void set_field_attribute_weights(std::vector&lt; double &gt; weights) bool get_use_geodesics_to_landmarks() void set_use_geodesics_to_landmarks(bool value) double get_geodesic_to_landmarks_weight() void set_geodesic_to_landmarks_weight(double value) std::string get_particle_format() void set_particle_format(std::string format) double get_geodesic_remesh_percent() void set_geodesic_remesh_percent(double value) bool get_shared_boundary() void set_shared_boundary(bool value) double get_shared_boundary_weight() void set_shared_boundary_weight(double value) EarlyStoppingConfig get_early_stopping_config() Parameters get_parameters() const"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::OptimizeParameters;\n</code></pre> <p>This class encapsulated processing of Optimization parameters </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-optimizeparameters","title":"function OptimizeParameters","text":"<pre><code>explicit OptimizeParameters(\n    ProjectHandle project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-save_to_project","title":"function save_to_project","text":"<pre><code>void save_to_project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_optimize_output_prefix","title":"function get_optimize_output_prefix","text":"<pre><code>std::string get_optimize_output_prefix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_optimize_output_prefix","title":"function set_optimize_output_prefix","text":"<pre><code>void set_optimize_output_prefix(\n    std::string prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_number_of_particles","title":"function get_number_of_particles","text":"<pre><code>std::vector&lt; int &gt; get_number_of_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_number_of_particles","title":"function set_number_of_particles","text":"<pre><code>void set_number_of_particles(\n    std::vector&lt; int &gt; number_of_particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_initial_relative_weighting","title":"function get_initial_relative_weighting","text":"<pre><code>double get_initial_relative_weighting()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_initial_relative_weighting","title":"function set_initial_relative_weighting","text":"<pre><code>void set_initial_relative_weighting(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_relative_weighting","title":"function get_relative_weighting","text":"<pre><code>double get_relative_weighting()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_relative_weighting","title":"function set_relative_weighting","text":"<pre><code>void set_relative_weighting(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_starting_regularization","title":"function get_starting_regularization","text":"<pre><code>double get_starting_regularization()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_starting_regularization","title":"function set_starting_regularization","text":"<pre><code>void set_starting_regularization(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_ending_regularization","title":"function get_ending_regularization","text":"<pre><code>double get_ending_regularization()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_ending_regularization","title":"function set_ending_regularization","text":"<pre><code>void set_ending_regularization(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_iterations_per_split","title":"function get_iterations_per_split","text":"<pre><code>int get_iterations_per_split()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_iterations_per_split","title":"function set_iterations_per_split","text":"<pre><code>void set_iterations_per_split(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_optimization_iterations","title":"function get_optimization_iterations","text":"<pre><code>int get_optimization_iterations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_optimization_iterations","title":"function set_optimization_iterations","text":"<pre><code>void set_optimization_iterations(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_geodesic_distance","title":"function get_use_geodesic_distance","text":"<pre><code>bool get_use_geodesic_distance()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_geodesic_distance","title":"function set_use_geodesic_distance","text":"<pre><code>void set_use_geodesic_distance(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_geodesic_cache_multiplier","title":"function get_geodesic_cache_multiplier","text":"<pre><code>int get_geodesic_cache_multiplier()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_geodesic_cache_multiplier","title":"function set_geodesic_cache_multiplier","text":"<pre><code>void set_geodesic_cache_multiplier(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_normals","title":"function get_use_normals","text":"<pre><code>std::vector&lt; bool &gt; get_use_normals()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_normals","title":"function set_use_normals","text":"<pre><code>void set_use_normals(\n    std::vector&lt; bool &gt; use_normals\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_normals_strength","title":"function get_normals_strength","text":"<pre><code>double get_normals_strength()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_normals_strength","title":"function set_normals_strength","text":"<pre><code>void set_normals_strength(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_disentangled_ssm","title":"function get_use_disentangled_ssm","text":"<pre><code>bool get_use_disentangled_ssm()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_disentangled_ssm","title":"function set_use_disentangled_ssm","text":"<pre><code>void set_use_disentangled_ssm(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_procrustes","title":"function get_use_procrustes","text":"<pre><code>bool get_use_procrustes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_procrustes","title":"function set_use_procrustes","text":"<pre><code>void set_use_procrustes(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_procrustes_scaling","title":"function get_use_procrustes_scaling","text":"<pre><code>bool get_use_procrustes_scaling()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_procrustes_scaling","title":"function set_use_procrustes_scaling","text":"<pre><code>void set_use_procrustes_scaling(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_procrustes_rotation_translation","title":"function get_use_procrustes_rotation_translation","text":"<pre><code>bool get_use_procrustes_rotation_translation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_procrustes_rotation_translation","title":"function set_use_procrustes_rotation_translation","text":"<pre><code>void set_use_procrustes_rotation_translation(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_procrustes_interval","title":"function get_procrustes_interval","text":"<pre><code>int get_procrustes_interval()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_procrustes_interval","title":"function set_procrustes_interval","text":"<pre><code>void set_procrustes_interval(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_multiscale","title":"function get_use_multiscale","text":"<pre><code>bool get_use_multiscale()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_multiscale","title":"function set_use_multiscale","text":"<pre><code>void set_use_multiscale(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_multiscale_particles","title":"function get_multiscale_particles","text":"<pre><code>int get_multiscale_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_multiscale_particles","title":"function set_multiscale_particles","text":"<pre><code>void set_multiscale_particles(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_narrow_band","title":"function get_narrow_band","text":"<pre><code>double get_narrow_band()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_narrow_band","title":"function set_narrow_band","text":"<pre><code>void set_narrow_band(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_verbosity","title":"function get_verbosity","text":"<pre><code>int get_verbosity()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_verbosity","title":"function set_verbosity","text":"<pre><code>void set_verbosity(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_mesh_ffc_mode","title":"function get_mesh_ffc_mode","text":"<pre><code>bool get_mesh_ffc_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_mesh_ffc_mode","title":"function set_mesh_ffc_mode","text":"<pre><code>void set_mesh_ffc_mode(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_landmarks","title":"function get_use_landmarks","text":"<pre><code>bool get_use_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_landmarks","title":"function set_use_landmarks","text":"<pre><code>void set_use_landmarks(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_fixed_subjects","title":"function get_use_fixed_subjects","text":"<pre><code>bool get_use_fixed_subjects()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_fixed_subjects","title":"function set_use_fixed_subjects","text":"<pre><code>void set_use_fixed_subjects(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_fixed_subjects_column","title":"function get_fixed_subjects_column","text":"<pre><code>std::string get_fixed_subjects_column()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_fixed_subject_column","title":"function set_fixed_subject_column","text":"<pre><code>void set_fixed_subject_column(\n    std::string column\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_fixed_subjects_choice","title":"function get_fixed_subjects_choice","text":"<pre><code>std::string get_fixed_subjects_choice()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_fixed_subjects_choice","title":"function set_fixed_subjects_choice","text":"<pre><code>void set_fixed_subjects_choice(\n    std::string choice\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_abort_load","title":"function set_abort_load","text":"<pre><code>void set_abort_load(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_load_callback","title":"function set_load_callback","text":"<pre><code>void set_load_callback(\n    const std::function&lt; void(int)&gt; &amp; f\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_up_optimize","title":"function set_up_optimize","text":"<pre><code>bool set_up_optimize(\n    Optimize * optimize\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-is_subject_fixed","title":"function is_subject_fixed","text":"<pre><code>bool is_subject_fixed(\n    std::shared_ptr&lt; Subject &gt; subject\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_checkpoint_interval","title":"function get_checkpoint_interval","text":"<pre><code>int get_checkpoint_interval()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_checkpoint_interval","title":"function set_checkpoint_interval","text":"<pre><code>void set_checkpoint_interval(\n    int iterations\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_save_init_splits","title":"function get_save_init_splits","text":"<pre><code>bool get_save_init_splits()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_save_init_splits","title":"function set_save_init_splits","text":"<pre><code>void set_save_init_splits(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_keep_checkpoints","title":"function get_keep_checkpoints","text":"<pre><code>bool get_keep_checkpoints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_keep_checkpoints","title":"function set_keep_checkpoints","text":"<pre><code>void set_keep_checkpoints(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_field_attributes","title":"function get_field_attributes","text":"<pre><code>std::vector&lt; std::string &gt; get_field_attributes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_field_attributes","title":"function set_field_attributes","text":"<pre><code>void set_field_attributes(\n    std::vector&lt; std::string &gt; attributes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_field_attribute_weights","title":"function get_field_attribute_weights","text":"<pre><code>std::vector&lt; double &gt; get_field_attribute_weights()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_field_attribute_weights","title":"function set_field_attribute_weights","text":"<pre><code>void set_field_attribute_weights(\n    std::vector&lt; double &gt; weights\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_use_geodesics_to_landmarks","title":"function get_use_geodesics_to_landmarks","text":"<pre><code>bool get_use_geodesics_to_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_use_geodesics_to_landmarks","title":"function set_use_geodesics_to_landmarks","text":"<pre><code>void set_use_geodesics_to_landmarks(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_geodesic_to_landmarks_weight","title":"function get_geodesic_to_landmarks_weight","text":"<pre><code>double get_geodesic_to_landmarks_weight()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_geodesic_to_landmarks_weight","title":"function set_geodesic_to_landmarks_weight","text":"<pre><code>void set_geodesic_to_landmarks_weight(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_particle_format","title":"function get_particle_format","text":"<pre><code>std::string get_particle_format()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_particle_format","title":"function set_particle_format","text":"<pre><code>void set_particle_format(\n    std::string format\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_geodesic_remesh_percent","title":"function get_geodesic_remesh_percent","text":"<pre><code>double get_geodesic_remesh_percent()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_geodesic_remesh_percent","title":"function set_geodesic_remesh_percent","text":"<pre><code>void set_geodesic_remesh_percent(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_shared_boundary","title":"function get_shared_boundary","text":"<pre><code>bool get_shared_boundary()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_shared_boundary","title":"function set_shared_boundary","text":"<pre><code>void set_shared_boundary(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_shared_boundary_weight","title":"function get_shared_boundary_weight","text":"<pre><code>double get_shared_boundary_weight()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-set_shared_boundary_weight","title":"function set_shared_boundary_weight","text":"<pre><code>void set_shared_boundary_weight(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_early_stopping_config","title":"function get_early_stopping_config","text":"<pre><code>EarlyStoppingConfig get_early_stopping_config()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeParameters.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>Parameters get_parameters() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html","title":"shapeworks::OptimizeTool","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-slots","title":"Public Slots","text":"Name void on_run_optimize_button_clicked()Run optimize tool. void on_restoreDefaults_clicked() void handle_optimize_complete() void handle_optimize_failed() void handle_progress(int val, QString message) void handle_error(QString ) void handle_warning(QString ) void handle_message(QString ) void update_ui_elements() bool validate_inputs()"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-signals","title":"Public Signals","text":"Name void optimize_start() void optimize_complete() void progress(int ) void status(std::string )"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-functions","title":"Public Functions","text":"Name OptimizeTool(Preferences &amp; prefs, Telemetry &amp; telemetry) ~OptimizeTool() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the project void activate()activate this tool void load_params()Load params from project. void store_params()Store params to project. void enable_actions()Enable action buttons. void disable_actions()Disable action buttons. void shutdown_threads()shut down any running threads"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-on_run_optimize_button_clicked","title":"slot on_run_optimize_button_clicked","text":"<pre><code>void on_run_optimize_button_clicked()\n</code></pre> <p>Run optimize tool. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-on_restoredefaults_clicked","title":"slot on_restoreDefaults_clicked","text":"<pre><code>void on_restoreDefaults_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_optimize_complete","title":"slot handle_optimize_complete","text":"<pre><code>void handle_optimize_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_optimize_failed","title":"slot handle_optimize_failed","text":"<pre><code>void handle_optimize_failed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_progress","title":"slot handle_progress","text":"<pre><code>void handle_progress(\n    int val,\n    QString message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_error","title":"slot handle_error","text":"<pre><code>void handle_error(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_warning","title":"slot handle_warning","text":"<pre><code>void handle_warning(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-handle_message","title":"slot handle_message","text":"<pre><code>void handle_message(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-update_ui_elements","title":"slot update_ui_elements","text":"<pre><code>void update_ui_elements()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#slot-validate_inputs","title":"slot validate_inputs","text":"<pre><code>bool validate_inputs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#signal-optimize_start","title":"signal optimize_start","text":"<pre><code>void optimize_start()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#signal-optimize_complete","title":"signal optimize_complete","text":"<pre><code>void optimize_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#signal-status","title":"signal status","text":"<pre><code>void status(\n    std::string \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-optimizetool","title":"function OptimizeTool","text":"<pre><code>OptimizeTool(\n    Preferences &amp; prefs,\n    Telemetry &amp; telemetry\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-optimizetool_1","title":"function ~OptimizeTool","text":"<pre><code>~OptimizeTool()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the project </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-activate","title":"function activate","text":"<pre><code>void activate()\n</code></pre> <p>activate this tool </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-load_params","title":"function load_params","text":"<pre><code>void load_params()\n</code></pre> <p>Load params from project. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-store_params","title":"function store_params","text":"<pre><code>void store_params()\n</code></pre> <p>Store params to project. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-enable_actions","title":"function enable_actions","text":"<pre><code>void enable_actions()\n</code></pre> <p>Enable action buttons. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-disable_actions","title":"function disable_actions","text":"<pre><code>void disable_actions()\n</code></pre> <p>Disable action buttons. </p>"},{"location":"api/Classes/classshapeworks_1_1OptimizeTool.html#function-shutdown_threads","title":"function shutdown_threads","text":"<pre><code>void shutdown_threads()\n</code></pre> <p>shut down any running threads </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html","title":"shapeworks::PaintWidget","text":"<p>Inherits from vtkAbstractWidget</p>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-types","title":"Protected Types","text":"Name enum @5"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#public-functions","title":"Public Functions","text":"Name PaintWidget * New() vtkTypeMacro(PaintWidget , vtkAbstractWidget ) void PrintSelf(ostream &amp; os, vtkIndent indent) vtkSetMacro(PointPlacer , vtkPointPlacer * ) vtkGetMacro(PointPlacer , vtkPointPlacer * ) vtkSetMacro(Renderer , vtkRenderer * ) vtkGetMacro(Renderer , vtkRenderer * ) void set_viewer(Viewer * viewer) void set_circle_mode(bool circle_mode) virtual void SetEnabled(int ) void SetRepresentation(vtkContourRepresentation * r) void CreateDefaultRepresentation() void update_position() virtual void Initialize(vtkPolyData * poly, int state =1) virtual void Initialize() void set_brush_size(double size) double get_brush_size() void set_brush_color(float r, float g, float b)"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-functions","title":"Protected Functions","text":"Name PaintWidget() ~PaintWidget() bool use_point_placer(double displayPos[2], int newState) void set_cursor(int requestedShape) void StartPaintAction(vtkAbstractWidget * w) void EndPaintAction(vtkAbstractWidget * w) void StartEraseAction(vtkAbstractWidget * w) void EndEraseAction(vtkAbstractWidget * w) void MoveAction(vtkAbstractWidget * w) void LeaveAction(vtkAbstractWidget * w) void KeyPressAction(vtkAbstractWidget * w)"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-attributes","title":"Protected Attributes","text":"Name int WidgetState vtkPointPlacer * PointPlacer vtkRenderer * Renderer StudioSphereRepresentation * sphere_cursor_ bool mouse_in_window_ Viewer * viewer_ bool circle_mode_"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#enum-5","title":"enum @5","text":"Enumerator Value Description Start Paint Erase"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-new","title":"function New","text":"<pre><code>static PaintWidget * New()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    PaintWidget ,\n    vtkAbstractWidget \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    ostream &amp; os,\n    vtkIndent indent\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-vtksetmacro","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    PointPlacer ,\n    vtkPointPlacer * \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-vtkgetmacro","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    PointPlacer ,\n    vtkPointPlacer * \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-vtksetmacro_1","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    Renderer ,\n    vtkRenderer * \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-vtkgetmacro_1","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    Renderer ,\n    vtkRenderer * \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-set_viewer","title":"function set_viewer","text":"<pre><code>void set_viewer(\n    Viewer * viewer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-set_circle_mode","title":"function set_circle_mode","text":"<pre><code>void set_circle_mode(\n    bool circle_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-setenabled","title":"function SetEnabled","text":"<pre><code>virtual void SetEnabled(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-setrepresentation","title":"function SetRepresentation","text":"<pre><code>inline void SetRepresentation(\n    vtkContourRepresentation * r\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-createdefaultrepresentation","title":"function CreateDefaultRepresentation","text":"<pre><code>void CreateDefaultRepresentation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-update_position","title":"function update_position","text":"<pre><code>void update_position()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-initialize","title":"function Initialize","text":"<pre><code>virtual void Initialize(\n    vtkPolyData * poly,\n    int state =1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-initialize_1","title":"function Initialize","text":"<pre><code>inline virtual void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-set_brush_size","title":"function set_brush_size","text":"<pre><code>void set_brush_size(\n    double size\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-get_brush_size","title":"function get_brush_size","text":"<pre><code>double get_brush_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-set_brush_color","title":"function set_brush_color","text":"<pre><code>void set_brush_color(\n    float r,\n    float g,\n    float b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-paintwidget","title":"function PaintWidget","text":"<pre><code>PaintWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-paintwidget_1","title":"function ~PaintWidget","text":"<pre><code>~PaintWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-use_point_placer","title":"function use_point_placer","text":"<pre><code>bool use_point_placer(\n    double displayPos[2],\n    int newState\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-set_cursor","title":"function set_cursor","text":"<pre><code>void set_cursor(\n    int requestedShape\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-startpaintaction","title":"function StartPaintAction","text":"<pre><code>static void StartPaintAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-endpaintaction","title":"function EndPaintAction","text":"<pre><code>static void EndPaintAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-starteraseaction","title":"function StartEraseAction","text":"<pre><code>static void StartEraseAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-enderaseaction","title":"function EndEraseAction","text":"<pre><code>static void EndEraseAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-moveaction","title":"function MoveAction","text":"<pre><code>static void MoveAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-leaveaction","title":"function LeaveAction","text":"<pre><code>static void LeaveAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#function-keypressaction","title":"function KeyPressAction","text":"<pre><code>static void KeyPressAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-widgetstate","title":"variable WidgetState","text":"<pre><code>int WidgetState;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-pointplacer","title":"variable PointPlacer","text":"<pre><code>vtkPointPlacer * PointPlacer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-renderer","title":"variable Renderer","text":"<pre><code>vtkRenderer * Renderer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-sphere_cursor_","title":"variable sphere_cursor_","text":"<pre><code>StudioSphereRepresentation * sphere_cursor_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-mouse_in_window_","title":"variable mouse_in_window_","text":"<pre><code>bool mouse_in_window_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-viewer_","title":"variable viewer_","text":"<pre><code>Viewer * viewer_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PaintWidget.html#variable-circle_mode_","title":"variable circle_mode_","text":"<pre><code>bool circle_mode_ = false;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html","title":"shapeworks::Parameters","text":"<p>Parameter settings.  More...</p> <p><code>#include &lt;Parameters.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#public-functions","title":"Public Functions","text":"Name Parameters()default constructor Parameters(StringMap map)construct from map Variant get(std::string key, Variant default_value)get a parameter based on a key, return default if it doesn't exist bool key_exists(std::string key)return if a key exists or not void set(std::string key, Variant value)set a parameter based on a key void remove_entry(std::string key)remove an entry void set_map(StringMap map)set underlying map StringMap get_map() constget underlying map void reset_parameters()reset parameters to blank"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#public-attributes","title":"Public Attributes","text":"Name constexpr const char * ANALYSIS_PARAMS constexpr const char * GROOM_PARAMS constexpr const char * OPTIMIZE_PARAMS constexpr const char * STUDIO_PARAMS constexpr const char * PROJECT_PARAMS constexpr const char * DEEPSSM_PARAMS constexpr const char * MONAI_PARAMS"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Parameters;\n</code></pre> <p>Parameter settings. </p> <p>Store key/variant combinations Used to store parameters for various tools </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-parameters","title":"function Parameters","text":"<pre><code>Parameters()\n</code></pre> <p>default constructor </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-parameters_1","title":"function Parameters","text":"<pre><code>explicit Parameters(\n    StringMap map\n)\n</code></pre> <p>construct from map </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-get","title":"function get","text":"<pre><code>Variant get(\n    std::string key,\n    Variant default_value\n)\n</code></pre> <p>get a parameter based on a key, return default if it doesn't exist </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-key_exists","title":"function key_exists","text":"<pre><code>bool key_exists(\n    std::string key\n)\n</code></pre> <p>return if a key exists or not </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-set","title":"function set","text":"<pre><code>void set(\n    std::string key,\n    Variant value\n)\n</code></pre> <p>set a parameter based on a key </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-remove_entry","title":"function remove_entry","text":"<pre><code>void remove_entry(\n    std::string key\n)\n</code></pre> <p>remove an entry </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-set_map","title":"function set_map","text":"<pre><code>void set_map(\n    StringMap map\n)\n</code></pre> <p>set underlying map </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-get_map","title":"function get_map","text":"<pre><code>StringMap get_map() const\n</code></pre> <p>get underlying map </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#function-reset_parameters","title":"function reset_parameters","text":"<pre><code>void reset_parameters()\n</code></pre> <p>reset parameters to blank </p>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-analysis_params","title":"variable ANALYSIS_PARAMS","text":"<pre><code>static constexpr const char * ANALYSIS_PARAMS = \"analysis\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-groom_params","title":"variable GROOM_PARAMS","text":"<pre><code>static constexpr const char * GROOM_PARAMS = \"groom\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-optimize_params","title":"variable OPTIMIZE_PARAMS","text":"<pre><code>static constexpr const char * OPTIMIZE_PARAMS = \"optimize\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-studio_params","title":"variable STUDIO_PARAMS","text":"<pre><code>static constexpr const char * STUDIO_PARAMS = \"studio\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-project_params","title":"variable PROJECT_PARAMS","text":"<pre><code>static constexpr const char * PROJECT_PARAMS = \"project\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-deepssm_params","title":"variable DEEPSSM_PARAMS","text":"<pre><code>static constexpr const char * DEEPSSM_PARAMS = \"deepssm\";\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Parameters.html#variable-monai_params","title":"variable MONAI_PARAMS","text":"<pre><code>static constexpr const char * MONAI_PARAMS = \"monai\";\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html","title":"shapeworks::ParticleArea","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#public-functions","title":"Public Functions","text":"Name void assign_vertex_particles(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, std::vector&lt; itk::Point&lt; double &gt; &gt; particles)assign particle ids for each vertex based on closest geodesic distance void assign_vertex_colors(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, std::vector&lt; QColor &gt; colors)assign vertex colors based on particle ids void assign_vertex_areas(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, Eigen::VectorXd areas)assign vertex areas based on particle ids std::vector&lt; QColor &gt; colors_from_lut(vtkSmartPointer&lt; vtkLookupTable &gt; lut)convert lut to array of colors Eigen::VectorXd compute_particle_triangle_areas(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, std::vector&lt; itk::Point&lt; double &gt; &gt; particles)compute the area assigned to each particle"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#function-assign_vertex_particles","title":"function assign_vertex_particles","text":"<pre><code>static void assign_vertex_particles(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    std::vector&lt; itk::Point&lt; double &gt; &gt; particles\n)\n</code></pre> <p>assign particle ids for each vertex based on closest geodesic distance </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#function-assign_vertex_colors","title":"function assign_vertex_colors","text":"<pre><code>static void assign_vertex_colors(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    std::vector&lt; QColor &gt; colors\n)\n</code></pre> <p>assign vertex colors based on particle ids </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#function-assign_vertex_areas","title":"function assign_vertex_areas","text":"<pre><code>static void assign_vertex_areas(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    Eigen::VectorXd areas\n)\n</code></pre> <p>assign vertex areas based on particle ids </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#function-colors_from_lut","title":"function colors_from_lut","text":"<pre><code>static std::vector&lt; QColor &gt; colors_from_lut(\n    vtkSmartPointer&lt; vtkLookupTable &gt; lut\n)\n</code></pre> <p>convert lut to array of colors </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleArea.html#function-compute_particle_triangle_areas","title":"function compute_particle_triangle_areas","text":"<pre><code>static Eigen::VectorXd compute_particle_triangle_areas(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    std::vector&lt; itk::Point&lt; double &gt; &gt; particles\n)\n</code></pre> <p>compute the area assigned to each particle </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html","title":"shapeworks::ParticleAreaJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#public-functions","title":"Public Functions","text":"Name ParticleAreaJob(QSharedPointer&lt; Session &gt; session) virtual void run() overriderun the job virtual QString name() overrideget the name of the job const Eigen::VectorXd &amp; get_mean_areas() const const Eigen::VectorXd &amp; get_stddev_areas() const"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#function-particleareajob","title":"function ParticleAreaJob","text":"<pre><code>ParticleAreaJob(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#function-name","title":"function name","text":"<pre><code>inline virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#function-get_mean_areas","title":"function get_mean_areas","text":"<pre><code>inline const Eigen::VectorXd &amp; get_mean_areas() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaJob.html#function-get_stddev_areas","title":"function get_stddev_areas","text":"<pre><code>inline const Eigen::VectorXd &amp; get_stddev_areas() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html","title":"shapeworks::ParticleAreaPanel","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-slots","title":"Public Slots","text":"Name void run_clicked() void show_particle_area_clicked() void display_option_changed() void handle_job_progress(int progress) void handle_job_complete()"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-signals","title":"Public Signals","text":"Name void update_view()"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-functions","title":"Public Functions","text":"Name ParticleAreaPanel(QWidget * parent =0) ~ParticleAreaPanel() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the session void reset() bool get_display_particle_area() const Eigen::VectorXd get_computed_values() const std::string get_computed_value_name() const"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#slot-run_clicked","title":"slot run_clicked","text":"<pre><code>void run_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#slot-show_particle_area_clicked","title":"slot show_particle_area_clicked","text":"<pre><code>void show_particle_area_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#slot-display_option_changed","title":"slot display_option_changed","text":"<pre><code>void display_option_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#slot-handle_job_progress","title":"slot handle_job_progress","text":"<pre><code>void handle_job_progress(\n    int progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#slot-handle_job_complete","title":"slot handle_job_complete","text":"<pre><code>void handle_job_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-particleareapanel","title":"function ParticleAreaPanel","text":"<pre><code>ParticleAreaPanel(\n    QWidget * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-particleareapanel_1","title":"function ~ParticleAreaPanel","text":"<pre><code>~ParticleAreaPanel()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the session </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-get_display_particle_area","title":"function get_display_particle_area","text":"<pre><code>bool get_display_particle_area() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-get_computed_values","title":"function get_computed_values","text":"<pre><code>Eigen::VectorXd get_computed_values() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleAreaPanel.html#function-get_computed_value_name","title":"function get_computed_value_name","text":"<pre><code>std::string get_computed_value_name() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html","title":"shapeworks::ParticleColors","text":"<p>Supplies particle colors.  More...</p> <p><code>#include &lt;ParticleColors.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#public-types","title":"Public Types","text":"Name enum ParticleColorsType"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#public-functions","title":"Public Functions","text":"Name Q_ENUM(ParticleColorsType ) vtkSmartPointer&lt; vtkLookupTable &gt; construct_distinct()"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ParticleColors;\n</code></pre> <p>Supplies particle colors. </p> <p>The ParticleColors supplies distinct colors for particles </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#enum-particlecolorstype","title":"enum ParticleColorsType","text":"Enumerator Value Description Distinct 0 Original 1"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#function-q_enum","title":"function Q_ENUM","text":"<pre><code>Q_ENUM(\n    ParticleColorsType \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleColors.html#function-construct_distinct","title":"function construct_distinct","text":"<pre><code>static vtkSmartPointer&lt; vtkLookupTable &gt; construct_distinct()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html","title":"shapeworks::ParticleDomain","text":"<p>Inherited by shapeworks::ContourDomain, shapeworks::MeshDomain, shapeworks::ParticleRegionDomain</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#public-types","title":"Public Types","text":"Name typedef std::shared_ptr&lt; ParticleDomain &gt; Pointer using itk::Point&lt; double, 3 &gt; PointType using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#public-functions","title":"Public Functions","text":"Name virtual bool ApplyConstraints(PointType &amp; p, int idx, bool dbg =false) const =0 virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual const PointType &amp; GetLowerBound() const =0 virtual const PointType &amp; GetUpperBound() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void DeleteImages() =0 virtual void DeletePartialDerivativeImages() =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name)"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#protected-functions","title":"Protected Functions","text":"Name ParticleDomain() virtual ~ParticleDomain()"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#protected-attributes","title":"Protected Attributes","text":"Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef std::shared_ptr&lt;ParticleDomain&gt; shapeworks::ParticleDomain::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::ParticleDomain::PointType =  itk::Point&lt;double, 3&gt;;\n</code></pre> <p>Point type used to store particle locations. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#using-gradntype","title":"using GradNType","text":"<pre><code>using shapeworks::ParticleDomain::GradNType =  vnl_matrix_fixed&lt;float, 3, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#using-vectordoubletype","title":"using VectorDoubleType","text":"<pre><code>using shapeworks::ParticleDomain::VectorDoubleType =  vnl_vector_fixed&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#using-vectorfloattype","title":"using VectorFloatType","text":"<pre><code>using shapeworks::ParticleDomain::VectorFloatType =  vnl_vector_fixed&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-applyconstraints","title":"function ApplyConstraints","text":"<pre><code>virtual bool ApplyConstraints(\n    PointType &amp; p,\n    int idx,\n    bool dbg =false\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::ApplyConstraints, shapeworks::ImplicitSurfaceDomain::ApplyConstraints, shapeworks::MeshDomain::ApplyConstraints</p> <p>Apply any constraints to the given point location. This should force the point to a position on the surface that satisfies all constraints. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-updateparticleposition","title":"function UpdateParticlePosition","text":"<pre><code>virtual PointType UpdateParticlePosition(\n    const PointType &amp; point,\n    int idx,\n    VectorDoubleType &amp; update\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::UpdateParticlePosition, shapeworks::MeshDomain::UpdateParticlePosition</p> <p>Applies the update to the point and returns the new point position. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-invalidateparticleposition","title":"function InvalidateParticlePosition","text":"<pre><code>inline virtual void InvalidateParticlePosition(\n    int idx\n) const\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::InvalidateParticlePosition, shapeworks::MeshDomain::InvalidateParticlePosition</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-projectvectortosurfacetangent","title":"function ProjectVectorToSurfaceTangent","text":"<pre><code>virtual VectorDoubleType ProjectVectorToSurfaceTangent(\n    VectorDoubleType &amp; gradE,\n    const PointType &amp; pos,\n    int idx\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::ProjectVectorToSurfaceTangent, shapeworks::MeshDomain::ProjectVectorToSurfaceTangent</p> <p>Projects the vector to the surface tangent at the point. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-samplegradientatpoint","title":"function SampleGradientAtPoint","text":"<pre><code>virtual VectorFloatType SampleGradientAtPoint(\n    const PointType &amp; point,\n    int idx\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ImageDomainWithGradients::SampleGradientAtPoint, shapeworks::ContourDomain::SampleGradientAtPoint, shapeworks::MeshDomain::SampleGradientAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-samplenormalatpoint","title":"function SampleNormalAtPoint","text":"<pre><code>virtual VectorFloatType SampleNormalAtPoint(\n    const PointType &amp; point,\n    int idx\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ImageDomainWithGradients::SampleNormalAtPoint, shapeworks::ContourDomain::SampleNormalAtPoint, shapeworks::MeshDomain::SampleNormalAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-samplegradnatpoint","title":"function SampleGradNAtPoint","text":"<pre><code>virtual GradNType SampleGradNAtPoint(\n    const PointType &amp; p,\n    int idx\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::SampleGradNAtPoint, shapeworks::ImageDomainWithGradN::SampleGradNAtPoint, shapeworks::MeshDomain::SampleGradNAtPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-distance","title":"function Distance","text":"<pre><code>inline virtual double Distance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b,\n    VectorDoubleType * out_grad =nullptr\n) const\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::Distance</p> <p>Distance between locations is used for computing energy and neighborhoods. Optionally return the gradient of the distance </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-squareddistance","title":"function SquaredDistance","text":"<pre><code>inline virtual double SquaredDistance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b\n) const\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::SquaredDistance, shapeworks::MeshDomain::SquaredDistance</p> <p>Squared Distance between locations is used for computing sigma. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-iswithindistance","title":"function IsWithinDistance","text":"<pre><code>inline virtual bool IsWithinDistance(\n    const PointType &amp; a,\n    int idx_a,\n    const PointType &amp; b,\n    int idx_b,\n    double test_dist,\n    double &amp; distance\n) const\n</code></pre> <p>Reimplemented by: shapeworks::MeshDomain::IsWithinDistance</p> <p>Returns whether or not the two points are separated by the given distance </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getcurvature","title":"function GetCurvature","text":"<pre><code>virtual double GetCurvature(\n    const PointType &amp; p,\n    int idx\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetCurvature, shapeworks::ImageDomainWithCurvature::GetCurvature, shapeworks::MeshDomain::GetCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getsurfacemeancurvature","title":"function GetSurfaceMeanCurvature","text":"<pre><code>virtual double GetSurfaceMeanCurvature() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetSurfaceMeanCurvature, shapeworks::ImageDomainWithCurvature::GetSurfaceMeanCurvature, shapeworks::MeshDomain::GetSurfaceMeanCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getsurfacestddevcurvature","title":"function GetSurfaceStdDevCurvature","text":"<pre><code>virtual double GetSurfaceStdDevCurvature() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetSurfaceStdDevCurvature, shapeworks::ImageDomainWithCurvature::GetSurfaceStdDevCurvature, shapeworks::MeshDomain::GetSurfaceStdDevCurvature</p> <p>Used in ParticleMeanCurvatureAttribute</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getlowerbound","title":"function GetLowerBound","text":"<pre><code>virtual const PointType &amp; GetLowerBound() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ParticleRegionDomain::GetLowerBound, shapeworks::ContourDomain::GetLowerBound, shapeworks::MeshDomain::GetLowerBound</p> <p>Gets the minimum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getupperbound","title":"function GetUpperBound","text":"<pre><code>virtual const PointType &amp; GetUpperBound() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ParticleRegionDomain::GetUpperBound, shapeworks::ContourDomain::GetUpperBound, shapeworks::MeshDomain::GetUpperBound</p> <p>Gets the maximum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getzerocrossingpoint","title":"function GetZeroCrossingPoint","text":"<pre><code>virtual PointType GetZeroCrossingPoint() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetZeroCrossingPoint, shapeworks::ImplicitSurfaceDomain::GetZeroCrossingPoint, shapeworks::MeshDomain::GetZeroCrossingPoint</p> <p>Get any valid point on the domain. This is used to place the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getsurfacearea","title":"function GetSurfaceArea","text":"<pre><code>virtual double GetSurfaceArea() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetSurfaceArea, shapeworks::ImageDomain::GetSurfaceArea, shapeworks::MeshDomain::GetSurfaceArea</p> <p>Use for neighborhood radius. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getvalidlocationnear","title":"function GetValidLocationNear","text":"<pre><code>virtual PointType GetValidLocationNear(\n    PointType p\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetValidLocationNear, shapeworks::ImageDomain::GetValidLocationNear, shapeworks::MeshDomain::GetValidLocationNear</p> <p>GetValidLocation returns a PointType location on the surface. Used for placing the first particle. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getmaxdiameter","title":"function GetMaxDiameter","text":"<pre><code>virtual double GetMaxDiameter() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetMaxDiameter, shapeworks::ImageDomain::GetMaxDiameter, shapeworks::MeshDomain::GetMaxDiameter</p> <p>GetMaxDiameter returns the maximum diameter of the domain and is used for computing sigma </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-deleteimages","title":"function DeleteImages","text":"<pre><code>virtual void DeleteImages() =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::DeleteImages, shapeworks::ImageDomain::DeleteImages, shapeworks::ImageDomainWithGradients::DeleteImages, shapeworks::ImageDomainWithGradN::DeleteImages, shapeworks::MeshDomain::DeleteImages</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-deletepartialderivativeimages","title":"function DeletePartialDerivativeImages","text":"<pre><code>virtual void DeletePartialDerivativeImages() =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::DeletePartialDerivativeImages, shapeworks::ImageDomainWithGradN::DeletePartialDerivativeImages, shapeworks::MeshDomain::DeletePartialDerivativeImages</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-updatezerocrossingpoint","title":"function UpdateZeroCrossingPoint","text":"<pre><code>virtual void UpdateZeroCrossingPoint() =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::UpdateZeroCrossingPoint, shapeworks::ImageDomain::UpdateZeroCrossingPoint, shapeworks::MeshDomain::UpdateZeroCrossingPoint</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-isdomainfixed","title":"function IsDomainFixed","text":"<pre><code>inline bool IsDomainFixed() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getdomaintype","title":"function GetDomainType","text":"<pre><code>virtual shapeworks::DomainType GetDomainType() const =0\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetDomainType, shapeworks::ImplicitSurfaceDomain::GetDomainType, shapeworks::MeshDomain::GetDomainType</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getconstraints","title":"function GetConstraints","text":"<pre><code>inline std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-getpositionaftersplit","title":"function GetPositionAfterSplit","text":"<pre><code>inline virtual PointType GetPositionAfterSplit(\n    const PointType &amp; pt,\n    const VectorDoubleType &amp; local_direction,\n    const VectorDoubleType &amp; global_direction,\n    double epsilon\n) const\n</code></pre> <p>Reimplemented by: shapeworks::ContourDomain::GetPositionAfterSplit</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-setdomainid","title":"function SetDomainID","text":"<pre><code>inline void SetDomainID(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-setdomainname","title":"function SetDomainName","text":"<pre><code>inline void SetDomainName(\n    std::string name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-particledomain","title":"function ParticleDomain","text":"<pre><code>inline ParticleDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#function-particledomain_1","title":"function ~ParticleDomain","text":"<pre><code>inline virtual ~ParticleDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#variable-m_fixeddomain","title":"variable m_FixedDomain","text":"<pre><code>bool m_FixedDomain {true};\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#variable-m_domainid","title":"variable m_DomainID","text":"<pre><code>int m_DomainID {-1};\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#variable-m_domainname","title":"variable m_DomainName","text":"<pre><code>std::string m_DomainName;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleDomain.html#variable-constraints","title":"variable constraints","text":"<pre><code>std::shared_ptr&lt; shapeworks::Constraints &gt; constraints;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html","title":"shapeworks::ParticleEvent","text":"<p>Inherits from itk::EventObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#public-types","title":"Public Types","text":"Name typedef ParticleEvent Self"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#public-functions","title":"Public Functions","text":"Name ParticleEvent() virtual ~ParticleEvent() ParticleEvent(const ParticleEvent &amp; v) const ParticleEvent &amp; operator=(const ParticleEvent &amp; v) virtual const char * GetEventName() const virtual bool CheckEvent(const ::itk::EventObject * e) const ::itk::EventObject * MakeObject() const void SetPositionIndex(int i) int GetPositionIndex() const void SetDomainIndex(int i) int GetDomainIndex() const"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ParticleEvent shapeworks::ParticleEvent::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-particleevent","title":"function ParticleEvent","text":"<pre><code>inline ParticleEvent()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-particleevent_1","title":"function ~ParticleEvent","text":"<pre><code>inline virtual ~ParticleEvent()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-particleevent_2","title":"function ParticleEvent","text":"<pre><code>inline ParticleEvent(\n    const ParticleEvent &amp; v\n)\n</code></pre> <p>Copy constructor and operator= </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-operator","title":"function operator=","text":"<pre><code>inline const ParticleEvent &amp; operator=(\n    const ParticleEvent &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-geteventname","title":"function GetEventName","text":"<pre><code>inline virtual const char * GetEventName() const\n</code></pre> <p>Standard ITK event members. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-checkevent","title":"function CheckEvent","text":"<pre><code>inline virtual bool CheckEvent(\n    const ::itk::EventObject * e\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-makeobject","title":"function MakeObject","text":"<pre><code>inline ::itk::EventObject * MakeObject() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-setpositionindex","title":"function SetPositionIndex","text":"<pre><code>inline void SetPositionIndex(\n    int i\n)\n</code></pre> <p>Get/Set the index value. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-getpositionindex","title":"function GetPositionIndex","text":"<pre><code>inline int GetPositionIndex() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-setdomainindex","title":"function SetDomainIndex","text":"<pre><code>inline void SetDomainIndex(\n    int i\n)\n</code></pre> <p>Get/Set the Domain index value. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleEvent.html#function-getdomainindex","title":"function GetDomainIndex","text":"<pre><code>inline int GetDomainIndex() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html","title":"shapeworks::ParticleGaussianModeWriter","text":"<p>More...</p> <p>Inherits from itk::DataObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#public-types","title":"Public Types","text":"Name typedef ParticleGaussianModeWriter Self typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef DataObject Superclass typedef ParticleSystem ParticleSystemType typedef LegacyShapeMatrix ShapeMatrixType typedef ShapeMatrixType::DataType DataType typedef ParticleSystemType::PointType PointType typedef vnl_vector&lt; DataType &gt; vnl_vector_type typedef vnl_matrix&lt; DataType &gt; vnl_matrix_type"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#public-functions","title":"Public Functions","text":"Name itkTypeMacro(ParticleGaussianModeWriter , DataObject ) itkNewMacro(Self ) itkStaticConstMacro(Dimension , unsigned int , VDimension ) void Update() const int GetNumberOfModes() const void SetNumberOfModes(int b) void SetShapeMatrix(ShapeMatrixType * s) ShapeMatrixType * GetShapeMatrix() const ShapeMatrixType * GetShapeMatrix() const void SetFileName(const std::string &amp; s) void SetFileName(const char * s) const std::string &amp; GetFileName() const"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#protected-functions","title":"Protected Functions","text":"Name ParticleGaussianModeWriter() virtual ~ParticleGaussianModeWriter() void operator=(const ParticleGaussianModeWriter &amp; ) ParticleGaussianModeWriter(const ParticleGaussianModeWriter &amp; )"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#protected-attributes","title":"Protected Attributes","text":"Name ShapeMatrixType::Pointer m_ShapeMatrix int m_NumberOfModes std::string m_FileName"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;unsigned int VDimension&gt;\nclass shapeworks::ParticleGaussianModeWriter;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ParticleGaussianModeWriter shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::Self;\n</code></pre> <p>Standard class typedefs. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef DataObject shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-particlesystemtype","title":"typedef ParticleSystemType","text":"<pre><code>typedef ParticleSystem shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::ParticleSystemType;\n</code></pre> <p>Type of particle system and associated classes. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-shapematrixtype","title":"typedef ShapeMatrixType","text":"<pre><code>typedef LegacyShapeMatrix shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::ShapeMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef ShapeMatrixType::DataType shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::DataType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleSystemType::PointType shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::PointType;\n</code></pre> <p>Vector &amp; Point types. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-vnl_vector_type","title":"typedef vnl_vector_type","text":"<pre><code>typedef vnl_vector&lt;DataType&gt; shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::vnl_vector_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#typedef-vnl_matrix_type","title":"typedef vnl_matrix_type","text":"<pre><code>typedef vnl_matrix&lt;DataType&gt; shapeworks::ParticleGaussianModeWriter&lt; VDimension &gt;::vnl_matrix_type;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    ParticleGaussianModeWriter ,\n    DataObject \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    Dimension ,\n    unsigned int ,\n    VDimension \n)\n</code></pre> <p>Dimensionality of the domain of the particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-update","title":"function Update","text":"<pre><code>void Update() const\n</code></pre> <p>Write the first n modes to +- 3 std dev and the mean of the model described by the covariance matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-getnumberofmodes","title":"function GetNumberOfModes","text":"<pre><code>inline int GetNumberOfModes() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-setnumberofmodes","title":"function SetNumberOfModes","text":"<pre><code>inline void SetNumberOfModes(\n    int b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-setshapematrix","title":"function SetShapeMatrix","text":"<pre><code>inline void SetShapeMatrix(\n    ShapeMatrixType * s\n)\n</code></pre> <p>Access the shape matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-getshapematrix","title":"function GetShapeMatrix","text":"<pre><code>inline ShapeMatrixType * GetShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-getshapematrix_1","title":"function GetShapeMatrix","text":"<pre><code>inline const ShapeMatrixType * GetShapeMatrix() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-setfilename","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const std::string &amp; s\n)\n</code></pre> <p>Set/Get the filename prefix. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-setfilename_1","title":"function SetFileName","text":"<pre><code>inline void SetFileName(\n    const char * s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-getfilename","title":"function GetFileName","text":"<pre><code>inline const std::string &amp; GetFileName() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-particlegaussianmodewriter","title":"function ParticleGaussianModeWriter","text":"<pre><code>inline ParticleGaussianModeWriter()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-particlegaussianmodewriter_1","title":"function ~ParticleGaussianModeWriter","text":"<pre><code>inline virtual ~ParticleGaussianModeWriter()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-operator","title":"function operator=","text":"<pre><code>void operator=(\n    const ParticleGaussianModeWriter &amp; \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#function-particlegaussianmodewriter_2","title":"function ParticleGaussianModeWriter","text":"<pre><code>ParticleGaussianModeWriter(\n    const ParticleGaussianModeWriter &amp; \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#variable-m_shapematrix","title":"variable m_ShapeMatrix","text":"<pre><code>ShapeMatrixType::Pointer m_ShapeMatrix;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#variable-m_numberofmodes","title":"variable m_NumberOfModes","text":"<pre><code>int m_NumberOfModes;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGaussianModeWriter.html#variable-m_filename","title":"variable m_FileName","text":"<pre><code>std::string m_FileName;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html","title":"shapeworks::ParticleGoodBadAssessment","text":"<p>Performs good/bad points assessment and reports the bad positions of the particle system. </p> <p><code>#include &lt;ParticleGoodBadAssessment.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#public-types","title":"Public Types","text":"Name using MeanCurvatureContainer&lt; float, 3 &gt; MeanCurvatureCacheType"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#public-functions","title":"Public Functions","text":"Name void set_domains_per_shape(int i) void set_criterion_angle(double a) std::vector&lt; std::vector&lt; int &gt; &gt; run_assessment(const ParticleSystem * ps, MeanCurvatureCacheType * mean_curvature_cache)"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#using-meancurvaturecachetype","title":"using MeanCurvatureCacheType","text":"<pre><code>using shapeworks::ParticleGoodBadAssessment::MeanCurvatureCacheType =  MeanCurvatureContainer&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#function-set_domains_per_shape","title":"function set_domains_per_shape","text":"<pre><code>inline void set_domains_per_shape(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#function-set_criterion_angle","title":"function set_criterion_angle","text":"<pre><code>inline void set_criterion_angle(\n    double a\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleGoodBadAssessment.html#function-run_assessment","title":"function run_assessment","text":"<pre><code>std::vector&lt; std::vector&lt; int &gt; &gt; run_assessment(\n    const ParticleSystem * ps,\n    MeanCurvatureCacheType * mean_curvature_cache\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html","title":"shapeworks::ParticleNeighborhood","text":"<p>More...</p> <p><code>#include &lt;ParticleNeighborhood.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#public-functions","title":"Public Functions","text":"Name ParticleNeighborhood(ParticleSystem * ps, int domain_id =-1) std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(const itk::Point&lt; double, 3 &gt; &amp; position, int id, std::vector&lt; double &gt; &amp; weights, std::vector&lt; double &gt; &amp; distances, double radius) std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(const itk::Point&lt; double, 3 &gt; &amp; position, int id, std::vector&lt; double &gt; &amp; weights, double radius) std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(const itk::Point&lt; double, 3 &gt; &amp; position, int id, double radius) void set_weighting_enabled(bool is_enabled) bool is_weighting_enabled() const void set_force_euclidean(bool is_enabled) bool is_force_euclidean() const void set_domain(ParticleDomain::Pointer domain) ParticleDomain::Pointer get_domain() const void set_domain_id(int id)"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ParticleNeighborhood;\n</code></pre> <p>A ParticleNeighborhood is responsible for computing neighborhoods of particles. Given a point position in a domain, and a neighborhood radius, the ParticleNeighborhood returns a list of points that are neighbors of that point. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-particleneighborhood","title":"function ParticleNeighborhood","text":"<pre><code>inline explicit ParticleNeighborhood(\n    ParticleSystem * ps,\n    int domain_id =-1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-find_neighborhood_points","title":"function find_neighborhood_points","text":"<pre><code>std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(\n    const itk::Point&lt; double, 3 &gt; &amp; position,\n    int id,\n    std::vector&lt; double &gt; &amp; weights,\n    std::vector&lt; double &gt; &amp; distances,\n    double radius\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-find_neighborhood_points_1","title":"function find_neighborhood_points","text":"<pre><code>std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(\n    const itk::Point&lt; double, 3 &gt; &amp; position,\n    int id,\n    std::vector&lt; double &gt; &amp; weights,\n    double radius\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-find_neighborhood_points_2","title":"function find_neighborhood_points","text":"<pre><code>std::vector&lt; ParticlePointIndexPair &gt; find_neighborhood_points(\n    const itk::Point&lt; double, 3 &gt; &amp; position,\n    int id,\n    double radius\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-set_weighting_enabled","title":"function set_weighting_enabled","text":"<pre><code>inline void set_weighting_enabled(\n    bool is_enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-is_weighting_enabled","title":"function is_weighting_enabled","text":"<pre><code>inline bool is_weighting_enabled() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-set_force_euclidean","title":"function set_force_euclidean","text":"<pre><code>inline void set_force_euclidean(\n    bool is_enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-is_force_euclidean","title":"function is_force_euclidean","text":"<pre><code>inline bool is_force_euclidean() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-set_domain","title":"function set_domain","text":"<pre><code>inline void set_domain(\n    ParticleDomain::Pointer domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-get_domain","title":"function get_domain","text":"<pre><code>inline ParticleDomain::Pointer get_domain() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNeighborhood.html#function-set_domain_id","title":"function set_domain_id","text":"<pre><code>inline void set_domain_id(\n    int id\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html","title":"shapeworks::ParticleNormalEvaluation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html#public-functions","title":"Public Functions","text":"Name std::vector&lt; double &gt; evaluate_particle_normals(const Eigen::MatrixXd &amp; particles, const Eigen::MatrixXd &amp; normals) std::vector&lt; bool &gt; threshold_particle_normals(std::vector&lt; double &gt; angles, double max_angle_degrees) Eigen::MatrixXd compute_particle_normals(const Eigen::MatrixXd &amp; particles, std::vector&lt; std::shared_ptr&lt; Surface &gt; &gt; meshes)Compute normals at particle positions."},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html#function-evaluate_particle_normals","title":"function evaluate_particle_normals","text":"<pre><code>static std::vector&lt; double &gt; evaluate_particle_normals(\n    const Eigen::MatrixXd &amp; particles,\n    const Eigen::MatrixXd &amp; normals\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html#function-threshold_particle_normals","title":"function threshold_particle_normals","text":"<pre><code>static std::vector&lt; bool &gt; threshold_particle_normals(\n    std::vector&lt; double &gt; angles,\n    double max_angle_degrees\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluation.html#function-compute_particle_normals","title":"function compute_particle_normals","text":"<pre><code>static Eigen::MatrixXd compute_particle_normals(\n    const Eigen::MatrixXd &amp; particles,\n    std::vector&lt; std::shared_ptr&lt; Surface &gt; &gt; meshes\n)\n</code></pre> <p>Compute normals at particle positions. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html","title":"shapeworks::ParticleNormalEvaluationJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#public-signals","title":"Public Signals","text":"Name void result_ready(std::vector&lt; bool &gt; good_bad)"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#public-functions","title":"Public Functions","text":"Name ParticleNormalEvaluationJob(QSharedPointer&lt; Session &gt; session, double max_angle_degrees) virtual void run() overriderun the job virtual QString name() overrideget the name of the job std::vector&lt; bool &gt; get_good_bad()"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#signal-result_ready","title":"signal result_ready","text":"<pre><code>void result_ready(\n    std::vector&lt; bool &gt; good_bad\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#function-particlenormalevaluationjob","title":"function ParticleNormalEvaluationJob","text":"<pre><code>ParticleNormalEvaluationJob(\n    QSharedPointer&lt; Session &gt; session,\n    double max_angle_degrees\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleNormalEvaluationJob.html#function-get_good_bad","title":"function get_good_bad","text":"<pre><code>std::vector&lt; bool &gt; get_good_bad()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html","title":"shapeworks::ParticleRegionDomain","text":"<p>Inherits from shapeworks::ParticleDomain</p> <p>Inherited by shapeworks::ImageDomain&lt; T &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; ParticleRegionDomain &gt; Pointer typedef ParticleDomain::PointType PointType"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#public-functions","title":"Public Functions","text":"Name virtual bool ApplyConstraints(PointType &amp; p) const virtual const PointType &amp; GetUpperBound() const virtual const PointType &amp; GetLowerBound() const void SetUpperBound(const PointType _UpperBound) void SetLowerBound(const PointType _LowerBound) void SetRegion(const PointType &amp; lowerBound, const PointType &amp; upperBound)"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#protected-functions","title":"Protected Functions","text":"Name ParticleRegionDomain() virtual ~ParticleRegionDomain() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const bool IsInsideBuffer(const PointType &amp; p) const"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::ParticleDomain</p> Name using vnl_matrix_fixed&lt; float, 3, 3 &gt; GradNType using vnl_vector_fixed&lt; double, 3 &gt; VectorDoubleType using vnl_vector_fixed&lt; float, 3 &gt; VectorFloatType <p>Public Functions inherited from shapeworks::ParticleDomain</p> Name virtual PointType UpdateParticlePosition(const PointType &amp; point, int idx, VectorDoubleType &amp; update) const =0 virtual void InvalidateParticlePosition(int idx) const virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp; gradE, const PointType &amp; pos, int idx) const =0 virtual VectorFloatType SampleGradientAtPoint(const PointType &amp; point, int idx) const =0 virtual VectorFloatType SampleNormalAtPoint(const PointType &amp; point, int idx) const =0 virtual GradNType SampleGradNAtPoint(const PointType &amp; p, int idx) const =0 virtual double Distance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, VectorDoubleType * out_grad =nullptr) const virtual double SquaredDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b) const virtual bool IsWithinDistance(const PointType &amp; a, int idx_a, const PointType &amp; b, int idx_b, double test_dist, double &amp; distance) const virtual double GetCurvature(const PointType &amp; p, int idx) const =0 virtual double GetSurfaceMeanCurvature() const =0 virtual double GetSurfaceStdDevCurvature() const =0 virtual PointType GetZeroCrossingPoint() const =0 virtual double GetSurfaceArea() const =0 virtual PointType GetValidLocationNear(PointType p) const =0 virtual double GetMaxDiameter() const =0 virtual void DeleteImages() =0 virtual void DeletePartialDerivativeImages() =0 virtual void UpdateZeroCrossingPoint() =0 bool IsDomainFixed() const virtual shapeworks::DomainType GetDomainType() const =0 std::shared_ptr&lt; shapeworks::Constraints &gt; GetConstraints() const virtual PointType GetPositionAfterSplit(const PointType &amp; pt, const VectorDoubleType &amp; local_direction, const VectorDoubleType &amp; global_direction, double epsilon) const void SetDomainID(int id) void SetDomainName(std::string name) <p>Protected Functions inherited from shapeworks::ParticleDomain</p> Name ParticleDomain() virtual ~ParticleDomain() <p>Protected Attributes inherited from shapeworks::ParticleDomain</p> Name bool m_FixedDomain int m_DomainID std::string m_DomainName std::shared_ptr&lt; shapeworks::Constraints &gt; constraints"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ParticleRegionDomain::Pointer =  std::shared_ptr&lt;ParticleRegionDomain&gt;;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef ParticleDomain::PointType shapeworks::ParticleRegionDomain::PointType;\n</code></pre> <p>Point type used to store particle locations. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-applyconstraints","title":"function ApplyConstraints","text":"<pre><code>inline virtual bool ApplyConstraints(\n    PointType &amp; p\n) const\n</code></pre> <p>Apply any constraints to the given point location. This method may, for example, implement boundary conditions or restrict points to lie on a surface. This function will clip the point to the boundaries. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-getupperbound","title":"function GetUpperBound","text":"<pre><code>inline virtual const PointType &amp; GetUpperBound() const\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetUpperBound</p> <p>Gets the maximum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-getlowerbound","title":"function GetLowerBound","text":"<pre><code>inline virtual const PointType &amp; GetLowerBound() const\n</code></pre> <p>Reimplements: shapeworks::ParticleDomain::GetLowerBound</p> <p>Gets the minimum x, y, z values of the bounding box for the domain. This is used for setting up the PowerOfTwoPointTree. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-setupperbound","title":"function SetUpperBound","text":"<pre><code>inline void SetUpperBound(\n    const PointType _UpperBound\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-setlowerbound","title":"function SetLowerBound","text":"<pre><code>inline void SetLowerBound(\n    const PointType _LowerBound\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-setregion","title":"function SetRegion","text":"<pre><code>inline void SetRegion(\n    const PointType &amp; lowerBound,\n    const PointType &amp; upperBound\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-particleregiondomain","title":"function ParticleRegionDomain","text":"<pre><code>inline ParticleRegionDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-particleregiondomain_1","title":"function ~ParticleRegionDomain","text":"<pre><code>inline virtual ~ParticleRegionDomain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleRegionDomain.html#function-isinsidebuffer","title":"function IsInsideBuffer","text":"<pre><code>inline bool IsInsideBuffer(\n    const PointType &amp; p\n) const\n</code></pre> <p>Check whether the point p may be sampled in this domain. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html","title":"shapeworks::ParticleShapeStatistics","text":"<p>More...</p> <p><code>#include &lt;ParticleShapeStatistics.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#public-functions","title":"Public Functions","text":"Name ParticleShapeStatistics() ParticleShapeStatistics(std::shared_ptr&lt; Project &gt; project) ~ParticleShapeStatistics() int do_pca(std::vector&lt; std::vector&lt; Point &gt; &gt; global_pts, int domainsPerShape =1) int do_pca(ParticleSystemEvaluation particleSystem, int domainsPerShape =1) int do_pca(std::shared_ptr&lt; Project &gt; project) int import_points(std::vector&lt; Eigen::VectorXd &gt; points, std::vector&lt; int &gt; group_ids)Loads a set of point files and pre-computes some statistics. void compute_multi_level_analysis_statistics(std::vector&lt; Eigen::VectorXd &gt; points, unsigned int dps)Loads a set of point files and pre-computes statistics for multi-level analysis. int compute_shape_dev_modes_for_mca()Compute shape variations for MLCA. int compute_relative_pose_modes_for_mca()Compute pose variations for MLCA. void set_num_particles_per_domain(const std::vector&lt; int &gt; &amp; num_particles_array)Set number of particles per domain/object (required for multi-level analysis) int read_point_files(const std::string &amp; s)Loads a set of point files and pre-computes some statistics. int write_csv_file(const std::string &amp; s)Writes a text file in comma-separated format. Suitable for reading into excel or R or Matlab for analysis. int compute_modes()Computes PCA modes from the set of correspondence mode positions. Requires that ReadPointFiles be called first. int get_num_modes() constReturn the number of modes. int principal_component_projections() Eigen::VectorXd project_new_sample(const Eigen::VectorXd &amp; new_sample)Projects a new sample into the PCA space defined by the original samples. int get_num_samples() constReturns the sample size. int get_group1_num_samples() const int get_group2_num_samples() const int get_num_dimensions() constReturns the number of dimensions (this is number of points times Dimension) int get_domains_per_shape()Return Number of objects present in Multi-Object Shape Structure. std::vector&lt; int &gt; NumberOfPointsArray()Returns Number of Particles Array. int GroupID(unsigned int i) constReturns the group ids. const std::vector&lt; int &gt; &amp; GroupID() const const Eigen::MatrixXd &amp; get_eigen_vectors() constReturns the eigenvectors/values. const std::vector&lt; double &gt; &amp; get_eigen_values() const const Eigen::MatrixXd &amp; get_eigenvectors_rel_pos()Returns the eigenvectors/eigenvalues for morphological and relative pose pariations of MLCA. const std::vector&lt; double &gt; &amp; get_eigenvalues_shape_dev() const Eigen::MatrixXd &amp; get_eigenvectors_shape_dev() const std::vector&lt; double &gt; &amp; get_eigenvalues_rel_pose() const Eigen::VectorXd &amp; get_mean_shape_dev()Returns the mean vector of within and between subspace. const Eigen::VectorXd &amp; get_mean_rel_pos() const Eigen::VectorXd &amp; get_mean() constReturns the mean shape. const Eigen::VectorXd &amp; get_group1_mean() const const Eigen::VectorXd &amp; get_group2_mean() const const Eigen::VectorXd &amp; get_group_difference() constReturns group2 - group1 mean. int compute_median_shape(const int ID) double l1_norm(unsigned int a, unsigned int b)Returns the euclidean L1 norm between shape a and b. Eigen::MatrixXd &amp; get_pca_loadings()Returns the component loadings. const std::vector&lt; double &gt; &amp; get_percent_variance_by_mode() const Eigen::VectorXd get_compactness(const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr) const Eigen::VectorXd get_specificity(const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr, const std::function&lt; bool()&gt; &amp; check_abort =nullptr) const Eigen::VectorXd get_generalization(const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr, const std::function&lt; bool(void)&gt; &amp; check_abort =nullptr) const Eigen::MatrixXd get_group1_matrix() const Eigen::MatrixXd get_group2_matrix() const Eigen::MatrixXd &amp; matrix() void set_num_values_per_particle(int value_per_particle)Set the number of values for each particle (e.g. 3 for x/y/z, 4 for x/y/z/scalar) void set_particle_to_surface_mode(bool value) bool get_particle_to_surface_mode() const void set_meshes(const std::vector&lt; Mesh &gt; &amp; meshes)Set the meshes for each sample (used for some evaluation metrics) void load_from_project(std::shared_ptr&lt; Project &gt; project) int simple_linear_regression(const std::vector&lt; double &gt; &amp; y, const std::vector&lt; double &gt; &amp; x, double &amp; a, double &amp; b)"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ParticleShapeStatistics;\n</code></pre> <p>This class computes various statistics for a set of correspondence positions and group ids. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-particleshapestatistics","title":"function ParticleShapeStatistics","text":"<pre><code>inline ParticleShapeStatistics()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-particleshapestatistics_1","title":"function ParticleShapeStatistics","text":"<pre><code>explicit ParticleShapeStatistics(\n    std::shared_ptr&lt; Project &gt; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-particleshapestatistics_2","title":"function ~ParticleShapeStatistics","text":"<pre><code>inline ~ParticleShapeStatistics()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-do_pca","title":"function do_pca","text":"<pre><code>int do_pca(\n    std::vector&lt; std::vector&lt; Point &gt; &gt; global_pts,\n    int domainsPerShape =1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-do_pca_1","title":"function do_pca","text":"<pre><code>int do_pca(\n    ParticleSystemEvaluation particleSystem,\n    int domainsPerShape =1\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-do_pca_2","title":"function do_pca","text":"<pre><code>int do_pca(\n    std::shared_ptr&lt; Project &gt; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-import_points","title":"function import_points","text":"<pre><code>int import_points(\n    std::vector&lt; Eigen::VectorXd &gt; points,\n    std::vector&lt; int &gt; group_ids\n)\n</code></pre> <p>Loads a set of point files and pre-computes some statistics. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-compute_multi_level_analysis_statistics","title":"function compute_multi_level_analysis_statistics","text":"<pre><code>void compute_multi_level_analysis_statistics(\n    std::vector&lt; Eigen::VectorXd &gt; points,\n    unsigned int dps\n)\n</code></pre> <p>Loads a set of point files and pre-computes statistics for multi-level analysis. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-compute_shape_dev_modes_for_mca","title":"function compute_shape_dev_modes_for_mca","text":"<pre><code>int compute_shape_dev_modes_for_mca()\n</code></pre> <p>Compute shape variations for MLCA. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-compute_relative_pose_modes_for_mca","title":"function compute_relative_pose_modes_for_mca","text":"<pre><code>int compute_relative_pose_modes_for_mca()\n</code></pre> <p>Compute pose variations for MLCA. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-set_num_particles_per_domain","title":"function set_num_particles_per_domain","text":"<pre><code>void set_num_particles_per_domain(\n    const std::vector&lt; int &gt; &amp; num_particles_array\n)\n</code></pre> <p>Set number of particles per domain/object (required for multi-level analysis) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-read_point_files","title":"function read_point_files","text":"<pre><code>int read_point_files(\n    const std::string &amp; s\n)\n</code></pre> <p>Loads a set of point files and pre-computes some statistics. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-write_csv_file","title":"function write_csv_file","text":"<pre><code>int write_csv_file(\n    const std::string &amp; s\n)\n</code></pre> <p>Writes a text file in comma-separated format. Suitable for reading into excel or R or Matlab for analysis. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-compute_modes","title":"function compute_modes","text":"<pre><code>int compute_modes()\n</code></pre> <p>Computes PCA modes from the set of correspondence mode positions. Requires that ReadPointFiles be called first. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_num_modes","title":"function get_num_modes","text":"<pre><code>int get_num_modes() const\n</code></pre> <p>Return the number of modes. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-principal_component_projections","title":"function principal_component_projections","text":"<pre><code>int principal_component_projections()\n</code></pre> <p>Computes the principal component loadings, or projections onto the principal componenent axes for each of the samples. ComputeModes must be called first. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-project_new_sample","title":"function project_new_sample","text":"<pre><code>Eigen::VectorXd project_new_sample(\n    const Eigen::VectorXd &amp; new_sample\n)\n</code></pre> <p>Projects a new sample into the PCA space defined by the original samples. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_num_samples","title":"function get_num_samples","text":"<pre><code>inline int get_num_samples() const\n</code></pre> <p>Returns the sample size. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group1_num_samples","title":"function get_group1_num_samples","text":"<pre><code>inline int get_group1_num_samples() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group2_num_samples","title":"function get_group2_num_samples","text":"<pre><code>inline int get_group2_num_samples() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_num_dimensions","title":"function get_num_dimensions","text":"<pre><code>inline int get_num_dimensions() const\n</code></pre> <p>Returns the number of dimensions (this is number of points times Dimension) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_domains_per_shape","title":"function get_domains_per_shape","text":"<pre><code>inline int get_domains_per_shape()\n</code></pre> <p>Return Number of objects present in Multi-Object Shape Structure. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-numberofpointsarray","title":"function NumberOfPointsArray","text":"<pre><code>inline std::vector&lt; int &gt; NumberOfPointsArray()\n</code></pre> <p>Returns Number of Particles Array. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-groupid","title":"function GroupID","text":"<pre><code>inline int GroupID(\n    unsigned int i\n) const\n</code></pre> <p>Returns the group ids. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-groupid_1","title":"function GroupID","text":"<pre><code>inline const std::vector&lt; int &gt; &amp; GroupID() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigen_vectors","title":"function get_eigen_vectors","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_eigen_vectors() const\n</code></pre> <p>Returns the eigenvectors/values. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigen_values","title":"function get_eigen_values","text":"<pre><code>inline const std::vector&lt; double &gt; &amp; get_eigen_values() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigenvectors_rel_pos","title":"function get_eigenvectors_rel_pos","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_eigenvectors_rel_pos()\n</code></pre> <p>Returns the eigenvectors/eigenvalues for morphological and relative pose pariations of MLCA. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigenvalues_shape_dev","title":"function get_eigenvalues_shape_dev","text":"<pre><code>inline const std::vector&lt; double &gt; &amp; get_eigenvalues_shape_dev()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigenvectors_shape_dev","title":"function get_eigenvectors_shape_dev","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_eigenvectors_shape_dev()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_eigenvalues_rel_pose","title":"function get_eigenvalues_rel_pose","text":"<pre><code>inline const std::vector&lt; double &gt; &amp; get_eigenvalues_rel_pose()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_mean_shape_dev","title":"function get_mean_shape_dev","text":"<pre><code>inline const Eigen::VectorXd &amp; get_mean_shape_dev()\n</code></pre> <p>Returns the mean vector of within and between subspace. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_mean_rel_pos","title":"function get_mean_rel_pos","text":"<pre><code>inline const Eigen::VectorXd &amp; get_mean_rel_pos()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_mean","title":"function get_mean","text":"<pre><code>inline const Eigen::VectorXd &amp; get_mean() const\n</code></pre> <p>Returns the mean shape. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group1_mean","title":"function get_group1_mean","text":"<pre><code>inline const Eigen::VectorXd &amp; get_group1_mean() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group2_mean","title":"function get_group2_mean","text":"<pre><code>inline const Eigen::VectorXd &amp; get_group2_mean() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group_difference","title":"function get_group_difference","text":"<pre><code>inline const Eigen::VectorXd &amp; get_group_difference() const\n</code></pre> <p>Returns group2 - group1 mean. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-compute_median_shape","title":"function compute_median_shape","text":"<pre><code>int compute_median_shape(\n    const int ID\n)\n</code></pre> <p>Returns the median shape for the set of shapes with Group ID equal to the integer argument. For example, compute_median_shape(0) returns the median shape for the set of shapes with m_groupIDs == 0. The median shape is defined as the shape with the minimum sum of Euclidean L1 norms to all other shapes in that group. Arguments passed to this function are set to the index number of the median shape for Group A and Group B, respectively.*/ </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-l1_norm","title":"function l1_norm","text":"<pre><code>double l1_norm(\n    unsigned int a,\n    unsigned int b\n)\n</code></pre> <p>Returns the euclidean L1 norm between shape a and b. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_pca_loadings","title":"function get_pca_loadings","text":"<pre><code>inline Eigen::MatrixXd &amp; get_pca_loadings()\n</code></pre> <p>Returns the component loadings. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_percent_variance_by_mode","title":"function get_percent_variance_by_mode","text":"<pre><code>inline const std::vector&lt; double &gt; &amp; get_percent_variance_by_mode() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_compactness","title":"function get_compactness","text":"<pre><code>Eigen::VectorXd get_compactness(\n    const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_specificity","title":"function get_specificity","text":"<pre><code>Eigen::VectorXd get_specificity(\n    const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr,\n    const std::function&lt; bool()&gt; &amp; check_abort =nullptr\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_generalization","title":"function get_generalization","text":"<pre><code>Eigen::VectorXd get_generalization(\n    const std::function&lt; void(float)&gt; &amp; progress_callback =nullptr,\n    const std::function&lt; bool(void)&gt; &amp; check_abort =nullptr\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group1_matrix","title":"function get_group1_matrix","text":"<pre><code>Eigen::MatrixXd get_group1_matrix() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_group2_matrix","title":"function get_group2_matrix","text":"<pre><code>Eigen::MatrixXd get_group2_matrix() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-matrix","title":"function matrix","text":"<pre><code>inline Eigen::MatrixXd &amp; matrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-set_num_values_per_particle","title":"function set_num_values_per_particle","text":"<pre><code>inline void set_num_values_per_particle(\n    int value_per_particle\n)\n</code></pre> <p>Set the number of values for each particle (e.g. 3 for x/y/z, 4 for x/y/z/scalar) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-set_particle_to_surface_mode","title":"function set_particle_to_surface_mode","text":"<pre><code>inline void set_particle_to_surface_mode(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-get_particle_to_surface_mode","title":"function get_particle_to_surface_mode","text":"<pre><code>inline bool get_particle_to_surface_mode() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-set_meshes","title":"function set_meshes","text":"<pre><code>inline void set_meshes(\n    const std::vector&lt; Mesh &gt; &amp; meshes\n)\n</code></pre> <p>Set the meshes for each sample (used for some evaluation metrics) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-load_from_project","title":"function load_from_project","text":"<pre><code>void load_from_project(\n    std::shared_ptr&lt; Project &gt; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleShapeStatistics.html#function-simple_linear_regression","title":"function simple_linear_regression","text":"<pre><code>static int simple_linear_regression(\n    const std::vector&lt; double &gt; &amp; y,\n    const std::vector&lt; double &gt; &amp; x,\n    double &amp; a,\n    double &amp; b\n)\n</code></pre> <p>Computes a simple linear regression of the first list of values with respect to the second y=a + bx. Returns the estimated parameters a &amp; b. Returns 0 on success and -1 on fail.*/ </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html","title":"shapeworks::ParticleSystem","text":"<p>A facade class managing interactions with a particle system.  More...</p> <p><code>#include &lt;ParticleSystem.h&gt;</code></p> <p>Inherits from itk::DataObject</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-types","title":"Public Types","text":"Name typedef ParticleSystem Self typedef DataObject Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer using shapeworks::ParticleDomain DomainType typedef itk::Point&lt; double, VDimension &gt; PointType typedef GenericContainer&lt; PointType &gt; PointContainerType typedef vnl_matrix_fixed&lt; double, VDimension+1, VDimension+1 &gt; TransformType typedef vnl_vector_fixed&lt; double, VDimension &gt; VectorType typedef vnl_matrix&lt; double &gt; VnlMatrixType using std::vector&lt; ParticlePointIndexPair &gt; PointVectorType"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(ParticleSystem , itk::DataObject ) itkStaticConstMacro(Dimension , unsigned int , VDimension ) void RegisterObserver(Observer * attr) void SynchronizePositions() unsigned long int GetNumberOfParticles(unsigned int d =0) const const PointType &amp; AddPosition(const PointType &amp; , unsigned int d =0) const PointType &amp; SetPosition(const PointType &amp; , unsigned long int k, unsigned int d =0) void RemovePosition(unsigned long int k, unsigned int d =0) PointType &amp; GetPosition(unsigned long int k, unsigned int d =0) const PointType &amp; GetPosition(unsigned long int k, unsigned int d =0) const PointType GetTransformedPosition(unsigned long int k, unsigned int d =0) const PointType GetPrefixTransformedPosition(unsigned long int k, unsigned int d =0) const void SplitAllParticles(double epsilon) void SplitParticle(double epsilon, unsigned int idx, unsigned int d =0) void AdvancedAllParticleSplitting(double epsilon, unsigned int domains_per_shape, unsigned int dom_to_process) void PrintParticleSystem() std::shared_ptr&lt; ParticleNeighborhood &gt; GetNeighborhood(unsigned int k) constGet the neighborhood object associated with domain k. PointVectorType FindNeighborhoodPoints(const PointType &amp; p, int idx, double r, unsigned int d =0) const PointVectorType FindNeighborhoodPoints(const PointType &amp; p, int idx, std::vector&lt; double &gt; &amp; w, std::vector&lt; double &gt; &amp; distances, double r, unsigned int d =0) const PointVectorType FindNeighborhoodPoints(const PointType &amp; p, int idx, std::vector&lt; double &gt; &amp; w, double r, unsigned int d =0) const PointVectorType FindNeighborhoodPoints(unsigned int idx, double r, unsigned int d =0) const PointVectorType FindNeighborhoodPoints(unsigned int idx, std::vector&lt; double &gt; &amp; w, std::vector&lt; double &gt; &amp; distances, double r, unsigned int d =0) const PointVectorType FindNeighborhoodPoints(unsigned int idx, std::vector&lt; double &gt; &amp; w, double r, unsigned int d =0) const void AddDomain(DomainType::Pointer input) std::vector&lt; DomainType::Pointer &gt;::const_iterator GetDomainsBegin() const std::vector&lt; DomainType::Pointer &gt;::const_iterator GetDomainsEnd() const DomainType * GetDomain(unsigned int i) DomainType * GetDomain() const DomainType * GetDomain(unsigned int i) const const DomainType * GetDomain() const unsigned int GetNumberOfDomains() const void SetTransform(unsigned int i, const TransformType &amp; ) void SetTransform(const TransformType &amp; p) void SetPrefixTransform(unsigned int i, const TransformType &amp; ) void SetPrefixTransform(const TransformType &amp; p) std::vector&lt; TransformType &gt;::const_iterator GetTransformsBegin() const std::vector&lt; TransformType &gt;::const_iterator GetTransformsEnd() const const TransformType &amp; GetTransform(unsigned int i) const const TransformType &amp; GetTransform() const TransformType GetTransform(unsigned int i) TransformType GetTransform() const TransformType &amp; GetPrefixTransform(unsigned int i) const const TransformType &amp; GetPrefixTransform() const TransformType GetPrefixTransform(unsigned int i) TransformType GetPrefixTransform() std::vector&lt; TransformType &gt;::const_iterator GetInverseTransformsBegin() const std::vector&lt; TransformType &gt;::const_iterator GetInverseTransformsEnd() const const TransformType &amp; GetInverseTransform(unsigned int i) const const TransformType &amp; GetInverseTransform() const const TransformType &amp; GetInversePrefixTransform(unsigned int i) const const TransformType &amp; GetInversePrefixTransform() const const std::vector&lt; PointContainerType::Pointer &gt; &amp; GetPositions() const const PointContainerType::Pointer &amp; GetPositions(unsigned int d) const void AddPositionList(const std::vector&lt; PointType &gt; &amp; , unsigned int d =0) PointType TransformPoint(const PointType &amp; , const TransformType &amp; ) const VectorType TransformVector(const VectorType &amp; , const TransformType &amp; ) const VnlMatrixType TransformNormalDerivative(const VnlMatrixType &amp; , const TransformType &amp; ) const TransformType InvertTransform(const TransformType &amp; T) const void FlagDomain(unsigned int i) void UnflagDomain(unsigned int i) bool GetDomainFlag(unsigned int i) const const std::vector&lt; bool &gt; &amp; GetDomainFlags() const void SetDomainFlags() void ResetDomainFlags() void SetFixedParticleFlag(unsigned int d, unsigned int i) void ResetFixedParticleFlag(unsigned int d, unsigned int i) bool GetFixedParticleFlag(unsigned int d, unsigned int i) const void ResetFixedParticleFlags() void SetDomainsPerShape(unsigned int num) unsigned int GetDomainsPerShape() const void SetNumberOfDomains(unsigned int ) double ComputeMaxDistNearestNeighbors(size_t dom) void SetFieldAttributes(const std::vector&lt; std::string &gt; &amp; field_attributes) const std::vector&lt; std::string &gt; &amp; GetFieldAttributes() const"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#protected-functions","title":"Protected Functions","text":"Name ParticleSystem() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const virtual ~ParticleSystem() TransformType &amp; GetInverseTransform(unsigned int i) TransformType &amp; GetInverseTransform() TransformType &amp; GetInversePrefixTransform(unsigned int i) TransformType &amp; GetInversePrefixTransform()"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-attributes","title":"Public Attributes","text":"Name constexpr int VDimension"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ParticleSystem;\n</code></pre> <p>A facade class managing interactions with a particle system. </p> <p>A particle system consists of a set of particle locations and domains in which those locations are defined. For example, a particle system may simply be a set of points in 3D Euclidean space that are constrained to a specified bounding box. A more complex example is a set of 3D points constrained to a given surface. The itkParticleSystem class is also designed to manage multiple sets of points across multiple domains. For example, one may create a system of dozens of point sets that are each defined in different spaces. The itkParticleSystem class can also maintain a set of transformations associated with each domain that map that particular domain into another coordinate frame, for example, a common coordinate frame. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ParticleSystem shapeworks::ParticleSystem::Self;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef DataObject shapeworks::ParticleSystem::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::ParticleSystem::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::ParticleSystem::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::ParticleSystem::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#using-domaintype","title":"using DomainType","text":"<pre><code>using shapeworks::ParticleSystem::DomainType =  shapeworks::ParticleDomain;\n</code></pre> <p>Define the base domain type. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef itk::Point&lt;double, VDimension&gt; shapeworks::ParticleSystem::PointType;\n</code></pre> <p>Point type used to store particle locations. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-pointcontainertype","title":"typedef PointContainerType","text":"<pre><code>typedef GenericContainer&lt;PointType&gt; shapeworks::ParticleSystem::PointContainerType;\n</code></pre> <p>Point container type. One is associated with each domain. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-transformtype","title":"typedef TransformType","text":"<pre><code>typedef vnl_matrix_fixed&lt;double, VDimension + 1, VDimension + 1&gt; shapeworks::ParticleSystem::TransformType;\n</code></pre> <p>Defines a transform class type. One is associated with each domain. Transforms are affine for simplicity. This could be extended by using the itk::Transform base type so that a variety of transform types may be used. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>typedef vnl_vector_fixed&lt;double, VDimension&gt; shapeworks::ParticleSystem::VectorType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#typedef-vnlmatrixtype","title":"typedef VnlMatrixType","text":"<pre><code>typedef vnl_matrix&lt;double&gt; shapeworks::ParticleSystem::VnlMatrixType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#using-pointvectortype","title":"using PointVectorType","text":"<pre><code>using shapeworks::ParticleSystem::PointVectorType =  std::vector&lt;ParticlePointIndexPair&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    ParticleSystem ,\n    itk::DataObject \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-itkstaticconstmacro","title":"function itkStaticConstMacro","text":"<pre><code>itkStaticConstMacro(\n    Dimension ,\n    unsigned int ,\n    VDimension \n)\n</code></pre> <p>Dimensionality of the domain of the particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-registerobserver","title":"function RegisterObserver","text":"<pre><code>void RegisterObserver(\n    Observer * attr\n)\n</code></pre> <p>Register an attribute object with this particle system. This action adds the attribute object as an observer for the particle system so that it will receive published updates. For example, a gradient attribute object may need to know when particle positions have changed so that it can update its internal state appropriately (e.g. precompute a gradient that corresponds to the new particle position). Internally, this method manages registering the appropriate itk::Command and itk::Object as an observer of this itk::Object (AddObserver). Relevant state information is passed to objects in particle events. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-synchronizepositions","title":"function SynchronizePositions","text":"<pre><code>inline void SynchronizePositions()\n</code></pre> <p>Invokes the set event on all particle positions, resetting them to their current value. This method may be called to synchronize positional information among various observers which may have gone out of sync. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getnumberofparticles","title":"function GetNumberOfParticles","text":"<pre><code>inline unsigned long int GetNumberOfParticles(\n    unsigned int d =0\n) const\n</code></pre> <p>Returns the number of particles in domain k. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-addposition","title":"function AddPosition","text":"<pre><code>const PointType &amp; AddPosition(\n    const PointType &amp; ,\n    unsigned int d =0\n)\n</code></pre> <p>Add/Set/Remove a single particle position. The actual position added or set will be returned. If, for example, the domain imposes any constraints on this location (e.g. out-of-bounds, projection onto a surface), then the method returns the location after constraints are applied. Both the Add and Set methods require a domain index. If unspecified, the domain index is zero. The Set method requires a specific particle index. If the given index does not exist, an exception is thrown. Set is intended to be used for moving particles. The SetTransformedPosition sets the position using a Point transformed by the m_Transform associated with the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setposition","title":"function SetPosition","text":"<pre><code>const PointType &amp; SetPosition(\n    const PointType &amp; ,\n    unsigned long int k,\n    unsigned int d =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-removeposition","title":"function RemovePosition","text":"<pre><code>void RemovePosition(\n    unsigned long int k,\n    unsigned int d =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getposition","title":"function GetPosition","text":"<pre><code>inline PointType &amp; GetPosition(\n    unsigned long int k,\n    unsigned int d =0\n)\n</code></pre> <p>Return a position with index k from domain d. Note the order in which the 2 integers must be specified! The domain number is specified second and the position index within the domain is specified first. Note that the domain index may be omitted if the particle system only contains a single domain. GetTransformedPosition returns the position premultiplied by the transform matrix for the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getposition_1","title":"function GetPosition","text":"<pre><code>inline const PointType &amp; GetPosition(\n    unsigned long int k,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransformedposition","title":"function GetTransformedPosition","text":"<pre><code>inline PointType GetTransformedPosition(\n    unsigned long int k,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getprefixtransformedposition","title":"function GetPrefixTransformedPosition","text":"<pre><code>inline PointType GetPrefixTransformedPosition(\n    unsigned long int k,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-splitallparticles","title":"function SplitAllParticles","text":"<pre><code>void SplitAllParticles(\n    double epsilon\n)\n</code></pre> <p>Doubles the number of particles of the system by splitting each particle into 2 particles. Each new particle position is added to the system at a random epsilon distance on the surface from the original particle. The new particles are added using the AddPosition method, so all appropriate callbacks are invoked. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-splitparticle","title":"function SplitParticle","text":"<pre><code>void SplitParticle(\n    double epsilon,\n    unsigned int idx,\n    unsigned int d =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-advancedallparticlesplitting","title":"function AdvancedAllParticleSplitting","text":"<pre><code>void AdvancedAllParticleSplitting(\n    double epsilon,\n    unsigned int domains_per_shape,\n    unsigned int dom_to_process\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-printparticlesystem","title":"function PrintParticleSystem","text":"<pre><code>void PrintParticleSystem()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getneighborhood","title":"function GetNeighborhood","text":"<pre><code>inline std::shared_ptr&lt; ParticleNeighborhood &gt; GetNeighborhood(\n    unsigned int k\n) const\n</code></pre> <p>Get the neighborhood object associated with domain k. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    const PointType &amp; p,\n    int idx,\n    double r,\n    unsigned int d =0\n) const\n</code></pre> <p>Return the neighborhood of points with radius r around point p in domain k. This is just a convenience method to avoid exposing the underlying Neighborhood objects. FindTransformedNeighborhoodPoints returns the list with all points transformed by the transform associated with the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints_1","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    const PointType &amp; p,\n    int idx,\n    std::vector&lt; double &gt; &amp; w,\n    std::vector&lt; double &gt; &amp; distances,\n    double r,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints_2","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    const PointType &amp; p,\n    int idx,\n    std::vector&lt; double &gt; &amp; w,\n    double r,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints_3","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    unsigned int idx,\n    double r,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints_4","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    unsigned int idx,\n    std::vector&lt; double &gt; &amp; w,\n    std::vector&lt; double &gt; &amp; distances,\n    double r,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-findneighborhoodpoints_5","title":"function FindNeighborhoodPoints","text":"<pre><code>inline PointVectorType FindNeighborhoodPoints(\n    unsigned int idx,\n    std::vector&lt; double &gt; &amp; w,\n    double r,\n    unsigned int d =0\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-adddomain","title":"function AddDomain","text":"<pre><code>void AddDomain(\n    DomainType::Pointer input\n)\n</code></pre> <p>Add a domain to the particle system. This method also allocates space for a list of positions that are contained within the domain, and a default neighborhood calculator. The final, optional argument indicates the calling thread id. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomainsbegin","title":"function GetDomainsBegin","text":"<pre><code>inline std::vector&lt; DomainType::Pointer &gt;::const_iterator GetDomainsBegin() const\n</code></pre> <p>Return an iterator that points to the first element of the list of the domains. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomainsend","title":"function GetDomainsEnd","text":"<pre><code>inline std::vector&lt; DomainType::Pointer &gt;::const_iterator GetDomainsEnd() const\n</code></pre> <p>Return an iterator that points one position past the last element of the list of the domains. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomain","title":"function GetDomain","text":"<pre><code>inline DomainType * GetDomain(\n    unsigned int i\n)\n</code></pre> <p>Return the i'th domain object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomain_1","title":"function GetDomain","text":"<pre><code>inline DomainType * GetDomain()\n</code></pre> <p>API for the single domain case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomain_2","title":"function GetDomain","text":"<pre><code>inline const DomainType * GetDomain(\n    unsigned int i\n) const\n</code></pre> <p>Return the i'th domain object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomain_3","title":"function GetDomain","text":"<pre><code>inline const DomainType * GetDomain() const\n</code></pre> <p>API for the single domain case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getnumberofdomains","title":"function GetNumberOfDomains","text":"<pre><code>inline unsigned int GetNumberOfDomains() const\n</code></pre> <p>Returns the number of domains contained in the particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-settransform","title":"function SetTransform","text":"<pre><code>void SetTransform(\n    unsigned int i,\n    const TransformType &amp; \n)\n</code></pre> <p>Set the transform associated with domain i. This method will also compute and set the corresponding inverse transform if possible. If the inverse transform cannot be computed, the exception is quietly handled by this method and an identity transform is set in its place. The calling program is responsible for knowing when an inverse transform cannot be computed. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-settransform_1","title":"function SetTransform","text":"<pre><code>inline void SetTransform(\n    const TransformType &amp; p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setprefixtransform","title":"function SetPrefixTransform","text":"<pre><code>void SetPrefixTransform(\n    unsigned int i,\n    const TransformType &amp; \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setprefixtransform_1","title":"function SetPrefixTransform","text":"<pre><code>inline void SetPrefixTransform(\n    const TransformType &amp; p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransformsbegin","title":"function GetTransformsBegin","text":"<pre><code>inline std::vector&lt; TransformType &gt;::const_iterator GetTransformsBegin() const\n</code></pre> <p>Return an iterator that points to the first element of the list of the transforms. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransformsend","title":"function GetTransformsEnd","text":"<pre><code>inline std::vector&lt; TransformType &gt;::const_iterator GetTransformsEnd() const\n</code></pre> <p>Return an iterator that points one position past the last element of the list of the transforms. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransform","title":"function GetTransform","text":"<pre><code>inline const TransformType &amp; GetTransform(\n    unsigned int i\n) const\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransform_1","title":"function GetTransform","text":"<pre><code>inline const TransformType &amp; GetTransform() const\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransform_2","title":"function GetTransform","text":"<pre><code>inline TransformType GetTransform(\n    unsigned int i\n)\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-gettransform_3","title":"function GetTransform","text":"<pre><code>inline TransformType GetTransform()\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getprefixtransform","title":"function GetPrefixTransform","text":"<pre><code>inline const TransformType &amp; GetPrefixTransform(\n    unsigned int i\n) const\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getprefixtransform_1","title":"function GetPrefixTransform","text":"<pre><code>inline const TransformType &amp; GetPrefixTransform() const\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getprefixtransform_2","title":"function GetPrefixTransform","text":"<pre><code>inline TransformType GetPrefixTransform(\n    unsigned int i\n)\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getprefixtransform_3","title":"function GetPrefixTransform","text":"<pre><code>inline TransformType GetPrefixTransform()\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransformsbegin","title":"function GetInverseTransformsBegin","text":"<pre><code>inline std::vector&lt; TransformType &gt;::const_iterator GetInverseTransformsBegin() const\n</code></pre> <p>Return an iterator that points to the first element of the list of the inverse transforms. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransformsend","title":"function GetInverseTransformsEnd","text":"<pre><code>inline std::vector&lt; TransformType &gt;::const_iterator GetInverseTransformsEnd() const\n</code></pre> <p>Return an iterator that points one position past the last element of the list of the transforms. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransform","title":"function GetInverseTransform","text":"<pre><code>inline const TransformType &amp; GetInverseTransform(\n    unsigned int i\n) const\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransform_1","title":"function GetInverseTransform","text":"<pre><code>inline const TransformType &amp; GetInverseTransform() const\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinverseprefixtransform","title":"function GetInversePrefixTransform","text":"<pre><code>inline const TransformType &amp; GetInversePrefixTransform(\n    unsigned int i\n) const\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinverseprefixtransform_1","title":"function GetInversePrefixTransform","text":"<pre><code>inline const TransformType &amp; GetInversePrefixTransform() const\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getpositions","title":"function GetPositions","text":"<pre><code>inline const std::vector&lt; PointContainerType::Pointer &gt; &amp; GetPositions() const\n</code></pre> <p>Return the array of particle positions. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getpositions_1","title":"function GetPositions","text":"<pre><code>inline const PointContainerType::Pointer &amp; GetPositions(\n    unsigned int d\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-addpositionlist","title":"function AddPositionList","text":"<pre><code>void AddPositionList(\n    const std::vector&lt; PointType &gt; &amp; ,\n    unsigned int d =0\n)\n</code></pre> <p>Adds a list of points to the specified domain. The arguments are the std::vector of points and the domain number. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-transformpoint","title":"function TransformPoint","text":"<pre><code>PointType TransformPoint(\n    const PointType &amp; ,\n    const TransformType &amp; \n) const\n</code></pre> <p>Transforms a point using the given transform. NOTE: Scaling is not currently implemented. (This method may be converted to virtual and overridden if tranform type is generalized.) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-transformvector","title":"function TransformVector","text":"<pre><code>VectorType TransformVector(\n    const VectorType &amp; ,\n    const TransformType &amp; \n) const\n</code></pre> <p>Transforms a vector using the given transform. Only the rotational part of the transform is applied. NOTE: Scaling is not currently supported. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-transformnormalderivative","title":"function TransformNormalDerivative","text":"<pre><code>VnlMatrixType TransformNormalDerivative(\n    const VnlMatrixType &amp; ,\n    const TransformType &amp; \n) const\n</code></pre> <p>Transforms the derivative of normals to new space. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-inverttransform","title":"function InvertTransform","text":"<pre><code>inline TransformType InvertTransform(\n    const TransformType &amp; T\n) const\n</code></pre> <p>Returns the inverse of a transformation matrix. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-flagdomain","title":"function FlagDomain","text":"<pre><code>inline void FlagDomain(\n    unsigned int i\n)\n</code></pre> <p>Flag/Unflag a domain. Flagging a domain has different meanings according to the application using this particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-unflagdomain","title":"function UnflagDomain","text":"<pre><code>inline void UnflagDomain(\n    unsigned int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomainflag","title":"function GetDomainFlag","text":"<pre><code>inline bool GetDomainFlag(\n    unsigned int i\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomainflags","title":"function GetDomainFlags","text":"<pre><code>inline const std::vector&lt; bool &gt; &amp; GetDomainFlags() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setdomainflags","title":"function SetDomainFlags","text":"<pre><code>inline void SetDomainFlags()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-resetdomainflags","title":"function ResetDomainFlags","text":"<pre><code>inline void ResetDomainFlags()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setfixedparticleflag","title":"function SetFixedParticleFlag","text":"<pre><code>inline void SetFixedParticleFlag(\n    unsigned int d,\n    unsigned int i\n)\n</code></pre> <p>The following methods provide functionality for specifying particle indices that are fixed landmarks. SetPosition() calls to these particle indices will silently fail. For simplicity, only one list of indices is maintained for all dimensions. If particle index n is flagged, for example, then particle index n in all domains is fixed. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-resetfixedparticleflag","title":"function ResetFixedParticleFlag","text":"<pre><code>inline void ResetFixedParticleFlag(\n    unsigned int d,\n    unsigned int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getfixedparticleflag","title":"function GetFixedParticleFlag","text":"<pre><code>inline bool GetFixedParticleFlag(\n    unsigned int d,\n    unsigned int i\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-resetfixedparticleflags","title":"function ResetFixedParticleFlags","text":"<pre><code>inline void ResetFixedParticleFlags()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    unsigned int num\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline unsigned int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setnumberofdomains","title":"function SetNumberOfDomains","text":"<pre><code>void SetNumberOfDomains(\n    unsigned int \n)\n</code></pre> <p>Set the number of domains. This method modifies the size of the m_Domains, m_Positions, and m_Transform lists. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-computemaxdistnearestneighbors","title":"function ComputeMaxDistNearestNeighbors","text":"<pre><code>double ComputeMaxDistNearestNeighbors(\n    size_t dom\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-setfieldattributes","title":"function SetFieldAttributes","text":"<pre><code>inline void SetFieldAttributes(\n    const std::vector&lt; std::string &gt; &amp; field_attributes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getfieldattributes","title":"function GetFieldAttributes","text":"<pre><code>inline const std::vector&lt; std::string &gt; &amp; GetFieldAttributes() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-particlesystem","title":"function ParticleSystem","text":"<pre><code>ParticleSystem()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-particlesystem_1","title":"function ~ParticleSystem","text":"<pre><code>inline virtual ~ParticleSystem()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransform_2","title":"function GetInverseTransform","text":"<pre><code>inline TransformType &amp; GetInverseTransform(\n    unsigned int i\n)\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinversetransform_3","title":"function GetInverseTransform","text":"<pre><code>inline TransformType &amp; GetInverseTransform()\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinverseprefixtransform_2","title":"function GetInversePrefixTransform","text":"<pre><code>inline TransformType &amp; GetInversePrefixTransform(\n    unsigned int i\n)\n</code></pre> <p>Return the i'th transform object. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#function-getinverseprefixtransform_3","title":"function GetInversePrefixTransform","text":"<pre><code>inline TransformType &amp; GetInversePrefixTransform()\n</code></pre> <p>API for the single transform case. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystem.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr int VDimension = 3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemCommand.html","title":"shapeworks::ParticleSystemCommand","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemCommand.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemCommand.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemCommand.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystemCommand.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html","title":"shapeworks::ParticleSystemEvaluation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#public-functions","title":"Public Functions","text":"Name ParticleSystemEvaluation(const std::vector&lt; std::string &gt; &amp; paths)Initialize particle system from a list of paths to particle files. ParticleSystemEvaluation(const Eigen::MatrixXd &amp; matrix, int num_values_per_particle =3)Initialize particle system from eigen matrix (rows=dimensions, cols=num_samples) const Eigen::MatrixXd &amp; get_matrix() constGet the matrix representation of the particle system. int get_num_values_per_particle() constGet the number of values for each particle (e.g. 3 for x/y/z, 4 for x/y/z/scalar) const std::vector&lt; std::string &gt; &amp; get_paths() constGet the paths to the particle files. int num_samples() constNumber of samples. int num_dims() constDimensions (e.g. x/y/z * number of particles) bool exact_compare(const ParticleSystemEvaluation &amp; other) constPerform an exact comparison of two particle systems. bool evaluation_compare(const ParticleSystemEvaluation &amp; other) constPerform an evaluation comparison of two particle systems. void set_meshes(const std::vector&lt; Mesh &gt; &amp; meshes)Set the meshes for each sample (used for some evaluation metrics) const std::vector&lt; Mesh &gt; &amp; get_meshes() constGet the meshes for each sample. bool read_particle_file(std::string filename, Eigen::VectorXd &amp; points)Read a particle file into an Eigen vector."},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#friends","title":"Friends","text":"Name struct SharedCommandData"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-particlesystemevaluation","title":"function ParticleSystemEvaluation","text":"<pre><code>explicit ParticleSystemEvaluation(\n    const std::vector&lt; std::string &gt; &amp; paths\n)\n</code></pre> <p>Initialize particle system from a list of paths to particle files. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-particlesystemevaluation_1","title":"function ParticleSystemEvaluation","text":"<pre><code>explicit ParticleSystemEvaluation(\n    const Eigen::MatrixXd &amp; matrix,\n    int num_values_per_particle =3\n)\n</code></pre> <p>Initialize particle system from eigen matrix (rows=dimensions, cols=num_samples) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-get_matrix","title":"function get_matrix","text":"<pre><code>inline const Eigen::MatrixXd &amp; get_matrix() const\n</code></pre> <p>Get the matrix representation of the particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-get_num_values_per_particle","title":"function get_num_values_per_particle","text":"<pre><code>inline int get_num_values_per_particle() const\n</code></pre> <p>Get the number of values for each particle (e.g. 3 for x/y/z, 4 for x/y/z/scalar) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-get_paths","title":"function get_paths","text":"<pre><code>inline const std::vector&lt; std::string &gt; &amp; get_paths() const\n</code></pre> <p>Get the paths to the particle files. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-num_samples","title":"function num_samples","text":"<pre><code>inline int num_samples() const\n</code></pre> <p>Number of samples. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-num_dims","title":"function num_dims","text":"<pre><code>inline int num_dims() const\n</code></pre> <p>Dimensions (e.g. x/y/z * number of particles) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-exact_compare","title":"function exact_compare","text":"<pre><code>bool exact_compare(\n    const ParticleSystemEvaluation &amp; other\n) const\n</code></pre> <p>Perform an exact comparison of two particle systems. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-evaluation_compare","title":"function evaluation_compare","text":"<pre><code>bool evaluation_compare(\n    const ParticleSystemEvaluation &amp; other\n) const\n</code></pre> <p>Perform an evaluation comparison of two particle systems. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-set_meshes","title":"function set_meshes","text":"<pre><code>void set_meshes(\n    const std::vector&lt; Mesh &gt; &amp; meshes\n)\n</code></pre> <p>Set the meshes for each sample (used for some evaluation metrics) </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-get_meshes","title":"function get_meshes","text":"<pre><code>inline const std::vector&lt; Mesh &gt; &amp; get_meshes() const\n</code></pre> <p>Get the meshes for each sample. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#function-read_particle_file","title":"function read_particle_file","text":"<pre><code>static bool read_particle_file(\n    std::string filename,\n    Eigen::VectorXd &amp; points\n)\n</code></pre> <p>Read a particle file into an Eigen vector. </p>"},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#friends_1","title":"Friends","text":""},{"location":"api/Classes/classshapeworks_1_1ParticleSystemEvaluation.html#friend-sharedcommanddata","title":"friend SharedCommandData","text":"<pre><code>friend struct SharedCommandData(\n    SharedCommandData \n);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Particles.html","title":"shapeworks::Particles","text":"<p>Representation of correspondence points for a shape including multiple domains.  More...</p> <p><code>#include &lt;Particles.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#public-functions","title":"Public Functions","text":"Name Particles() =default void set_local_particles(int domain, const std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; particles) void set_world_particles(int domain, const std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; particles) void set_local_particles(int domain, Eigen::VectorXd particles) void set_world_particles(int domain, Eigen::VectorXd particles) std::vector&lt; Eigen::VectorXd &gt; get_local_particles() const std::vector&lt; Eigen::VectorXd &gt; get_world_particles() const Eigen::VectorXd get_local_particles(int domain) Eigen::VectorXd get_world_particles(int domain) Eigen::VectorXd get_raw_world_particles(int domain)Get untransformed original world particles from optimizer. Eigen::VectorXd get_combined_local_particles() const Eigen::VectorXd get_combined_global_particles() const void set_combined_global_particles(const Eigen::VectorXd &amp; particles) std::vector&lt; itk::Point&lt; double &gt; &gt; get_local_points(int domain) std::vector&lt; itk::Point&lt; double &gt; &gt; get_world_points(int domain) int get_domain_for_combined_id(int id)Return which domain a particle belongs to when they are concatenated together. void set_transform(vtkSmartPointer&lt; vtkTransform &gt; transform) void set_procrustes_transforms(const std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; &amp; transforms) void set_alignment_type(int alignment) Eigen::VectorXd get_difference_vectors(const Particles &amp; other) const int get_number_of_domains() int get_total_number_of_particles() void save_particles_file(std::string filename, const Eigen::VectorXd &amp; points)"},{"location":"api/Classes/classshapeworks_1_1Particles.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Particles;\n</code></pre> <p>Representation of correspondence points for a shape including multiple domains. </p> <p>The StudioParticles class encapsulates the correspondence points for a shape, including multiple domains, local and global points </p>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-particles","title":"function Particles","text":"<pre><code>Particles() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_local_particles","title":"function set_local_particles","text":"<pre><code>void set_local_particles(\n    int domain,\n    const std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_world_particles","title":"function set_world_particles","text":"<pre><code>void set_world_particles(\n    int domain,\n    const std::vector&lt; itk::Point&lt; double &gt; &gt; &amp; particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_local_particles_1","title":"function set_local_particles","text":"<pre><code>void set_local_particles(\n    int domain,\n    Eigen::VectorXd particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_world_particles_1","title":"function set_world_particles","text":"<pre><code>void set_world_particles(\n    int domain,\n    Eigen::VectorXd particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_local_particles","title":"function get_local_particles","text":"<pre><code>std::vector&lt; Eigen::VectorXd &gt; get_local_particles() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_world_particles","title":"function get_world_particles","text":"<pre><code>std::vector&lt; Eigen::VectorXd &gt; get_world_particles() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_local_particles_1","title":"function get_local_particles","text":"<pre><code>Eigen::VectorXd get_local_particles(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_world_particles_1","title":"function get_world_particles","text":"<pre><code>Eigen::VectorXd get_world_particles(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_raw_world_particles","title":"function get_raw_world_particles","text":"<pre><code>Eigen::VectorXd get_raw_world_particles(\n    int domain\n)\n</code></pre> <p>Get untransformed original world particles from optimizer. </p>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_combined_local_particles","title":"function get_combined_local_particles","text":"<pre><code>Eigen::VectorXd get_combined_local_particles() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_combined_global_particles","title":"function get_combined_global_particles","text":"<pre><code>Eigen::VectorXd get_combined_global_particles() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_combined_global_particles","title":"function set_combined_global_particles","text":"<pre><code>void set_combined_global_particles(\n    const Eigen::VectorXd &amp; particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_local_points","title":"function get_local_points","text":"<pre><code>std::vector&lt; itk::Point&lt; double &gt; &gt; get_local_points(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_world_points","title":"function get_world_points","text":"<pre><code>std::vector&lt; itk::Point&lt; double &gt; &gt; get_world_points(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_domain_for_combined_id","title":"function get_domain_for_combined_id","text":"<pre><code>int get_domain_for_combined_id(\n    int id\n)\n</code></pre> <p>Return which domain a particle belongs to when they are concatenated together. </p>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_transform","title":"function set_transform","text":"<pre><code>void set_transform(\n    vtkSmartPointer&lt; vtkTransform &gt; transform\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_procrustes_transforms","title":"function set_procrustes_transforms","text":"<pre><code>void set_procrustes_transforms(\n    const std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; &amp; transforms\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-set_alignment_type","title":"function set_alignment_type","text":"<pre><code>void set_alignment_type(\n    int alignment\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_difference_vectors","title":"function get_difference_vectors","text":"<pre><code>Eigen::VectorXd get_difference_vectors(\n    const Particles &amp; other\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_number_of_domains","title":"function get_number_of_domains","text":"<pre><code>int get_number_of_domains()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-get_total_number_of_particles","title":"function get_total_number_of_particles","text":"<pre><code>int get_total_number_of_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Particles.html#function-save_particles_file","title":"function save_particles_file","text":"<pre><code>static void save_particles_file(\n    std::string filename,\n    const Eigen::VectorXd &amp; points\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html","title":"shapeworks::PhysicalRegion","text":"<p>physical bounds of a 3d region of space </p> <p><code>#include &lt;Region.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#public-functions","title":"Public Functions","text":"Name PhysicalRegion(const PhysicalRegion &amp; ) =default PhysicalRegion(const Point &amp; _min, const Point &amp; _max) PhysicalRegion() PhysicalRegion(std::string str) bool operator==(const PhysicalRegion &amp; other) const bool valid() constverified min/max do not create an inverted or an empty region Point origin() const Point size() const PhysicalRegion &amp; shrink(const PhysicalRegion &amp; other)shrink this region down to the smallest portions of both PhysicalRegion &amp; expand(const PhysicalRegion &amp; other)expand this region to include the largest portions of both PhysicalRegion &amp; expand(const Point &amp; pt)expand this region to include this point PhysicalRegion &amp; pad(double padding)uniformly grows or shrinks the region by the specified amount std::string to_string() constserialize to a string"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#public-attributes","title":"Public Attributes","text":"Name Point min Point max"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-physicalregion","title":"function PhysicalRegion","text":"<pre><code>PhysicalRegion(\n    const PhysicalRegion &amp; \n) =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-physicalregion_1","title":"function PhysicalRegion","text":"<pre><code>inline PhysicalRegion(\n    const Point &amp; _min,\n    const Point &amp; _max\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-physicalregion_2","title":"function PhysicalRegion","text":"<pre><code>inline PhysicalRegion()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-physicalregion_3","title":"function PhysicalRegion","text":"<pre><code>PhysicalRegion(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-operator","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const PhysicalRegion &amp; other\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-valid","title":"function valid","text":"<pre><code>inline bool valid() const\n</code></pre> <p>verified min/max do not create an inverted or an empty region </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-origin","title":"function origin","text":"<pre><code>inline Point origin() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-size","title":"function size","text":"<pre><code>inline Point size() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-shrink","title":"function shrink","text":"<pre><code>PhysicalRegion &amp; shrink(\n    const PhysicalRegion &amp; other\n)\n</code></pre> <p>shrink this region down to the smallest portions of both </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-expand","title":"function expand","text":"<pre><code>PhysicalRegion &amp; expand(\n    const PhysicalRegion &amp; other\n)\n</code></pre> <p>expand this region to include the largest portions of both </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-expand_1","title":"function expand","text":"<pre><code>PhysicalRegion &amp; expand(\n    const Point &amp; pt\n)\n</code></pre> <p>expand this region to include this point </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-pad","title":"function pad","text":"<pre><code>PhysicalRegion &amp; pad(\n    double padding\n)\n</code></pre> <p>uniformly grows or shrinks the region by the specified amount </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#function-to_string","title":"function to_string","text":"<pre><code>std::string to_string() const\n</code></pre> <p>serialize to a string </p>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#variable-min","title":"variable min","text":"<pre><code>Point min;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PhysicalRegion.html#variable-max","title":"variable max","text":"<pre><code>Point max;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PickResult.html","title":"shapeworks::PickResult","text":""},{"location":"api/Classes/classshapeworks_1_1PickResult.html#public-attributes","title":"Public Attributes","text":"Name Shape::Point pos_ int domain_ int subject_"},{"location":"api/Classes/classshapeworks_1_1PickResult.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PickResult.html#variable-pos_","title":"variable pos_","text":"<pre><code>Shape::Point pos_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PickResult.html#variable-domain_","title":"variable domain_","text":"<pre><code>int domain_ = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PickResult.html#variable-subject_","title":"variable subject_","text":"<pre><code>int subject_ = -1;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html","title":"shapeworks::PlaneConstraint","text":"<p>More...</p> <p><code>#include &lt;PlaneConstraint.h&gt;</code></p> <p>Inherits from shapeworks::Constraint</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#public-functions","title":"Public Functions","text":"Name virtual bool isViolated(const Eigen::Vector3d &amp; pt) const overrideReturns if pt in Eigen format is violated by the constraint. virtual void print() const overridePrints the constraint neatly. Eigen::Vector3d getPlaneNormal()Get plane normal. void setPlaneNormal(const Eigen::Vector3d &amp; inPlane)Set plane normal. Eigen::Vector3d getPlanePoint()Get plane center point. void setPlanePoint(const vnl_vector&lt; double &gt; &amp; point)Set plane center point. void setPlanePoint(const Eigen::Vector3d &amp; p)Set plane center point. virtual Eigen::Vector3d constraintGradient(const Eigen::Vector3d &amp; pt) const overrideReturns the gradient of the constraint. std::vector&lt; Eigen::Vector3d &gt; &amp; points() double getOffset() void setOffset(double offset) virtual double constraintEval(const Eigen::Vector3d &amp; pt) const overrideReturns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. void updatePlaneFromPoints() vtkSmartPointer&lt; vtkPlane &gt; getVTKPlane()Return this plane as a vtkPlane."},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Constraint</p> Name void setMus(std::vector&lt; double &gt; inmu)Initializes mu. std::vector&lt; double &gt; getMus()Gets mu. void updateMu(const Eigen::Vector3d &amp; pt, double C, size_t index)Updates the value of mu according to the augmented lagrangian update. Eigen::Vector3d lagragianGradient(const Eigen::Vector3d &amp; pt, double C, size_t index) constComputes the lagrangian gradient based on lagrangian inequality equations. NOTE: Not actually lagrangian. We are using quadratic penalty and not lagrangian because it works better. <p>Protected Functions inherited from shapeworks::Constraint</p> Name int sgn(double val)Returns the sign of the double. <p>Protected Attributes inherited from shapeworks::Constraint</p> Name std::vector&lt; double &gt; mus_ Mu is the lagrangian momentum term."},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::PlaneConstraint;\n</code></pre> <p>Encapsulate functionality related to cutting-plane constraints. Inherits from Constraint. See [Constraint.h] for more information </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-isviolated","title":"function isViolated","text":"<pre><code>virtual bool isViolated(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns if pt in Eigen format is violated by the constraint. </p> <p>Reimplements: shapeworks::Constraint::isViolated</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-print","title":"function print","text":"<pre><code>virtual void print() const override\n</code></pre> <p>Prints the constraint neatly. </p> <p>Reimplements: shapeworks::Constraint::print</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-getplanenormal","title":"function getPlaneNormal","text":"<pre><code>inline Eigen::Vector3d getPlaneNormal()\n</code></pre> <p>Get plane normal. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-setplanenormal","title":"function setPlaneNormal","text":"<pre><code>inline void setPlaneNormal(\n    const Eigen::Vector3d &amp; inPlane\n)\n</code></pre> <p>Set plane normal. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-getplanepoint","title":"function getPlanePoint","text":"<pre><code>inline Eigen::Vector3d getPlanePoint()\n</code></pre> <p>Get plane center point. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-setplanepoint","title":"function setPlanePoint","text":"<pre><code>inline void setPlanePoint(\n    const vnl_vector&lt; double &gt; &amp; point\n)\n</code></pre> <p>Set plane center point. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-setplanepoint_1","title":"function setPlanePoint","text":"<pre><code>inline void setPlanePoint(\n    const Eigen::Vector3d &amp; p\n)\n</code></pre> <p>Set plane center point. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-constraintgradient","title":"function constraintGradient","text":"<pre><code>inline virtual Eigen::Vector3d constraintGradient(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns the gradient of the constraint. </p> <p>Reimplements: shapeworks::Constraint::constraintGradient</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-points","title":"function points","text":"<pre><code>inline std::vector&lt; Eigen::Vector3d &gt; &amp; points()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-getoffset","title":"function getOffset","text":"<pre><code>double getOffset()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-setoffset","title":"function setOffset","text":"<pre><code>void setOffset(\n    double offset\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-constrainteval","title":"function constraintEval","text":"<pre><code>virtual double constraintEval(\n    const Eigen::Vector3d &amp; pt\n) const override\n</code></pre> <p>Returns the evaluation on the constraint, i.e. the signed distance to the constraint boundary. </p> <p>Reimplements: shapeworks::Constraint::constraintEval</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-updateplanefrompoints","title":"function updatePlaneFromPoints","text":"<pre><code>void updatePlaneFromPoints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneConstraint.html#function-getvtkplane","title":"function getVTKPlane","text":"<pre><code>vtkSmartPointer&lt; vtkPlane &gt; getVTKPlane()\n</code></pre> <p>Return this plane as a vtkPlane. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html","title":"shapeworks::PlaneWidget","text":"<p>PlaneWidget.  More...</p> <p><code>#include &lt;PlaneWidget.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#public-functions","title":"Public Functions","text":"Name PlaneWidget(Viewer * viewer) ~PlaneWidget() void update()Update the widget from shape data. void store_positions()Store positions back to shape data (this is called by callback) void update_glyph_properties()Update the sizes and detail of control spheres. void clear_planes()Clear point handles and planes. void handle_right_click(int domain, int plane, int point)Handle a right click on a particular point. void delete_plane(int domain, int plane_id)Delete a particular plane. void flip_plane(int domain, int plane_id)Flip the normal for a given plane. void apply_plane(int domain, int plane_id)Apply a plane from one shape to all others (e.g. copy and paste) void set_plane_offset(int domain, int plane_id, int offset)Set an offset for a given plane. void finalize_plane_offset(int domain, int plane_id)Finalize the offset for a given plane."},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::PlaneWidget;\n</code></pre> <p>PlaneWidget. </p> <p>Widget to display and manipulate constraint planes </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-planewidget","title":"function PlaneWidget","text":"<pre><code>PlaneWidget(\n    Viewer * viewer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-planewidget_1","title":"function ~PlaneWidget","text":"<pre><code>~PlaneWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-update","title":"function update","text":"<pre><code>void update()\n</code></pre> <p>Update the widget from shape data. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-store_positions","title":"function store_positions","text":"<pre><code>void store_positions()\n</code></pre> <p>Store positions back to shape data (this is called by callback) </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-update_glyph_properties","title":"function update_glyph_properties","text":"<pre><code>void update_glyph_properties()\n</code></pre> <p>Update the sizes and detail of control spheres. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-clear_planes","title":"function clear_planes","text":"<pre><code>void clear_planes()\n</code></pre> <p>Clear point handles and planes. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-handle_right_click","title":"function handle_right_click","text":"<pre><code>void handle_right_click(\n    int domain,\n    int plane,\n    int point\n)\n</code></pre> <p>Handle a right click on a particular point. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-delete_plane","title":"function delete_plane","text":"<pre><code>void delete_plane(\n    int domain,\n    int plane_id\n)\n</code></pre> <p>Delete a particular plane. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-flip_plane","title":"function flip_plane","text":"<pre><code>void flip_plane(\n    int domain,\n    int plane_id\n)\n</code></pre> <p>Flip the normal for a given plane. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-apply_plane","title":"function apply_plane","text":"<pre><code>void apply_plane(\n    int domain,\n    int plane_id\n)\n</code></pre> <p>Apply a plane from one shape to all others (e.g. copy and paste) </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-set_plane_offset","title":"function set_plane_offset","text":"<pre><code>void set_plane_offset(\n    int domain,\n    int plane_id,\n    int offset\n)\n</code></pre> <p>Set an offset for a given plane. </p>"},{"location":"api/Classes/classshapeworks_1_1PlaneWidget.html#function-finalize_plane_offset","title":"function finalize_plane_offset","text":"<pre><code>void finalize_plane_offset(\n    int domain,\n    int plane_id\n)\n</code></pre> <p>Finalize the offset for a given plane. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html","title":"shapeworks::PlatformUtils","text":"<p>Platform utility functions. </p> <p><code>#include &lt;PlatformUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html#public-functions","title":"Public Functions","text":"Name bool is_windows() bool is_linux() bool is_macos()"},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html#function-is_windows","title":"function is_windows","text":"<pre><code>static inline bool is_windows()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html#function-is_linux","title":"function is_linux","text":"<pre><code>static inline bool is_linux()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PlatformUtils.html#function-is_macos","title":"function is_macos","text":"<pre><code>static inline bool is_macos()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html","title":"shapeworks::PreferencesWindow","text":"<p>Qt UI dialog to control preferences.  More...</p> <p><code>#include &lt;PreferencesWindow.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-slots","title":"Public Slots","text":"Name void on_mesh_cache_enabled_stateChanged(int state) void on_mesh_cache_memory_valueChanged(int value) void on_color_scheme_currentIndexChanged(int index) void on_pca_range_valueChanged(double value) void on_pca_steps_valueChanged(int value) void on_parallel_enabled_toggled(bool b) void on_num_threads_valueChanged(int i) void accept() override void restore_defaults() void save_to_preferences()"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-signals","title":"Public Signals","text":"Name void clear_cache() void update_view() void slider_update()"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-functions","title":"Public Functions","text":"Name PreferencesWindow(QWidget * parent, Preferences &amp; prefs) void set_values_from_preferences() void closeEvent(QCloseEvent * event) override"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::PreferencesWindow;\n</code></pre> <p>Qt UI dialog to control preferences. </p> <p>The PreferenceWindow provides controls over preferences for the application. It is synchronized with the singleton Preference object </p>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_mesh_cache_enabled_statechanged","title":"slot on_mesh_cache_enabled_stateChanged","text":"<pre><code>void on_mesh_cache_enabled_stateChanged(\n    int state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_mesh_cache_memory_valuechanged","title":"slot on_mesh_cache_memory_valueChanged","text":"<pre><code>void on_mesh_cache_memory_valueChanged(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_color_scheme_currentindexchanged","title":"slot on_color_scheme_currentIndexChanged","text":"<pre><code>void on_color_scheme_currentIndexChanged(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_pca_range_valuechanged","title":"slot on_pca_range_valueChanged","text":"<pre><code>void on_pca_range_valueChanged(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_pca_steps_valuechanged","title":"slot on_pca_steps_valueChanged","text":"<pre><code>void on_pca_steps_valueChanged(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_parallel_enabled_toggled","title":"slot on_parallel_enabled_toggled","text":"<pre><code>void on_parallel_enabled_toggled(\n    bool b\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-on_num_threads_valuechanged","title":"slot on_num_threads_valueChanged","text":"<pre><code>void on_num_threads_valueChanged(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-accept","title":"slot accept","text":"<pre><code>void accept() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-restore_defaults","title":"slot restore_defaults","text":"<pre><code>void restore_defaults()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#slot-save_to_preferences","title":"slot save_to_preferences","text":"<pre><code>void save_to_preferences()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#signal-clear_cache","title":"signal clear_cache","text":"<pre><code>void clear_cache()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#signal-slider_update","title":"signal slider_update","text":"<pre><code>void slider_update()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#function-preferenceswindow","title":"function PreferencesWindow","text":"<pre><code>PreferencesWindow(\n    QWidget * parent,\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#function-set_values_from_preferences","title":"function set_values_from_preferences","text":"<pre><code>void set_values_from_preferences()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PreferencesWindow.html#function-closeevent","title":"function closeEvent","text":"<pre><code>void closeEvent(\n    QCloseEvent * event\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html","title":"shapeworks::ProcrustesRegistration","text":""},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; ProcrustesRegistration &gt; Pointer using ParticleSystem ParticleSystemType using ParticleSystemType::PointType PointType"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#public-functions","title":"Public Functions","text":"Name void SetParticleSystem(ParticleSystemType * p) ParticleSystemType * GetParticleSystem() const ParticleSystemType * GetParticleSystem() void RunRegistration(int i) void RunRegistration()Run registration on all domains. void SetDomainsPerShape(int i)Set/Get the number of Domains in each shape. Procrustes will be performed separately for each domain. int GetDomainsPerShape() const bool GetScaling() const void SetScaling(bool scaling) bool GetRotationTranslation() const void SetRotationTranslation(bool rotationTranslation)"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#using-pointer","title":"using Pointer","text":"<pre><code>using shapeworks::ProcrustesRegistration::Pointer =  std::shared_ptr&lt;ProcrustesRegistration&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#using-particlesystemtype","title":"using ParticleSystemType","text":"<pre><code>using shapeworks::ProcrustesRegistration::ParticleSystemType =  ParticleSystem;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::ProcrustesRegistration::PointType =  ParticleSystemType::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-setparticlesystem","title":"function SetParticleSystem","text":"<pre><code>inline void SetParticleSystem(\n    ParticleSystemType * p\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-getparticlesystem","title":"function GetParticleSystem","text":"<pre><code>inline ParticleSystemType * GetParticleSystem() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-getparticlesystem_1","title":"function GetParticleSystem","text":"<pre><code>inline ParticleSystemType * GetParticleSystem()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-runregistration","title":"function RunRegistration","text":"<pre><code>void RunRegistration(\n    int i\n)\n</code></pre> <p>Performs a procrustes registration and modifies the transforms of the particle system accordingly. Assumes m_ParticleSystem has been set to point to a valid object. </p>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-runregistration_1","title":"function RunRegistration","text":"<pre><code>void RunRegistration()\n</code></pre> <p>Run registration on all domains. </p>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of Domains in each shape. Procrustes will be performed separately for each domain. </p>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-getscaling","title":"function GetScaling","text":"<pre><code>inline bool GetScaling() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-setscaling","title":"function SetScaling","text":"<pre><code>inline void SetScaling(\n    bool scaling\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-getrotationtranslation","title":"function GetRotationTranslation","text":"<pre><code>inline bool GetRotationTranslation() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProcrustesRegistration.html#function-setrotationtranslation","title":"function SetRotationTranslation","text":"<pre><code>inline void SetRotationTranslation(\n    bool rotationTranslation\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html","title":"shapeworks::Profiler","text":""},{"location":"api/Classes/classshapeworks_1_1Profiler.html#public-functions","title":"Public Functions","text":"Name Profiler &amp; instance() void start_timer(const QString &amp; name) void stop_timer(const QString &amp; name) void finalize() bool is_profiling_enabled() const bool is_tracing_enabled() const"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-instance","title":"function instance","text":"<pre><code>static Profiler &amp; instance()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-start_timer","title":"function start_timer","text":"<pre><code>void start_timer(\n    const QString &amp; name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-stop_timer","title":"function stop_timer","text":"<pre><code>void stop_timer(\n    const QString &amp; name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-finalize","title":"function finalize","text":"<pre><code>void finalize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-is_profiling_enabled","title":"function is_profiling_enabled","text":"<pre><code>inline bool is_profiling_enabled() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Profiler.html#function-is_tracing_enabled","title":"function is_tracing_enabled","text":"<pre><code>inline bool is_tracing_enabled() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Project.html","title":"shapeworks::Project","text":"<p>Representation of a project.  More...</p> <p><code>#include &lt;Project.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#public-functions","title":"Public Functions","text":"Name Project() ~Project() bool load(const std::string &amp; filename)Load from project file. bool save(const std::string &amp; filename =\"\")Save to project file. void set_project_path(const std::string &amp; path)Set the project path. std::string get_project_path()Return the project path. std::string get_filename()Return the filename. void set_filename(std::string filename)Set project filename. std::vector&lt; std::string &gt; get_headers()Return the headers of the subject sheet. std::vector&lt; std::string &gt; get_string_column(const std::string &amp; name) constReturn a column by name. int get_number_of_subjects()Return the number of subjects in the project. int get_number_of_domains_per_subject()Return the number of domains. std::vector&lt; std::string &gt; get_domain_names()Return the domain names (e.g. femur, pelvis, etc) void set_domain_names(std::vector&lt; std::string &gt; domain_names)Set the domain names. std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; &amp; get_subjects()Return the Subjects (as a reference) std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; get_non_excluded_subjects()Return the non-excluded Subjects (as a reference) void set_subjects(const std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; &amp; subjects)Set the Subjects. void update_subjects() bool get_originals_present() constReturn if originals are present. bool get_groomed_present() constReturn if groomed files are present. bool get_particles_present() constReturn if particle files are present. bool get_images_present()Return if images are present (e.g. CT/MRI) bool get_fixed_subjects_present()Return if there are fixed subjects present. bool get_excluded_subjects_present()Return if there are excluded subjects present. std::vector&lt; std::string &gt; get_feature_names()Get feature names. std::vector&lt; std::string &gt; get_image_names()Get image names. std::vector&lt; std::string &gt; get_group_names()Get group names. std::vector&lt; std::string &gt; get_group_values(const std::string &amp; group_name) constGet possible group values. Parameters get_parameters(const std::string &amp; name, std::string domain_name =\"\")Retrieve parameters based on key. std::map&lt; std::string, Parameters &gt; get_parameter_map(const std::string &amp; name)Retrieve full parameter map for a given name. void set_parameter_map(const std::string &amp; name, std::map&lt; std::string, Parameters &gt; map)Set parameter map for a given name. void set_parameters(const std::string &amp; name, Parameters params, std::string domain_name =\"\")Store parameters based on key. void clear_parameters(const std::string &amp; name)Clear parameters based on key. int get_supported_version() constGet the supported version (this version of the code) int get_version() constGet the version of the currently loaded project. std::vector&lt; LandmarkDefinition &gt; get_landmarks(int domain_id)Return the set of landmarks definitions for a particular domain. std::vector&lt; std::vector&lt; LandmarkDefinition &gt; &gt; get_all_landmark_definitions()Return all landmark definitions. void set_landmark_definitions(std::vector&lt; std::vector&lt; LandmarkDefinition &gt; &gt; defs)Set all landmark definitions. bool get_landmarks_present()Return if landmarks are present. void set_landmarks(int domain_id, std::vector&lt; LandmarkDefinition &gt; landmarks)Set landmarks for this project. void new_landmark(int domain_id)Add a new landmark. std::vector&lt; DomainType &gt; get_original_domain_types()Return the original domain types. std::vector&lt; DomainType &gt; get_groomed_domain_types()Return the groomed domain types. void set_original_domain_types(std::vector&lt; DomainType &gt; domain_types)Set the original domain types. void set_groomed_domain_types(std::vector&lt; DomainType &gt; domain_types)Get the groomed domain types."},{"location":"api/Classes/classshapeworks_1_1Project.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Project;\n</code></pre> <p>Representation of a project. </p> <p>The Project class encapsulates the spreadsheet based file format for storing project data. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Project.html#function-project","title":"function Project","text":"<pre><code>Project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-project_1","title":"function ~Project","text":"<pre><code>~Project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-load","title":"function load","text":"<pre><code>bool load(\n    const std::string &amp; filename\n)\n</code></pre> <p>Load from project file. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-save","title":"function save","text":"<pre><code>bool save(\n    const std::string &amp; filename =\"\"\n)\n</code></pre> <p>Save to project file. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_project_path","title":"function set_project_path","text":"<pre><code>void set_project_path(\n    const std::string &amp; path\n)\n</code></pre> <p>Set the project path. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_project_path","title":"function get_project_path","text":"<pre><code>std::string get_project_path()\n</code></pre> <p>Return the project path. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_filename","title":"function get_filename","text":"<pre><code>std::string get_filename()\n</code></pre> <p>Return the filename. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_filename","title":"function set_filename","text":"<pre><code>void set_filename(\n    std::string filename\n)\n</code></pre> <p>Set project filename. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_headers","title":"function get_headers","text":"<pre><code>std::vector&lt; std::string &gt; get_headers()\n</code></pre> <p>Return the headers of the subject sheet. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_string_column","title":"function get_string_column","text":"<pre><code>std::vector&lt; std::string &gt; get_string_column(\n    const std::string &amp; name\n) const\n</code></pre> <p>Return a column by name. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_number_of_subjects","title":"function get_number_of_subjects","text":"<pre><code>int get_number_of_subjects()\n</code></pre> <p>Return the number of subjects in the project. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_number_of_domains_per_subject","title":"function get_number_of_domains_per_subject","text":"<pre><code>int get_number_of_domains_per_subject()\n</code></pre> <p>Return the number of domains. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_domain_names","title":"function get_domain_names","text":"<pre><code>std::vector&lt; std::string &gt; get_domain_names()\n</code></pre> <p>Return the domain names (e.g. femur, pelvis, etc) </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_domain_names","title":"function set_domain_names","text":"<pre><code>void set_domain_names(\n    std::vector&lt; std::string &gt; domain_names\n)\n</code></pre> <p>Set the domain names. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_subjects","title":"function get_subjects","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; &amp; get_subjects()\n</code></pre> <p>Return the Subjects (as a reference) </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_non_excluded_subjects","title":"function get_non_excluded_subjects","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; get_non_excluded_subjects()\n</code></pre> <p>Return the non-excluded Subjects (as a reference) </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_subjects","title":"function set_subjects","text":"<pre><code>void set_subjects(\n    const std::vector&lt; std::shared_ptr&lt; Subject &gt; &gt; &amp; subjects\n)\n</code></pre> <p>Set the Subjects. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-update_subjects","title":"function update_subjects","text":"<pre><code>void update_subjects()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_originals_present","title":"function get_originals_present","text":"<pre><code>bool get_originals_present() const\n</code></pre> <p>Return if originals are present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_groomed_present","title":"function get_groomed_present","text":"<pre><code>bool get_groomed_present() const\n</code></pre> <p>Return if groomed files are present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_particles_present","title":"function get_particles_present","text":"<pre><code>bool get_particles_present() const\n</code></pre> <p>Return if particle files are present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_images_present","title":"function get_images_present","text":"<pre><code>bool get_images_present()\n</code></pre> <p>Return if images are present (e.g. CT/MRI) </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_fixed_subjects_present","title":"function get_fixed_subjects_present","text":"<pre><code>bool get_fixed_subjects_present()\n</code></pre> <p>Return if there are fixed subjects present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_excluded_subjects_present","title":"function get_excluded_subjects_present","text":"<pre><code>bool get_excluded_subjects_present()\n</code></pre> <p>Return if there are excluded subjects present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_feature_names","title":"function get_feature_names","text":"<pre><code>std::vector&lt; std::string &gt; get_feature_names()\n</code></pre> <p>Get feature names. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_image_names","title":"function get_image_names","text":"<pre><code>std::vector&lt; std::string &gt; get_image_names()\n</code></pre> <p>Get image names. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_group_names","title":"function get_group_names","text":"<pre><code>std::vector&lt; std::string &gt; get_group_names()\n</code></pre> <p>Get group names. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_group_values","title":"function get_group_values","text":"<pre><code>std::vector&lt; std::string &gt; get_group_values(\n    const std::string &amp; group_name\n) const\n</code></pre> <p>Get possible group values. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>Parameters get_parameters(\n    const std::string &amp; name,\n    std::string domain_name =\"\"\n)\n</code></pre> <p>Retrieve parameters based on key. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_parameter_map","title":"function get_parameter_map","text":"<pre><code>std::map&lt; std::string, Parameters &gt; get_parameter_map(\n    const std::string &amp; name\n)\n</code></pre> <p>Retrieve full parameter map for a given name. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_parameter_map","title":"function set_parameter_map","text":"<pre><code>void set_parameter_map(\n    const std::string &amp; name,\n    std::map&lt; std::string, Parameters &gt; map\n)\n</code></pre> <p>Set parameter map for a given name. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_parameters","title":"function set_parameters","text":"<pre><code>void set_parameters(\n    const std::string &amp; name,\n    Parameters params,\n    std::string domain_name =\"\"\n)\n</code></pre> <p>Store parameters based on key. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-clear_parameters","title":"function clear_parameters","text":"<pre><code>void clear_parameters(\n    const std::string &amp; name\n)\n</code></pre> <p>Clear parameters based on key. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_supported_version","title":"function get_supported_version","text":"<pre><code>int get_supported_version() const\n</code></pre> <p>Get the supported version (this version of the code) </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_version","title":"function get_version","text":"<pre><code>int get_version() const\n</code></pre> <p>Get the version of the currently loaded project. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_landmarks","title":"function get_landmarks","text":"<pre><code>std::vector&lt; LandmarkDefinition &gt; get_landmarks(\n    int domain_id\n)\n</code></pre> <p>Return the set of landmarks definitions for a particular domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_all_landmark_definitions","title":"function get_all_landmark_definitions","text":"<pre><code>std::vector&lt; std::vector&lt; LandmarkDefinition &gt; &gt; get_all_landmark_definitions()\n</code></pre> <p>Return all landmark definitions. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_landmark_definitions","title":"function set_landmark_definitions","text":"<pre><code>void set_landmark_definitions(\n    std::vector&lt; std::vector&lt; LandmarkDefinition &gt; &gt; defs\n)\n</code></pre> <p>Set all landmark definitions. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_landmarks_present","title":"function get_landmarks_present","text":"<pre><code>bool get_landmarks_present()\n</code></pre> <p>Return if landmarks are present. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_landmarks","title":"function set_landmarks","text":"<pre><code>void set_landmarks(\n    int domain_id,\n    std::vector&lt; LandmarkDefinition &gt; landmarks\n)\n</code></pre> <p>Set landmarks for this project. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-new_landmark","title":"function new_landmark","text":"<pre><code>void new_landmark(\n    int domain_id\n)\n</code></pre> <p>Add a new landmark. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_original_domain_types","title":"function get_original_domain_types","text":"<pre><code>std::vector&lt; DomainType &gt; get_original_domain_types()\n</code></pre> <p>Return the original domain types. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-get_groomed_domain_types","title":"function get_groomed_domain_types","text":"<pre><code>std::vector&lt; DomainType &gt; get_groomed_domain_types()\n</code></pre> <p>Return the groomed domain types. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_original_domain_types","title":"function set_original_domain_types","text":"<pre><code>void set_original_domain_types(\n    std::vector&lt; DomainType &gt; domain_types\n)\n</code></pre> <p>Set the original domain types. </p>"},{"location":"api/Classes/classshapeworks_1_1Project.html#function-set_groomed_domain_types","title":"function set_groomed_domain_types","text":"<pre><code>void set_groomed_domain_types(\n    std::vector&lt; DomainType &gt; domain_types\n)\n</code></pre> <p>Get the groomed domain types. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectCommandGroup.html","title":"shapeworks::ProjectCommandGroup","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectCommandGroup.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1ProjectCommandGroup.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1ProjectCommandGroup.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectCommandGroup.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html","title":"shapeworks::ProjectReader","text":"<p>Base class for Project readers.  More...</p> <p><code>#include &lt;ProjectReader.h&gt;</code></p> <p>Inherited by shapeworks::ExcelProjectReader, shapeworks::JsonProjectReader</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#public-types","title":"Public Types","text":"Name using project::types::StringMapList StringMapList using project::types::StringMap StringMap using project::types::StringList StringList using project::types::StringMultiMap StringMultiMap"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#public-functions","title":"Public Functions","text":"Name ProjectReader(Project &amp; project)Constructor. virtual ~ProjectReader() =defaultDestructor. virtual bool read_project(std::string filename) =0Read a project from a file. virtual StringMap get_parameters(std::string name) =0 virtual StringMultiMap get_multi_parameters(std::string name) =0"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#protected-functions","title":"Protected Functions","text":"Name void load_subjects(StringMapList list)Load subjects from string map list. void load_parameters() void load_parameter(std::string name, StringMap map) void load_landmark_definitions(StringMapList list) bool contains(StringMap map, std::string key) StringList get_keys(StringMap map)"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#protected-attributes","title":"Protected Attributes","text":"Name Project &amp; project_"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ProjectReader;\n</code></pre> <p>Base class for Project readers. </p> <p>This class serves as an abstract base class for project readers </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#using-stringmaplist","title":"using StringMapList","text":"<pre><code>using shapeworks::ProjectReader::StringMapList =  project::types::StringMapList;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#using-stringmap","title":"using StringMap","text":"<pre><code>using shapeworks::ProjectReader::StringMap =  project::types::StringMap;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#using-stringlist","title":"using StringList","text":"<pre><code>using shapeworks::ProjectReader::StringList =  project::types::StringList;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#using-stringmultimap","title":"using StringMultiMap","text":"<pre><code>using shapeworks::ProjectReader::StringMultiMap =  project::types::StringMultiMap;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-projectreader","title":"function ProjectReader","text":"<pre><code>ProjectReader(\n    Project &amp; project\n)\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-projectreader_1","title":"function ~ProjectReader","text":"<pre><code>virtual ~ProjectReader() =default\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-read_project","title":"function read_project","text":"<pre><code>virtual bool read_project(\n    std::string filename\n) =0\n</code></pre> <p>Read a project from a file. </p> <p>Reimplemented by: shapeworks::ExcelProjectReader::read_project, shapeworks::JsonProjectReader::read_project</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-get_parameters","title":"function get_parameters","text":"<pre><code>virtual StringMap get_parameters(\n    std::string name\n) =0\n</code></pre> <p>Reimplemented by: shapeworks::ExcelProjectReader::get_parameters, shapeworks::JsonProjectReader::get_parameters</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-get_multi_parameters","title":"function get_multi_parameters","text":"<pre><code>virtual StringMultiMap get_multi_parameters(\n    std::string name\n) =0\n</code></pre> <p>Reimplemented by: shapeworks::ExcelProjectReader::get_multi_parameters, shapeworks::JsonProjectReader::get_multi_parameters</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-load_subjects","title":"function load_subjects","text":"<pre><code>void load_subjects(\n    StringMapList list\n)\n</code></pre> <p>Load subjects from string map list. </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-load_parameters","title":"function load_parameters","text":"<pre><code>void load_parameters()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-load_parameter","title":"function load_parameter","text":"<pre><code>void load_parameter(\n    std::string name,\n    StringMap map\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-load_landmark_definitions","title":"function load_landmark_definitions","text":"<pre><code>void load_landmark_definitions(\n    StringMapList list\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-contains","title":"function contains","text":"<pre><code>bool contains(\n    StringMap map,\n    std::string key\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#function-get_keys","title":"function get_keys","text":"<pre><code>static StringList get_keys(\n    StringMap map\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectReader.html#variable-project_","title":"variable project_","text":"<pre><code>Project &amp; project_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html","title":"shapeworks::ProjectUtils","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#public-types","title":"Public Types","text":"Name using project::types::StringList StringList using project::types::StringMap StringMap"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#public-functions","title":"Public Functions","text":"Name vtkSmartPointer&lt; vtkTransform &gt; convert_transform(std::vector&lt; double &gt; list)convert a list of doubles from a spreadsheet to a vtkTransform vtkSmartPointer&lt; vtkTransform &gt; convert_transform(std::string string)convert a string of doubles from to a vtkTransform std::vector&lt; double &gt; convert_transform(vtkSmartPointer&lt; vtkTransform &gt; transform)convert a vtkTransform to a list of doubles (e.g. for project spreadsheet) StringList determine_domain_names(StringList keys)determine domain names from a subject's keys void determine_domain_types(Project * project, StringMap key_map)determine and set domain types StringList get_input_prefixes()return a list of the input prefixes StringList get_groomed_prefixes()return a list of the groomed prefixes StringList get_original_keys(StringList domain_names, StringMap key_map)extract original keys from key_map given an ordered list of domain names StringList get_values(StringList prefixes, StringList domain_names, StringMap key_map)get the values for a list of prefixes from key_map, ordered by domain_names std::vector&lt; std::vector&lt; double &gt; &gt; get_transforms(std::string prefix, StringList domain_names, StringMap key_map)get the transforms for a prefix from key_map, ordered by domain_names StringMap get_value_map(std::vector&lt; std::string &gt; prefix, StringMap key_map)get a map for a list of prefixes from a key_map (e.g. group_, or feature_) StringMap get_extra_columns(StringMap key_map)get any extra columns that don't match prefixes DomainType determine_domain_type(std::string filename)determine the domain type, given a filename bool starts_with(std::string str, std::string prefix) std::string transform_to_string(std::vector&lt; double &gt; transform) std::vector&lt; std::string &gt; convert_domain_types(std::vector&lt; DomainType &gt; domain_types) std::vector&lt; std::string &gt; convert_groomed_domain_types(std::vector&lt; DomainType &gt; domain_types) StringMap convert_subject_to_map(Project * project, Subject * subject)"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#using-stringlist","title":"using StringList","text":"<pre><code>using shapeworks::ProjectUtils::StringList =  project::types::StringList;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#using-stringmap","title":"using StringMap","text":"<pre><code>using shapeworks::ProjectUtils::StringMap =  project::types::StringMap;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_transform","title":"function convert_transform","text":"<pre><code>static vtkSmartPointer&lt; vtkTransform &gt; convert_transform(\n    std::vector&lt; double &gt; list\n)\n</code></pre> <p>convert a list of doubles from a spreadsheet to a vtkTransform </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_transform_1","title":"function convert_transform","text":"<pre><code>static vtkSmartPointer&lt; vtkTransform &gt; convert_transform(\n    std::string string\n)\n</code></pre> <p>convert a string of doubles from to a vtkTransform </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_transform_2","title":"function convert_transform","text":"<pre><code>static std::vector&lt; double &gt; convert_transform(\n    vtkSmartPointer&lt; vtkTransform &gt; transform\n)\n</code></pre> <p>convert a vtkTransform to a list of doubles (e.g. for project spreadsheet) </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-determine_domain_names","title":"function determine_domain_names","text":"<pre><code>static StringList determine_domain_names(\n    StringList keys\n)\n</code></pre> <p>determine domain names from a subject's keys </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-determine_domain_types","title":"function determine_domain_types","text":"<pre><code>static void determine_domain_types(\n    Project * project,\n    StringMap key_map\n)\n</code></pre> <p>determine and set domain types </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_input_prefixes","title":"function get_input_prefixes","text":"<pre><code>static StringList get_input_prefixes()\n</code></pre> <p>return a list of the input prefixes </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_groomed_prefixes","title":"function get_groomed_prefixes","text":"<pre><code>static StringList get_groomed_prefixes()\n</code></pre> <p>return a list of the groomed prefixes </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_original_keys","title":"function get_original_keys","text":"<pre><code>static StringList get_original_keys(\n    StringList domain_names,\n    StringMap key_map\n)\n</code></pre> <p>extract original keys from key_map given an ordered list of domain names </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_values","title":"function get_values","text":"<pre><code>static StringList get_values(\n    StringList prefixes,\n    StringList domain_names,\n    StringMap key_map\n)\n</code></pre> <p>get the values for a list of prefixes from key_map, ordered by domain_names </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_transforms","title":"function get_transforms","text":"<pre><code>static std::vector&lt; std::vector&lt; double &gt; &gt; get_transforms(\n    std::string prefix,\n    StringList domain_names,\n    StringMap key_map\n)\n</code></pre> <p>get the transforms for a prefix from key_map, ordered by domain_names </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_value_map","title":"function get_value_map","text":"<pre><code>static StringMap get_value_map(\n    std::vector&lt; std::string &gt; prefix,\n    StringMap key_map\n)\n</code></pre> <p>get a map for a list of prefixes from a key_map (e.g. group_, or feature_)"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-get_extra_columns","title":"function get_extra_columns","text":"<pre><code>static StringMap get_extra_columns(\n    StringMap key_map\n)\n</code></pre> <p>get any extra columns that don't match prefixes </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-determine_domain_type","title":"function determine_domain_type","text":"<pre><code>static DomainType determine_domain_type(\n    std::string filename\n)\n</code></pre> <p>determine the domain type, given a filename </p>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-starts_with","title":"function starts_with","text":"<pre><code>static bool starts_with(\n    std::string str,\n    std::string prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-transform_to_string","title":"function transform_to_string","text":"<pre><code>static std::string transform_to_string(\n    std::vector&lt; double &gt; transform\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_domain_types","title":"function convert_domain_types","text":"<pre><code>static std::vector&lt; std::string &gt; convert_domain_types(\n    std::vector&lt; DomainType &gt; domain_types\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_groomed_domain_types","title":"function convert_groomed_domain_types","text":"<pre><code>static std::vector&lt; std::string &gt; convert_groomed_domain_types(\n    std::vector&lt; DomainType &gt; domain_types\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ProjectUtils.html#function-convert_subject_to_map","title":"function convert_subject_to_map","text":"<pre><code>static StringMap convert_subject_to_map(\n    Project * project,\n    Subject * subject\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html","title":"shapeworks::PythonWorker","text":"<p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-slots","title":"Public Slots","text":"Name bool init() void start_job(QSharedPointer&lt; Job &gt; job) void finalize_python()"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-signals","title":"Public Signals","text":"Name void result_ready() void finished()"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-functions","title":"Public Functions","text":"Name PythonWorker() ~PythonWorker() void set_vtk_output_window(vtkSmartPointer&lt; ShapeWorksVtkOutputWindow &gt; output_window) void set_cli_mode(bool cli_mode) void run_job(QSharedPointer&lt; Job &gt; job) void set_current_job(QSharedPointer&lt; Job &gt; job) void incoming_python_message(std::string message_string) void incoming_python_progress(double value, std::string message) void end_python() void abort_job()"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-attributes","title":"Public Attributes","text":"Name constexpr static const char * python_api_version"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#slot-init","title":"slot init","text":"<pre><code>bool init()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#slot-start_job","title":"slot start_job","text":"<pre><code>void start_job(\n    QSharedPointer&lt; Job &gt; job\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#slot-finalize_python","title":"slot finalize_python","text":"<pre><code>void finalize_python()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#signal-result_ready","title":"signal result_ready","text":"<pre><code>void result_ready()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#signal-finished","title":"signal finished","text":"<pre><code>void finished()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-pythonworker","title":"function PythonWorker","text":"<pre><code>PythonWorker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-pythonworker_1","title":"function ~PythonWorker","text":"<pre><code>~PythonWorker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-set_vtk_output_window","title":"function set_vtk_output_window","text":"<pre><code>void set_vtk_output_window(\n    vtkSmartPointer&lt; ShapeWorksVtkOutputWindow &gt; output_window\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-set_cli_mode","title":"function set_cli_mode","text":"<pre><code>void set_cli_mode(\n    bool cli_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-run_job","title":"function run_job","text":"<pre><code>void run_job(\n    QSharedPointer&lt; Job &gt; job\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-set_current_job","title":"function set_current_job","text":"<pre><code>void set_current_job(\n    QSharedPointer&lt; Job &gt; job\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-incoming_python_message","title":"function incoming_python_message","text":"<pre><code>void incoming_python_message(\n    std::string message_string\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-incoming_python_progress","title":"function incoming_python_progress","text":"<pre><code>void incoming_python_progress(\n    double value,\n    std::string message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-end_python","title":"function end_python","text":"<pre><code>void end_python()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#function-abort_job","title":"function abort_job","text":"<pre><code>void abort_job()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1PythonWorker.html#variable-python_api_version","title":"variable python_api_version","text":"<pre><code>static constexpr static const char * python_api_version = \"6.7\";\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html","title":"shapeworks::QMeshWarper","text":"<p>Wraps MeshWarper as a QObject. </p> <p><code>#include &lt;QMeshWarper.h&gt;</code></p> <p>Inherits from QObject, shapeworks::MeshWarper</p>"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#public-signals","title":"Public Signals","text":"Name void progress()"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#public-functions","title":"Public Functions","text":"Name QMeshWarper(QObject * parent =nullptr) float get_progress()"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#protected-functions","title":"Protected Functions","text":"Name virtual void update_progress(float p) overrideFor overriding to handle progress updates."},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::MeshWarper</p> Name void set_reference_mesh(vtkSmartPointer&lt; vtkPolyData &gt; reference_mesh, const Eigen::MatrixXd &amp; reference_particles, const Eigen::MatrixXd &amp; landmarks ={})Set the reference mesh and particles. bool generate_warp()Generate warp, return true on success. bool get_warp_available()Return if the warp is available. bool is_contour() const vtkSmartPointer&lt; vtkPolyData &gt; build_mesh(const Eigen::MatrixXd &amp; particles)Build a mesh for a given set of particles. Eigen::MatrixXd extract_landmarks(vtkSmartPointer&lt; vtkPolyData &gt; warped_mesh)Return the landmarks (matrix [Nx3]) from the warped builded mesh. bool is_contour()Return if set as a contour. std::map&lt; int, int &gt; get_landmarks_map() constReturn the map of landmarks id (Key) to vertice index (Value) std::vector&lt; int &gt; get_good_particle_indices() constReturn the indexes of good particles (those that really control the warping) const Eigen::MatrixXd &amp; get_warp_matrix() constReturn the warp matrix. bool has_bad_particles() constReturn true if warping has removed any bad particle(s) vtkSmartPointer&lt; vtkPolyData &gt; get_reference_mesh()Return the reference mesh which has been cleaned and vertices added. const Eigen::MatrixXd &amp; get_reference_particles() constReturn the reference particles."},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#signal-progress","title":"signal progress","text":"<pre><code>void progress()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#function-qmeshwarper","title":"function QMeshWarper","text":"<pre><code>QMeshWarper(\n    QObject * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#function-get_progress","title":"function get_progress","text":"<pre><code>float get_progress()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QMeshWarper.html#function-update_progress","title":"function update_progress","text":"<pre><code>virtual void update_progress(\n    float p\n) override\n</code></pre> <p>For overriding to handle progress updates. </p> <p>Reimplements: shapeworks::MeshWarper::update_progress</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html","title":"shapeworks::QOptimize","text":"<p>Wraps Optimize as a QObject. </p> <p><code>#include &lt;QOptimize.h&gt;</code></p> <p>Inherits from QObject, shapeworks::Optimize</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#public-signals","title":"Public Signals","text":"Name void progress(int , QString )"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#public-functions","title":"Public Functions","text":"Name QOptimize(QObject * parent =nullptr) virtual ~QOptimize() virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetLocalPoints() overrideReturn the local points. virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetGlobalPoints() overrideReturn the global points. std::vector&lt; Particles &gt; GetParticles() virtual std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; GetProcrustesTransforms() override virtual void UpdateExportablePoints() override"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#protected-functions","title":"Protected Functions","text":"Name virtual void SetIterationCallback() overrideSet the iteration callback. Derived classes should override to set their own callback. void IterateCallbackInternal()"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from shapeworks::Optimize</p> Name using itk::Image&lt; float, 3 &gt; ImageType using VectorFunction::VectorType VectorType using Eigen::MatrixXd MatrixType <p>Public Functions inherited from shapeworks::Optimize</p> Name Optimize()Constructor. virtual ~Optimize()Destructor. bool Run()Run the optimization. bool LoadParameterFile(std::string filename)Load a parameter file. bool SetUpOptimize(ProjectHandle project)Set up this Optimize object using a ShapeWorks project. void SetProject(std::shared_ptr&lt; Project &gt; project)Set the Project object. void SetIterationCallbackFunction(const std::function&lt; void(void)&gt; &amp; f)Set an iteration callback function to be called after each iteration. void AbortOptimization()Abort optimization. bool GetAborted()Return if the optimization was aborted. void SetCutPlanes(std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; cut_planes)Set cutting planes. void SetVerbosity(int verbosity_level)Set the verbosity level (0-5) void SetDomainsPerShape(int domains_per_shape)Set the number of domains per shape. int GetDomainsPerShape()Return the number of domains per shape. void SetDomainType(shapeworks::DomainType type) shapeworks::DomainType GetDomainType() void SetNumberOfParticles(std::vector&lt; int &gt; number_of_particles)Set the numbers of particles (vector of numbers, one for each domain) std::vector&lt; int &gt; GetNumberOfParticles()Return the numbers of particles per domain. void SetTransformFile(std::string filename)Set the transform file. std::string GetTransformFile()Get the transform file. void SetPrefixTransformFile(std::string prefix_transform_file)Set the prefix transform file (TODO: details) std::string GetPrefixTransformFile()Get the prefix transform file. void SetOutputDir(std::string output_dir)Set the output directory. void SetOutputTransformFile(std::string output_transform_file)Set the output transform file. void SetOutputIndividualTransformFiles(bool value)Set whether individual transforms should be written. void SetUseMeshBasedAttributes(bool use_mesh_based_attributes)Set if mesh based attributes should be used. bool GetUseMeshBasedAttributes()Get if mesh based attributes are being used. void SetUseXYZ(std::vector&lt; bool &gt; use_xyz)Set if XYZ is used, one value per domain. void SetUseNormals(std::vector&lt; bool &gt; use_normals)Set if Normals are being used, one value per domain. void SetAttributesPerDomain(std::vector&lt; int &gt; attributes_per_domain)Set the attributes per domain. std::vector&lt; int &gt; GetAttributesPerDomain()Get attributes per domain. void SetDistributionDomainID(int distribution_domain_id)Set the distribution domain ID (TODO: details) int GetDistributionDomainID()Get the distribution domain ID. void SetOutputCuttingPlaneFile(std::string output_cutting_plane_file)Set the output cutting plane file. void SetUseCuttingPlanes(bool use_cutting_planes)Set if using cutting planes. void SetCuttingPlane(unsigned int i, const vnl_vector_fixed&lt; double, 3 &gt; &amp; va, const vnl_vector_fixed&lt; double, 3 &gt; &amp; vb, const vnl_vector_fixed&lt; double, 3 &gt; &amp; vc)Set a given cutting plane for a shape. void SetMeshFFCMode(int mesh_ffc_mode)Set Mesh FFC Mode false/0 = mesh clipping mode, true/1 = mesh augmented lagrangian mode. void SetTimePtsPerSubject(int time_pts_per_subject)Set the number of time points per subject (TODO: details) int GetTimePtsPerSubject()Get the number of time points per subject (TODO: details) void SetOptimizationIterations(int optimization_iterations)Set the number of optimization iterations. void SetOptimizationIterationsCompleted(int optimization_iterations_completed)Set the number of optimization iterations already completed (TODO: details) void SetIterationsPerSplit(int iterations_per_split)Set the number of iterations per split. void SetUseShapeStatisticsInInit(bool use_shape_statistics_in_init)Set if shape statistics should be used in initialization. void SetProcrustesInterval(int procrustes_interval)Set the interval for running procrustes (0 to disable) void SetProcrustesScaling(bool procrustes_scaling)Set if procrustes scaling should be used. void SetProcrustesRotationTranslation(bool procrustes_rotation_translation)Set if procrustes rotation/translation should be used. void SetRelativeWeighting(double relative_weighting)Set the relative weighting (TODO: details) void SetInitialRelativeWeighting(double initial_relative_weighting)Set the initial relative weigting (TODO: details) void SetStartingRegularization(double starting_regularization)Set the starting regularization (TODO: details) void SetEndingRegularization(double ending_regularization)Set the ending regularization (TODO: details) void SetRecomputeRegularizationInterval(int recompute_regularization_interval)Set the interval for recomputing regularization (TODO: details) void SetSaveInitSplits(bool save_init_splits)Set if initialization splits should be saved or not. void SetCheckpointingInterval(int checkpointing_interval)Set the checkpointing interval. void SetKeepCheckpoints(int keep_checkpoints)Set if checkpoints should be kept (0=disable, 1=enable) void SetUseRegression(bool use_regression)Set if regression should be used (TODO: details) void SetUseMixedEffects(bool use_mixed_effects)Set if mixed effects should be used (TODO: details) void SetUseDisentangledSpatiotemporalSSM(bool use_disentangled_ssm_4d)Set if optimization should be done using disentangled spatiotemporal SSM method. bool GetUseDisentangledSpatiotemporalSSM()Returns true if optimization is to be done using disentangled spatiotemporal SSM method. void SetNormalAngle(double normal_angle)For good/bad analysis, set the normal angle to use (TODO: details) void SetPerformGoodBad(bool perform_good_bad)Set if good/bad analysis should be done (TODO: details) void SetLogEnergy(bool log_energy)Set the log energy (TODO: details) void AddImage(ImageType::Pointer image, std::string name =\"\")Set the shape input images. void AddMesh(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void AddContour(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void SetFilenames(const std::vector&lt; std::string &gt; &amp; filenames)Set the shape filenames (TODO: details) void SetPointFiles(const std::vector&lt; std::string &gt; &amp; point_files)Set starting point files (TODO: details) void SetInitialPoints(std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; initial_points)Set initial particle positions (e.g. for fixed subjects) int GetNumShapes()Get number of shapes. void SetAttributeScales(const std::vector&lt; double &gt; &amp; scales)Set attribute scales (TODO: details) void SetFieldAttributes(const std::vector&lt; std::string &gt; &amp; field_attributes)Set the field attributes. void SetParticleFlags(std::vector&lt; int &gt; flags)Set Particle Flags (TODO: details) void SetFixedDomains(std::vector&lt; int &gt; flags)Set Domain Flags (TODO: details) void SetSharedBoundaryEnabled(bool enabled)Shared boundary settings. void SetSharedBoundaryWeight(double weight) void SetEarlyStoppingConfig(EarlyStoppingConfig config)Early Stopping params. const std::vector&lt; int &gt; &amp; GetDomainFlags() void SetFileOutputEnabled(bool enabled)Set if file output is enabled. std::vector&lt; bool &gt; GetUseXYZ()Return if XYZ is used, per shape. std::vector&lt; bool &gt; GetUseNormals()Return if Normals are used, per shape. void SetNarrowBand(double v)Set the narrow band used to be +/- the given value as a multiple of the spacing. double GetNarrowBand()Return the narrow band to be used. void SetUseShapeStatisticsAfter(int num_particles)Set the number of particles when correspondence based multiscale takes over. int GetUseShapeStatisticsAfter()Return the number of particles when correspondence based multiscale takes over. void PrintParamInfo()Print parameter info to stdout. std::shared_ptr&lt; Sampler &gt; GetSampler()Return the Sampler. MatrixContainer GetParticleSystem()Return the particle system as a matrix. void SetPythonFile(std::string filename)Set the python file to run at startup. void SetGeodesicsEnabled(bool is_enabled)Set whether or not geodesics are enabled. bool GetGeodesicsEnabled() const void SetGeodesicsCacheSizeMultiplier(size_t n) void SetGeodesicsRemeshPercent(double percent)Set the remeshing percent for the mesh used for computing geodesics (0-100) OptimizationVisualizer &amp; GetVisualizer() void SetShowVisualizer(bool show) bool GetShowVisualizer() bool GetMeshFFCMode() vnl_vector_fixed&lt; double, 3 &gt; TransformPoint(int domain, vnl_vector_fixed&lt; double, 3 &gt; input)transform a point if necessary void UpdateProgress() void set_particle_format(std::string format) <p>Protected Functions inherited from shapeworks::Optimize</p> Name void ComputeTotalIterations() void OptimizerStop() void ReadTransformFile() void ReadPrefixTransformFile(const std::string &amp; s) void InitializeSampler() double GetMinNeighborhoodRadius() void AddSinglePoint() void Initialize() void RunOptimize() void ComputeEnergyAfterIteration() void SetCotanSigma() void WriteTransformFile(int iter =-1) const void WriteTransformFile(std::string iter_prefix) const void WriteTransformFiles(int iter =-1) const void WriteTransformFiles(std::string iter_prefix) const void WritePointFiles(int iter =-1) void WritePointFiles(std::string iter_prefix) void WritePointFilesWithFeatures(int iter =-1) void WritePointFilesWithFeatures(std::string iter_prefix) void WriteEnergyFiles() void WriteSplitFiles(std::string name) void WriteCuttingPlanePoints(int iter =-1) void WriteParameters(std::string output_dir =\"\") void ReportBadParticles() int SetParameters() void WriteModes() void PrintStartMessage(std::string str, unsigned int vlevel =0) const void PrintDoneMessage(unsigned int vlevel =0) const void UpdateProject() std::string GetCheckpointDir() <p>Protected Attributes inherited from shapeworks::Optimize</p> Name std::shared_ptr&lt; Sampler &gt; m_sampler ProcrustesRegistration::Pointer m_procrustes std::shared_ptr&lt; ParticleGoodBadAssessment &gt; m_good_bad unsigned int m_verbosity_level std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_local_points std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; m_global_points int m_checkpoint_counter int m_procrustes_counter bool m_use_cutting_planes bool m_optimizing bool m_use_regression bool m_use_mixed_effects bool m_use_disentangled_ssm unsigned int m_domains_per_shape shapeworks::DomainType m_domain_type std::vector&lt; int &gt; m_number_of_particles std::string m_transform_file std::string m_prefix_transform_file std::string m_output_dir std::string m_output_transform_file bool m_output_transform_files bool m_mesh_based_attributes std::vector&lt; bool &gt; m_use_xyz std::vector&lt; bool &gt; m_use_normals std::vector&lt; int &gt; m_attributes_per_domain int m_distribution_domain_id std::string m_output_cutting_plane_file bool m_mesh_ffc_mode unsigned int m_timepts_per_subject int m_optimization_iterations int m_optimization_iterations_completed int m_iterations_per_split bool m_use_shape_statistics_in_init unsigned int m_procrustes_interval bool m_procrustes_scaling bool m_procrustes_rotation_translation double m_relative_weighting double m_initial_relative_weighting double m_starting_regularization double m_ending_regularization int m_recompute_regularization_interval bool m_save_init_splits unsigned int m_checkpointing_interval int m_keep_checkpoints double m_cotan_sigma_factor std::vector&lt; int &gt; m_particle_flags std::vector&lt; int &gt; m_domain_flags double m_narrow_band bool m_narrow_band_set bool m_fixed_domains_present int m_use_shape_statistics_after std::string m_python_filename bool m_geodesics_enabled size_t m_geodesic_cache_size_multiplier double m_geodesic_remesh_percent double m_spacing std::vector&lt; std::string &gt; m_filenames int m_num_shapes std::vector&lt; double &gt; m_energy_a std::vector&lt; double &gt; m_energy_b std::vector&lt; double &gt; m_total_energy bool m_log_energy std::string m_str_energy std::vector&lt; std::vector&lt; int &gt; &gt; m_bad_ids double m_normal_angle bool m_perform_good_bad std::vector&lt; int &gt; m_cutting_planes_per_input std::vector&lt; int &gt; m_spheres_per_input bool m_file_output_enabled bool m_aborted std::vector&lt; std::array&lt; itk::Point&lt; double &gt;, 3 &gt; &gt; m_cut_planes int m_total_iterations int m_iteration_count int m_split_number int current_particle_iterations_ int total_particle_iterations_ std::function&lt; void(void)&gt; iteration_callback_ bool show_visualizer_ shapeworks::OptimizationVisualizer visualizer_ std::string particle_format_ std::shared_ptr&lt; Project &gt; project_ std::chrono::system_clock::time_point m_start_time std::chrono::system_clock::time_point m_last_update_time std::chrono::system_clock::time_point m_last_remaining_update_time std::string m_remaining_time_message"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int ,\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-qoptimize","title":"function QOptimize","text":"<pre><code>QOptimize(\n    QObject * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-qoptimize_1","title":"function ~QOptimize","text":"<pre><code>virtual ~QOptimize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-getlocalpoints","title":"function GetLocalPoints","text":"<pre><code>virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetLocalPoints() override\n</code></pre> <p>Return the local points. </p> <p>Reimplements: shapeworks::Optimize::GetLocalPoints</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-getglobalpoints","title":"function GetGlobalPoints","text":"<pre><code>virtual std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; GetGlobalPoints() override\n</code></pre> <p>Return the global points. </p> <p>Reimplements: shapeworks::Optimize::GetGlobalPoints</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-getparticles","title":"function GetParticles","text":"<pre><code>std::vector&lt; Particles &gt; GetParticles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-getprocrustestransforms","title":"function GetProcrustesTransforms","text":"<pre><code>virtual std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; GetProcrustesTransforms() override\n</code></pre> <p>Reimplements: shapeworks::Optimize::GetProcrustesTransforms</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-updateexportablepoints","title":"function UpdateExportablePoints","text":"<pre><code>virtual void UpdateExportablePoints() override\n</code></pre> <p>Reimplements: shapeworks::Optimize::UpdateExportablePoints</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-setiterationcallback","title":"function SetIterationCallback","text":"<pre><code>virtual void SetIterationCallback() override\n</code></pre> <p>Set the iteration callback. Derived classes should override to set their own callback. </p> <p>Reimplements: shapeworks::Optimize::SetIterationCallback</p>"},{"location":"api/Classes/classshapeworks_1_1QOptimize.html#function-iteratecallbackinternal","title":"function IterateCallbackInternal","text":"<pre><code>void IterateCallbackInternal()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html","title":"shapeworks::ReconstructSurface","text":"<p>More...</p>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#public-types","title":"Public Types","text":"Name using typename TransformType::Pointer TransformTypePtr using typename TransformType::PointSetType PointSetType using typename PointSetType::PointIdentifier PointIdType"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#public-functions","title":"Public Functions","text":"Name ReconstructSurface() =default ReconstructSurface(const std::string &amp; denseFile, const std::string &amp; sparseFile, const std::string &amp; goodPointsFile) double computeAverageDistanceToNeighbors(vtkSmartPointer&lt; vtkPoints &gt; points, std::vector&lt; int &gt; particlesIndices) void checkMapping(TransformTypePtr transform, vtkSmartPointer&lt; vtkPoints &gt; sourcePoints, vtkSmartPointer&lt; vtkPoints &gt; targetPoints) void generateWarpedMeshes(TransformTypePtr transform, vtkSmartPointer&lt; vtkPolyData &gt; &amp; outputMesh) Mesh getMesh(PointArray localPoints) vtkSmartPointer&lt; vtkPoints &gt; convertToImageCoordinates(vtkSmartPointer&lt; vtkPoints &gt; particles, const Vector &amp; spacing, const Point3 &amp; origin) int computeMedianShape(std::vector&lt; Eigen::MatrixXd &gt; &amp; shapeList) void performKMeansClustering(std::vector&lt; PointArray &gt; worldPoints, int numberOfParticles, std::vector&lt; int &gt; &amp; centroidIndices) Eigen::MatrixXd computeParticlesNormals(vtkSmartPointer&lt; vtkPoints &gt; particles, Image dt) vtkSmartPointer&lt; vtkPolyData &gt; getDenseMean(std::vector&lt; PointArray &gt; localPoints, std::vector&lt; PointArray &gt; worldPoints, std::vector&lt; std::string &gt; distance_transform) void computeDenseMean(std::vector&lt; PointArray &gt; localPoints, std::vector&lt; PointArray &gt; worldPoints, std::vector&lt; std::string &gt; distanceTransform) std::vector&lt; PointArray &gt; computeSparseMean(std::vector&lt; PointArray &gt; localPoints, Point3 commonCenter) void writeMeanInfo() void surface(const std::vector&lt; std::string &gt; localPointsFiles) void samplesAlongPCAModes(const std::vector&lt; std::string &gt; worldPointsFiles) void meanSurface(const std::vector&lt; std::string &gt; distanceTransformFiles, const std::vector&lt; std::string &gt; localPointsFiles, const std::vector&lt; std::string &gt; worldPointsFiles) void setOutPrefix(std::string prefix) void setOutPath(std::string path) void setDoProcrustes(bool doProcrusts) void setDoProcrustesScaling(bool doProcrustsScaling) void setPairwiseNormalsDiffForGoodBad(bool pairwiseNormalsDiffForGoodBad) void setMeanBeforeWarp(bool meanBeforeWarp) void setEnableOutput(bool enableOutput) void setModeIndex(int modeIndex) void setNumOfModes(int numOfModes) void setNumOfSamplesPerMode(int numOfSamplesPerMode) void setNumOfParticles(int numOfParticles) void setNumOfClusters(int numOfClusters) void setMaxStdDev(float maxStdDev) void setMaxVarianceCaptured(float maxVarianceCaptured) void setMaxAngleDegrees(float maxAngleDegrees)"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class TransformType &gt;\nclass shapeworks::ReconstructSurface;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#using-transformtypeptr","title":"using TransformTypePtr","text":"<pre><code>using shapeworks::ReconstructSurface&lt; TransformType &gt;::TransformTypePtr =  typename TransformType::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#using-pointsettype","title":"using PointSetType","text":"<pre><code>using shapeworks::ReconstructSurface&lt; TransformType &gt;::PointSetType =  typename TransformType::PointSetType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#using-pointidtype","title":"using PointIdType","text":"<pre><code>using shapeworks::ReconstructSurface&lt; TransformType &gt;::PointIdType =  typename PointSetType::PointIdentifier;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-reconstructsurface","title":"function ReconstructSurface","text":"<pre><code>ReconstructSurface() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-reconstructsurface_1","title":"function ReconstructSurface","text":"<pre><code>ReconstructSurface(\n    const std::string &amp; denseFile,\n    const std::string &amp; sparseFile,\n    const std::string &amp; goodPointsFile\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-computeaveragedistancetoneighbors","title":"function computeAverageDistanceToNeighbors","text":"<pre><code>double computeAverageDistanceToNeighbors(\n    vtkSmartPointer&lt; vtkPoints &gt; points,\n    std::vector&lt; int &gt; particlesIndices\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-checkmapping","title":"function checkMapping","text":"<pre><code>void checkMapping(\n    TransformTypePtr transform,\n    vtkSmartPointer&lt; vtkPoints &gt; sourcePoints,\n    vtkSmartPointer&lt; vtkPoints &gt; targetPoints\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-generatewarpedmeshes","title":"function generateWarpedMeshes","text":"<pre><code>void generateWarpedMeshes(\n    TransformTypePtr transform,\n    vtkSmartPointer&lt; vtkPolyData &gt; &amp; outputMesh\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-getmesh","title":"function getMesh","text":"<pre><code>Mesh getMesh(\n    PointArray localPoints\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-converttoimagecoordinates","title":"function convertToImageCoordinates","text":"<pre><code>vtkSmartPointer&lt; vtkPoints &gt; convertToImageCoordinates(\n    vtkSmartPointer&lt; vtkPoints &gt; particles,\n    const Vector &amp; spacing,\n    const Point3 &amp; origin\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-computemedianshape","title":"function computeMedianShape","text":"<pre><code>int computeMedianShape(\n    std::vector&lt; Eigen::MatrixXd &gt; &amp; shapeList\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-performkmeansclustering","title":"function performKMeansClustering","text":"<pre><code>void performKMeansClustering(\n    std::vector&lt; PointArray &gt; worldPoints,\n    int numberOfParticles,\n    std::vector&lt; int &gt; &amp; centroidIndices\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-computeparticlesnormals","title":"function computeParticlesNormals","text":"<pre><code>Eigen::MatrixXd computeParticlesNormals(\n    vtkSmartPointer&lt; vtkPoints &gt; particles,\n    Image dt\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-getdensemean","title":"function getDenseMean","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; getDenseMean(\n    std::vector&lt; PointArray &gt; localPoints,\n    std::vector&lt; PointArray &gt; worldPoints,\n    std::vector&lt; std::string &gt; distance_transform\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-computedensemean","title":"function computeDenseMean","text":"<pre><code>void computeDenseMean(\n    std::vector&lt; PointArray &gt; localPoints,\n    std::vector&lt; PointArray &gt; worldPoints,\n    std::vector&lt; std::string &gt; distanceTransform\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-computesparsemean","title":"function computeSparseMean","text":"<pre><code>std::vector&lt; PointArray &gt; computeSparseMean(\n    std::vector&lt; PointArray &gt; localPoints,\n    Point3 commonCenter\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-writemeaninfo","title":"function writeMeanInfo","text":"<pre><code>void writeMeanInfo()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-surface","title":"function surface","text":"<pre><code>void surface(\n    const std::vector&lt; std::string &gt; localPointsFiles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-samplesalongpcamodes","title":"function samplesAlongPCAModes","text":"<pre><code>void samplesAlongPCAModes(\n    const std::vector&lt; std::string &gt; worldPointsFiles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-meansurface","title":"function meanSurface","text":"<pre><code>void meanSurface(\n    const std::vector&lt; std::string &gt; distanceTransformFiles,\n    const std::vector&lt; std::string &gt; localPointsFiles,\n    const std::vector&lt; std::string &gt; worldPointsFiles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setoutprefix","title":"function setOutPrefix","text":"<pre><code>inline void setOutPrefix(\n    std::string prefix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setoutpath","title":"function setOutPath","text":"<pre><code>inline void setOutPath(\n    std::string path\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setdoprocrustes","title":"function setDoProcrustes","text":"<pre><code>inline void setDoProcrustes(\n    bool doProcrusts\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setdoprocrustesscaling","title":"function setDoProcrustesScaling","text":"<pre><code>inline void setDoProcrustesScaling(\n    bool doProcrustsScaling\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setpairwisenormalsdiffforgoodbad","title":"function setPairwiseNormalsDiffForGoodBad","text":"<pre><code>inline void setPairwiseNormalsDiffForGoodBad(\n    bool pairwiseNormalsDiffForGoodBad\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setmeanbeforewarp","title":"function setMeanBeforeWarp","text":"<pre><code>inline void setMeanBeforeWarp(\n    bool meanBeforeWarp\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setenableoutput","title":"function setEnableOutput","text":"<pre><code>inline void setEnableOutput(\n    bool enableOutput\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setmodeindex","title":"function setModeIndex","text":"<pre><code>inline void setModeIndex(\n    int modeIndex\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setnumofmodes","title":"function setNumOfModes","text":"<pre><code>inline void setNumOfModes(\n    int numOfModes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setnumofsamplespermode","title":"function setNumOfSamplesPerMode","text":"<pre><code>inline void setNumOfSamplesPerMode(\n    int numOfSamplesPerMode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setnumofparticles","title":"function setNumOfParticles","text":"<pre><code>inline void setNumOfParticles(\n    int numOfParticles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setnumofclusters","title":"function setNumOfClusters","text":"<pre><code>inline void setNumOfClusters(\n    int numOfClusters\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setmaxstddev","title":"function setMaxStdDev","text":"<pre><code>inline void setMaxStdDev(\n    float maxStdDev\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setmaxvariancecaptured","title":"function setMaxVarianceCaptured","text":"<pre><code>inline void setMaxVarianceCaptured(\n    float maxVarianceCaptured\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ReconstructSurface.html#function-setmaxangledegrees","title":"function setMaxAngleDegrees","text":"<pre><code>inline void setMaxAngleDegrees(\n    float maxAngleDegrees\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html","title":"shapeworks::Sampler","text":""},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-classes","title":"Public Classes","text":"Name struct CuttingPlaneType struct SphereType"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-types","title":"Public Types","text":"Name using float PixelType using itk::Image&lt; PixelType, Dimension &gt; ImageType using ImageType::PointType PointType using MeanCurvatureContainer&lt; PixelType, Dimension &gt; MeanCurvatureCacheType using vnl_matrix_fixed&lt; double, Dimension+1, Dimension+1 &gt; TransformType using GradientDescentOptimizer OptimizerType using std::vector&lt; std::vector&lt; std::pair&lt; Eigen::Vector3d, Eigen::Vector3d &gt; &gt; &gt; CuttingPlaneList"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-functions","title":"Public Functions","text":"Name Sampler()Constructor. virtual ~Sampler()Destructor. ParticleSystem * GetParticleSystem()Returns the particle system. const ParticleSystem * GetParticleSystem() const std::shared_ptr&lt; SamplingFunction &gt; GetCurvatureGradientFunction() std::shared_ptr&lt; OptimizerType &gt; GetOptimizer()Return a pointer to the optimizer object. std::shared_ptr&lt; const OptimizerType &gt; GetOptimizer() const void SetPointsFile(unsigned int i, const std::string &amp; s) void SetPointsFile(const std::string &amp; s) void SetInitialPoints(std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; initial_points)Set initial particle positions (e.g. for fixed subjects) void AddImage(ImageType::Pointer image, double narrow_band, std::string name =\"\") void ApplyConstraintsToZeroCrossing() void AddMesh(std::shared_ptr&lt; shapeworks::Surface &gt; mesh, double geodesic_remesh_percent =100) void AddContour(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void SetFieldAttributes(const std::vector&lt; std::string &gt; &amp; s) void SetDomainsPerShape(int n) void SetCuttingPlane(unsigned int i, const vnl_vector_fixed&lt; double, Dimension &gt; &amp; va, const vnl_vector_fixed&lt; double, Dimension &gt; &amp; vb, const vnl_vector_fixed&lt; double, Dimension &gt; &amp; vc) void AddFreeFormConstraint(int domain, const FreeFormConstraint &amp; ffc) void TransformCuttingPlanes(unsigned int i) void AddSphere(unsigned int i, vnl_vector_fixed&lt; double, Dimension &gt; &amp; c, double r) void SetAdaptivityMode() void SetCorrespondenceOn() void SetCorrespondenceOff() void SetSamplingOn() void SetSamplingOff() bool GetCorrespondenceOn() const bool GetSamplingOn() const void SetCorrespondenceMode(shapeworks::CorrespondenceMode mode) void RegisterGeneralShapeMatrices() void SetAttributeScales(const std::vector&lt; double &gt; &amp; s) void SetXYZ(unsigned int i, bool flag) void SetNormals(int i, bool flag) void SetAttributesPerDomain(const std::vector&lt; int &gt; s) LegacyShapeMatrix * GetShapeMatrix() ShapeMatrix * GetGeneralShapeMatrix() ShapeGradientMatrix * GetGeneralShapeGradientMatrix() DualVectorFunction * GetLinkingFunction() LegacyCorrespondenceFunction * GetEnsembleEntropyFunction() DisentangledCorrespondenceFunction * GetDisentangledEnsembleEntropyFunction() LegacyCorrespondenceFunction * GetEnsembleRegressionEntropyFunction() LegacyCorrespondenceFunction * GetEnsembleMixedEffectsEntropyFunction() CorrespondenceFunction * GetMeshBasedGeneralEntropyGradientFunction() const DualVectorFunction * GetLinkingFunction() const const LegacyCorrespondenceFunction * GetEnsembleEntropyFunction() const const DisentangledCorrespondenceFunction * GetDisentangledEnsembleEntropyFunction() const const LegacyCorrespondenceFunction * GetEnsembleRegressionEntropyFunction() const const LegacyCorrespondenceFunction * GetEnsembleMixedEffectsEntropyFunction() const const CorrespondenceFunction * GetMeshBasedGeneralEntropyGradientFunction() const void SetTimeptsPerIndividual(int n) shapeworks::CorrespondenceMode GetCorrespondenceMode() const void SetTransformFile(const std::string &amp; s) void SetTransformFile(const char * s) void SetPrefixTransformFile(const std::string &amp; s) void SetPrefixTransformFile(const char * s) void SetPairwisePotentialType(int pairwise_potential_type) int GetPairwisePotentialType() void SetVerbosity(unsigned int val) unsigned int GetVerbosity() void SetSharedBoundaryEnabled(bool enabled) void SetSharedBoundaryWeight(double weight) void SetEarlyStoppingConfig(EarlyStoppingConfig config) void ReadTransforms() void ReadPointsFiles() void AllocateDataCaches() void AllocateDomainsAndNeighborhoods() void InitializeOptimizationFunctions() void initialize_initial_positions() void Initialize() void ReInitialize() void Execute() CuttingPlaneList ComputeCuttingPlanes() Eigen::Vector3d ComputePlaneNormal(const vnl_vector&lt; double &gt; &amp; a, const vnl_vector&lt; double &gt; &amp; b, const vnl_vector&lt; double &gt; &amp; c) std::vector&lt; FreeFormConstraint &gt; GetFFCs() void SetMeshFFCMode(bool mesh_ffc_mode)"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-attributes","title":"Public Attributes","text":"Name constexpr unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-pixeltype","title":"using PixelType","text":"<pre><code>using shapeworks::Sampler::PixelType =  float;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::Sampler::ImageType =  itk::Image&lt;PixelType, Dimension&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::Sampler::PointType =  ImageType::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-meancurvaturecachetype","title":"using MeanCurvatureCacheType","text":"<pre><code>using shapeworks::Sampler::MeanCurvatureCacheType =  MeanCurvatureContainer&lt;PixelType, Dimension&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-transformtype","title":"using TransformType","text":"<pre><code>using shapeworks::Sampler::TransformType =  vnl_matrix_fixed&lt;double, Dimension + 1, Dimension + 1&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-optimizertype","title":"using OptimizerType","text":"<pre><code>using shapeworks::Sampler::OptimizerType =  GradientDescentOptimizer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#using-cuttingplanelist","title":"using CuttingPlaneList","text":"<pre><code>using shapeworks::Sampler::CuttingPlaneList =  std::vector&lt;std::vector&lt;std::pair&lt;Eigen::Vector3d, Eigen::Vector3d&gt; &gt;&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-sampler","title":"function Sampler","text":"<pre><code>Sampler()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-sampler_1","title":"function ~Sampler","text":"<pre><code>inline virtual ~Sampler()\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getparticlesystem","title":"function GetParticleSystem","text":"<pre><code>inline ParticleSystem * GetParticleSystem()\n</code></pre> <p>Returns the particle system. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getparticlesystem_1","title":"function GetParticleSystem","text":"<pre><code>inline const ParticleSystem * GetParticleSystem() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getcurvaturegradientfunction","title":"function GetCurvatureGradientFunction","text":"<pre><code>inline std::shared_ptr&lt; SamplingFunction &gt; GetCurvatureGradientFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getoptimizer","title":"function GetOptimizer","text":"<pre><code>inline std::shared_ptr&lt; OptimizerType &gt; GetOptimizer()\n</code></pre> <p>Return a pointer to the optimizer object. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getoptimizer_1","title":"function GetOptimizer","text":"<pre><code>inline std::shared_ptr&lt; const OptimizerType &gt; GetOptimizer() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setpointsfile","title":"function SetPointsFile","text":"<pre><code>inline void SetPointsFile(\n    unsigned int i,\n    const std::string &amp; s\n)\n</code></pre> <p>Optionally provide a filename for an initial point set. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setpointsfile_1","title":"function SetPointsFile","text":"<pre><code>inline void SetPointsFile(\n    const std::string &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setinitialpoints","title":"function SetInitialPoints","text":"<pre><code>inline void SetInitialPoints(\n    std::vector&lt; std::vector&lt; itk::Point&lt; double &gt; &gt; &gt; initial_points\n)\n</code></pre> <p>Set initial particle positions (e.g. for fixed subjects) </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-addimage","title":"function AddImage","text":"<pre><code>void AddImage(\n    ImageType::Pointer image,\n    double narrow_band,\n    std::string name =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-applyconstraintstozerocrossing","title":"function ApplyConstraintsToZeroCrossing","text":"<pre><code>inline void ApplyConstraintsToZeroCrossing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-addmesh","title":"function AddMesh","text":"<pre><code>void AddMesh(\n    std::shared_ptr&lt; shapeworks::Surface &gt; mesh,\n    double geodesic_remesh_percent =100\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-addcontour","title":"function AddContour","text":"<pre><code>void AddContour(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setfieldattributes","title":"function SetFieldAttributes","text":"<pre><code>void SetFieldAttributes(\n    const std::vector&lt; std::string &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setcuttingplane","title":"function SetCuttingPlane","text":"<pre><code>void SetCuttingPlane(\n    unsigned int i,\n    const vnl_vector_fixed&lt; double, Dimension &gt; &amp; va,\n    const vnl_vector_fixed&lt; double, Dimension &gt; &amp; vb,\n    const vnl_vector_fixed&lt; double, Dimension &gt; &amp; vc\n)\n</code></pre> <p>Optionally supply a cutting plane that will be set as a particle optimization constraint in the image domains. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-addfreeformconstraint","title":"function AddFreeFormConstraint","text":"<pre><code>void AddFreeFormConstraint(\n    int domain,\n    const FreeFormConstraint &amp; ffc\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-transformcuttingplanes","title":"function TransformCuttingPlanes","text":"<pre><code>void TransformCuttingPlanes(\n    unsigned int i\n)\n</code></pre> <p>Transform a cutting plane based on procrustes transformation </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-addsphere","title":"function AddSphere","text":"<pre><code>void AddSphere(\n    unsigned int i,\n    vnl_vector_fixed&lt; double, Dimension &gt; &amp; c,\n    double r\n)\n</code></pre> <p>Optionally add spheres that may be used as constraints to the domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setadaptivitymode","title":"function SetAdaptivityMode","text":"<pre><code>inline void SetAdaptivityMode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setcorrespondenceon","title":"function SetCorrespondenceOn","text":"<pre><code>inline void SetCorrespondenceOn()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setcorrespondenceoff","title":"function SetCorrespondenceOff","text":"<pre><code>inline void SetCorrespondenceOff()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setsamplingon","title":"function SetSamplingOn","text":"<pre><code>inline void SetSamplingOn()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setsamplingoff","title":"function SetSamplingOff","text":"<pre><code>inline void SetSamplingOff()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getcorrespondenceon","title":"function GetCorrespondenceOn","text":"<pre><code>inline bool GetCorrespondenceOn() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getsamplingon","title":"function GetSamplingOn","text":"<pre><code>inline bool GetSamplingOn() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setcorrespondencemode","title":"function SetCorrespondenceMode","text":"<pre><code>void SetCorrespondenceMode(\n    shapeworks::CorrespondenceMode mode\n)\n</code></pre> <p>This method sets the optimization function for correspondences between surfaces (domains). </p>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-registergeneralshapematrices","title":"function RegisterGeneralShapeMatrices","text":"<pre><code>inline void RegisterGeneralShapeMatrices()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setattributescales","title":"function SetAttributeScales","text":"<pre><code>inline void SetAttributeScales(\n    const std::vector&lt; double &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setxyz","title":"function SetXYZ","text":"<pre><code>inline void SetXYZ(\n    unsigned int i,\n    bool flag\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setnormals","title":"function SetNormals","text":"<pre><code>inline void SetNormals(\n    int i,\n    bool flag\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setattributesperdomain","title":"function SetAttributesPerDomain","text":"<pre><code>void SetAttributesPerDomain(\n    const std::vector&lt; int &gt; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getshapematrix","title":"function GetShapeMatrix","text":"<pre><code>inline LegacyShapeMatrix * GetShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getgeneralshapematrix","title":"function GetGeneralShapeMatrix","text":"<pre><code>inline ShapeMatrix * GetGeneralShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getgeneralshapegradientmatrix","title":"function GetGeneralShapeGradientMatrix","text":"<pre><code>inline ShapeGradientMatrix * GetGeneralShapeGradientMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getlinkingfunction","title":"function GetLinkingFunction","text":"<pre><code>inline DualVectorFunction * GetLinkingFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensembleentropyfunction","title":"function GetEnsembleEntropyFunction","text":"<pre><code>inline LegacyCorrespondenceFunction * GetEnsembleEntropyFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getdisentangledensembleentropyfunction","title":"function GetDisentangledEnsembleEntropyFunction","text":"<pre><code>inline DisentangledCorrespondenceFunction * GetDisentangledEnsembleEntropyFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensembleregressionentropyfunction","title":"function GetEnsembleRegressionEntropyFunction","text":"<pre><code>inline LegacyCorrespondenceFunction * GetEnsembleRegressionEntropyFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensemblemixedeffectsentropyfunction","title":"function GetEnsembleMixedEffectsEntropyFunction","text":"<pre><code>inline LegacyCorrespondenceFunction * GetEnsembleMixedEffectsEntropyFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getmeshbasedgeneralentropygradientfunction","title":"function GetMeshBasedGeneralEntropyGradientFunction","text":"<pre><code>inline CorrespondenceFunction * GetMeshBasedGeneralEntropyGradientFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getlinkingfunction_1","title":"function GetLinkingFunction","text":"<pre><code>inline const DualVectorFunction * GetLinkingFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensembleentropyfunction_1","title":"function GetEnsembleEntropyFunction","text":"<pre><code>inline const LegacyCorrespondenceFunction * GetEnsembleEntropyFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getdisentangledensembleentropyfunction_1","title":"function GetDisentangledEnsembleEntropyFunction","text":"<pre><code>inline const DisentangledCorrespondenceFunction * GetDisentangledEnsembleEntropyFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensembleregressionentropyfunction_1","title":"function GetEnsembleRegressionEntropyFunction","text":"<pre><code>inline const LegacyCorrespondenceFunction * GetEnsembleRegressionEntropyFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getensemblemixedeffectsentropyfunction_1","title":"function GetEnsembleMixedEffectsEntropyFunction","text":"<pre><code>inline const LegacyCorrespondenceFunction * GetEnsembleMixedEffectsEntropyFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getmeshbasedgeneralentropygradientfunction_1","title":"function GetMeshBasedGeneralEntropyGradientFunction","text":"<pre><code>inline const CorrespondenceFunction * GetMeshBasedGeneralEntropyGradientFunction() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-settimeptsperindividual","title":"function SetTimeptsPerIndividual","text":"<pre><code>inline void SetTimeptsPerIndividual(\n    int n\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getcorrespondencemode","title":"function GetCorrespondenceMode","text":"<pre><code>inline shapeworks::CorrespondenceMode GetCorrespondenceMode() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-settransformfile","title":"function SetTransformFile","text":"<pre><code>inline void SetTransformFile(\n    const std::string &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-settransformfile_1","title":"function SetTransformFile","text":"<pre><code>inline void SetTransformFile(\n    const char * s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setprefixtransformfile","title":"function SetPrefixTransformFile","text":"<pre><code>inline void SetPrefixTransformFile(\n    const std::string &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setprefixtransformfile_1","title":"function SetPrefixTransformFile","text":"<pre><code>inline void SetPrefixTransformFile(\n    const char * s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setpairwisepotentialtype","title":"function SetPairwisePotentialType","text":"<pre><code>inline void SetPairwisePotentialType(\n    int pairwise_potential_type\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getpairwisepotentialtype","title":"function GetPairwisePotentialType","text":"<pre><code>inline int GetPairwisePotentialType()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setverbosity","title":"function SetVerbosity","text":"<pre><code>inline void SetVerbosity(\n    unsigned int val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getverbosity","title":"function GetVerbosity","text":"<pre><code>inline unsigned int GetVerbosity()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setsharedboundaryenabled","title":"function SetSharedBoundaryEnabled","text":"<pre><code>inline void SetSharedBoundaryEnabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setsharedboundaryweight","title":"function SetSharedBoundaryWeight","text":"<pre><code>inline void SetSharedBoundaryWeight(\n    double weight\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setearlystoppingconfig","title":"function SetEarlyStoppingConfig","text":"<pre><code>inline void SetEarlyStoppingConfig(\n    EarlyStoppingConfig config\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-readtransforms","title":"function ReadTransforms","text":"<pre><code>void ReadTransforms()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-readpointsfiles","title":"function ReadPointsFiles","text":"<pre><code>void ReadPointsFiles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-allocatedatacaches","title":"function AllocateDataCaches","text":"<pre><code>void AllocateDataCaches()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-allocatedomainsandneighborhoods","title":"function AllocateDomainsAndNeighborhoods","text":"<pre><code>void AllocateDomainsAndNeighborhoods()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-initializeoptimizationfunctions","title":"function InitializeOptimizationFunctions","text":"<pre><code>void InitializeOptimizationFunctions()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-initialize_initial_positions","title":"function initialize_initial_positions","text":"<pre><code>void initialize_initial_positions()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-initialize","title":"function Initialize","text":"<pre><code>inline void Initialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-reinitialize","title":"function ReInitialize","text":"<pre><code>void ReInitialize()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-execute","title":"function Execute","text":"<pre><code>void Execute()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-computecuttingplanes","title":"function ComputeCuttingPlanes","text":"<pre><code>CuttingPlaneList ComputeCuttingPlanes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-computeplanenormal","title":"function ComputePlaneNormal","text":"<pre><code>Eigen::Vector3d ComputePlaneNormal(\n    const vnl_vector&lt; double &gt; &amp; a,\n    const vnl_vector&lt; double &gt; &amp; b,\n    const vnl_vector&lt; double &gt; &amp; c\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-getffcs","title":"function GetFFCs","text":"<pre><code>inline std::vector&lt; FreeFormConstraint &gt; GetFFCs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#function-setmeshffcmode","title":"function SetMeshFFCMode","text":"<pre><code>inline void SetMeshFFCMode(\n    bool mesh_ffc_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Sampler.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Sampler.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr unsigned int Dimension = 3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html","title":"shapeworks::SamplingFunction","text":"<p>More...</p> <p><code>#include &lt;SamplingFunction.h&gt;</code></p> <p>Inherits from shapeworks::VectorFunction</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-types","title":"Public Types","text":"Name using vnl_vector_fixed&lt; double, 3 &gt; VectorType using ParticleSystem::PointType PointType using vnl_vector_fixed&lt; float, 3 &gt; GradientVectorType using GenericContainerArray&lt; double &gt; SigmaCacheType"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-functions","title":"Public Functions","text":"Name std::shared_ptr&lt; SamplingFunction &gt; New()Factory method for creating instances. virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep) const override virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; , double &amp; ) const override virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) override virtual double energy(unsigned int a, unsigned int b, const ParticleSystem * c) const override double EstimateSigma(unsigned int idx, unsigned int dom, const shapeworks::ParticleDomain * domain, const PointType &amp; pos, double initial_sigma, double precision, int &amp; err, double &amp; avg_kappa) const void SetSharedBoundaryWeight(double w) double GetSharedBoundaryWeight() const void SetSharedBoundaryEnabled(bool enabled) bool GetSharedBoundaryEnabled() const void SetSpatialSigmaCache(SigmaCacheType * s) SigmaCacheType * GetSpatialSigmaCache() const SigmaCacheType * GetSpatialSigmaCache() const void SetMinimumNeighborhoodRadius(double s) double GetMinimumNeighborhoodRadius() const void SetMaximumNeighborhoodRadius(double s) double GetMaximumNeighborhoodRadius() const void SetFlatCutoff(double s) double GetFlatCutoff() const void SetNeighborhoodToSigmaRatio(double s) double GetNeighborhoodToSigmaRatio() const virtual void reset_buffers() overrideMay be called by the solver class. virtual std::shared_ptr&lt; VectorFunction &gt; clone() override SamplingFunction() ~SamplingFunction() override =default"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static int VDimension"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::VectorFunction</p> Name virtual void after_iteration()This method is called by a solver after each iteration. virtual void before_iteration()This method is called by a solver before each iteration. virtual void set_particle_system(ParticleSystem * p)Some subclasses may require a pointer to the particle system and its domain number. virtual ParticleSystem * get_particle_system() const virtual void set_domain_number(unsigned int i) virtual int get_domain_number() const virtual double get_relative_energy_scaling() const virtual void set_relative_energy_scaling(double r) virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes. <p>Protected Functions inherited from shapeworks::VectorFunction</p> Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete <p>Public Attributes inherited from shapeworks::VectorFunction</p> Name constexpr static unsigned int Dimension <p>Protected Attributes inherited from shapeworks::VectorFunction</p> Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::SamplingFunction;\n</code></pre> <p>This function is responsible for the sampling term of the optimization. E.g. the repulsion force between particles on a single shape </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::SamplingFunction::VectorType =  vnl_vector_fixed&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::SamplingFunction::PointType =  ParticleSystem::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#using-gradientvectortype","title":"using GradientVectorType","text":"<pre><code>using shapeworks::SamplingFunction::GradientVectorType =  vnl_vector_fixed&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#using-sigmacachetype","title":"using SigmaCacheType","text":"<pre><code>using shapeworks::SamplingFunction::SigmaCacheType =  GenericContainerArray&lt;double&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-new","title":"function New","text":"<pre><code>static inline std::shared_ptr&lt; SamplingFunction &gt; New()\n</code></pre> <p>Factory method for creating instances. </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>inline virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep\n) const override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; ,\n    double &amp; \n) const override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::evaluate</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-before_evaluate","title":"function before_evaluate","text":"<pre><code>virtual void before_evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * \n) override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::before_evaluate</p> <p>This method may be called to set up the state of the function object before a call to evaluate. It is necessary in order to initialize certain constants and variables that may be used for calculating the energy as well as the gradients. Typically this is only necessary for the adaptive gradient descent algorithm. </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-energy","title":"function energy","text":"<pre><code>inline virtual double energy(\n    unsigned int a,\n    unsigned int b,\n    const ParticleSystem * c\n) const override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-estimatesigma","title":"function EstimateSigma","text":"<pre><code>double EstimateSigma(\n    unsigned int idx,\n    unsigned int dom,\n    const shapeworks::ParticleDomain * domain,\n    const PointType &amp; pos,\n    double initial_sigma,\n    double precision,\n    int &amp; err,\n    double &amp; avg_kappa\n) const\n</code></pre> <p>Estimate the best sigma for Parzen windowing in a given neighborhood. The best sigma is the sigma that maximizes probability at the given point </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setsharedboundaryweight","title":"function SetSharedBoundaryWeight","text":"<pre><code>inline void SetSharedBoundaryWeight(\n    double w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getsharedboundaryweight","title":"function GetSharedBoundaryWeight","text":"<pre><code>inline double GetSharedBoundaryWeight() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setsharedboundaryenabled","title":"function SetSharedBoundaryEnabled","text":"<pre><code>inline void SetSharedBoundaryEnabled(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getsharedboundaryenabled","title":"function GetSharedBoundaryEnabled","text":"<pre><code>inline bool GetSharedBoundaryEnabled() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setspatialsigmacache","title":"function SetSpatialSigmaCache","text":"<pre><code>inline void SetSpatialSigmaCache(\n    SigmaCacheType * s\n)\n</code></pre> <p>Access the cache of sigma values for each particle position. This cache is populated by registering this object as an observer of the correct particle system (see SetParticleSystem). </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getspatialsigmacache","title":"function GetSpatialSigmaCache","text":"<pre><code>inline SigmaCacheType * GetSpatialSigmaCache()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getspatialsigmacache_1","title":"function GetSpatialSigmaCache","text":"<pre><code>inline const SigmaCacheType * GetSpatialSigmaCache() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setminimumneighborhoodradius","title":"function SetMinimumNeighborhoodRadius","text":"<pre><code>inline void SetMinimumNeighborhoodRadius(\n    double s\n)\n</code></pre> <p>Minimum radius of the neighborhood of points that are considered in the calculation. The neighborhood is a spherical radius in 3D space. The actual radius used in a calculation may exceed this value, but will not exceed the MaximumNeighborhoodRadius. </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getminimumneighborhoodradius","title":"function GetMinimumNeighborhoodRadius","text":"<pre><code>inline double GetMinimumNeighborhoodRadius() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setmaximumneighborhoodradius","title":"function SetMaximumNeighborhoodRadius","text":"<pre><code>inline void SetMaximumNeighborhoodRadius(\n    double s\n)\n</code></pre> <p>Maximum radius of the neighborhood of points that are considered in the calculation. The neighborhood is a spherical radius in 3D space. </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getmaximumneighborhoodradius","title":"function GetMaximumNeighborhoodRadius","text":"<pre><code>inline double GetMaximumNeighborhoodRadius() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setflatcutoff","title":"function SetFlatCutoff","text":"<pre><code>inline void SetFlatCutoff(\n    double s\n)\n</code></pre> <p>Numerical parameters </p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getflatcutoff","title":"function GetFlatCutoff","text":"<pre><code>inline double GetFlatCutoff() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-setneighborhoodtosigmaratio","title":"function SetNeighborhoodToSigmaRatio","text":"<pre><code>inline void SetNeighborhoodToSigmaRatio(\n    double s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-getneighborhoodtosigmaratio","title":"function GetNeighborhoodToSigmaRatio","text":"<pre><code>inline double GetNeighborhoodToSigmaRatio() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-reset_buffers","title":"function reset_buffers","text":"<pre><code>inline virtual void reset_buffers() override\n</code></pre> <p>May be called by the solver class. </p> <p>Reimplements: shapeworks::VectorFunction::reset_buffers</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-clone","title":"function clone","text":"<pre><code>virtual std::shared_ptr&lt; VectorFunction &gt; clone() override\n</code></pre> <p>Reimplements: shapeworks::VectorFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-samplingfunction","title":"function SamplingFunction","text":"<pre><code>inline SamplingFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#function-samplingfunction_1","title":"function ~SamplingFunction","text":"<pre><code>~SamplingFunction() override =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SamplingFunction.html#variable-vdimension","title":"variable VDimension","text":"<pre><code>static constexpr static int VDimension = 3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ScopedTimer.html","title":"shapeworks::ScopedTimer","text":""},{"location":"api/Classes/classshapeworks_1_1ScopedTimer.html#public-functions","title":"Public Functions","text":"Name ScopedTimer(const QString &amp; name) ~ScopedTimer()"},{"location":"api/Classes/classshapeworks_1_1ScopedTimer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ScopedTimer.html#function-scopedtimer","title":"function ScopedTimer","text":"<pre><code>ScopedTimer(\n    const QString &amp; name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ScopedTimer.html#function-scopedtimer_1","title":"function ~ScopedTimer","text":"<pre><code>~ScopedTimer()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html","title":"shapeworks::SegmentationToolPanel","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#public-signals","title":"Public Signals","text":"Name void update_view()"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#public-functions","title":"Public Functions","text":"Name SegmentationToolPanel(QWidget * parent =0) ~SegmentationToolPanel() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the session void reset()"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#function-segmentationtoolpanel","title":"function SegmentationToolPanel","text":"<pre><code>SegmentationToolPanel(\n    QWidget * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#function-segmentationtoolpanel_1","title":"function ~SegmentationToolPanel","text":"<pre><code>~SegmentationToolPanel()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the session </p>"},{"location":"api/Classes/classshapeworks_1_1SegmentationToolPanel.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Session.html","title":"shapeworks::Session","text":"<p>Representation of a session.  More...</p> <p><code>#include &lt;Session.h&gt;</code></p> <p>Inherits from QObject, QEnableSharedFromThis&lt; Session &gt;</p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-types","title":"Public Types","text":"Name using Analyze::AlignmentType AlignmentType"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-slots","title":"Public Slots","text":"Name void set_feature_auto_scale(bool value) void set_landmark_drag_mode(bool mode) bool get_landmark_drag_mode() void handle_clear_cache() void handle_new_mesh() void handle_thread_complete()"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-signals","title":"Public Signals","text":"Name void data_changed()signal that the data has changed void tool_state_changed() void points_changed() void landmarks_changed() void planes_changed() void ffc_changed() void update_display() void feature_map_changed() void reset_stats() void new_mesh() void feature_range_changed() void update_view_mode() void image_slice_settings_changed() void paint_mode_changed() void repaint() void reinsert_shapes() void annotations_changed() void save() void session_title_changed() void image_name_changed() void fill_all_ffc_requested()"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-functions","title":"Public Functions","text":"Name Session(QWidget * parent, Preferences &amp; prefs)constructor ~Session()destructor void set_parent(QWidget * parent)set QWidget parent bool save_project(QString filename)save project to file bool load_project(QString filename)load project from file bool load_light_project(QString filename)read a lightweight project file bool load_xl_project(QString filename)load a shapeworks project void set_project_path(QString relative_path) std::shared_ptr&lt; shapeworks::Project &gt; get_project() void load_original_files(std::vector&lt; std::string &gt; filenames)import files void load_groomed_files(std::vector&lt; std::string &gt; file_names, double iso, int domains_per_shape)load groomed files bool load_point_files(std::vector&lt; std::string &gt; local, std::vector&lt; std::string &gt; world, int domains_per_shape) bool update_particles(std::vector&lt; Particles &gt; particles) int get_num_particles()Return the total number of particles for all domains, combined. ParticleSystemEvaluation get_local_particle_system(int domain) void update_procrustes_transforms(std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; transforms) bool is_light_project() bool get_groomed_present() void remove_shapes(QList&lt; int &gt; list)remove shapes ShapeList get_shapes()return all shapes ShapeList get_non_excluded_shapes()return all non-excluded shapes void calculate_reconstructed_samples() QString get_filename()get the filename QString get_display_name()get file display name bool original_present() bool groomed_present() bool particles_present() bool groups_available() int get_num_shapes() int get_domains_per_shape() std::string get_default_feature_map() std::shared_ptr&lt; MeshManager &gt; get_mesh_manager() shapeworks::Parameters &amp; parameters() std::vector&lt; DomainType &gt; get_groomed_domain_types() double update_auto_glyph_size() double get_auto_glyph_size() void clear_particles()clear particles from session (e.g. groom start, optimize start) bool get_feature_auto_scale() double get_feature_range_max() double get_feature_range_min() void set_feature_range(double min, double max) void set_feature_range_min(double value) void set_feature_range_max(double value) void set_feature_uniform_scale(bool value) bool get_feature_uniform_scale() void handle_ctrl_click(PickResult result) void trigger_landmarks_changed() void trigger_planes_changed() void trigger_ffc_changed() void trigger_annotations_changed() void trigger_save() void trigger_data_changed() void reload_particles() void trigger_fill_all_ffc() void set_active_landmark_domain(int id) int get_active_landmark_domain() void set_placing_landmark(int id) int get_placing_landmark() void set_landmarks_active(bool active) bool get_landmarks_active() void set_planes_active(bool active) bool get_planes_active() void set_show_landmark_labels(bool show) bool get_show_landmark_labels() void set_show_planes(bool show) bool get_show_planes() bool should_show_planes() void set_show_landmarks(bool show) bool get_show_landmarks() bool set_image_name(std::string image_name) std::string get_image_name() void set_image_axis(QString axis) Axis get_image_axis() void set_image_3d_mode(bool mode) bool get_image_3d_mode() void set_image_share_window_and_level(bool enabled) bool get_image_share_brightness_contrast() void set_image_sync_slice(bool enabled) bool get_image_sync_slice() void set_image_thickness_feature(bool enabled) bool get_image_thickness_feature() void set_feature_map(std::string feature_map) std::string get_feature_map() bool has_constraints() void set_loading(bool loading) bool is_loading() void set_tool_state(std::string state) std::string get_tool_state() bool is_analysis_mode() void set_ffc_paint_active(bool enabled) bool get_ffc_paint_active() void set_seg_paint_active(bool enabled) bool get_seg_paint_active() void set_seg_paint_value(int value) int get_seg_paint_value() void set_ffc_paint_mode_inclusive(bool inclusive) bool get_ffc_paint_mode_inclusive() void set_ffc_paint_size(double size) double get_ffc_paint_size() void set_seg_paint_size(double size) double get_seg_paint_size() bool get_show_good_bad_particles() void set_show_good_bad_particles(bool enabled) bool get_show_difference_vectors() void set_show_difference_vectors(bool enabled) bool should_difference_vectors_show() std::vector&lt; bool &gt; get_good_bad_particles() void set_good_bad_particles(const std::vector&lt; bool &gt; &amp; good_bad) void set_difference_particles(Particles particles) Particles get_difference_particles() void set_compare_settings(CompareSettings settings) CompareSettings get_compare_settings() void trigger_repaint() void trigger_reinsert_shapes() void set_display_mode(DisplayMode mode)set display mode (original, groomed, reconstructed) DisplayMode get_display_mode()return the current display mode void set_glyph_lut(vtkSmartPointer&lt; vtkLookupTable &gt; lut) vtkSmartPointer&lt; vtkLookupTable &gt; get_glyph_lut() void set_py_worker(QSharedPointer&lt; PythonWorker &gt; worker) QSharedPointer&lt; PythonWorker &gt; get_py_worker() Eigen::MatrixXd get_all_particles()Return all world particles (number of shapes, 3 x num particles) Eigen::MatrixXd get_all_scalars(std::string target_feature)Return all scalars for all shapes, given target feature. void set_current_alignment(AlignmentType alignment) AlignmentType get_current_alignment() bool is_modified() void set_modified(bool modified) void recompute_surfaces() bool is_supported_file_format(std::string filename) Point3 get_point(const Eigen::VectorXd &amp; points, int i)"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-attributes","title":"Public Attributes","text":"Name const std::string DATA_C const std::string GROOM_C const std::string OPTIMIZE_C const std::string ANALYSIS_C const std::string DEEPSSM_C const std::string MONAI_C"},{"location":"api/Classes/classshapeworks_1_1Session.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Session;\n</code></pre> <p>Representation of a session. </p> <p>The Session class encapsulates everything about a session/project. </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Session.html#using-alignmenttype","title":"using AlignmentType","text":"<pre><code>using shapeworks::Session::AlignmentType =  Analyze::AlignmentType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-set_feature_auto_scale","title":"slot set_feature_auto_scale","text":"<pre><code>void set_feature_auto_scale(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-set_landmark_drag_mode","title":"slot set_landmark_drag_mode","text":"<pre><code>void set_landmark_drag_mode(\n    bool mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-get_landmark_drag_mode","title":"slot get_landmark_drag_mode","text":"<pre><code>bool get_landmark_drag_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-handle_clear_cache","title":"slot handle_clear_cache","text":"<pre><code>void handle_clear_cache()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-handle_new_mesh","title":"slot handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#slot-handle_thread_complete","title":"slot handle_thread_complete","text":"<pre><code>void handle_thread_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-data_changed","title":"signal data_changed","text":"<pre><code>void data_changed()\n</code></pre> <p>signal that the data has changed </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-tool_state_changed","title":"signal tool_state_changed","text":"<pre><code>void tool_state_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-points_changed","title":"signal points_changed","text":"<pre><code>void points_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-landmarks_changed","title":"signal landmarks_changed","text":"<pre><code>void landmarks_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-planes_changed","title":"signal planes_changed","text":"<pre><code>void planes_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-ffc_changed","title":"signal ffc_changed","text":"<pre><code>void ffc_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-update_display","title":"signal update_display","text":"<pre><code>void update_display()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-feature_map_changed","title":"signal feature_map_changed","text":"<pre><code>void feature_map_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-reset_stats","title":"signal reset_stats","text":"<pre><code>void reset_stats()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-new_mesh","title":"signal new_mesh","text":"<pre><code>void new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-feature_range_changed","title":"signal feature_range_changed","text":"<pre><code>void feature_range_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-update_view_mode","title":"signal update_view_mode","text":"<pre><code>void update_view_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-image_slice_settings_changed","title":"signal image_slice_settings_changed","text":"<pre><code>void image_slice_settings_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-paint_mode_changed","title":"signal paint_mode_changed","text":"<pre><code>void paint_mode_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-repaint","title":"signal repaint","text":"<pre><code>void repaint()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-reinsert_shapes","title":"signal reinsert_shapes","text":"<pre><code>void reinsert_shapes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-annotations_changed","title":"signal annotations_changed","text":"<pre><code>void annotations_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-save","title":"signal save","text":"<pre><code>void save()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-session_title_changed","title":"signal session_title_changed","text":"<pre><code>void session_title_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-image_name_changed","title":"signal image_name_changed","text":"<pre><code>void image_name_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#signal-fill_all_ffc_requested","title":"signal fill_all_ffc_requested","text":"<pre><code>void fill_all_ffc_requested()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Session.html#function-session","title":"function Session","text":"<pre><code>Session(\n    QWidget * parent,\n    Preferences &amp; prefs\n)\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-session_1","title":"function ~Session","text":"<pre><code>~Session()\n</code></pre> <p>destructor </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_parent","title":"function set_parent","text":"<pre><code>void set_parent(\n    QWidget * parent\n)\n</code></pre> <p>set QWidget parent </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-save_project","title":"function save_project","text":"<pre><code>bool save_project(\n    QString filename\n)\n</code></pre> <p>save project to file </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_project","title":"function load_project","text":"<pre><code>bool load_project(\n    QString filename\n)\n</code></pre> <p>load project from file </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_light_project","title":"function load_light_project","text":"<pre><code>bool load_light_project(\n    QString filename\n)\n</code></pre> <p>read a lightweight project file </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_xl_project","title":"function load_xl_project","text":"<pre><code>bool load_xl_project(\n    QString filename\n)\n</code></pre> <p>load a shapeworks project </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_project_path","title":"function set_project_path","text":"<pre><code>void set_project_path(\n    QString relative_path\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_project","title":"function get_project","text":"<pre><code>std::shared_ptr&lt; shapeworks::Project &gt; get_project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_original_files","title":"function load_original_files","text":"<pre><code>void load_original_files(\n    std::vector&lt; std::string &gt; filenames\n)\n</code></pre> <p>import files </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_groomed_files","title":"function load_groomed_files","text":"<pre><code>void load_groomed_files(\n    std::vector&lt; std::string &gt; file_names,\n    double iso,\n    int domains_per_shape\n)\n</code></pre> <p>load groomed files </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-load_point_files","title":"function load_point_files","text":"<pre><code>bool load_point_files(\n    std::vector&lt; std::string &gt; local,\n    std::vector&lt; std::string &gt; world,\n    int domains_per_shape\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-update_particles","title":"function update_particles","text":"<pre><code>bool update_particles(\n    std::vector&lt; Particles &gt; particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_num_particles","title":"function get_num_particles","text":"<pre><code>int get_num_particles()\n</code></pre> <p>Return the total number of particles for all domains, combined. </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_local_particle_system","title":"function get_local_particle_system","text":"<pre><code>ParticleSystemEvaluation get_local_particle_system(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-update_procrustes_transforms","title":"function update_procrustes_transforms","text":"<pre><code>void update_procrustes_transforms(\n    std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt; transforms\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-is_light_project","title":"function is_light_project","text":"<pre><code>bool is_light_project()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_groomed_present","title":"function get_groomed_present","text":"<pre><code>bool get_groomed_present()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-remove_shapes","title":"function remove_shapes","text":"<pre><code>void remove_shapes(\n    QList&lt; int &gt; list\n)\n</code></pre> <p>remove shapes </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_shapes","title":"function get_shapes","text":"<pre><code>ShapeList get_shapes()\n</code></pre> <p>return all shapes </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_non_excluded_shapes","title":"function get_non_excluded_shapes","text":"<pre><code>ShapeList get_non_excluded_shapes()\n</code></pre> <p>return all non-excluded shapes </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-calculate_reconstructed_samples","title":"function calculate_reconstructed_samples","text":"<pre><code>void calculate_reconstructed_samples()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_filename","title":"function get_filename","text":"<pre><code>QString get_filename()\n</code></pre> <p>get the filename </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_display_name","title":"function get_display_name","text":"<pre><code>QString get_display_name()\n</code></pre> <p>get file display name </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-original_present","title":"function original_present","text":"<pre><code>bool original_present()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-groomed_present","title":"function groomed_present","text":"<pre><code>bool groomed_present()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-particles_present","title":"function particles_present","text":"<pre><code>bool particles_present()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-groups_available","title":"function groups_available","text":"<pre><code>bool groups_available()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_num_shapes","title":"function get_num_shapes","text":"<pre><code>int get_num_shapes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_domains_per_shape","title":"function get_domains_per_shape","text":"<pre><code>int get_domains_per_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_default_feature_map","title":"function get_default_feature_map","text":"<pre><code>std::string get_default_feature_map()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_mesh_manager","title":"function get_mesh_manager","text":"<pre><code>inline std::shared_ptr&lt; MeshManager &gt; get_mesh_manager()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-parameters","title":"function parameters","text":"<pre><code>shapeworks::Parameters &amp; parameters()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_groomed_domain_types","title":"function get_groomed_domain_types","text":"<pre><code>std::vector&lt; DomainType &gt; get_groomed_domain_types()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-update_auto_glyph_size","title":"function update_auto_glyph_size","text":"<pre><code>double update_auto_glyph_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_auto_glyph_size","title":"function get_auto_glyph_size","text":"<pre><code>double get_auto_glyph_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-clear_particles","title":"function clear_particles","text":"<pre><code>void clear_particles()\n</code></pre> <p>clear particles from session (e.g. groom start, optimize start) </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_feature_auto_scale","title":"function get_feature_auto_scale","text":"<pre><code>bool get_feature_auto_scale()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_feature_range_max","title":"function get_feature_range_max","text":"<pre><code>double get_feature_range_max()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_feature_range_min","title":"function get_feature_range_min","text":"<pre><code>double get_feature_range_min()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_feature_range","title":"function set_feature_range","text":"<pre><code>void set_feature_range(\n    double min,\n    double max\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_feature_range_min","title":"function set_feature_range_min","text":"<pre><code>void set_feature_range_min(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_feature_range_max","title":"function set_feature_range_max","text":"<pre><code>void set_feature_range_max(\n    double value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_feature_uniform_scale","title":"function set_feature_uniform_scale","text":"<pre><code>void set_feature_uniform_scale(\n    bool value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_feature_uniform_scale","title":"function get_feature_uniform_scale","text":"<pre><code>bool get_feature_uniform_scale()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-handle_ctrl_click","title":"function handle_ctrl_click","text":"<pre><code>void handle_ctrl_click(\n    PickResult result\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_landmarks_changed","title":"function trigger_landmarks_changed","text":"<pre><code>void trigger_landmarks_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_planes_changed","title":"function trigger_planes_changed","text":"<pre><code>void trigger_planes_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_ffc_changed","title":"function trigger_ffc_changed","text":"<pre><code>void trigger_ffc_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_annotations_changed","title":"function trigger_annotations_changed","text":"<pre><code>void trigger_annotations_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_save","title":"function trigger_save","text":"<pre><code>void trigger_save()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_data_changed","title":"function trigger_data_changed","text":"<pre><code>void trigger_data_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-reload_particles","title":"function reload_particles","text":"<pre><code>void reload_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_fill_all_ffc","title":"function trigger_fill_all_ffc","text":"<pre><code>void trigger_fill_all_ffc()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_active_landmark_domain","title":"function set_active_landmark_domain","text":"<pre><code>void set_active_landmark_domain(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_active_landmark_domain","title":"function get_active_landmark_domain","text":"<pre><code>int get_active_landmark_domain()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_placing_landmark","title":"function set_placing_landmark","text":"<pre><code>void set_placing_landmark(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_placing_landmark","title":"function get_placing_landmark","text":"<pre><code>int get_placing_landmark()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_landmarks_active","title":"function set_landmarks_active","text":"<pre><code>void set_landmarks_active(\n    bool active\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_landmarks_active","title":"function get_landmarks_active","text":"<pre><code>bool get_landmarks_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_planes_active","title":"function set_planes_active","text":"<pre><code>void set_planes_active(\n    bool active\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_planes_active","title":"function get_planes_active","text":"<pre><code>bool get_planes_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_show_landmark_labels","title":"function set_show_landmark_labels","text":"<pre><code>void set_show_landmark_labels(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_show_landmark_labels","title":"function get_show_landmark_labels","text":"<pre><code>bool get_show_landmark_labels()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_show_planes","title":"function set_show_planes","text":"<pre><code>void set_show_planes(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_show_planes","title":"function get_show_planes","text":"<pre><code>bool get_show_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-should_show_planes","title":"function should_show_planes","text":"<pre><code>bool should_show_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_show_landmarks","title":"function set_show_landmarks","text":"<pre><code>void set_show_landmarks(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_show_landmarks","title":"function get_show_landmarks","text":"<pre><code>bool get_show_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_name","title":"function set_image_name","text":"<pre><code>bool set_image_name(\n    std::string image_name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_name","title":"function get_image_name","text":"<pre><code>std::string get_image_name()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_axis","title":"function set_image_axis","text":"<pre><code>void set_image_axis(\n    QString axis\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_axis","title":"function get_image_axis","text":"<pre><code>Axis get_image_axis()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_3d_mode","title":"function set_image_3d_mode","text":"<pre><code>void set_image_3d_mode(\n    bool mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_3d_mode","title":"function get_image_3d_mode","text":"<pre><code>bool get_image_3d_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_share_window_and_level","title":"function set_image_share_window_and_level","text":"<pre><code>void set_image_share_window_and_level(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_share_brightness_contrast","title":"function get_image_share_brightness_contrast","text":"<pre><code>bool get_image_share_brightness_contrast()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_sync_slice","title":"function set_image_sync_slice","text":"<pre><code>void set_image_sync_slice(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_sync_slice","title":"function get_image_sync_slice","text":"<pre><code>bool get_image_sync_slice()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_image_thickness_feature","title":"function set_image_thickness_feature","text":"<pre><code>void set_image_thickness_feature(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_image_thickness_feature","title":"function get_image_thickness_feature","text":"<pre><code>bool get_image_thickness_feature()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_feature_map","title":"function set_feature_map","text":"<pre><code>void set_feature_map(\n    std::string feature_map\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_feature_map","title":"function get_feature_map","text":"<pre><code>std::string get_feature_map()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-has_constraints","title":"function has_constraints","text":"<pre><code>bool has_constraints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_loading","title":"function set_loading","text":"<pre><code>void set_loading(\n    bool loading\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-is_loading","title":"function is_loading","text":"<pre><code>bool is_loading()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_tool_state","title":"function set_tool_state","text":"<pre><code>void set_tool_state(\n    std::string state\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_tool_state","title":"function get_tool_state","text":"<pre><code>std::string get_tool_state()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-is_analysis_mode","title":"function is_analysis_mode","text":"<pre><code>bool is_analysis_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_ffc_paint_active","title":"function set_ffc_paint_active","text":"<pre><code>void set_ffc_paint_active(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_ffc_paint_active","title":"function get_ffc_paint_active","text":"<pre><code>bool get_ffc_paint_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_seg_paint_active","title":"function set_seg_paint_active","text":"<pre><code>void set_seg_paint_active(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_seg_paint_active","title":"function get_seg_paint_active","text":"<pre><code>bool get_seg_paint_active()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_seg_paint_value","title":"function set_seg_paint_value","text":"<pre><code>void set_seg_paint_value(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_seg_paint_value","title":"function get_seg_paint_value","text":"<pre><code>int get_seg_paint_value()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_ffc_paint_mode_inclusive","title":"function set_ffc_paint_mode_inclusive","text":"<pre><code>void set_ffc_paint_mode_inclusive(\n    bool inclusive\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_ffc_paint_mode_inclusive","title":"function get_ffc_paint_mode_inclusive","text":"<pre><code>bool get_ffc_paint_mode_inclusive()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_ffc_paint_size","title":"function set_ffc_paint_size","text":"<pre><code>void set_ffc_paint_size(\n    double size\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_ffc_paint_size","title":"function get_ffc_paint_size","text":"<pre><code>double get_ffc_paint_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_seg_paint_size","title":"function set_seg_paint_size","text":"<pre><code>void set_seg_paint_size(\n    double size\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_seg_paint_size","title":"function get_seg_paint_size","text":"<pre><code>double get_seg_paint_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_show_good_bad_particles","title":"function get_show_good_bad_particles","text":"<pre><code>bool get_show_good_bad_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_show_good_bad_particles","title":"function set_show_good_bad_particles","text":"<pre><code>void set_show_good_bad_particles(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_show_difference_vectors","title":"function get_show_difference_vectors","text":"<pre><code>bool get_show_difference_vectors()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_show_difference_vectors","title":"function set_show_difference_vectors","text":"<pre><code>void set_show_difference_vectors(\n    bool enabled\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-should_difference_vectors_show","title":"function should_difference_vectors_show","text":"<pre><code>bool should_difference_vectors_show()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_good_bad_particles","title":"function get_good_bad_particles","text":"<pre><code>std::vector&lt; bool &gt; get_good_bad_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_good_bad_particles","title":"function set_good_bad_particles","text":"<pre><code>void set_good_bad_particles(\n    const std::vector&lt; bool &gt; &amp; good_bad\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_difference_particles","title":"function set_difference_particles","text":"<pre><code>inline void set_difference_particles(\n    Particles particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_difference_particles","title":"function get_difference_particles","text":"<pre><code>inline Particles get_difference_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_compare_settings","title":"function set_compare_settings","text":"<pre><code>void set_compare_settings(\n    CompareSettings settings\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_compare_settings","title":"function get_compare_settings","text":"<pre><code>CompareSettings get_compare_settings()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_repaint","title":"function trigger_repaint","text":"<pre><code>void trigger_repaint()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-trigger_reinsert_shapes","title":"function trigger_reinsert_shapes","text":"<pre><code>void trigger_reinsert_shapes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_display_mode","title":"function set_display_mode","text":"<pre><code>void set_display_mode(\n    DisplayMode mode\n)\n</code></pre> <p>set display mode (original, groomed, reconstructed) </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_display_mode","title":"function get_display_mode","text":"<pre><code>DisplayMode get_display_mode()\n</code></pre> <p>return the current display mode </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_glyph_lut","title":"function set_glyph_lut","text":"<pre><code>inline void set_glyph_lut(\n    vtkSmartPointer&lt; vtkLookupTable &gt; lut\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_glyph_lut","title":"function get_glyph_lut","text":"<pre><code>inline vtkSmartPointer&lt; vtkLookupTable &gt; get_glyph_lut()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_py_worker","title":"function set_py_worker","text":"<pre><code>inline void set_py_worker(\n    QSharedPointer&lt; PythonWorker &gt; worker\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_py_worker","title":"function get_py_worker","text":"<pre><code>inline QSharedPointer&lt; PythonWorker &gt; get_py_worker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_all_particles","title":"function get_all_particles","text":"<pre><code>Eigen::MatrixXd get_all_particles()\n</code></pre> <p>Return all world particles (number of shapes, 3 x num particles) </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_all_scalars","title":"function get_all_scalars","text":"<pre><code>Eigen::MatrixXd get_all_scalars(\n    std::string target_feature\n)\n</code></pre> <p>Return all scalars for all shapes, given target feature. </p>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_current_alignment","title":"function set_current_alignment","text":"<pre><code>inline void set_current_alignment(\n    AlignmentType alignment\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_current_alignment","title":"function get_current_alignment","text":"<pre><code>inline AlignmentType get_current_alignment()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-is_modified","title":"function is_modified","text":"<pre><code>inline bool is_modified()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-set_modified","title":"function set_modified","text":"<pre><code>void set_modified(\n    bool modified\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-recompute_surfaces","title":"function recompute_surfaces","text":"<pre><code>void recompute_surfaces()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-is_supported_file_format","title":"function is_supported_file_format","text":"<pre><code>static bool is_supported_file_format(\n    std::string filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#function-get_point","title":"function get_point","text":"<pre><code>static Point3 get_point(\n    const Eigen::VectorXd &amp; points,\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-data_c","title":"variable DATA_C","text":"<pre><code>static const std::string DATA_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-groom_c","title":"variable GROOM_C","text":"<pre><code>static const std::string GROOM_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-optimize_c","title":"variable OPTIMIZE_C","text":"<pre><code>static const std::string OPTIMIZE_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-analysis_c","title":"variable ANALYSIS_C","text":"<pre><code>static const std::string ANALYSIS_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-deepssm_c","title":"variable DEEPSSM_C","text":"<pre><code>static const std::string DEEPSSM_C;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Session.html#variable-monai_c","title":"variable MONAI_C","text":"<pre><code>static const std::string MONAI_C;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html","title":"shapeworks::Shape","text":"<p>Representation of a single shape/patient/subject. </p> <p><code>#include &lt;Shape.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#public-classes","title":"Public Classes","text":"Name class Point TODO: replace this wherever it is used."},{"location":"api/Classes/classshapeworks_1_1Shape.html#public-functions","title":"Public Functions","text":"Name Shape() ~Shape() std::string get_display_name() MeshGroup get_meshes(DisplayMode display_mode, bool wait =false) void set_annotations(std::vector&lt; std::string &gt; annotations, bool only_overwrite_blank =true) std::vector&lt; std::string &gt; get_annotations() void set_mesh_manager(std::shared_ptr&lt; MeshManager &gt; mesh_manager) void set_subject(std::shared_ptr&lt; shapeworks::Subject &gt; subject) bool is_subject()Is this shape a population subject (e.g. mean/pca constructions are not) std::shared_ptr&lt; shapeworks::Subject &gt; get_subject()Return the pointer to the subject object. bool is_fixed()Helper to ask if this shape is fixed or not. bool is_excluded()Helper to ask if this shape is excluded. void import_original_file(const std::string &amp; filename)Import the original raw mesh or image file. MeshGroup get_original_meshes(bool wait =false)Retrieve the original meshes. MeshGroup get_groomed_meshes(bool wait =false)Retrieve the groomed meshes. MeshGroup get_reconstructed_meshes(bool wait =false)Retrieve the reconstructed meshes. void set_reconstructed_meshes(MeshGroup meshes)Set the reconstructed meshes. void reset_groomed_mesh()Reset the groomed mesh so that it will be re-created. bool import_global_point_files(std::vector&lt; std::string &gt; filenames)Import global correspondence point files. bool import_local_point_files(std::vector&lt; std::string &gt; filenames)Import local correspondence point files. bool import_landmarks_files(std::vector&lt; std::string &gt; filenames)Import landmarks files. bool store_landmarks()Store landmarks. bool import_constraints(std::vector&lt; std::string &gt; filenames)import constraints bool store_constraints()Store constraints. void set_particles(Particles particles)Set particles. Particles get_particles()Get particles. void set_particle_transform(vtkSmartPointer&lt; vtkTransform &gt; transform)Set the particle transform (alignment) void set_alignment_type(int alignment)Set the alignment type. Eigen::VectorXd get_global_correspondence_points()Get the global correspondence points. std::vector&lt; Eigen::VectorXd &gt; get_particles_for_display()Get the global correspondence points for display. Eigen::VectorXd get_local_correspondence_points()Get the local correspondence points. void clear_reconstructed_mesh() int get_id()Get the id of this shape. void set_id(int id)Set the id of this shape. void update_annotations()Update the name of this shape. std::vector&lt; std::string &gt; get_original_filenames() std::vector&lt; std::string &gt; get_original_filenames_with_path() std::string get_original_filename() std::string get_original_filename_with_path() std::string get_groomed_filename() std::string get_groomed_filename_with_path(int domain) std::string get_global_point_filename() std::string get_global_point_filename_with_path() std::string get_local_point_filename() std::string get_local_point_filename_with_path() void set_transform(vtkSmartPointer&lt; vtkTransform &gt; transform) vtkSmartPointer&lt; vtkTransform &gt; get_transform(int domain =0) vtkSmartPointer&lt; vtkTransform &gt; get_inverse_transform(int domain =0) bool has_alignment() vtkSmartPointer&lt; vtkTransform &gt; get_original_transform(int domain =0) void set_reconstruction_transforms(std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; transforms) vtkSmartPointer&lt; vtkTransform &gt; get_reconstruction_transform(int domain) vtkSmartPointer&lt; vtkTransform &gt; get_groomed_transform(int domain =0) vtkSmartPointer&lt; vtkTransform &gt; get_procrustes_transform(int domain =0) std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; get_procrustes_transforms() vtkSmartPointer&lt; vtkTransform &gt; get_alignment(int domain =0) void load_feature(DisplayMode display_mode, std::string feature) std::shared_ptr&lt; Image &gt; get_image_volume(std::string image_volume_name) std::shared_ptr&lt; Image &gt; get_segmentation() std::string get_segmentation_filename() Eigen::VectorXd get_point_features(std::string feature) void set_point_features(std::string feature, Eigen::VectorXd values) void load_feature_from_scalar_file(std::string filename, std::string feature_name) void set_override_feature(std::string feature) std::string get_override_feature() Eigen::MatrixXd &amp; landmarks() std::vector&lt; Constraints &gt; &amp; constraints() Constraints &amp; get_constraints(int domain_id) bool has_constraints() bool has_planes() std::vector&lt; std::shared_ptr&lt; Surface &gt; &gt; get_groomed_mesh_wrappers() void recompute_original_surface() void ensure_segmentation()If a segmentation doesn't exist, create a blank canvas."},{"location":"api/Classes/classshapeworks_1_1Shape.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-shape","title":"function Shape","text":"<pre><code>Shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-shape_1","title":"function ~Shape","text":"<pre><code>~Shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_display_name","title":"function get_display_name","text":"<pre><code>std::string get_display_name()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_meshes","title":"function get_meshes","text":"<pre><code>MeshGroup get_meshes(\n    DisplayMode display_mode,\n    bool wait =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_annotations","title":"function set_annotations","text":"<pre><code>void set_annotations(\n    std::vector&lt; std::string &gt; annotations,\n    bool only_overwrite_blank =true\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_annotations","title":"function get_annotations","text":"<pre><code>std::vector&lt; std::string &gt; get_annotations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_mesh_manager","title":"function set_mesh_manager","text":"<pre><code>void set_mesh_manager(\n    std::shared_ptr&lt; MeshManager &gt; mesh_manager\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_subject","title":"function set_subject","text":"<pre><code>void set_subject(\n    std::shared_ptr&lt; shapeworks::Subject &gt; subject\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-is_subject","title":"function is_subject","text":"<pre><code>bool is_subject()\n</code></pre> <p>Is this shape a population subject (e.g. mean/pca constructions are not) </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_subject","title":"function get_subject","text":"<pre><code>std::shared_ptr&lt; shapeworks::Subject &gt; get_subject()\n</code></pre> <p>Return the pointer to the subject object. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-is_fixed","title":"function is_fixed","text":"<pre><code>bool is_fixed()\n</code></pre> <p>Helper to ask if this shape is fixed or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-is_excluded","title":"function is_excluded","text":"<pre><code>bool is_excluded()\n</code></pre> <p>Helper to ask if this shape is excluded. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-import_original_file","title":"function import_original_file","text":"<pre><code>void import_original_file(\n    const std::string &amp; filename\n)\n</code></pre> <p>Import the original raw mesh or image file. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_meshes","title":"function get_original_meshes","text":"<pre><code>MeshGroup get_original_meshes(\n    bool wait =false\n)\n</code></pre> <p>Retrieve the original meshes. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_groomed_meshes","title":"function get_groomed_meshes","text":"<pre><code>MeshGroup get_groomed_meshes(\n    bool wait =false\n)\n</code></pre> <p>Retrieve the groomed meshes. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_reconstructed_meshes","title":"function get_reconstructed_meshes","text":"<pre><code>MeshGroup get_reconstructed_meshes(\n    bool wait =false\n)\n</code></pre> <p>Retrieve the reconstructed meshes. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_reconstructed_meshes","title":"function set_reconstructed_meshes","text":"<pre><code>void set_reconstructed_meshes(\n    MeshGroup meshes\n)\n</code></pre> <p>Set the reconstructed meshes. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-reset_groomed_mesh","title":"function reset_groomed_mesh","text":"<pre><code>void reset_groomed_mesh()\n</code></pre> <p>Reset the groomed mesh so that it will be re-created. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-import_global_point_files","title":"function import_global_point_files","text":"<pre><code>bool import_global_point_files(\n    std::vector&lt; std::string &gt; filenames\n)\n</code></pre> <p>Import global correspondence point files. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-import_local_point_files","title":"function import_local_point_files","text":"<pre><code>bool import_local_point_files(\n    std::vector&lt; std::string &gt; filenames\n)\n</code></pre> <p>Import local correspondence point files. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-import_landmarks_files","title":"function import_landmarks_files","text":"<pre><code>bool import_landmarks_files(\n    std::vector&lt; std::string &gt; filenames\n)\n</code></pre> <p>Import landmarks files. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-store_landmarks","title":"function store_landmarks","text":"<pre><code>bool store_landmarks()\n</code></pre> <p>Store landmarks. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-import_constraints","title":"function import_constraints","text":"<pre><code>bool import_constraints(\n    std::vector&lt; std::string &gt; filenames\n)\n</code></pre> <p>import constraints </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-store_constraints","title":"function store_constraints","text":"<pre><code>bool store_constraints()\n</code></pre> <p>Store constraints. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_particles","title":"function set_particles","text":"<pre><code>void set_particles(\n    Particles particles\n)\n</code></pre> <p>Set particles. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_particles","title":"function get_particles","text":"<pre><code>Particles get_particles()\n</code></pre> <p>Get particles. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_particle_transform","title":"function set_particle_transform","text":"<pre><code>void set_particle_transform(\n    vtkSmartPointer&lt; vtkTransform &gt; transform\n)\n</code></pre> <p>Set the particle transform (alignment) </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_alignment_type","title":"function set_alignment_type","text":"<pre><code>void set_alignment_type(\n    int alignment\n)\n</code></pre> <p>Set the alignment type. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_global_correspondence_points","title":"function get_global_correspondence_points","text":"<pre><code>Eigen::VectorXd get_global_correspondence_points()\n</code></pre> <p>Get the global correspondence points. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_particles_for_display","title":"function get_particles_for_display","text":"<pre><code>std::vector&lt; Eigen::VectorXd &gt; get_particles_for_display()\n</code></pre> <p>Get the global correspondence points for display. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_local_correspondence_points","title":"function get_local_correspondence_points","text":"<pre><code>Eigen::VectorXd get_local_correspondence_points()\n</code></pre> <p>Get the local correspondence points. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-clear_reconstructed_mesh","title":"function clear_reconstructed_mesh","text":"<pre><code>void clear_reconstructed_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_id","title":"function get_id","text":"<pre><code>int get_id()\n</code></pre> <p>Get the id of this shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_id","title":"function set_id","text":"<pre><code>void set_id(\n    int id\n)\n</code></pre> <p>Set the id of this shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-update_annotations","title":"function update_annotations","text":"<pre><code>void update_annotations()\n</code></pre> <p>Update the name of this shape. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_filenames","title":"function get_original_filenames","text":"<pre><code>std::vector&lt; std::string &gt; get_original_filenames()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_filenames_with_path","title":"function get_original_filenames_with_path","text":"<pre><code>std::vector&lt; std::string &gt; get_original_filenames_with_path()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_filename","title":"function get_original_filename","text":"<pre><code>std::string get_original_filename()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_filename_with_path","title":"function get_original_filename_with_path","text":"<pre><code>std::string get_original_filename_with_path()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_groomed_filename","title":"function get_groomed_filename","text":"<pre><code>std::string get_groomed_filename()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_groomed_filename_with_path","title":"function get_groomed_filename_with_path","text":"<pre><code>std::string get_groomed_filename_with_path(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_global_point_filename","title":"function get_global_point_filename","text":"<pre><code>std::string get_global_point_filename()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_global_point_filename_with_path","title":"function get_global_point_filename_with_path","text":"<pre><code>std::string get_global_point_filename_with_path()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_local_point_filename","title":"function get_local_point_filename","text":"<pre><code>std::string get_local_point_filename()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_local_point_filename_with_path","title":"function get_local_point_filename_with_path","text":"<pre><code>std::string get_local_point_filename_with_path()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_transform","title":"function set_transform","text":"<pre><code>void set_transform(\n    vtkSmartPointer&lt; vtkTransform &gt; transform\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_transform","title":"function get_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_transform(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_inverse_transform","title":"function get_inverse_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_inverse_transform(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-has_alignment","title":"function has_alignment","text":"<pre><code>bool has_alignment()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_original_transform","title":"function get_original_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_original_transform(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_reconstruction_transforms","title":"function set_reconstruction_transforms","text":"<pre><code>void set_reconstruction_transforms(\n    std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; transforms\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_reconstruction_transform","title":"function get_reconstruction_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_reconstruction_transform(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_groomed_transform","title":"function get_groomed_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_groomed_transform(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_procrustes_transform","title":"function get_procrustes_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_procrustes_transform(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_procrustes_transforms","title":"function get_procrustes_transforms","text":"<pre><code>std::vector&lt; vtkSmartPointer&lt; vtkTransform &gt; &gt; get_procrustes_transforms()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_alignment","title":"function get_alignment","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_alignment(\n    int domain =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-load_feature","title":"function load_feature","text":"<pre><code>void load_feature(\n    DisplayMode display_mode,\n    std::string feature\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_image_volume","title":"function get_image_volume","text":"<pre><code>std::shared_ptr&lt; Image &gt; get_image_volume(\n    std::string image_volume_name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_segmentation","title":"function get_segmentation","text":"<pre><code>std::shared_ptr&lt; Image &gt; get_segmentation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_segmentation_filename","title":"function get_segmentation_filename","text":"<pre><code>inline std::string get_segmentation_filename()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_point_features","title":"function get_point_features","text":"<pre><code>Eigen::VectorXd get_point_features(\n    std::string feature\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_point_features","title":"function set_point_features","text":"<pre><code>void set_point_features(\n    std::string feature,\n    Eigen::VectorXd values\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-load_feature_from_scalar_file","title":"function load_feature_from_scalar_file","text":"<pre><code>void load_feature_from_scalar_file(\n    std::string filename,\n    std::string feature_name\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-set_override_feature","title":"function set_override_feature","text":"<pre><code>void set_override_feature(\n    std::string feature\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_override_feature","title":"function get_override_feature","text":"<pre><code>std::string get_override_feature()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-landmarks","title":"function landmarks","text":"<pre><code>Eigen::MatrixXd &amp; landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-constraints","title":"function constraints","text":"<pre><code>std::vector&lt; Constraints &gt; &amp; constraints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_constraints","title":"function get_constraints","text":"<pre><code>Constraints &amp; get_constraints(\n    int domain_id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-has_constraints","title":"function has_constraints","text":"<pre><code>bool has_constraints()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-has_planes","title":"function has_planes","text":"<pre><code>bool has_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-get_groomed_mesh_wrappers","title":"function get_groomed_mesh_wrappers","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; Surface &gt; &gt; get_groomed_mesh_wrappers()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-recompute_original_surface","title":"function recompute_original_surface","text":"<pre><code>void recompute_original_surface()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape.html#function-ensure_segmentation","title":"function ensure_segmentation","text":"<pre><code>void ensure_segmentation()\n</code></pre> <p>If a segmentation doesn't exist, create a blank canvas. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html","title":"shapeworks::ShapeEvaluation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#public-functions","title":"Public Functions","text":"Name ShapeEvaluation() double compute_compactness(const ParticleSystemEvaluation &amp; particle_system, int num_modes, const std::string &amp; save_to =\"\") Eigen::VectorXd compute_full_compactness(const ParticleSystemEvaluation &amp; particle_system, std::function&lt; void(float)&gt; progress_callback =nullptr) double compute_generalization(const ParticleSystemEvaluation &amp; particle_system, int num_modes, const std::string &amp; save_to =\"\", bool surface_distance_mode =false) Eigen::VectorXd compute_full_generalization(const ParticleSystemEvaluation &amp; particle_system, std::function&lt; void(float)&gt; progress_callback =nullptr, std::function&lt; bool()&gt; check_abort =nullptr, bool surface_distance_mode =false) double compute_specificity(const ParticleSystemEvaluation &amp; particle_system, int num_mode, const std::string &amp; save_to =\"\", bool surface_distance_mode =false) Eigen::VectorXd compute_full_specificity(const ParticleSystemEvaluation &amp; particle_system, std::function&lt; void(float)&gt; progress_callback =nullptr, std::function&lt; bool()&gt; check_abort =nullptr, bool surface_distance_mode =false)"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-shapeevaluation","title":"function ShapeEvaluation","text":"<pre><code>ShapeEvaluation()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_compactness","title":"function compute_compactness","text":"<pre><code>static double compute_compactness(\n    const ParticleSystemEvaluation &amp; particle_system,\n    int num_modes,\n    const std::string &amp; save_to =\"\"\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_full_compactness","title":"function compute_full_compactness","text":"<pre><code>static Eigen::VectorXd compute_full_compactness(\n    const ParticleSystemEvaluation &amp; particle_system,\n    std::function&lt; void(float)&gt; progress_callback =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_generalization","title":"function compute_generalization","text":"<pre><code>static double compute_generalization(\n    const ParticleSystemEvaluation &amp; particle_system,\n    int num_modes,\n    const std::string &amp; save_to =\"\",\n    bool surface_distance_mode =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_full_generalization","title":"function compute_full_generalization","text":"<pre><code>static Eigen::VectorXd compute_full_generalization(\n    const ParticleSystemEvaluation &amp; particle_system,\n    std::function&lt; void(float)&gt; progress_callback =nullptr,\n    std::function&lt; bool()&gt; check_abort =nullptr,\n    bool surface_distance_mode =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_specificity","title":"function compute_specificity","text":"<pre><code>static double compute_specificity(\n    const ParticleSystemEvaluation &amp; particle_system,\n    int num_mode,\n    const std::string &amp; save_to =\"\",\n    bool surface_distance_mode =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluation.html#function-compute_full_specificity","title":"function compute_full_specificity","text":"<pre><code>static Eigen::VectorXd compute_full_specificity(\n    const ParticleSystemEvaluation &amp; particle_system,\n    std::function&lt; void(float)&gt; progress_callback =nullptr,\n    std::function&lt; bool()&gt; check_abort =nullptr,\n    bool surface_distance_mode =false\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html","title":"shapeworks::ShapeEvaluationJob","text":"<p>The ShapeEvaluationJob class is a worker class that computes shape evaluation metrics of compactness, specificity, and generalization. It runs asynchronously using the Job and Worker interfaces. </p> <p><code>#include &lt;ShapeEvaluationJob.h&gt;</code></p> <p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-types","title":"Public Types","text":"Name enum class JobType"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-signals","title":"Public Signals","text":"Name void report_progress(shapeworks::ShapeEvaluationJob::JobType job_type, float progress) void result_ready(shapeworks::ShapeEvaluationJob::JobType job_type, Eigen::VectorXd data)"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-functions","title":"Public Functions","text":"Name ShapeEvaluationJob(JobType job_type, ParticleShapeStatistics stats, QSharedPointer&lt; Session &gt; session) virtual void run() overriderun the job virtual QString name() overrideget the name of the job"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#enum-jobtype","title":"enum JobType","text":"Enumerator Value Description CompactnessType SpecificityType GeneralizationType"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#signal-report_progress","title":"signal report_progress","text":"<pre><code>void report_progress(\n    shapeworks::ShapeEvaluationJob::JobType job_type,\n    float progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#signal-result_ready","title":"signal result_ready","text":"<pre><code>void result_ready(\n    shapeworks::ShapeEvaluationJob::JobType job_type,\n    Eigen::VectorXd data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#function-shapeevaluationjob","title":"function ShapeEvaluationJob","text":"<pre><code>ShapeEvaluationJob(\n    JobType job_type,\n    ParticleShapeStatistics stats,\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeEvaluationJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html","title":"shapeworks::ShapeGradientMatrix","text":"<p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES!  More...</p> <p><code>#include &lt;ShapeGradientMatrix.h&gt;</code></p> <p>Inherits from vnl_matrix&lt; double &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#public-types","title":"Public Types","text":"Name typedef double DataType typedef ShapeGradientMatrix Self typedef Observer Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer typedef ParticleSystem ParticleSystemType"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(ShapeGradientMatrix , Observer ) virtual void BeforeIteration() virtual void AfterIteration() void SetDomainsPerShape(int i) int GetDomainsPerShape() const void SetAttributesPerDomain(const std::vector&lt; int &gt; &amp; i) void SetAttributeScales(const std::vector&lt; double &gt; &amp; s) void SetXYZ(int i, bool val) void SetNormals(int i, bool val) virtual void SetMatrix(const vnl_matrix&lt; double &gt; &amp; m) virtual void ResizeMatrix(int rs, int cs) void SetValues(const ParticleSystemType * ps, int idx, int d) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; ) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; )"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#protected-functions","title":"Protected Functions","text":"Name ShapeGradientMatrix() virtual ~ShapeGradientMatrix() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#protected-attributes","title":"Protected Attributes","text":"Name int m_DomainsPerShape"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ShapeGradientMatrix;\n</code></pre> <p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </p> <p>Each column represents a single shape. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef double shapeworks::ShapeGradientMatrix::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ShapeGradientMatrix shapeworks::ShapeGradientMatrix::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Observer shapeworks::ShapeGradientMatrix::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::ShapeGradientMatrix::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::ShapeGradientMatrix::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::ShapeGradientMatrix::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#typedef-particlesystemtype","title":"typedef ParticleSystemType","text":"<pre><code>typedef ParticleSystem shapeworks::ShapeGradientMatrix::ParticleSystemType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    ShapeGradientMatrix ,\n    Observer \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-beforeiteration","title":"function BeforeIteration","text":"<pre><code>inline virtual void BeforeIteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-afteriteration","title":"function AfterIteration","text":"<pre><code>inline virtual void AfterIteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. This can only be safely done before shapes are initialized with points! </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setattributesperdomain","title":"function SetAttributesPerDomain","text":"<pre><code>inline void SetAttributesPerDomain(\n    const std::vector&lt; int &gt; &amp; i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setattributescales","title":"function SetAttributeScales","text":"<pre><code>inline void SetAttributeScales(\n    const std::vector&lt; double &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setxyz","title":"function SetXYZ","text":"<pre><code>inline void SetXYZ(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setnormals","title":"function SetNormals","text":"<pre><code>inline void SetNormals(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setmatrix","title":"function SetMatrix","text":"<pre><code>inline virtual void SetMatrix(\n    const vnl_matrix&lt; double &gt; &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-resizematrix","title":"function ResizeMatrix","text":"<pre><code>inline virtual void ResizeMatrix(\n    int rs,\n    int cs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-setvalues","title":"function SetValues","text":"<pre><code>void SetValues(\n    const ParticleSystemType * ps,\n    int idx,\n    int d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-shapegradientmatrix","title":"function ShapeGradientMatrix","text":"<pre><code>inline ShapeGradientMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-shapegradientmatrix_1","title":"function ~ShapeGradientMatrix","text":"<pre><code>inline virtual ~ShapeGradientMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeGradientMatrix.html#variable-m_domainspershape","title":"variable m_DomainsPerShape","text":"<pre><code>int m_DomainsPerShape;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html","title":"shapeworks::ShapeMatrix","text":"<p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES!  More...</p> <p><code>#include &lt;ShapeMatrix.h&gt;</code></p> <p>Inherits from vnl_matrix&lt; double &gt;, shapeworks::Observer</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#public-types","title":"Public Types","text":"Name typedef double DataType typedef ShapeMatrix Self typedef Observer Superclass typedef itk::SmartPointer&lt; Self &gt; Pointer typedef itk::SmartPointer&lt; const Self &gt; ConstPointer typedef itk::WeakPointer&lt; const Self &gt; ConstWeakPointer"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#public-functions","title":"Public Functions","text":"Name itkNewMacro(Self ) itkTypeMacro(ShapeMatrix , Observer ) virtual void before_iteration() virtual void after_iteration() void SetDomainsPerShape(int i) int GetDomainsPerShape() const void SetAttributesPerDomain(const std::vector&lt; int &gt; &amp; i) void SetAttributeScales(const std::vector&lt; double &gt; &amp; s) void SetXYZ(int i, bool val) void SetNormals(int i, bool val) virtual void SetMatrix(const vnl_matrix&lt; double &gt; &amp; m) virtual void ResizeMatrix(int rs, int cs) virtual void DomainAddEventCallback(Object * , const itk::EventObject &amp; ) void SetValues(const ParticleSystem * ps, int idx, int d) virtual void PositionAddEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionSetEventCallback(Object * o, const itk::EventObject &amp; e) virtual void PositionRemoveEventCallback(Object * , const itk::EventObject &amp; ) void PrintMatrix() bool CheckForNans()"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#protected-functions","title":"Protected Functions","text":"Name ShapeMatrix() virtual ~ShapeMatrix() void PrintSelf(std::ostream &amp; os, itk::Indent indent) const"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#protected-attributes","title":"Protected Attributes","text":"Name int m_DomainsPerShape"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from shapeworks::Observer</p> Name struct DefinedCallbacksStruct <p>Public Functions inherited from shapeworks::Observer</p> Name virtual void TransformSetEventCallback(Object * , const itk::EventObject &amp; ) virtual void PrefixTransformSetEventCallback(Object * , const itk::EventObject &amp; ) <p>Protected Functions inherited from shapeworks::Observer</p> Name Observer() virtual ~Observer() <p>Public Attributes inherited from shapeworks::Observer</p> Name DefinedCallbacksStruct m_DefinedCallbacks"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ShapeMatrix;\n</code></pre> <p>Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </p> <p>Each column represents a single shape. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-datatype","title":"typedef DataType","text":"<pre><code>typedef double shapeworks::ShapeMatrix::DataType;\n</code></pre> <p>Standard class typedefs </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-self","title":"typedef Self","text":"<pre><code>typedef ShapeMatrix shapeworks::ShapeMatrix::Self;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-superclass","title":"typedef Superclass","text":"<pre><code>typedef Observer shapeworks::ShapeMatrix::Superclass;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-pointer","title":"typedef Pointer","text":"<pre><code>typedef itk::SmartPointer&lt;Self&gt; shapeworks::ShapeMatrix::Pointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-constpointer","title":"typedef ConstPointer","text":"<pre><code>typedef itk::SmartPointer&lt;const Self&gt; shapeworks::ShapeMatrix::ConstPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#typedef-constweakpointer","title":"typedef ConstWeakPointer","text":"<pre><code>typedef itk::WeakPointer&lt;const Self&gt; shapeworks::ShapeMatrix::ConstWeakPointer;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-itknewmacro","title":"function itkNewMacro","text":"<pre><code>itkNewMacro(\n    Self \n)\n</code></pre> <p>Method for creation through the object factory. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-itktypemacro","title":"function itkTypeMacro","text":"<pre><code>itkTypeMacro(\n    ShapeMatrix ,\n    Observer \n)\n</code></pre> <p>Run-time type information (and related methods). </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setdomainspershape","title":"function SetDomainsPerShape","text":"<pre><code>inline void SetDomainsPerShape(\n    int i\n)\n</code></pre> <p>Set/Get the number of domains per shape. This can only be safely done before shapes are initialized with points! </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-getdomainspershape","title":"function GetDomainsPerShape","text":"<pre><code>inline int GetDomainsPerShape() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setattributesperdomain","title":"function SetAttributesPerDomain","text":"<pre><code>inline void SetAttributesPerDomain(\n    const std::vector&lt; int &gt; &amp; i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setattributescales","title":"function SetAttributeScales","text":"<pre><code>inline void SetAttributeScales(\n    const std::vector&lt; double &gt; &amp; s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setxyz","title":"function SetXYZ","text":"<pre><code>inline void SetXYZ(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setnormals","title":"function SetNormals","text":"<pre><code>inline void SetNormals(\n    int i,\n    bool val\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setmatrix","title":"function SetMatrix","text":"<pre><code>inline virtual void SetMatrix(\n    const vnl_matrix&lt; double &gt; &amp; m\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-resizematrix","title":"function ResizeMatrix","text":"<pre><code>inline virtual void ResizeMatrix(\n    int rs,\n    int cs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-domainaddeventcallback","title":"function DomainAddEventCallback","text":"<pre><code>inline virtual void DomainAddEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::DomainAddEventCallback</p> <p>Callbacks that may be defined by a subclass. If a subclass defines one of these callback methods, the corresponding flag in m_DefinedCallbacks should be set to true so that the ParticleSystem will know to register the appropriate event with this method. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-setvalues","title":"function SetValues","text":"<pre><code>inline void SetValues(\n    const ParticleSystem * ps,\n    int idx,\n    int d\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-positionaddeventcallback","title":"function PositionAddEventCallback","text":"<pre><code>inline virtual void PositionAddEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionAddEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-positionseteventcallback","title":"function PositionSetEventCallback","text":"<pre><code>inline virtual void PositionSetEventCallback(\n    Object * o,\n    const itk::EventObject &amp; e\n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionSetEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-positionremoveeventcallback","title":"function PositionRemoveEventCallback","text":"<pre><code>inline virtual void PositionRemoveEventCallback(\n    Object * ,\n    const itk::EventObject &amp; \n)\n</code></pre> <p>Reimplements: shapeworks::Observer::PositionRemoveEventCallback</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-printmatrix","title":"function PrintMatrix","text":"<pre><code>inline void PrintMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-checkfornans","title":"function CheckForNans","text":"<pre><code>inline bool CheckForNans()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-shapematrix","title":"function ShapeMatrix","text":"<pre><code>inline ShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-shapematrix_1","title":"function ~ShapeMatrix","text":"<pre><code>inline virtual ~ShapeMatrix()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#function-printself","title":"function PrintSelf","text":"<pre><code>inline void PrintSelf(\n    std::ostream &amp; os,\n    itk::Indent indent\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeMatrix.html#variable-m_domainspershape","title":"variable m_DomainsPerShape","text":"<pre><code>int m_DomainsPerShape;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html","title":"shapeworks::ShapeScalarJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#public-types","title":"Public Types","text":"Name enum class JobType enum class Direction"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#public-functions","title":"Public Functions","text":"Name ShapeScalarJob(QSharedPointer&lt; Session &gt; session, QString target_feature, Eigen::MatrixXd target_particles, JobType job_type) virtual void run() overriderun the job virtual QString name() overrideget the name of the job QPixmap get_plot() void set_number_of_components(int num_components) void set_number_of_folds(int num_folds) void set_max_number_of_components(int num) Eigen::VectorXd get_prediction() void set_direction(Direction direction) Eigen::VectorXd predict_scalars(QSharedPointer&lt; Session &gt; session, QString target_feature, Eigen::MatrixXd target_particles) Eigen::VectorXd predict_shape(QSharedPointer&lt; Session &gt; session, QString target_feature, Eigen::MatrixXd target_particles) void clear_model()"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#enum-jobtype","title":"enum JobType","text":"Enumerator Value Description Find_Components MSE_Plot Predict"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#enum-direction","title":"enum Direction","text":"Enumerator Value Description To_Shape To_Scalar"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-shapescalarjob","title":"function ShapeScalarJob","text":"<pre><code>ShapeScalarJob(\n    QSharedPointer&lt; Session &gt; session,\n    QString target_feature,\n    Eigen::MatrixXd target_particles,\n    JobType job_type\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-get_plot","title":"function get_plot","text":"<pre><code>QPixmap get_plot()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-set_number_of_components","title":"function set_number_of_components","text":"<pre><code>inline void set_number_of_components(\n    int num_components\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-set_number_of_folds","title":"function set_number_of_folds","text":"<pre><code>inline void set_number_of_folds(\n    int num_folds\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-set_max_number_of_components","title":"function set_max_number_of_components","text":"<pre><code>inline void set_max_number_of_components(\n    int num\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-get_prediction","title":"function get_prediction","text":"<pre><code>inline Eigen::VectorXd get_prediction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-set_direction","title":"function set_direction","text":"<pre><code>inline void set_direction(\n    Direction direction\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-predict_scalars","title":"function predict_scalars","text":"<pre><code>static Eigen::VectorXd predict_scalars(\n    QSharedPointer&lt; Session &gt; session,\n    QString target_feature,\n    Eigen::MatrixXd target_particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-predict_shape","title":"function predict_shape","text":"<pre><code>static Eigen::VectorXd predict_shape(\n    QSharedPointer&lt; Session &gt; session,\n    QString target_feature,\n    Eigen::MatrixXd target_particles\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarJob.html#function-clear_model","title":"function clear_model","text":"<pre><code>static inline void clear_model()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html","title":"shapeworks::ShapeScalarPanel","text":"<p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-slots","title":"Public Slots","text":"Name void run_clicked() void handle_job_progress(int progress) void handle_job_complete()"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-signals","title":"Public Signals","text":"Name void update_view()"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-functions","title":"Public Functions","text":"Name ShapeScalarPanel(QWidget * parent =0) ~ShapeScalarPanel() void set_session(QSharedPointer&lt; Session &gt; session)set the pointer to the session void reset()"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#slot-run_clicked","title":"slot run_clicked","text":"<pre><code>void run_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#slot-handle_job_progress","title":"slot handle_job_progress","text":"<pre><code>void handle_job_progress(\n    int progress\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#slot-handle_job_complete","title":"slot handle_job_complete","text":"<pre><code>void handle_job_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#signal-update_view","title":"signal update_view","text":"<pre><code>void update_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#function-shapescalarpanel","title":"function ShapeScalarPanel","text":"<pre><code>ShapeScalarPanel(\n    QWidget * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#function-shapescalarpanel_1","title":"function ~ShapeScalarPanel","text":"<pre><code>~ShapeScalarPanel()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre> <p>set the pointer to the session </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeScalarPanel.html#function-reset","title":"function reset","text":"<pre><code>void reset()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html","title":"shapeworks::ShapeWorksStudioApp","text":"<p>Main ShapeWorksStudio window.  More...</p> <p><code>#include &lt;ShapeWorksStudioApp.h&gt;</code></p> <p>Inherits from QMainWindow</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#public-slots","title":"Public Slots","text":"Name void open_project(QString filename) void on_action_new_project_triggered() void on_action_open_project_triggered() void on_action_show_project_folder_triggered() bool on_action_save_project_triggered() bool save_project_as(QString type) void save_as_swproj_clicked() void save_as_xlsx_clicked() void on_action_quit_triggered() void on_action_import_triggered() void splash_screen_closed() void on_vertical_scroll_bar_valueChanged() void on_action_import_mode_triggered() void on_action_groom_mode_triggered() void on_action_optimize_mode_triggered() void on_action_analysis_mode_triggered() void on_action_deepssm_mode_triggered() void on_action_monai_mode_triggered() void on_actionShow_Tool_Window_triggered() void on_actionExport_PCA_Mesh_triggered() void on_actionExport_Eigenvalues_triggered() void on_actionExport_Eigenvectors_triggered() void on_actionExport_PCA_Mode_Points_triggered() void on_action_preferences_triggered() void action_export_current_mesh_triggered(int index =0, bool clip_constraints =false) void on_action_export_current_particles_triggered() void on_action_export_mesh_scalars_triggered() void on_action_export_pca_scores_triggered() void action_export_pca_montage_triggered() void action_export_screenshot_triggered() void action_export_particle_scalars_triggered() void action_export_all_subjects_particle_scalars_triggered() void on_center_checkbox_stateChanged() void on_zoom_slider_valueChanged() void on_view_mode_combobox_currentIndexChanged(QString disp_mode) void on_auto_view_button_clicked() void handle_pca_changed() void handle_slider_update() void handle_mca_changed() void handle_project_changed() void handle_points_changed() void handle_groom_start() void handle_groom_complete() void handle_optimize_start() void handle_optimize_complete() void handle_reconstruction_complete() void handle_reset_stats() void handle_display_setting_changed() void handle_glyph_changed() void handle_opacity_changed() void handle_alignment_changed() void handle_open_recent() void handle_color_scheme() void handle_pca_update() void clear_message() void handle_message(std::string str) void handle_error(std::string str) void handle_warning(std::string str) void handle_debug(std::string str) void handle_status(std::string str) void handle_progress_with_message(int amt, std::string str) void handle_progress(int amt) void message_callback(std::string str) void handle_new_mesh() void handle_clear_cache() void handle_compare_settings_changed() void handle_lightbox_right_click(int index) void update_feature_map_selection(int index) void update_feature_map_scale() void image_combo_changed(int index) void handle_image_name_changed() void show_splash_screen() void hide_splash_screen() void about() void keyboard_shortcuts() void toggle_log_window() QSharedPointer&lt; PythonWorker &gt; get_py_worker() Preferences &amp; prefs() QSharedPointer&lt; Session &gt; session() QSharedPointer&lt; Visualizer &gt; get_visualizer()"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#public-functions","title":"Public Functions","text":"Name ShapeWorksStudioApp() ~ShapeWorksStudioApp() void closeEvent(QCloseEvent * event) override void initialize_vtk() void import_files(QStringList file_names)"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#protected-functions","title":"Protected Functions","text":"Name void dragEnterEvent(QDragEnterEvent * event) override void dragLeaveEvent(QDragLeaveEvent * event) override void dropEvent(QDropEvent * event) override"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::ShapeWorksStudioApp;\n</code></pre> <p>Main ShapeWorksStudio window. </p> <p>This class represents the primary ShapeWorksStudio window interface </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-open_project","title":"slot open_project","text":"<pre><code>void open_project(\n    QString filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_new_project_triggered","title":"slot on_action_new_project_triggered","text":"<pre><code>void on_action_new_project_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_open_project_triggered","title":"slot on_action_open_project_triggered","text":"<pre><code>void on_action_open_project_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_show_project_folder_triggered","title":"slot on_action_show_project_folder_triggered","text":"<pre><code>void on_action_show_project_folder_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_save_project_triggered","title":"slot on_action_save_project_triggered","text":"<pre><code>bool on_action_save_project_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-save_project_as","title":"slot save_project_as","text":"<pre><code>bool save_project_as(\n    QString type\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-save_as_swproj_clicked","title":"slot save_as_swproj_clicked","text":"<pre><code>void save_as_swproj_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-save_as_xlsx_clicked","title":"slot save_as_xlsx_clicked","text":"<pre><code>void save_as_xlsx_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_quit_triggered","title":"slot on_action_quit_triggered","text":"<pre><code>void on_action_quit_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_import_triggered","title":"slot on_action_import_triggered","text":"<pre><code>void on_action_import_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-splash_screen_closed","title":"slot splash_screen_closed","text":"<pre><code>void splash_screen_closed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_vertical_scroll_bar_valuechanged","title":"slot on_vertical_scroll_bar_valueChanged","text":"<pre><code>void on_vertical_scroll_bar_valueChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_import_mode_triggered","title":"slot on_action_import_mode_triggered","text":"<pre><code>void on_action_import_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_groom_mode_triggered","title":"slot on_action_groom_mode_triggered","text":"<pre><code>void on_action_groom_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_optimize_mode_triggered","title":"slot on_action_optimize_mode_triggered","text":"<pre><code>void on_action_optimize_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_analysis_mode_triggered","title":"slot on_action_analysis_mode_triggered","text":"<pre><code>void on_action_analysis_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_deepssm_mode_triggered","title":"slot on_action_deepssm_mode_triggered","text":"<pre><code>void on_action_deepssm_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_monai_mode_triggered","title":"slot on_action_monai_mode_triggered","text":"<pre><code>void on_action_monai_mode_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_actionshow_tool_window_triggered","title":"slot on_actionShow_Tool_Window_triggered","text":"<pre><code>void on_actionShow_Tool_Window_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_actionexport_pca_mesh_triggered","title":"slot on_actionExport_PCA_Mesh_triggered","text":"<pre><code>void on_actionExport_PCA_Mesh_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_actionexport_eigenvalues_triggered","title":"slot on_actionExport_Eigenvalues_triggered","text":"<pre><code>void on_actionExport_Eigenvalues_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_actionexport_eigenvectors_triggered","title":"slot on_actionExport_Eigenvectors_triggered","text":"<pre><code>void on_actionExport_Eigenvectors_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_actionexport_pca_mode_points_triggered","title":"slot on_actionExport_PCA_Mode_Points_triggered","text":"<pre><code>void on_actionExport_PCA_Mode_Points_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_preferences_triggered","title":"slot on_action_preferences_triggered","text":"<pre><code>void on_action_preferences_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-action_export_current_mesh_triggered","title":"slot action_export_current_mesh_triggered","text":"<pre><code>void action_export_current_mesh_triggered(\n    int index =0,\n    bool clip_constraints =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_export_current_particles_triggered","title":"slot on_action_export_current_particles_triggered","text":"<pre><code>void on_action_export_current_particles_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_export_mesh_scalars_triggered","title":"slot on_action_export_mesh_scalars_triggered","text":"<pre><code>void on_action_export_mesh_scalars_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_action_export_pca_scores_triggered","title":"slot on_action_export_pca_scores_triggered","text":"<pre><code>void on_action_export_pca_scores_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-action_export_pca_montage_triggered","title":"slot action_export_pca_montage_triggered","text":"<pre><code>void action_export_pca_montage_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-action_export_screenshot_triggered","title":"slot action_export_screenshot_triggered","text":"<pre><code>void action_export_screenshot_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-action_export_particle_scalars_triggered","title":"slot action_export_particle_scalars_triggered","text":"<pre><code>void action_export_particle_scalars_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-action_export_all_subjects_particle_scalars_triggered","title":"slot action_export_all_subjects_particle_scalars_triggered","text":"<pre><code>void action_export_all_subjects_particle_scalars_triggered()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_center_checkbox_statechanged","title":"slot on_center_checkbox_stateChanged","text":"<pre><code>void on_center_checkbox_stateChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_zoom_slider_valuechanged","title":"slot on_zoom_slider_valueChanged","text":"<pre><code>void on_zoom_slider_valueChanged()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_view_mode_combobox_currentindexchanged","title":"slot on_view_mode_combobox_currentIndexChanged","text":"<pre><code>void on_view_mode_combobox_currentIndexChanged(\n    QString disp_mode\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-on_auto_view_button_clicked","title":"slot on_auto_view_button_clicked","text":"<pre><code>void on_auto_view_button_clicked()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_pca_changed","title":"slot handle_pca_changed","text":"<pre><code>void handle_pca_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_slider_update","title":"slot handle_slider_update","text":"<pre><code>void handle_slider_update()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_mca_changed","title":"slot handle_mca_changed","text":"<pre><code>void handle_mca_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_project_changed","title":"slot handle_project_changed","text":"<pre><code>void handle_project_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_points_changed","title":"slot handle_points_changed","text":"<pre><code>void handle_points_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_groom_start","title":"slot handle_groom_start","text":"<pre><code>void handle_groom_start()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_groom_complete","title":"slot handle_groom_complete","text":"<pre><code>void handle_groom_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_optimize_start","title":"slot handle_optimize_start","text":"<pre><code>void handle_optimize_start()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_optimize_complete","title":"slot handle_optimize_complete","text":"<pre><code>void handle_optimize_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_reconstruction_complete","title":"slot handle_reconstruction_complete","text":"<pre><code>void handle_reconstruction_complete()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_reset_stats","title":"slot handle_reset_stats","text":"<pre><code>void handle_reset_stats()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_display_setting_changed","title":"slot handle_display_setting_changed","text":"<pre><code>void handle_display_setting_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_glyph_changed","title":"slot handle_glyph_changed","text":"<pre><code>void handle_glyph_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_opacity_changed","title":"slot handle_opacity_changed","text":"<pre><code>void handle_opacity_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_alignment_changed","title":"slot handle_alignment_changed","text":"<pre><code>void handle_alignment_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_open_recent","title":"slot handle_open_recent","text":"<pre><code>void handle_open_recent()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_color_scheme","title":"slot handle_color_scheme","text":"<pre><code>void handle_color_scheme()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_pca_update","title":"slot handle_pca_update","text":"<pre><code>void handle_pca_update()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-clear_message","title":"slot clear_message","text":"<pre><code>void clear_message()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_message","title":"slot handle_message","text":"<pre><code>void handle_message(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_error","title":"slot handle_error","text":"<pre><code>void handle_error(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_warning","title":"slot handle_warning","text":"<pre><code>void handle_warning(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_debug","title":"slot handle_debug","text":"<pre><code>void handle_debug(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_status","title":"slot handle_status","text":"<pre><code>void handle_status(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_progress_with_message","title":"slot handle_progress_with_message","text":"<pre><code>void handle_progress_with_message(\n    int amt,\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_progress","title":"slot handle_progress","text":"<pre><code>void handle_progress(\n    int amt\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-message_callback","title":"slot message_callback","text":"<pre><code>void message_callback(\n    std::string str\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_new_mesh","title":"slot handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_clear_cache","title":"slot handle_clear_cache","text":"<pre><code>void handle_clear_cache()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_compare_settings_changed","title":"slot handle_compare_settings_changed","text":"<pre><code>void handle_compare_settings_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_lightbox_right_click","title":"slot handle_lightbox_right_click","text":"<pre><code>void handle_lightbox_right_click(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-update_feature_map_selection","title":"slot update_feature_map_selection","text":"<pre><code>void update_feature_map_selection(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-update_feature_map_scale","title":"slot update_feature_map_scale","text":"<pre><code>void update_feature_map_scale()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-image_combo_changed","title":"slot image_combo_changed","text":"<pre><code>void image_combo_changed(\n    int index\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-handle_image_name_changed","title":"slot handle_image_name_changed","text":"<pre><code>void handle_image_name_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-show_splash_screen","title":"slot show_splash_screen","text":"<pre><code>void show_splash_screen()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-hide_splash_screen","title":"slot hide_splash_screen","text":"<pre><code>void hide_splash_screen()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-about","title":"slot about","text":"<pre><code>void about()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-keyboard_shortcuts","title":"slot keyboard_shortcuts","text":"<pre><code>void keyboard_shortcuts()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-toggle_log_window","title":"slot toggle_log_window","text":"<pre><code>void toggle_log_window()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-get_py_worker","title":"slot get_py_worker","text":"<pre><code>QSharedPointer&lt; PythonWorker &gt; get_py_worker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-prefs","title":"slot prefs","text":"<pre><code>inline Preferences &amp; prefs()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-session","title":"slot session","text":"<pre><code>inline QSharedPointer&lt; Session &gt; session()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#slot-get_visualizer","title":"slot get_visualizer","text":"<pre><code>inline QSharedPointer&lt; Visualizer &gt; get_visualizer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-shapeworksstudioapp","title":"function ShapeWorksStudioApp","text":"<pre><code>ShapeWorksStudioApp()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-shapeworksstudioapp_1","title":"function ~ShapeWorksStudioApp","text":"<pre><code>~ShapeWorksStudioApp()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-closeevent","title":"function closeEvent","text":"<pre><code>void closeEvent(\n    QCloseEvent * event\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-initialize_vtk","title":"function initialize_vtk","text":"<pre><code>void initialize_vtk()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-import_files","title":"function import_files","text":"<pre><code>void import_files(\n    QStringList file_names\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-dragenterevent","title":"function dragEnterEvent","text":"<pre><code>void dragEnterEvent(\n    QDragEnterEvent * event\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-dragleaveevent","title":"function dragLeaveEvent","text":"<pre><code>void dragLeaveEvent(\n    QDragLeaveEvent * event\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksStudioApp.html#function-dropevent","title":"function dropEvent","text":"<pre><code>void dropEvent(\n    QDropEvent * event\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html","title":"shapeworks::ShapeWorksUtils","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#public-functions","title":"Public Functions","text":"Name time_point now()get the current time double elapsed(time_point start, time_point end, bool print_elapsed =true)return elapsed time in seconds, optionally printing to console unsigned get_rng_seed()returns random seed void set_rng_seed(const unsigned seed)sets random seed unsigned get_random_number()generates random number bool is_directory(const std::string &amp; pathname)returns true if pathname is a directory bool file_exists(const std::string &amp; filename)returns true if filename exists void setup_console_logging(bool show_progress, bool xml_status)Set up the console logging options. void set_progress_callback(void * ptr)Set up a progress callback. void setup_threads()Set up the number of threads from TBB_NUM_THREADS env variable. Matrix33 convert_matrix(const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat)converts a vtkMatrix4x4 to a Matrix33 and corresponding translationVector Vector3 get_offset(const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat)"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-now","title":"function now","text":"<pre><code>static inline time_point now()\n</code></pre> <p>get the current time </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-elapsed","title":"function elapsed","text":"<pre><code>static double elapsed(\n    time_point start,\n    time_point end,\n    bool print_elapsed =true\n)\n</code></pre> <p>return elapsed time in seconds, optionally printing to console </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-get_rng_seed","title":"function get_rng_seed","text":"<pre><code>static inline unsigned get_rng_seed()\n</code></pre> <p>returns random seed </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-set_rng_seed","title":"function set_rng_seed","text":"<pre><code>static void set_rng_seed(\n    const unsigned seed\n)\n</code></pre> <p>sets random seed </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-get_random_number","title":"function get_random_number","text":"<pre><code>static inline unsigned get_random_number()\n</code></pre> <p>generates random number </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-is_directory","title":"function is_directory","text":"<pre><code>static bool is_directory(\n    const std::string &amp; pathname\n)\n</code></pre> <p>returns true if pathname is a directory </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-file_exists","title":"function file_exists","text":"<pre><code>static bool file_exists(\n    const std::string &amp; filename\n)\n</code></pre> <p>returns true if filename exists </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-setup_console_logging","title":"function setup_console_logging","text":"<pre><code>static void setup_console_logging(\n    bool show_progress,\n    bool xml_status\n)\n</code></pre> <p>Set up the console logging options. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-set_progress_callback","title":"function set_progress_callback","text":"<pre><code>static void set_progress_callback(\n    void * ptr\n)\n</code></pre> <p>Set up a progress callback. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-setup_threads","title":"function setup_threads","text":"<pre><code>static void setup_threads()\n</code></pre> <p>Set up the number of threads from TBB_NUM_THREADS env variable. </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-convert_matrix","title":"function convert_matrix","text":"<pre><code>static Matrix33 convert_matrix(\n    const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat\n)\n</code></pre> <p>converts a vtkMatrix4x4 to a Matrix33 and corresponding translationVector </p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksUtils.html#function-get_offset","title":"function get_offset","text":"<pre><code>static Vector3 get_offset(\n    const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html","title":"shapeworks::ShapeWorksVtkOutputWindow","text":"<p>Implementation of vtkOutputWindow to capture and display VTK error messages. </p> <p><code>#include &lt;ShapeWorksVtkOutputWindow.h&gt;</code></p> <p>Inherits from QObject, vtkOutputWindow</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#public-functions","title":"Public Functions","text":"Name ShapeWorksVtkOutputWindow * New() vtkTypeMacro(ShapeWorksVtkOutputWindow , vtkOutputWindow ) ShapeWorksVtkOutputWindow() void DisplayErrorText(const char * text) override void DisplayWarningText(const char * text) override void DisplayGenericWarningText(const char * text) override void DisplayDebugText(const char * text) override"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-new","title":"function New","text":"<pre><code>static ShapeWorksVtkOutputWindow * New()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    ShapeWorksVtkOutputWindow ,\n    vtkOutputWindow \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-shapeworksvtkoutputwindow","title":"function ShapeWorksVtkOutputWindow","text":"<pre><code>ShapeWorksVtkOutputWindow()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-displayerrortext","title":"function DisplayErrorText","text":"<pre><code>void DisplayErrorText(\n    const char * text\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-displaywarningtext","title":"function DisplayWarningText","text":"<pre><code>void DisplayWarningText(\n    const char * text\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-displaygenericwarningtext","title":"function DisplayGenericWarningText","text":"<pre><code>void DisplayGenericWarningText(\n    const char * text\n) override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeWorksVtkOutputWindow.html#function-displaydebugtext","title":"function DisplayDebugText","text":"<pre><code>void DisplayDebugText(\n    const char * text\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html","title":"classshapeworks 1 1Shape 1 1Point","text":"<p>title: shapeworks::Shape::Point summary: TODO: replace this wherever it is used. </p>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#shapeworksshapepoint","title":"shapeworks::Shape::Point","text":"<p>TODO: replace this wherever it is used. </p> <p><code>#include &lt;Shape.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#public-functions","title":"Public Functions","text":"Name Point() Point(double _x, double _y, double _z)"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#public-attributes","title":"Public Attributes","text":"Name double x double y double z"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#function-point","title":"function Point","text":"<pre><code>inline Point()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#function-point_1","title":"function Point","text":"<pre><code>inline Point(\n    double _x,\n    double _y,\n    double _z\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#variable-x","title":"variable x","text":"<pre><code>double x = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#variable-y","title":"variable y","text":"<pre><code>double y = 0;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Shape_1_1Point.html#variable-z","title":"variable z","text":"<pre><code>double z = 0;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksCommand.html","title":"shapeworks::ShapeworksCommand","text":"<p>Inherits from shapeworks::Command</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksCommand.html#public-functions","title":"Public Functions","text":"Name virtual const std::string type() override"},{"location":"api/Classes/classshapeworks_1_1ShapeworksCommand.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from shapeworks::Command</p> Name const std::string name() const const std::string usage() const const std::string desc() const std::vector&lt; std::string &gt; parse_args(const std::vector&lt; std::string &gt; &amp; arguments)parses the arguments for this command, saving them in the parser and returning the leftovers int run(SharedCommandData &amp; sharedData)calls execute for this command using the parsed args, returning system exit value <p>Protected Functions inherited from shapeworks::Command</p> Name virtual void buildParser() <p>Protected Attributes inherited from shapeworks::Command</p> Name optparse::OptionParser parser"},{"location":"api/Classes/classshapeworks_1_1ShapeworksCommand.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeworksCommand.html#function-type","title":"function type","text":"<pre><code>inline virtual const std::string type() override\n</code></pre> <p>Reimplements: shapeworks::Command::type</p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html","title":"shapeworks::ShapeworksWorker","text":"<p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-types","title":"Public Types","text":"Name enum ThreadType"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-slots","title":"Public Slots","text":"Name void process()"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-signals","title":"Public Signals","text":"Name void result_ready() void failure() void finished()"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-functions","title":"Public Functions","text":"Name ShapeworksWorker(ThreadType type, QSharedPointer&lt; Groom &gt; groom, QSharedPointer&lt; Optimize &gt; optimize, QSharedPointer&lt; OptimizeParameters &gt; optimize_parameters, QSharedPointer&lt; Session &gt; session, double maxAngle =45., float decimationPercent =0.3f, int numClusters =5) ~ShapeworksWorker()"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#enum-threadtype","title":"enum ThreadType","text":"Enumerator Value Description GroomType OptimizeType ReconstructType"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#slot-process","title":"slot process","text":"<pre><code>void process()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#signal-result_ready","title":"signal result_ready","text":"<pre><code>void result_ready()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#signal-failure","title":"signal failure","text":"<pre><code>void failure()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#signal-finished","title":"signal finished","text":"<pre><code>void finished()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#function-shapeworksworker","title":"function ShapeworksWorker","text":"<pre><code>ShapeworksWorker(\n    ThreadType type,\n    QSharedPointer&lt; Groom &gt; groom,\n    QSharedPointer&lt; Optimize &gt; optimize,\n    QSharedPointer&lt; OptimizeParameters &gt; optimize_parameters,\n    QSharedPointer&lt; Session &gt; session,\n    double maxAngle =45.,\n    float decimationPercent =0.3f,\n    int numClusters =5\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1ShapeworksWorker.html#function-shapeworksworker_1","title":"function ~ShapeworksWorker","text":"<pre><code>~ShapeworksWorker()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html","title":"shapeworks::SliceView","text":"<p>SliceView.  More...</p> <p><code>#include &lt;SliceView.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#public-types","title":"Public Types","text":"Name enum SliceChange"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#public-functions","title":"Public Functions","text":"Name SliceView(Viewer * viewer) void set_volume(std::shared_ptr&lt; Image &gt; volume) void add_mesh(vtkSmartPointer&lt; vtkPolyData &gt; poly_data) void set_mask(std::shared_ptr&lt; Image &gt; mask) void clear_meshes() void set_orientation(int orientation) bool is_image_loaded() void update_colormap() void update_renderer() void update_camera() Point handle_key(std::string key) void change_slice(SliceChange change) Point get_slice_position() void set_slice_position(Point point) void set_brightness_and_contrast(double brightness, double contrast) double get_spacing() int get_orientation_index() void update_particles() Viewer * get_viewer() bool should_point_show(double x, double y, double z) int get_slice_number() vtkSmartPointer&lt; vtkImageActor &gt; get_image_actor() vtkPlane * get_slice_plane() void update()"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::SliceView;\n</code></pre> <p>SliceView. </p> <p>Provide slice viewing to the Viewer</p>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SliceView.html#enum-slicechange","title":"enum SliceChange","text":"Enumerator Value Description Down Up"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-sliceview","title":"function SliceView","text":"<pre><code>SliceView(\n    Viewer * viewer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-set_volume","title":"function set_volume","text":"<pre><code>void set_volume(\n    std::shared_ptr&lt; Image &gt; volume\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-add_mesh","title":"function add_mesh","text":"<pre><code>void add_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-set_mask","title":"function set_mask","text":"<pre><code>void set_mask(\n    std::shared_ptr&lt; Image &gt; mask\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-clear_meshes","title":"function clear_meshes","text":"<pre><code>void clear_meshes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-set_orientation","title":"function set_orientation","text":"<pre><code>void set_orientation(\n    int orientation\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-is_image_loaded","title":"function is_image_loaded","text":"<pre><code>bool is_image_loaded()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-update_colormap","title":"function update_colormap","text":"<pre><code>void update_colormap()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-update_renderer","title":"function update_renderer","text":"<pre><code>void update_renderer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-update_camera","title":"function update_camera","text":"<pre><code>void update_camera()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-handle_key","title":"function handle_key","text":"<pre><code>Point handle_key(\n    std::string key\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-change_slice","title":"function change_slice","text":"<pre><code>void change_slice(\n    SliceChange change\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_slice_position","title":"function get_slice_position","text":"<pre><code>Point get_slice_position()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-set_slice_position","title":"function set_slice_position","text":"<pre><code>void set_slice_position(\n    Point point\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-set_brightness_and_contrast","title":"function set_brightness_and_contrast","text":"<pre><code>void set_brightness_and_contrast(\n    double brightness,\n    double contrast\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_spacing","title":"function get_spacing","text":"<pre><code>double get_spacing()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_orientation_index","title":"function get_orientation_index","text":"<pre><code>int get_orientation_index()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-update_particles","title":"function update_particles","text":"<pre><code>void update_particles()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_viewer","title":"function get_viewer","text":"<pre><code>Viewer * get_viewer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-should_point_show","title":"function should_point_show","text":"<pre><code>bool should_point_show(\n    double x,\n    double y,\n    double z\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_slice_number","title":"function get_slice_number","text":"<pre><code>int get_slice_number()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_image_actor","title":"function get_image_actor","text":"<pre><code>vtkSmartPointer&lt; vtkImageActor &gt; get_image_actor()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-get_slice_plane","title":"function get_slice_plane","text":"<pre><code>vtkPlane * get_slice_plane()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1SliceView.html#function-update","title":"function update","text":"<pre><code>void update()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html","title":"shapeworks::SplashScreen","text":"<p>More...</p> <p><code>#include &lt;SplashScreen.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#public-signals","title":"Public Signals","text":"Name void open_project(QString file_path)signal to open a particular project"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#public-functions","title":"Public Functions","text":"Name SplashScreen(QWidget * parent, Preferences &amp; preferences)constructor virtual ~SplashScreen()destructor"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::SplashScreen;\n</code></pre> <p>The SplashScreen is a QDialog that implements the user interface for the Studio Splash Screen It supports a recent file list as well as loading other existing projects </p>"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#signal-open_project","title":"signal open_project","text":"<pre><code>void open_project(\n    QString file_path\n)\n</code></pre> <p>signal to open a particular project </p>"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#function-splashscreen","title":"function SplashScreen","text":"<pre><code>SplashScreen(\n    QWidget * parent,\n    Preferences &amp; preferences\n)\n</code></pre> <p>constructor </p>"},{"location":"api/Classes/classshapeworks_1_1SplashScreen.html#function-splashscreen_1","title":"function ~SplashScreen","text":"<pre><code>virtual ~SplashScreen()\n</code></pre> <p>destructor </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html","title":"shapeworks::StatsGroupLDAJob","text":"<p>Inherits from shapeworks::Job, QObject</p>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#public-functions","title":"Public Functions","text":"Name StatsGroupLDAJob() void set_stats(ParticleShapeStatistics stats) virtual void run() overriderun the job virtual QString name() overrideget the name of the job Eigen::VectorXf get_group_pvalues() void plot(JKQTPlotter * plot, QString group_1_name, QString group_2_name)"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Signals inherited from shapeworks::Job</p> Name void progress(double , QString  =\"\") void finished() <p>Public Functions inherited from shapeworks::Job</p> Name Job() virtual ~Job() virtual QString get_completion_message()get a message to display when the job is complete virtual QString get_abort_message()get a message to display when the job is aborted void start_timer()start the timer qint64 timer_elapsed()how much time has elapsed since the timer was started void set_complete(bool complete)set the job as complete bool is_complete() constis the job complete? void abort()abort the job bool is_aborted() constwas the job aborted? void set_quiet_mode(bool quiet)set to quiet mode (no progress messages) bool get_quiet_mode()get quiet mode"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-statsgroupldajob","title":"function StatsGroupLDAJob","text":"<pre><code>StatsGroupLDAJob()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-set_stats","title":"function set_stats","text":"<pre><code>void set_stats(\n    ParticleShapeStatistics stats\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-run","title":"function run","text":"<pre><code>virtual void run() override\n</code></pre> <p>run the job </p> <p>Reimplements: shapeworks::Job::run</p>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-name","title":"function name","text":"<pre><code>virtual QString name() override\n</code></pre> <p>get the name of the job </p> <p>Reimplements: shapeworks::Job::name</p>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-get_group_pvalues","title":"function get_group_pvalues","text":"<pre><code>Eigen::VectorXf get_group_pvalues()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatsGroupLDAJob.html#function-plot","title":"function plot","text":"<pre><code>void plot(\n    JKQTPlotter * plot,\n    QString group_1_name,\n    QString group_2_name\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html","title":"shapeworks::StatusBarWidget","text":"<p>StatusBarWidget.  More...</p> <p><code>#include &lt;StatusBarWidget.h&gt;</code></p> <p>Inherits from QWidget</p>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#public-signals","title":"Public Signals","text":"Name void toggle_log_window()"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#public-functions","title":"Public Functions","text":"Name StatusBarWidget(QMainWindow * parent =0) void set_message(MessageType message_type, QString message) void set_progress(int value) void resizeEvent(QResizeEvent * event) override"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::StatusBarWidget;\n</code></pre> <p>StatusBarWidget. </p> <p>This widget is used in place of the standard QStatusBar It supports a log window toggle, current message, with color, and progressbar </p>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#signal-toggle_log_window","title":"signal toggle_log_window","text":"<pre><code>void toggle_log_window()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#function-statusbarwidget","title":"function StatusBarWidget","text":"<pre><code>StatusBarWidget(\n    QMainWindow * parent =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#function-set_message","title":"function set_message","text":"<pre><code>void set_message(\n    MessageType message_type,\n    QString message\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#function-set_progress","title":"function set_progress","text":"<pre><code>void set_progress(\n    int value\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StatusBarWidget.html#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void resizeEvent(\n    QResizeEvent * event\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html","title":"shapeworks::StringUtils","text":"<p>String utility functions. </p> <p><code>#include &lt;StringUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#public-functions","title":"Public Functions","text":"Name std::string removeExtension(std::string const &amp; filename) std::string getPath(std::string const &amp; filename) std::string getFilename(std::string const &amp; pathname)Remove path from filename and return. std::string getBaseFilenameWithoutExtension(std::string const &amp; pathname)Get just the filename without path and without extension. std::string toLower(std::string s) bool hasSuffix(std::string const &amp; filename, std::string const &amp; suffix) std::vector&lt; std::string &gt; getFileNamesFromPaths(const std::vector&lt; std::string &gt; &amp; paths) std::string getLowerExtension(std::string const &amp; filename) std::string safeString(const char * s) std::string replace_string(std::string str, const std::string &amp; search, const std::string &amp; replace)Replace a search string with a replacement. std::string join(const std::vector&lt; std::string &gt; &amp; strings, const std::string &amp; delimiter)"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-removeextension","title":"function removeExtension","text":"<pre><code>static std::string removeExtension(\n    std::string const &amp; filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-getpath","title":"function getPath","text":"<pre><code>static std::string getPath(\n    std::string const &amp; filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-getfilename","title":"function getFilename","text":"<pre><code>static std::string getFilename(\n    std::string const &amp; pathname\n)\n</code></pre> <p>Remove path from filename and return. </p>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-getbasefilenamewithoutextension","title":"function getBaseFilenameWithoutExtension","text":"<pre><code>static std::string getBaseFilenameWithoutExtension(\n    std::string const &amp; pathname\n)\n</code></pre> <p>Get just the filename without path and without extension. </p>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-tolower","title":"function toLower","text":"<pre><code>static std::string toLower(\n    std::string s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-hassuffix","title":"function hasSuffix","text":"<pre><code>static bool hasSuffix(\n    std::string const &amp; filename,\n    std::string const &amp; suffix\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-getfilenamesfrompaths","title":"function getFileNamesFromPaths","text":"<pre><code>static std::vector&lt; std::string &gt; getFileNamesFromPaths(\n    const std::vector&lt; std::string &gt; &amp; paths\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-getlowerextension","title":"function getLowerExtension","text":"<pre><code>static std::string getLowerExtension(\n    std::string const &amp; filename\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-safestring","title":"function safeString","text":"<pre><code>static inline std::string safeString(\n    const char * s\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-replace_string","title":"function replace_string","text":"<pre><code>static std::string replace_string(\n    std::string str,\n    const std::string &amp; search,\n    const std::string &amp; replace\n)\n</code></pre> <p>Replace a search string with a replacement. </p>"},{"location":"api/Classes/classshapeworks_1_1StringUtils.html#function-join","title":"function join","text":"<pre><code>static std::string join(\n    const std::vector&lt; std::string &gt; &amp; strings,\n    const std::string &amp; delimiter\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html","title":"shapeworks::StudioHandleWidget","text":"<p>Inherits from vtkHandleWidget</p>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#public-functions","title":"Public Functions","text":"Name StudioHandleWidget * New() StudioHandleWidget() void set_domain(int domain) void set_plane(int plane) void set_point(int point) void set_plane_widget(PlaneWidget * plane_widget)"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#protected-functions","title":"Protected Functions","text":"Name void RightClickSelectAction(vtkAbstractWidget * w) void CustomMoveAction(vtkAbstractWidget * w) void CustomSelectAction(vtkAbstractWidget * w) void CustomEndSelectAction(vtkAbstractWidget * w)"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#protected-attributes","title":"Protected Attributes","text":"Name int domain_ int plane_ int point_ PlaneWidget * plane_widget_ bool shift_active_ int start_y_"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-new","title":"function New","text":"<pre><code>static StudioHandleWidget * New()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-studiohandlewidget","title":"function StudioHandleWidget","text":"<pre><code>StudioHandleWidget()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-set_domain","title":"function set_domain","text":"<pre><code>inline void set_domain(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-set_plane","title":"function set_plane","text":"<pre><code>inline void set_plane(\n    int plane\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-set_point","title":"function set_point","text":"<pre><code>inline void set_point(\n    int point\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-set_plane_widget","title":"function set_plane_widget","text":"<pre><code>inline void set_plane_widget(\n    PlaneWidget * plane_widget\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-rightclickselectaction","title":"function RightClickSelectAction","text":"<pre><code>static void RightClickSelectAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-custommoveaction","title":"function CustomMoveAction","text":"<pre><code>static void CustomMoveAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-customselectaction","title":"function CustomSelectAction","text":"<pre><code>static void CustomSelectAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#function-customendselectaction","title":"function CustomEndSelectAction","text":"<pre><code>static void CustomEndSelectAction(\n    vtkAbstractWidget * w\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-domain_","title":"variable domain_","text":"<pre><code>int domain_ = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-plane_","title":"variable plane_","text":"<pre><code>int plane_ = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-point_","title":"variable point_","text":"<pre><code>int point_ = -1;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-plane_widget_","title":"variable plane_widget_","text":"<pre><code>PlaneWidget * plane_widget_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-shift_active_","title":"variable shift_active_","text":"<pre><code>bool shift_active_ = false;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioHandleWidget.html#variable-start_y_","title":"variable start_y_","text":"<pre><code>int start_y_ = 0;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html","title":"shapeworks::StudioInteractorStyle","text":"<p>Inherits from vtkInteractorStyleTrackballCamera</p>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#public-functions","title":"Public Functions","text":"Name StudioInteractorStyle * New() vtkTypeMacro(StudioInteractorStyle , vtkInteractorStyleTrackballCamera ) void set_lightbox(Lightbox * lightbox) StudioInteractorStyle() virtual ~StudioInteractorStyle() void OnLeftButtonDown() override void OnRightButtonDown() override void OnRightButtonUp() override void OnMouseWheelForward() override void OnMouseWheelBackward() override void OnKeyDown() override void Dolly() override void Rotate() override void OnMouseMove() override"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#protected-functions","title":"Protected Functions","text":"Name void Dolly(double factor) override"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-new","title":"function New","text":"<pre><code>static StudioInteractorStyle * New()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    StudioInteractorStyle ,\n    vtkInteractorStyleTrackballCamera \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-set_lightbox","title":"function set_lightbox","text":"<pre><code>void set_lightbox(\n    Lightbox * lightbox\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-studiointeractorstyle","title":"function StudioInteractorStyle","text":"<pre><code>StudioInteractorStyle()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-studiointeractorstyle_1","title":"function ~StudioInteractorStyle","text":"<pre><code>virtual ~StudioInteractorStyle()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onleftbuttondown","title":"function OnLeftButtonDown","text":"<pre><code>void OnLeftButtonDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onrightbuttondown","title":"function OnRightButtonDown","text":"<pre><code>void OnRightButtonDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onrightbuttonup","title":"function OnRightButtonUp","text":"<pre><code>void OnRightButtonUp() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onmousewheelforward","title":"function OnMouseWheelForward","text":"<pre><code>void OnMouseWheelForward() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onmousewheelbackward","title":"function OnMouseWheelBackward","text":"<pre><code>void OnMouseWheelBackward() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onkeydown","title":"function OnKeyDown","text":"<pre><code>void OnKeyDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-dolly","title":"function Dolly","text":"<pre><code>void Dolly() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-rotate","title":"function Rotate","text":"<pre><code>void Rotate() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-onmousemove","title":"function OnMouseMove","text":"<pre><code>void OnMouseMove() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioInteractorStyle.html#function-dolly_1","title":"function Dolly","text":"<pre><code>void Dolly(\n    double factor\n) override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html","title":"shapeworks::StudioMesh","text":"<p>Representation of a single mesh.  More...</p> <p><code>#include &lt;StudioMesh.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#public-functions","title":"Public Functions","text":"Name StudioMesh()Constructor. ~StudioMesh()Destructor. vtkSmartPointer&lt; vtkPolyData &gt; get_poly_data()Get the mesh polydata. void set_poly_data(vtkSmartPointer&lt; vtkPolyData &gt; poly_data)Set the poly data directly. void set_error_message(std::string error_message)Set the error message. std::string get_error_message()Return the error message. void apply_feature_map(std::string name, ImageType::Pointer image)Apply a feature map. void apply_scalars(MeshHandle mesh)Apply scalars from another mesh, with a transform. void interpolate_scalars_to_mesh(std::string name, Eigen::VectorXd positions, Eigen::VectorXd scalar_values)Interpolation scalars at positions to this mesh. double get_largest_dimension_size()Return the range of largest axis (e.g. 200 for an object that sits in 100x200x100) vtkFloatArray * get_or_create_array(std::string name, float default_value)Get or create and return an array with a given name. void paint_ffc(double world_pos[], double radius, bool inclusive)Paint free form constraint. void fill_ffc(bool inclusive)Fill all vertices with specified inclusion/exclusion value. bool has_ffc_paint()Does this mesh have free form constraint paint? Mesh get_sw_mesh()Return a shapeworks Mesh library class mesh."},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#public-attributes","title":"Public Attributes","text":"Name constexpr const char *const FFC_PAINT"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::StudioMesh;\n</code></pre> <p>Representation of a single mesh. </p> <p>The Mesh class represents a single mesh generated from an image file or set of particles. It is responsible for loading the image and generating a mesh from it.</p> <p>TODO: Merge this functionality with Libs/Mesh/Mesh class </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-studiomesh","title":"function StudioMesh","text":"<pre><code>StudioMesh()\n</code></pre> <p>Constructor. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-studiomesh_1","title":"function ~StudioMesh","text":"<pre><code>~StudioMesh()\n</code></pre> <p>Destructor. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-get_poly_data","title":"function get_poly_data","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; get_poly_data()\n</code></pre> <p>Get the mesh polydata. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-set_poly_data","title":"function set_poly_data","text":"<pre><code>void set_poly_data(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre> <p>Set the poly data directly. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-set_error_message","title":"function set_error_message","text":"<pre><code>void set_error_message(\n    std::string error_message\n)\n</code></pre> <p>Set the error message. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-get_error_message","title":"function get_error_message","text":"<pre><code>std::string get_error_message()\n</code></pre> <p>Return the error message. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-apply_feature_map","title":"function apply_feature_map","text":"<pre><code>void apply_feature_map(\n    std::string name,\n    ImageType::Pointer image\n)\n</code></pre> <p>Apply a feature map. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-apply_scalars","title":"function apply_scalars","text":"<pre><code>void apply_scalars(\n    MeshHandle mesh\n)\n</code></pre> <p>Apply scalars from another mesh, with a transform. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-interpolate_scalars_to_mesh","title":"function interpolate_scalars_to_mesh","text":"<pre><code>void interpolate_scalars_to_mesh(\n    std::string name,\n    Eigen::VectorXd positions,\n    Eigen::VectorXd scalar_values\n)\n</code></pre> <p>Interpolation scalars at positions to this mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-get_largest_dimension_size","title":"function get_largest_dimension_size","text":"<pre><code>double get_largest_dimension_size()\n</code></pre> <p>Return the range of largest axis (e.g. 200 for an object that sits in 100x200x100) </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-get_or_create_array","title":"function get_or_create_array","text":"<pre><code>vtkFloatArray * get_or_create_array(\n    std::string name,\n    float default_value\n)\n</code></pre> <p>Get or create and return an array with a given name. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-paint_ffc","title":"function paint_ffc","text":"<pre><code>void paint_ffc(\n    double world_pos[],\n    double radius,\n    bool inclusive\n)\n</code></pre> <p>Paint free form constraint. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-fill_ffc","title":"function fill_ffc","text":"<pre><code>void fill_ffc(\n    bool inclusive\n)\n</code></pre> <p>Fill all vertices with specified inclusion/exclusion value. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-has_ffc_paint","title":"function has_ffc_paint","text":"<pre><code>bool has_ffc_paint()\n</code></pre> <p>Does this mesh have free form constraint paint? </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#function-get_sw_mesh","title":"function get_sw_mesh","text":"<pre><code>Mesh get_sw_mesh()\n</code></pre> <p>Return a shapeworks Mesh library class mesh. </p>"},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioMesh.html#variable-ffc_paint","title":"variable FFC_PAINT","text":"<pre><code>static constexpr const char *const FFC_PAINT = \"ffc_paint\";\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html","title":"shapeworks::StudioSliceInteractorStyle","text":"<p>Inherits from vtkInteractorStyleImage</p>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#public-functions","title":"Public Functions","text":"Name StudioSliceInteractorStyle * New() vtkTypeMacro(StudioSliceInteractorStyle , vtkInteractorStyleImage ) void set_lightbox(Lightbox * lightbox) StudioSliceInteractorStyle() virtual ~StudioSliceInteractorStyle() void OnLeftButtonDown() override void OnRightButtonDown() override void OnMouseWheelForward() override void OnMouseWheelBackward() override void OnKeyDown() override void WindowLevel() override void StartWindowLevel() override"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-new","title":"function New","text":"<pre><code>static StudioSliceInteractorStyle * New()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    StudioSliceInteractorStyle ,\n    vtkInteractorStyleImage \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-set_lightbox","title":"function set_lightbox","text":"<pre><code>void set_lightbox(\n    Lightbox * lightbox\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-studiosliceinteractorstyle","title":"function StudioSliceInteractorStyle","text":"<pre><code>StudioSliceInteractorStyle()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-studiosliceinteractorstyle_1","title":"function ~StudioSliceInteractorStyle","text":"<pre><code>virtual ~StudioSliceInteractorStyle()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-onleftbuttondown","title":"function OnLeftButtonDown","text":"<pre><code>void OnLeftButtonDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-onrightbuttondown","title":"function OnRightButtonDown","text":"<pre><code>void OnRightButtonDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-onmousewheelforward","title":"function OnMouseWheelForward","text":"<pre><code>void OnMouseWheelForward() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-onmousewheelbackward","title":"function OnMouseWheelBackward","text":"<pre><code>void OnMouseWheelBackward() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-onkeydown","title":"function OnKeyDown","text":"<pre><code>void OnKeyDown() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-windowlevel","title":"function WindowLevel","text":"<pre><code>void WindowLevel() override\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioSliceInteractorStyle.html#function-startwindowlevel","title":"function StartWindowLevel","text":"<pre><code>void StartWindowLevel() override\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html","title":"shapeworks::StudioUtils","text":"<p>Utilities for Studio. </p> <p><code>#include &lt;StudioUtils.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#public-functions","title":"Public Functions","text":"Name bool ask_multiple_domains_as_single(QWidget * parent, std::shared_ptr&lt; Project &gt; project) QStringList to_string_list(std::vector&lt; std::string &gt; vector)convert a vector of std::string to QStringList QImage vtk_image_to_qimage(vtkSmartPointer&lt; vtkImageData &gt; image_data)convert vtkImageData to QImage vtkSmartPointer&lt; vtkPolyData &gt; reverse_poly_data(vtkSmartPointer&lt; vtkPolyData &gt; poly_data)reverse a poly data QString get_platform_string()return platform string void add_viewport_border(vtkRenderer * renderer, double * color, double line_width =6.0)add a color border to a viewport bool write_mesh(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, QString filename)write a mesh to file void brightness_contrast_to_window_width_level(double brightness, double contrast, double min_intensity, double max_intensity, double &amp; window_width, double &amp; window_level)convert brightness and contrast to window width and level void window_width_level_to_brightness_contrast(double window_width, double window_level, double min_intensity, double max_intensity, double &amp; brightness, double &amp; contrast)convert window width and level to brightness and contrast void update_domain_combobox(QComboBox * combobox, QSharedPointer&lt; Session &gt; session, const std::vector&lt; QString &gt; &amp; filters ={})update a combobox with domain names"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-ask_multiple_domains_as_single","title":"function ask_multiple_domains_as_single","text":"<pre><code>static bool ask_multiple_domains_as_single(\n    QWidget * parent,\n    std::shared_ptr&lt; Project &gt; project\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-to_string_list","title":"function to_string_list","text":"<pre><code>static QStringList to_string_list(\n    std::vector&lt; std::string &gt; vector\n)\n</code></pre> <p>convert a vector of std::string to QStringList </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-vtk_image_to_qimage","title":"function vtk_image_to_qimage","text":"<pre><code>static QImage vtk_image_to_qimage(\n    vtkSmartPointer&lt; vtkImageData &gt; image_data\n)\n</code></pre> <p>convert vtkImageData to QImage </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-reverse_poly_data","title":"function reverse_poly_data","text":"<pre><code>static vtkSmartPointer&lt; vtkPolyData &gt; reverse_poly_data(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data\n)\n</code></pre> <p>reverse a poly data </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-get_platform_string","title":"function get_platform_string","text":"<pre><code>static QString get_platform_string()\n</code></pre> <p>return platform string </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-add_viewport_border","title":"function add_viewport_border","text":"<pre><code>static void add_viewport_border(\n    vtkRenderer * renderer,\n    double * color,\n    double line_width =6.0\n)\n</code></pre> <p>add a color border to a viewport </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-write_mesh","title":"function write_mesh","text":"<pre><code>static bool write_mesh(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    QString filename\n)\n</code></pre> <p>write a mesh to file </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-brightness_contrast_to_window_width_level","title":"function brightness_contrast_to_window_width_level","text":"<pre><code>static void brightness_contrast_to_window_width_level(\n    double brightness,\n    double contrast,\n    double min_intensity,\n    double max_intensity,\n    double &amp; window_width,\n    double &amp; window_level\n)\n</code></pre> <p>convert brightness and contrast to window width and level </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-window_width_level_to_brightness_contrast","title":"function window_width_level_to_brightness_contrast","text":"<pre><code>static void window_width_level_to_brightness_contrast(\n    double window_width,\n    double window_level,\n    double min_intensity,\n    double max_intensity,\n    double &amp; brightness,\n    double &amp; contrast\n)\n</code></pre> <p>convert window width and level to brightness and contrast </p>"},{"location":"api/Classes/classshapeworks_1_1StudioUtils.html#function-update_domain_combobox","title":"function update_domain_combobox","text":"<pre><code>static void update_domain_combobox(\n    QComboBox * combobox,\n    QSharedPointer&lt; Session &gt; session,\n    const std::vector&lt; QString &gt; &amp; filters ={}\n)\n</code></pre> <p>update a combobox with domain names </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Style.html","title":"shapeworks::Style","text":""},{"location":"api/Classes/classshapeworks_1_1Style.html#public-functions","title":"Public Functions","text":"Name Style() void apply_normal_button_style(QPushButton * button) void apply_abort_button_style(QPushButton * button)"},{"location":"api/Classes/classshapeworks_1_1Style.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Style.html#function-style","title":"function Style","text":"<pre><code>Style()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Style.html#function-apply_normal_button_style","title":"function apply_normal_button_style","text":"<pre><code>static void apply_normal_button_style(\n    QPushButton * button\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Style.html#function-apply_abort_button_style","title":"function apply_abort_button_style","text":"<pre><code>static void apply_abort_button_style(\n    QPushButton * button\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html","title":"shapeworks::Subject","text":"<p>Representation of a single subject.  More...</p> <p><code>#include &lt;Subject.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#public-types","title":"Public Types","text":"Name using project::types::StringMap StringMap using project::types::StringList StringList"},{"location":"api/Classes/classshapeworks_1_1Subject.html#public-functions","title":"Public Functions","text":"Name Subject() ~Subject() void set_original_filenames(StringList filenames)Set original filenames (one per domain) StringList get_original_filenames()Get original filenames. void set_groomed_filenames(StringList filenames)Set groomed filenames. StringList get_groomed_filenames()Get groomed filenames. void set_local_particle_filenames(StringList filenames)Set local particle filenames (one per domain) StringList get_local_particle_filenames()Get local particle filenames. void set_world_particle_filenames(StringList filenames)Set the world particle filenames. StringList get_world_particle_filenames()Get the world particle filenames. void set_landmarks_filenames(StringList filenames)Get the landmarks filenames (one per domain) StringList get_landmarks_filenames()Set the landmarks filenames. void set_constraints_filenames(StringList filenames)Get the constraints filenames (one per domain) StringList get_constraints_filenames()Set the constratins filenames. void set_number_of_domains(int number_of_domains)Set the number of domains. int get_number_of_domains()Get the number of domains. StringMap get_feature_filenames() constGet the feature map filenames. void set_feature_filenames(const StringMap &amp; feature_filenames)Set the feature map filenames. std::vector&lt; std::vector&lt; double &gt; &gt; get_groomed_transforms() constGet the groomed transforms (one vector per domain) void set_groomed_transforms(std::vector&lt; std::vector&lt; double &gt; &gt; transforms)Set the groomed transforms (one vector per domain) void set_groomed_transform(int i, std::vector&lt; double &gt; transform)Set the i-th groomed transform. std::vector&lt; std::vector&lt; double &gt; &gt; get_procrustes_transforms() constGet the procrustes transforms (one vector per domain) void set_procrustes_transforms(std::vector&lt; std::vector&lt; double &gt; &gt; transforms)Set the procrustes transforms (one vector per domain) StringMap get_group_values() constGet the group values. std::string get_group_value(std::string group_name)Get a specific group value. void set_group_values(const StringMap &amp; group_values)Set the group values. StringMap get_extra_values() constGet extra values (extra columns we don't interpret) void set_extra_values(StringMap extra_values) StringMap get_table_values() constGet all table values. void set_table_values(StringMap table_values) std::string get_display_name()Get the display name. void set_display_name(std::string display_name)Set the display name. bool is_fixed()Get if this subject is fixed or not. void set_fixed(bool fixed)Set if this subject is fixed or not. bool is_excluded()Get if this subject is excluded or not. void set_excluded(bool excluded)Set if this subject is excluded or not. std::string get_notes()Get the notes. void set_notes(std::string notes)Set the notes."},{"location":"api/Classes/classshapeworks_1_1Subject.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Subject;\n</code></pre> <p>Representation of a single subject. </p> <p>The Subject class encapsulates one \"sample\" in the shapeworks system (e.g. one row in a spreadsheet project) A Subject may have multiple segmentations/domains associated with it. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Subject.html#using-stringmap","title":"using StringMap","text":"<pre><code>using shapeworks::Subject::StringMap =  project::types::StringMap;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#using-stringlist","title":"using StringList","text":"<pre><code>using shapeworks::Subject::StringList =  project::types::StringList;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-subject","title":"function Subject","text":"<pre><code>Subject()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-subject_1","title":"function ~Subject","text":"<pre><code>~Subject()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_original_filenames","title":"function set_original_filenames","text":"<pre><code>void set_original_filenames(\n    StringList filenames\n)\n</code></pre> <p>Set original filenames (one per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_original_filenames","title":"function get_original_filenames","text":"<pre><code>StringList get_original_filenames()\n</code></pre> <p>Get original filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_groomed_filenames","title":"function set_groomed_filenames","text":"<pre><code>void set_groomed_filenames(\n    StringList filenames\n)\n</code></pre> <p>Set groomed filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_groomed_filenames","title":"function get_groomed_filenames","text":"<pre><code>StringList get_groomed_filenames()\n</code></pre> <p>Get groomed filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_local_particle_filenames","title":"function set_local_particle_filenames","text":"<pre><code>void set_local_particle_filenames(\n    StringList filenames\n)\n</code></pre> <p>Set local particle filenames (one per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_local_particle_filenames","title":"function get_local_particle_filenames","text":"<pre><code>StringList get_local_particle_filenames()\n</code></pre> <p>Get local particle filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_world_particle_filenames","title":"function set_world_particle_filenames","text":"<pre><code>void set_world_particle_filenames(\n    StringList filenames\n)\n</code></pre> <p>Set the world particle filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_world_particle_filenames","title":"function get_world_particle_filenames","text":"<pre><code>StringList get_world_particle_filenames()\n</code></pre> <p>Get the world particle filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_landmarks_filenames","title":"function set_landmarks_filenames","text":"<pre><code>void set_landmarks_filenames(\n    StringList filenames\n)\n</code></pre> <p>Get the landmarks filenames (one per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_landmarks_filenames","title":"function get_landmarks_filenames","text":"<pre><code>StringList get_landmarks_filenames()\n</code></pre> <p>Set the landmarks filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_constraints_filenames","title":"function set_constraints_filenames","text":"<pre><code>void set_constraints_filenames(\n    StringList filenames\n)\n</code></pre> <p>Get the constraints filenames (one per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_constraints_filenames","title":"function get_constraints_filenames","text":"<pre><code>StringList get_constraints_filenames()\n</code></pre> <p>Set the constratins filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_number_of_domains","title":"function set_number_of_domains","text":"<pre><code>void set_number_of_domains(\n    int number_of_domains\n)\n</code></pre> <p>Set the number of domains. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_number_of_domains","title":"function get_number_of_domains","text":"<pre><code>int get_number_of_domains()\n</code></pre> <p>Get the number of domains. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_feature_filenames","title":"function get_feature_filenames","text":"<pre><code>StringMap get_feature_filenames() const\n</code></pre> <p>Get the feature map filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_feature_filenames","title":"function set_feature_filenames","text":"<pre><code>void set_feature_filenames(\n    const StringMap &amp; feature_filenames\n)\n</code></pre> <p>Set the feature map filenames. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_groomed_transforms","title":"function get_groomed_transforms","text":"<pre><code>std::vector&lt; std::vector&lt; double &gt; &gt; get_groomed_transforms() const\n</code></pre> <p>Get the groomed transforms (one vector per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_groomed_transforms","title":"function set_groomed_transforms","text":"<pre><code>void set_groomed_transforms(\n    std::vector&lt; std::vector&lt; double &gt; &gt; transforms\n)\n</code></pre> <p>Set the groomed transforms (one vector per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_groomed_transform","title":"function set_groomed_transform","text":"<pre><code>void set_groomed_transform(\n    int i,\n    std::vector&lt; double &gt; transform\n)\n</code></pre> <p>Set the i-th groomed transform. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_procrustes_transforms","title":"function get_procrustes_transforms","text":"<pre><code>std::vector&lt; std::vector&lt; double &gt; &gt; get_procrustes_transforms() const\n</code></pre> <p>Get the procrustes transforms (one vector per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_procrustes_transforms","title":"function set_procrustes_transforms","text":"<pre><code>void set_procrustes_transforms(\n    std::vector&lt; std::vector&lt; double &gt; &gt; transforms\n)\n</code></pre> <p>Set the procrustes transforms (one vector per domain) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_group_values","title":"function get_group_values","text":"<pre><code>StringMap get_group_values() const\n</code></pre> <p>Get the group values. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_group_value","title":"function get_group_value","text":"<pre><code>std::string get_group_value(\n    std::string group_name\n)\n</code></pre> <p>Get a specific group value. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_group_values","title":"function set_group_values","text":"<pre><code>void set_group_values(\n    const StringMap &amp; group_values\n)\n</code></pre> <p>Set the group values. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_extra_values","title":"function get_extra_values","text":"<pre><code>StringMap get_extra_values() const\n</code></pre> <p>Get extra values (extra columns we don't interpret) </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_extra_values","title":"function set_extra_values","text":"<pre><code>void set_extra_values(\n    StringMap extra_values\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_table_values","title":"function get_table_values","text":"<pre><code>StringMap get_table_values() const\n</code></pre> <p>Get all table values. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_table_values","title":"function set_table_values","text":"<pre><code>void set_table_values(\n    StringMap table_values\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_display_name","title":"function get_display_name","text":"<pre><code>std::string get_display_name()\n</code></pre> <p>Get the display name. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_display_name","title":"function set_display_name","text":"<pre><code>void set_display_name(\n    std::string display_name\n)\n</code></pre> <p>Set the display name. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-is_fixed","title":"function is_fixed","text":"<pre><code>bool is_fixed()\n</code></pre> <p>Get if this subject is fixed or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_fixed","title":"function set_fixed","text":"<pre><code>void set_fixed(\n    bool fixed\n)\n</code></pre> <p>Set if this subject is fixed or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-is_excluded","title":"function is_excluded","text":"<pre><code>bool is_excluded()\n</code></pre> <p>Get if this subject is excluded or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_excluded","title":"function set_excluded","text":"<pre><code>void set_excluded(\n    bool excluded\n)\n</code></pre> <p>Set if this subject is excluded or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-get_notes","title":"function get_notes","text":"<pre><code>std::string get_notes()\n</code></pre> <p>Get the notes. </p>"},{"location":"api/Classes/classshapeworks_1_1Subject.html#function-set_notes","title":"function set_notes","text":"<pre><code>void set_notes(\n    std::string notes\n)\n</code></pre> <p>Set the notes. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Surface.html","title":"shapeworks::Surface","text":""},{"location":"api/Classes/classshapeworks_1_1Surface.html#public-types","title":"Public Types","text":"Name using ParticleDomain::PointType PointType using ParticleDomain::GradNType GradNType using vnl_vector_fixed&lt; float, 3 &gt; NormalType using vnl_vector_fixed&lt; double, 3 &gt; VectorType"},{"location":"api/Classes/classshapeworks_1_1Surface.html#public-functions","title":"Public Functions","text":"Name Surface(vtkSmartPointer&lt; vtkPolyData &gt; mesh, bool geodesics_enabled =false, size_t geodesics_cache_multiplier_size =0) ~Surface() =default double compute_distance(const PointType &amp; pointa, int idxa, const PointType &amp; pointb, int idxb, VectorType * out_grad =nullptr) const bool is_within_distance(const PointType &amp; pointa, int idxa, const PointType &amp; pointb, int idxb, double test_dist, double &amp; dist) const PointType geodesic_walk(PointType p, int idx, VectorType vector) const VectorType project_vector_to_surface_tangent(const PointType &amp; pointa, int idx, VectorType &amp; vector) const NormalType sample_normal_at_point(PointType p, int idx =-1) const GradNType sample_gradient_normal_at_point(PointType p, int idx) const PointType snap_to_mesh(PointType pointa, int idx) const PointType get_point_on_mesh() const const PointType &amp; get_mesh_lower_bound() const const PointType &amp; get_mesh_upper_bound() const virtual void invalidate_particle(int idx) vtkSmartPointer&lt; vtkPolyData &gt; get_polydata() const bool is_geodesics_enabled() const"},{"location":"api/Classes/classshapeworks_1_1Surface.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Surface.html#using-pointtype","title":"using PointType","text":"<pre><code>using shapeworks::Surface::PointType =  ParticleDomain::PointType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#using-gradntype","title":"using GradNType","text":"<pre><code>using shapeworks::Surface::GradNType =  ParticleDomain::GradNType;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#using-normaltype","title":"using NormalType","text":"<pre><code>using shapeworks::Surface::NormalType =  vnl_vector_fixed&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::Surface::VectorType =  vnl_vector_fixed&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-surface","title":"function Surface","text":"<pre><code>explicit Surface(\n    vtkSmartPointer&lt; vtkPolyData &gt; mesh,\n    bool geodesics_enabled =false,\n    size_t geodesics_cache_multiplier_size =0\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-surface_1","title":"function ~Surface","text":"<pre><code>~Surface() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-compute_distance","title":"function compute_distance","text":"<pre><code>double compute_distance(\n    const PointType &amp; pointa,\n    int idxa,\n    const PointType &amp; pointb,\n    int idxb,\n    VectorType * out_grad =nullptr\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-is_within_distance","title":"function is_within_distance","text":"<pre><code>bool is_within_distance(\n    const PointType &amp; pointa,\n    int idxa,\n    const PointType &amp; pointb,\n    int idxb,\n    double test_dist,\n    double &amp; dist\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-geodesic_walk","title":"function geodesic_walk","text":"<pre><code>PointType geodesic_walk(\n    PointType p,\n    int idx,\n    VectorType vector\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-project_vector_to_surface_tangent","title":"function project_vector_to_surface_tangent","text":"<pre><code>VectorType project_vector_to_surface_tangent(\n    const PointType &amp; pointa,\n    int idx,\n    VectorType &amp; vector\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-sample_normal_at_point","title":"function sample_normal_at_point","text":"<pre><code>NormalType sample_normal_at_point(\n    PointType p,\n    int idx =-1\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-sample_gradient_normal_at_point","title":"function sample_gradient_normal_at_point","text":"<pre><code>GradNType sample_gradient_normal_at_point(\n    PointType p,\n    int idx\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-snap_to_mesh","title":"function snap_to_mesh","text":"<pre><code>PointType snap_to_mesh(\n    PointType pointa,\n    int idx\n) const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-get_point_on_mesh","title":"function get_point_on_mesh","text":"<pre><code>PointType get_point_on_mesh() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-get_mesh_lower_bound","title":"function get_mesh_lower_bound","text":"<pre><code>inline const PointType &amp; get_mesh_lower_bound() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-get_mesh_upper_bound","title":"function get_mesh_upper_bound","text":"<pre><code>inline const PointType &amp; get_mesh_upper_bound() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-invalidate_particle","title":"function invalidate_particle","text":"<pre><code>virtual void invalidate_particle(\n    int idx\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-get_polydata","title":"function get_polydata","text":"<pre><code>inline vtkSmartPointer&lt; vtkPolyData &gt; get_polydata() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Surface.html#function-is_geodesics_enabled","title":"function is_geodesics_enabled","text":"<pre><code>inline bool is_geodesics_enabled() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html","title":"shapeworks::Telemetry","text":"<p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#public-slots","title":"Public Slots","text":"Name void handle_network_reply(QNetworkReply * reply)"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#public-functions","title":"Public Functions","text":"Name Telemetry(Preferences &amp; prefs) void record_event(const QString &amp; name, const QVariantMap &amp; params)"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#slot-handle_network_reply","title":"slot handle_network_reply","text":"<pre><code>void handle_network_reply(\n    QNetworkReply * reply\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#function-telemetry","title":"function Telemetry","text":"<pre><code>Telemetry(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Telemetry.html#function-record_event","title":"function record_event","text":"<pre><code>void record_event(\n    const QString &amp; name,\n    const QVariantMap &amp; params\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html","title":"shapeworks::TimerStackEntry","text":""},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#public-functions","title":"Public Functions","text":"Name TimerStackEntry(const QString &amp; name, qint64 start_time_us)"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#public-attributes","title":"Public Attributes","text":"Name QString name qint64 start_time_us double accumulated_child_time_ms"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#function-timerstackentry","title":"function TimerStackEntry","text":"<pre><code>TimerStackEntry(\n    const QString &amp; name,\n    qint64 start_time_us\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#variable-name","title":"variable name","text":"<pre><code>QString name;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#variable-start_time_us","title":"variable start_time_us","text":"<pre><code>qint64 start_time_us;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1TimerStackEntry.html#variable-accumulated_child_time_ms","title":"variable accumulated_child_time_ms","text":"<pre><code>double accumulated_child_time_ms;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html","title":"shapeworks::UpdateChecker","text":"<p>Update Checker.  More...</p> <p><code>#include &lt;UpdateChecker.h&gt;</code></p> <p>Inherits from QDialog</p>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#public-slots","title":"Public Slots","text":"Name void handleNetworkReply(QNetworkReply * reply)"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#public-functions","title":"Public Functions","text":"Name UpdateChecker(Preferences &amp; prefs, QWidget * parent =nullptr) ~UpdateChecker() void run_auto_update_check() void run_manual_update_check()"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::UpdateChecker;\n</code></pre> <p>Update Checker. </p> <p>This class checks for new versions of ShapeWorks and informs the user with a dialog </p>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#slot-handlenetworkreply","title":"slot handleNetworkReply","text":"<pre><code>void handleNetworkReply(\n    QNetworkReply * reply\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#function-updatechecker","title":"function UpdateChecker","text":"<pre><code>explicit UpdateChecker(\n    Preferences &amp; prefs,\n    QWidget * parent =nullptr\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#function-updatechecker_1","title":"function ~UpdateChecker","text":"<pre><code>~UpdateChecker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#function-run_auto_update_check","title":"function run_auto_update_check","text":"<pre><code>void run_auto_update_check()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1UpdateChecker.html#function-run_manual_update_check","title":"function run_manual_update_check","text":"<pre><code>void run_manual_update_check()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Variant.html","title":"shapeworks::Variant","text":"<p>Variant class to represent multiple types.  More...</p> <p><code>#include &lt;Variant.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#public-functions","title":"Public Functions","text":"Name Variant() Variant(const std::string &amp; v) Variant(int v) Variant(double v) Variant(const char * v) Variant(bool v) Variant(std::vector&lt; double &gt; v) Variant(std::vector&lt; int &gt; v) Variant(std::vector&lt; bool &gt; v) Variant(std::vector&lt; std::string &gt; v) operator std::string() const operator bool() const operator int() const operator unsigned int() const operator long() const operator unsigned long() const operator float() const operator double() const operator std::vector&lt; double &gt;() const operator std::vector&lt; int &gt;() const operator std::vector&lt; bool &gt;() const operator std::vector&lt; std::string &gt;() const"},{"location":"api/Classes/classshapeworks_1_1Variant.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Variant;\n</code></pre> <p>Variant class to represent multiple types. </p> <p>This class was adapted from optparse to contain multiple types as a string This is used for storing parameters in a spreadsheet </p>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant","title":"function Variant","text":"<pre><code>inline Variant()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_1","title":"function Variant","text":"<pre><code>inline Variant(\n    const std::string &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_2","title":"function Variant","text":"<pre><code>inline Variant(\n    int v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_3","title":"function Variant","text":"<pre><code>inline Variant(\n    double v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_4","title":"function Variant","text":"<pre><code>inline Variant(\n    const char * v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_5","title":"function Variant","text":"<pre><code>inline Variant(\n    bool v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_6","title":"function Variant","text":"<pre><code>inline Variant(\n    std::vector&lt; double &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_7","title":"function Variant","text":"<pre><code>inline Variant(\n    std::vector&lt; int &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_8","title":"function Variant","text":"<pre><code>inline Variant(\n    std::vector&lt; bool &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-variant_9","title":"function Variant","text":"<pre><code>inline Variant(\n    std::vector&lt; std::string &gt; v\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-stdstring","title":"function operator std::string","text":"<pre><code>operator std::string() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-bool","title":"function operator bool","text":"<pre><code>operator bool() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-int","title":"function operator int","text":"<pre><code>operator int() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-unsigned-int","title":"function operator unsigned int","text":"<pre><code>operator unsigned int() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-long","title":"function operator long","text":"<pre><code>operator long() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-unsigned-long","title":"function operator unsigned long","text":"<pre><code>operator unsigned long() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-float","title":"function operator float","text":"<pre><code>operator float() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-double","title":"function operator double","text":"<pre><code>operator double() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-stdvector-double","title":"function operator std::vector&lt; double &gt;","text":"<pre><code>operator std::vector&lt; double &gt;() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-stdvector-int","title":"function operator std::vector&lt; int &gt;","text":"<pre><code>operator std::vector&lt; int &gt;() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-stdvector-bool","title":"function operator std::vector&lt; bool &gt;","text":"<pre><code>operator std::vector&lt; bool &gt;() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Variant.html#function-operator-stdvector-stdstring","title":"function operator std::vector&lt; std::string &gt;","text":"<pre><code>operator std::vector&lt; std::string &gt;() const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html","title":"shapeworks::VectorFunction","text":"<p>More...</p> <p><code>#include &lt;VectorFunction.h&gt;</code></p> <p>Inherited by shapeworks::CorrespondenceFunction, shapeworks::DisentangledCorrespondenceFunction, shapeworks::DualVectorFunction, shapeworks::LegacyCorrespondenceFunction, shapeworks::SamplingFunction</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-types","title":"Public Types","text":"Name using vnl_vector_fixed&lt; double, Dimension &gt; VectorType Type of vectors."},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-functions","title":"Public Functions","text":"Name virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep) const =0 virtual VectorType evaluate(unsigned int , unsigned int , const ParticleSystem * , double &amp; maxtimestep, double &amp; energy) const =0 virtual double energy(unsigned int , unsigned int , const ParticleSystem * ) const =0 virtual void reset_buffers()May be called by the solver class. virtual void after_iteration()This method is called by a solver after each iteration. virtual void before_iteration()This method is called by a solver before each iteration. virtual void before_evaluate(unsigned int , unsigned int , const ParticleSystem * ) virtual void set_particle_system(ParticleSystem * p)Some subclasses may require a pointer to the particle system and its domain number. virtual ParticleSystem * get_particle_system() const virtual void set_domain_number(unsigned int i) virtual int get_domain_number() const virtual std::shared_ptr&lt; VectorFunction &gt; clone() virtual double get_relative_energy_scaling() const virtual void set_relative_energy_scaling(double r) virtual ~VectorFunction() =defaultVirtual destructor for proper cleanup of derived classes."},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#protected-functions","title":"Protected Functions","text":"Name VectorFunction() VectorFunction(const VectorFunction &amp; ) =delete VectorFunction &amp; operator=(const VectorFunction &amp; ) =delete"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-attributes","title":"Public Attributes","text":"Name constexpr static unsigned int Dimension"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#protected-attributes","title":"Protected Attributes","text":"Name ParticleSystem * particle_system_ unsigned int domain_number_"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::VectorFunction;\n</code></pre> <p>This is the base class defining the API for a function that takes a particle system, domain, and location index as arguments and returns a vector-valued result. </p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#using-vectortype","title":"using VectorType","text":"<pre><code>using shapeworks::VectorFunction::VectorType =  vnl_vector_fixed&lt;double, Dimension&gt;;\n</code></pre> <p>Type of vectors. </p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-evaluate","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::CorrespondenceFunction::evaluate, shapeworks::DisentangledCorrespondenceFunction::evaluate, shapeworks::LegacyCorrespondenceFunction::evaluate, shapeworks::SamplingFunction::evaluate, shapeworks::DualVectorFunction::evaluate</p> <p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-evaluate_1","title":"function evaluate","text":"<pre><code>virtual VectorType evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * ,\n    double &amp; maxtimestep,\n    double &amp; energy\n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::DualVectorFunction::evaluate, shapeworks::CorrespondenceFunction::evaluate, shapeworks::DisentangledCorrespondenceFunction::evaluate, shapeworks::LegacyCorrespondenceFunction::evaluate, shapeworks::SamplingFunction::evaluate</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-energy","title":"function energy","text":"<pre><code>virtual double energy(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * \n) const =0\n</code></pre> <p>Reimplemented by: shapeworks::CorrespondenceFunction::energy, shapeworks::DisentangledCorrespondenceFunction::energy, shapeworks::LegacyCorrespondenceFunction::energy, shapeworks::SamplingFunction::energy, shapeworks::DualVectorFunction::energy</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-reset_buffers","title":"function reset_buffers","text":"<pre><code>inline virtual void reset_buffers()\n</code></pre> <p>May be called by the solver class. </p> <p>Reimplemented by: shapeworks::SamplingFunction::reset_buffers</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-after_iteration","title":"function after_iteration","text":"<pre><code>inline virtual void after_iteration()\n</code></pre> <p>This method is called by a solver after each iteration. </p> <p>Reimplemented by: shapeworks::CorrespondenceFunction::after_iteration, shapeworks::DisentangledCorrespondenceFunction::after_iteration, shapeworks::DualVectorFunction::after_iteration, shapeworks::LegacyCorrespondenceFunction::after_iteration</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-before_iteration","title":"function before_iteration","text":"<pre><code>inline virtual void before_iteration()\n</code></pre> <p>This method is called by a solver before each iteration. </p> <p>Reimplemented by: shapeworks::CorrespondenceFunction::before_iteration, shapeworks::DisentangledCorrespondenceFunction::before_iteration, shapeworks::LegacyCorrespondenceFunction::before_iteration, shapeworks::DualVectorFunction::before_iteration</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-before_evaluate","title":"function before_evaluate","text":"<pre><code>inline virtual void before_evaluate(\n    unsigned int ,\n    unsigned int ,\n    const ParticleSystem * \n)\n</code></pre> <p>Reimplemented by: shapeworks::DualVectorFunction::before_evaluate, shapeworks::SamplingFunction::before_evaluate</p> <p>This method may be called to set up the state of the function object before a call to evaluate. It is necessary in order to initialize certain constants and variables that may be used for calculating the energy as well as the gradients. Typically this is only necessary for the adaptive gradient descent algorithm. </p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-set_particle_system","title":"function set_particle_system","text":"<pre><code>inline virtual void set_particle_system(\n    ParticleSystem * p\n)\n</code></pre> <p>Some subclasses may require a pointer to the particle system and its domain number. </p> <p>Reimplemented by: shapeworks::DualVectorFunction::set_particle_system</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-get_particle_system","title":"function get_particle_system","text":"<pre><code>inline virtual ParticleSystem * get_particle_system() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-set_domain_number","title":"function set_domain_number","text":"<pre><code>inline virtual void set_domain_number(\n    unsigned int i\n)\n</code></pre> <p>Reimplemented by: shapeworks::DualVectorFunction::set_domain_number</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-get_domain_number","title":"function get_domain_number","text":"<pre><code>inline virtual int get_domain_number() const\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-clone","title":"function clone","text":"<pre><code>inline virtual std::shared_ptr&lt; VectorFunction &gt; clone()\n</code></pre> <p>Reimplemented by: shapeworks::CorrespondenceFunction::clone, shapeworks::DisentangledCorrespondenceFunction::clone, shapeworks::DualVectorFunction::clone, shapeworks::LegacyCorrespondenceFunction::clone, shapeworks::SamplingFunction::clone</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-get_relative_energy_scaling","title":"function get_relative_energy_scaling","text":"<pre><code>inline virtual double get_relative_energy_scaling() const\n</code></pre> <p>Reimplemented by: shapeworks::DualVectorFunction::get_relative_energy_scaling</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-set_relative_energy_scaling","title":"function set_relative_energy_scaling","text":"<pre><code>inline virtual void set_relative_energy_scaling(\n    double r\n)\n</code></pre> <p>Reimplemented by: shapeworks::DualVectorFunction::set_relative_energy_scaling</p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-vectorfunction","title":"function ~VectorFunction","text":"<pre><code>virtual ~VectorFunction() =default\n</code></pre> <p>Virtual destructor for proper cleanup of derived classes. </p>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-vectorfunction_1","title":"function VectorFunction","text":"<pre><code>inline VectorFunction()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-vectorfunction_2","title":"function VectorFunction","text":"<pre><code>VectorFunction(\n    const VectorFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#function-operator","title":"function operator=","text":"<pre><code>VectorFunction &amp; operator=(\n    const VectorFunction &amp; \n) =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#variable-dimension","title":"variable Dimension","text":"<pre><code>static constexpr static unsigned int Dimension = 3;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#variable-particle_system_","title":"variable particle_system_","text":"<pre><code>ParticleSystem * particle_system_;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorFunction.html#variable-domain_number_","title":"variable domain_number_","text":"<pre><code>unsigned int domain_number_;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html","title":"shapeworks::VectorImage","text":"<p>Gradient (vector) image. </p> <p><code>#include &lt;VectorImage.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#public-types","title":"Public Types","text":"Name using itk::GradientImageFilter&lt; Image::ImageType &gt; GradientImageFilter using itk::Image&lt; Covariant, 3 &gt; ImageType using itk::VectorLinearInterpolateImageFunction&lt; ImageType, Image::PixelType &gt; GradientInterpolatorType using itk::ImageRegionIterator&lt; ImageType &gt; ImageIterator"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#public-functions","title":"Public Functions","text":"Name VectorImage(const Image &amp; dt_img)Creates a gradient vector image of image (presumably a distance transform) VectorImage() =delete ~VectorImage() =default Vector evaluate(Point p)Returns a Vector (which can be normalized using <code>v.Normalize()</code>). ImageIterator iterator()"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#using-gradientimagefilter","title":"using GradientImageFilter","text":"<pre><code>using shapeworks::VectorImage::GradientImageFilter =  itk::GradientImageFilter&lt;Image::ImageType&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::VectorImage::ImageType =  itk::Image&lt;Covariant, 3&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#using-gradientinterpolatortype","title":"using GradientInterpolatorType","text":"<pre><code>using shapeworks::VectorImage::GradientInterpolatorType =  itk::VectorLinearInterpolateImageFunction&lt;ImageType, Image::PixelType&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#using-imageiterator","title":"using ImageIterator","text":"<pre><code>using shapeworks::VectorImage::ImageIterator =  itk::ImageRegionIterator&lt;ImageType&gt;;\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#function-vectorimage","title":"function VectorImage","text":"<pre><code>VectorImage(\n    const Image &amp; dt_img\n)\n</code></pre> <p>Creates a gradient vector image of image (presumably a distance transform) </p>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#function-vectorimage_1","title":"function VectorImage","text":"<pre><code>VectorImage() =delete\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#function-vectorimage_2","title":"function ~VectorImage","text":"<pre><code>~VectorImage() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#function-evaluate","title":"function evaluate","text":"<pre><code>Vector evaluate(\n    Point p\n)\n</code></pre> <p>Returns a Vector (which can be normalized using <code>v.Normalize()</code>). </p>"},{"location":"api/Classes/classshapeworks_1_1VectorImage.html#function-iterator","title":"function iterator","text":"<pre><code>ImageIterator iterator()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html","title":"shapeworks::Viewer","text":"<p>3D Viewer More...</p> <p><code>#include &lt;Viewer.h&gt;</code></p>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#public-functions","title":"Public Functions","text":"Name Viewer() ~Viewer() =default void set_renderer(vtkSmartPointer&lt; vtkRenderer &gt; renderer) vtkSmartPointer&lt; vtkRenderer &gt; get_renderer() void display_shape(std::shared_ptr&lt; Shape &gt; shape) void update_annotations() void clear_viewer() void reset_camera(std::array&lt; double, 3 &gt; c) void reset_camera() void set_color_series(ColorMap color_series) void set_glyph_size_and_quality(double size, double quality) double get_glyph_size() double get_glyph_quality() void set_session(QSharedPointer&lt; Session &gt; session) QSharedPointer&lt; Session &gt; get_session() void set_show_glyphs(bool show) void set_show_surface(bool show) void set_scale_arrows(bool scale) void update_points() void update_glyph_properties() int handle_pick(int * click_pos) PickResult handle_ctrl_click(int * click_pos) void set_selected_point(int id) void set_glyph_lut(vtkSmartPointer&lt; vtkLookupTable &gt; lut) void set_loading_screen(vtkSmartPointer&lt; vtkImageData &gt; loading_screen) void set_color_scheme(int i) void handle_new_mesh() bool is_viewer_ready() void set_visualizer(Visualizer * visualizer) void update_feature_range(double * range) void reset_feature_range() void update_opacities() std::shared_ptr&lt; Shape &gt; get_shape() void update_landmarks() void update_planes() void update_paint_mode() std::vector&lt; vtkSmartPointer&lt; vtkActor &gt; &gt; get_surface_actors() std::vector&lt; vtkSmartPointer&lt; vtkActor &gt; &gt; get_unclipped_surface_actors() MeshGroup get_meshes() vtkSmartPointer&lt; vtkTransform &gt; get_transform(int alignment_domain, int domain) vtkSmartPointer&lt; vtkTransform &gt; get_landmark_transform(int domain) vtkSmartPointer&lt; vtkTransform &gt; get_inverse_landmark_transform(int domain) vtkSmartPointer&lt; vtkTransform &gt; get_image_transform() vtkSmartPointer&lt; vtkTransform &gt; get_inverse_image_transform() SliceView &amp; slice_view() void update_image_volume(bool force =false) vtkSmartPointer&lt; vtkPoints &gt; get_glyph_points() vtkSmartPointer&lt; vtkTransform &gt; get_alignment_transform() void update_clipping_planes() vtkSmartPointer&lt; vtkPolygonalSurfacePointPlacer &gt; get_point_placer() void handle_paint(double display_pos[2], double world_pos[3]) void fill_all_ffc() void update_actors() void remove_scalar_bar() bool is_ready() vtkFloatArray * get_particle_scalars() vtkSmartPointer&lt; vtkPolyData &gt; get_particle_poly_data() void insert_compare_meshes() void set_scalar_visibility(vtkSmartPointer&lt; vtkPolyData &gt; poly_data, vtkSmartPointer&lt; vtkPolyDataMapper &gt; mapper, std::string scalar) vtkSmartPointer&lt; vtkLookupTable &gt; get_surface_lut() bool showing_feature_map() bool is_reverse(vtkSmartPointer&lt; vtkTransform &gt; transform)"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Viewer;\n</code></pre> <p>3D Viewer</p> <p>The Viewer class encapsulates all the functionality for visualizing a single subject/shape </p>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-viewer","title":"function Viewer","text":"<pre><code>Viewer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-viewer_1","title":"function ~Viewer","text":"<pre><code>~Viewer() =default\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_renderer","title":"function set_renderer","text":"<pre><code>void set_renderer(\n    vtkSmartPointer&lt; vtkRenderer &gt; renderer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_renderer","title":"function get_renderer","text":"<pre><code>vtkSmartPointer&lt; vtkRenderer &gt; get_renderer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-display_shape","title":"function display_shape","text":"<pre><code>void display_shape(\n    std::shared_ptr&lt; Shape &gt; shape\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_annotations","title":"function update_annotations","text":"<pre><code>void update_annotations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-clear_viewer","title":"function clear_viewer","text":"<pre><code>void clear_viewer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-reset_camera","title":"function reset_camera","text":"<pre><code>void reset_camera(\n    std::array&lt; double, 3 &gt; c\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-reset_camera_1","title":"function reset_camera","text":"<pre><code>void reset_camera()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_color_series","title":"function set_color_series","text":"<pre><code>void set_color_series(\n    ColorMap color_series\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_glyph_size_and_quality","title":"function set_glyph_size_and_quality","text":"<pre><code>void set_glyph_size_and_quality(\n    double size,\n    double quality\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_glyph_size","title":"function get_glyph_size","text":"<pre><code>double get_glyph_size()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_glyph_quality","title":"function get_glyph_quality","text":"<pre><code>double get_glyph_quality()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    QSharedPointer&lt; Session &gt; session\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_session","title":"function get_session","text":"<pre><code>QSharedPointer&lt; Session &gt; get_session()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_show_glyphs","title":"function set_show_glyphs","text":"<pre><code>void set_show_glyphs(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_show_surface","title":"function set_show_surface","text":"<pre><code>void set_show_surface(\n    bool show\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_scale_arrows","title":"function set_scale_arrows","text":"<pre><code>void set_scale_arrows(\n    bool scale\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_points","title":"function update_points","text":"<pre><code>void update_points()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_glyph_properties","title":"function update_glyph_properties","text":"<pre><code>void update_glyph_properties()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-handle_pick","title":"function handle_pick","text":"<pre><code>int handle_pick(\n    int * click_pos\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-handle_ctrl_click","title":"function handle_ctrl_click","text":"<pre><code>PickResult handle_ctrl_click(\n    int * click_pos\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_selected_point","title":"function set_selected_point","text":"<pre><code>void set_selected_point(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_glyph_lut","title":"function set_glyph_lut","text":"<pre><code>void set_glyph_lut(\n    vtkSmartPointer&lt; vtkLookupTable &gt; lut\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_loading_screen","title":"function set_loading_screen","text":"<pre><code>void set_loading_screen(\n    vtkSmartPointer&lt; vtkImageData &gt; loading_screen\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_color_scheme","title":"function set_color_scheme","text":"<pre><code>void set_color_scheme(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-handle_new_mesh","title":"function handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-is_viewer_ready","title":"function is_viewer_ready","text":"<pre><code>bool is_viewer_ready()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_visualizer","title":"function set_visualizer","text":"<pre><code>void set_visualizer(\n    Visualizer * visualizer\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_feature_range","title":"function update_feature_range","text":"<pre><code>void update_feature_range(\n    double * range\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-reset_feature_range","title":"function reset_feature_range","text":"<pre><code>void reset_feature_range()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_opacities","title":"function update_opacities","text":"<pre><code>void update_opacities()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_shape","title":"function get_shape","text":"<pre><code>std::shared_ptr&lt; Shape &gt; get_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_landmarks","title":"function update_landmarks","text":"<pre><code>void update_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_planes","title":"function update_planes","text":"<pre><code>void update_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_paint_mode","title":"function update_paint_mode","text":"<pre><code>void update_paint_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_surface_actors","title":"function get_surface_actors","text":"<pre><code>std::vector&lt; vtkSmartPointer&lt; vtkActor &gt; &gt; get_surface_actors()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_unclipped_surface_actors","title":"function get_unclipped_surface_actors","text":"<pre><code>std::vector&lt; vtkSmartPointer&lt; vtkActor &gt; &gt; get_unclipped_surface_actors()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_meshes","title":"function get_meshes","text":"<pre><code>MeshGroup get_meshes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_transform","title":"function get_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_transform(\n    int alignment_domain,\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_landmark_transform","title":"function get_landmark_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_landmark_transform(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_inverse_landmark_transform","title":"function get_inverse_landmark_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_inverse_landmark_transform(\n    int domain\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_image_transform","title":"function get_image_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_image_transform()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_inverse_image_transform","title":"function get_inverse_image_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_inverse_image_transform()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-slice_view","title":"function slice_view","text":"<pre><code>SliceView &amp; slice_view()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_image_volume","title":"function update_image_volume","text":"<pre><code>void update_image_volume(\n    bool force =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_glyph_points","title":"function get_glyph_points","text":"<pre><code>vtkSmartPointer&lt; vtkPoints &gt; get_glyph_points()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_alignment_transform","title":"function get_alignment_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_alignment_transform()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_clipping_planes","title":"function update_clipping_planes","text":"<pre><code>void update_clipping_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_point_placer","title":"function get_point_placer","text":"<pre><code>vtkSmartPointer&lt; vtkPolygonalSurfacePointPlacer &gt; get_point_placer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-handle_paint","title":"function handle_paint","text":"<pre><code>void handle_paint(\n    double display_pos[2],\n    double world_pos[3]\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-fill_all_ffc","title":"function fill_all_ffc","text":"<pre><code>void fill_all_ffc()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-update_actors","title":"function update_actors","text":"<pre><code>void update_actors()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-remove_scalar_bar","title":"function remove_scalar_bar","text":"<pre><code>void remove_scalar_bar()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-is_ready","title":"function is_ready","text":"<pre><code>inline bool is_ready()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_particle_scalars","title":"function get_particle_scalars","text":"<pre><code>vtkFloatArray * get_particle_scalars()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_particle_poly_data","title":"function get_particle_poly_data","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; get_particle_poly_data()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-insert_compare_meshes","title":"function insert_compare_meshes","text":"<pre><code>void insert_compare_meshes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-set_scalar_visibility","title":"function set_scalar_visibility","text":"<pre><code>void set_scalar_visibility(\n    vtkSmartPointer&lt; vtkPolyData &gt; poly_data,\n    vtkSmartPointer&lt; vtkPolyDataMapper &gt; mapper,\n    std::string scalar\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-get_surface_lut","title":"function get_surface_lut","text":"<pre><code>inline vtkSmartPointer&lt; vtkLookupTable &gt; get_surface_lut()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-showing_feature_map","title":"function showing_feature_map","text":"<pre><code>bool showing_feature_map()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Viewer.html#function-is_reverse","title":"function is_reverse","text":"<pre><code>static bool is_reverse(\n    vtkSmartPointer&lt; vtkTransform &gt; transform\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html","title":"shapeworks::Visualizer","text":"<p>Controls display of objects in viewers.  More...</p> <p><code>#include &lt;Visualizer.h&gt;</code></p> <p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#public-slots","title":"Public Slots","text":"Name void update_viewer_properties()update viewer properties (e.g. glyph size, quality, etc) void handle_feature_range_changed() void handle_image_slice_settings_changed()"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#public-functions","title":"Public Functions","text":"Name Visualizer(Preferences &amp; prefs) ~Visualizer() void set_lightbox(LightboxHandle lightbox)set the lightbox void set_session(SessionHandle session)set the session void set_center(bool center)turn automatic centering on/off bool get_center()get centering on/off void set_alignment_domain(int domain)set the alignment domain int get_alignment_domain()get the current alignment domain void set_show_glyphs(bool show)turn on/off glyph display void set_show_surface(bool show)turn on/off surface display void display_samples()update the display using the current settings void update_samples() void update_landmarks() void update_planes() void update_paint_mode() void handle_fill_all_ffc() void display_sample(int i) void display_shape(ShapeHandle shape) void display_shapes(ShapeList shapes) void set_selected_point_one(int id) void set_selected_point_two(int id) void set_mean(const Eigen::VectorXd &amp; mean) void set_mean_shape(ShapeHandle mean_shape) ShapeHandle get_mean_shape() void reset_camera() void update_lut() void update_annotations() Particles get_current_shape() vtkFloatArray * get_current_particle_scalars() vtkSmartPointer&lt; vtkPolyData &gt; get_current_particle_poly_data() void handle_new_mesh() vtkSmartPointer&lt; vtkPolyData &gt; get_current_mesh(int index, bool clip_constraints) std::vector&lt; vtkSmartPointer&lt; vtkPolyData &gt; &gt; get_current_meshes_transformed(int index, bool clip_constraints =false) const std::string &amp; get_feature_map() constGet the currently selected feature map. void set_uniform_feature_range(bool value)Set if we are using a uniform feature range. bool get_uniform_feature_range(void )Return if we are using a uniform feature range. void set_feature_map(const std::string &amp; feature_map)Set the currently selected feature map. void clear_viewers()clear out the viewers void reset_feature_range()Reset the feature range (e.g. for a new feature) double * get_feature_range()Get the current feature range. double * get_feature_raw_range()Get the current raw feature range. bool get_feature_range_valid()Return if the feature range is valid or not. void update_feature_range(double * range)Update the feature range with a given range. void update_feature_range(double min, double max)Update the feature range with a given range. vtkSmartPointer&lt; vtkTransform &gt; get_transform(std::shared_ptr&lt; Shape &gt; shape, int alignment_domain, int domain)Request the transform for a given shape and domain. vtkSmartPointer&lt; vtkTransform &gt; get_transform(std::shared_ptr&lt; Shape &gt; shape, DisplayMode display_mode, int alignment_domain, int domain)Request the transform for a given shape and domain and display mode. void set_opacities(std::vector&lt; float &gt; opacities)Set domain opacities. std::vector&lt; float &gt; get_opacities()Get domain opacities. void set_domain_particle_visibilities(std::vector&lt; bool &gt; visibilities)Set the per-domain particle visibilities. std::vector&lt; bool &gt; get_domain_particle_visibilities()Get the per-domain particle visibilities. double get_current_glyph_size()Get the current glyph size. void handle_ctrl_click(PickResult result)Handle ctrl click. void redraw()Redraw renderers. QPixmap export_to_pixmap(QSize size, bool transparent_background, bool show_orientation_marker, bool show_color_scale, bool &amp; ready)Export render window to pixmap. QSize get_render_size()Return render window size. LightboxHandle get_lightbox()"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#detailed-description","title":"Detailed Description","text":"<pre><code>class shapeworks::Visualizer;\n</code></pre> <p>Controls display of objects in viewers. </p> <p>The Visualizer class maintains state and control over viewer properties. Additionally, it performs all shape-based statistical functions. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#slot-update_viewer_properties","title":"slot update_viewer_properties","text":"<pre><code>void update_viewer_properties()\n</code></pre> <p>update viewer properties (e.g. glyph size, quality, etc) </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#slot-handle_feature_range_changed","title":"slot handle_feature_range_changed","text":"<pre><code>void handle_feature_range_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#slot-handle_image_slice_settings_changed","title":"slot handle_image_slice_settings_changed","text":"<pre><code>void handle_image_slice_settings_changed()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-visualizer","title":"function Visualizer","text":"<pre><code>Visualizer(\n    Preferences &amp; prefs\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-visualizer_1","title":"function ~Visualizer","text":"<pre><code>~Visualizer()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_lightbox","title":"function set_lightbox","text":"<pre><code>void set_lightbox(\n    LightboxHandle lightbox\n)\n</code></pre> <p>set the lightbox </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_session","title":"function set_session","text":"<pre><code>void set_session(\n    SessionHandle session\n)\n</code></pre> <p>set the session </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_center","title":"function set_center","text":"<pre><code>void set_center(\n    bool center\n)\n</code></pre> <p>turn automatic centering on/off </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_center","title":"function get_center","text":"<pre><code>bool get_center()\n</code></pre> <p>get centering on/off </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_alignment_domain","title":"function set_alignment_domain","text":"<pre><code>void set_alignment_domain(\n    int domain\n)\n</code></pre> <p>set the alignment domain </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_alignment_domain","title":"function get_alignment_domain","text":"<pre><code>int get_alignment_domain()\n</code></pre> <p>get the current alignment domain </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_show_glyphs","title":"function set_show_glyphs","text":"<pre><code>void set_show_glyphs(\n    bool show\n)\n</code></pre> <p>turn on/off glyph display </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_show_surface","title":"function set_show_surface","text":"<pre><code>void set_show_surface(\n    bool show\n)\n</code></pre> <p>turn on/off surface display </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-display_samples","title":"function display_samples","text":"<pre><code>void display_samples()\n</code></pre> <p>update the display using the current settings </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_samples","title":"function update_samples","text":"<pre><code>void update_samples()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_landmarks","title":"function update_landmarks","text":"<pre><code>void update_landmarks()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_planes","title":"function update_planes","text":"<pre><code>void update_planes()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_paint_mode","title":"function update_paint_mode","text":"<pre><code>void update_paint_mode()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-handle_fill_all_ffc","title":"function handle_fill_all_ffc","text":"<pre><code>void handle_fill_all_ffc()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-display_sample","title":"function display_sample","text":"<pre><code>void display_sample(\n    int i\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-display_shape","title":"function display_shape","text":"<pre><code>void display_shape(\n    ShapeHandle shape\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-display_shapes","title":"function display_shapes","text":"<pre><code>void display_shapes(\n    ShapeList shapes\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_selected_point_one","title":"function set_selected_point_one","text":"<pre><code>void set_selected_point_one(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_selected_point_two","title":"function set_selected_point_two","text":"<pre><code>void set_selected_point_two(\n    int id\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_mean","title":"function set_mean","text":"<pre><code>void set_mean(\n    const Eigen::VectorXd &amp; mean\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_mean_shape","title":"function set_mean_shape","text":"<pre><code>void set_mean_shape(\n    ShapeHandle mean_shape\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_mean_shape","title":"function get_mean_shape","text":"<pre><code>ShapeHandle get_mean_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-reset_camera","title":"function reset_camera","text":"<pre><code>void reset_camera()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_lut","title":"function update_lut","text":"<pre><code>void update_lut()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_annotations","title":"function update_annotations","text":"<pre><code>void update_annotations()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_shape","title":"function get_current_shape","text":"<pre><code>Particles get_current_shape()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_particle_scalars","title":"function get_current_particle_scalars","text":"<pre><code>vtkFloatArray * get_current_particle_scalars()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_particle_poly_data","title":"function get_current_particle_poly_data","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; get_current_particle_poly_data()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-handle_new_mesh","title":"function handle_new_mesh","text":"<pre><code>void handle_new_mesh()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_mesh","title":"function get_current_mesh","text":"<pre><code>vtkSmartPointer&lt; vtkPolyData &gt; get_current_mesh(\n    int index,\n    bool clip_constraints\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_meshes_transformed","title":"function get_current_meshes_transformed","text":"<pre><code>std::vector&lt; vtkSmartPointer&lt; vtkPolyData &gt; &gt; get_current_meshes_transformed(\n    int index,\n    bool clip_constraints =false\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_feature_map","title":"function get_feature_map","text":"<pre><code>const std::string &amp; get_feature_map() const\n</code></pre> <p>Get the currently selected feature map. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_uniform_feature_range","title":"function set_uniform_feature_range","text":"<pre><code>void set_uniform_feature_range(\n    bool value\n)\n</code></pre> <p>Set if we are using a uniform feature range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_uniform_feature_range","title":"function get_uniform_feature_range","text":"<pre><code>bool get_uniform_feature_range(\n    void \n)\n</code></pre> <p>Return if we are using a uniform feature range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_feature_map","title":"function set_feature_map","text":"<pre><code>void set_feature_map(\n    const std::string &amp; feature_map\n)\n</code></pre> <p>Set the currently selected feature map. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-clear_viewers","title":"function clear_viewers","text":"<pre><code>void clear_viewers()\n</code></pre> <p>clear out the viewers </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-reset_feature_range","title":"function reset_feature_range","text":"<pre><code>void reset_feature_range()\n</code></pre> <p>Reset the feature range (e.g. for a new feature) </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_feature_range","title":"function get_feature_range","text":"<pre><code>double * get_feature_range()\n</code></pre> <p>Get the current feature range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_feature_raw_range","title":"function get_feature_raw_range","text":"<pre><code>double * get_feature_raw_range()\n</code></pre> <p>Get the current raw feature range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_feature_range_valid","title":"function get_feature_range_valid","text":"<pre><code>bool get_feature_range_valid()\n</code></pre> <p>Return if the feature range is valid or not. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_feature_range","title":"function update_feature_range","text":"<pre><code>void update_feature_range(\n    double * range\n)\n</code></pre> <p>Update the feature range with a given range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-update_feature_range_1","title":"function update_feature_range","text":"<pre><code>void update_feature_range(\n    double min,\n    double max\n)\n</code></pre> <p>Update the feature range with a given range. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_transform","title":"function get_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_transform(\n    std::shared_ptr&lt; Shape &gt; shape,\n    int alignment_domain,\n    int domain\n)\n</code></pre> <p>Request the transform for a given shape and domain. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_transform_1","title":"function get_transform","text":"<pre><code>vtkSmartPointer&lt; vtkTransform &gt; get_transform(\n    std::shared_ptr&lt; Shape &gt; shape,\n    DisplayMode display_mode,\n    int alignment_domain,\n    int domain\n)\n</code></pre> <p>Request the transform for a given shape and domain and display mode. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_opacities","title":"function set_opacities","text":"<pre><code>void set_opacities(\n    std::vector&lt; float &gt; opacities\n)\n</code></pre> <p>Set domain opacities. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_opacities","title":"function get_opacities","text":"<pre><code>std::vector&lt; float &gt; get_opacities()\n</code></pre> <p>Get domain opacities. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-set_domain_particle_visibilities","title":"function set_domain_particle_visibilities","text":"<pre><code>void set_domain_particle_visibilities(\n    std::vector&lt; bool &gt; visibilities\n)\n</code></pre> <p>Set the per-domain particle visibilities. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_domain_particle_visibilities","title":"function get_domain_particle_visibilities","text":"<pre><code>std::vector&lt; bool &gt; get_domain_particle_visibilities()\n</code></pre> <p>Get the per-domain particle visibilities. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_current_glyph_size","title":"function get_current_glyph_size","text":"<pre><code>double get_current_glyph_size()\n</code></pre> <p>Get the current glyph size. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-handle_ctrl_click","title":"function handle_ctrl_click","text":"<pre><code>void handle_ctrl_click(\n    PickResult result\n)\n</code></pre> <p>Handle ctrl click. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-redraw","title":"function redraw","text":"<pre><code>void redraw()\n</code></pre> <p>Redraw renderers. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-export_to_pixmap","title":"function export_to_pixmap","text":"<pre><code>QPixmap export_to_pixmap(\n    QSize size,\n    bool transparent_background,\n    bool show_orientation_marker,\n    bool show_color_scale,\n    bool &amp; ready\n)\n</code></pre> <p>Export render window to pixmap. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_render_size","title":"function get_render_size","text":"<pre><code>QSize get_render_size()\n</code></pre> <p>Return render window size. </p>"},{"location":"api/Classes/classshapeworks_1_1Visualizer.html#function-get_lightbox","title":"function get_lightbox","text":"<pre><code>inline LightboxHandle get_lightbox()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html","title":"shapeworks::WheelEventForwarder","text":"<p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html#public-functions","title":"Public Functions","text":"Name WheelEventForwarder(QScrollBar * target) ~WheelEventForwarder() bool eventFilter(QObject * obj, QEvent * event)"},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html#function-wheeleventforwarder","title":"function WheelEventForwarder","text":"<pre><code>explicit WheelEventForwarder(\n    QScrollBar * target\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html#function-wheeleventforwarder_1","title":"function ~WheelEventForwarder","text":"<pre><code>~WheelEventForwarder()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1WheelEventForwarder.html#function-eventfilter","title":"function eventFilter","text":"<pre><code>bool eventFilter(\n    QObject * obj,\n    QEvent * event\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classshapeworks_1_1Worker.html","title":"shapeworks::Worker","text":"<p>Inherits from QObject</p>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-slots","title":"Public Slots","text":"Name void process()"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-signals","title":"Public Signals","text":"Name void error_message(QString ) void warning_message(QString ) void status_message(QString ) void progress(int ) void finished()"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-functions","title":"Public Functions","text":"Name Worker() ~Worker() void run_job(QSharedPointer&lt; Job &gt; job) QPointer&lt; QThread &gt; get_thread() void stop() Worker * create_worker()"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Worker.html#slot-process","title":"slot process","text":"<pre><code>void process()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Worker.html#signal-error_message","title":"signal error_message","text":"<pre><code>void error_message(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#signal-warning_message","title":"signal warning_message","text":"<pre><code>void warning_message(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#signal-status_message","title":"signal status_message","text":"<pre><code>void status_message(\n    QString \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#signal-progress","title":"signal progress","text":"<pre><code>void progress(\n    int \n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#signal-finished","title":"signal finished","text":"<pre><code>void finished()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-worker","title":"function Worker","text":"<pre><code>Worker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-worker_1","title":"function ~Worker","text":"<pre><code>~Worker()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-run_job","title":"function run_job","text":"<pre><code>void run_job(\n    QSharedPointer&lt; Job &gt; job\n)\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-get_thread","title":"function get_thread","text":"<pre><code>inline QPointer&lt; QThread &gt; get_thread()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-stop","title":"function stop","text":"<pre><code>void stop()\n</code></pre>"},{"location":"api/Classes/classshapeworks_1_1Worker.html#function-create_worker","title":"function create_worker","text":"<pre><code>static Worker * create_worker()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classvec2d.html","title":"vec2d","text":""},{"location":"api/Classes/classvec2d.html#public-functions","title":"Public Functions","text":"Name vec2d() vec2d(double X, double Y) vec2d operator-() vec2d operator-(const vec2d &amp; r) vec2d operator+(const vec2d &amp; r) vec2d operator*(double g) double operator*(const vec2d &amp; r) double norm() double unit() bool operator==(const vec2d &amp; r) const"},{"location":"api/Classes/classvec2d.html#public-attributes","title":"Public Attributes","text":"Name double x double y"},{"location":"api/Classes/classvec2d.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classvec2d.html#function-vec2d","title":"function vec2d","text":"<pre><code>inline vec2d()\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-vec2d_1","title":"function vec2d","text":"<pre><code>inline vec2d(\n    double X,\n    double Y\n)\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator-","title":"function operator-","text":"<pre><code>inline vec2d operator-()\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator-_1","title":"function operator-","text":"<pre><code>inline vec2d operator-(\n    const vec2d &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator","title":"function operator+","text":"<pre><code>inline vec2d operator+(\n    const vec2d &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator_1","title":"function operator*","text":"<pre><code>inline vec2d operator*(\n    double g\n)\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator_2","title":"function operator*","text":"<pre><code>inline double operator*(\n    const vec2d &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-norm","title":"function norm","text":"<pre><code>inline double norm()\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-unit","title":"function unit","text":"<pre><code>inline double unit()\n</code></pre>"},{"location":"api/Classes/classvec2d.html#function-operator_3","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const vec2d &amp; r\n) const\n</code></pre>"},{"location":"api/Classes/classvec2d.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classvec2d.html#variable-x","title":"variable x","text":"<pre><code>double x;\n</code></pre>"},{"location":"api/Classes/classvec2d.html#variable-y","title":"variable y","text":"<pre><code>double y;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classvec3d.html","title":"vec3d","text":""},{"location":"api/Classes/classvec3d.html#public-functions","title":"Public Functions","text":"Name vec3d() vec3d(double rx, double ry, double rz) vec3d(const vec2d &amp; r) vec3d operator+(const vec3d &amp; v) const vec3d operator-(const vec3d &amp; v) const vec3d operator^(const vec3d &amp; v) const double operator*(const vec3d &amp; v) const vec3d operator*(const double g) const vec3d operator/(const double g) const const vec3d &amp; operator+=(const vec3d &amp; v) const vec3d &amp; operator-=(const vec3d &amp; v) const vec3d &amp; operator/=(const double f) const vec3d &amp; operator/=(const int n) const vec3d &amp; operator*=(const double f) vec3d operator-() const double Length() const double SqrLength() const vec3d &amp; Normalize()"},{"location":"api/Classes/classvec3d.html#public-attributes","title":"Public Attributes","text":"Name double x double y double z"},{"location":"api/Classes/classvec3d.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classvec3d.html#function-vec3d","title":"function vec3d","text":"<pre><code>inline vec3d()\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-vec3d_1","title":"function vec3d","text":"<pre><code>inline vec3d(\n    double rx,\n    double ry,\n    double rz\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-vec3d_2","title":"function vec3d","text":"<pre><code>inline vec3d(\n    const vec2d &amp; r\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator","title":"function operator+","text":"<pre><code>inline vec3d operator+(\n    const vec3d &amp; v\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator-","title":"function operator-","text":"<pre><code>inline vec3d operator-(\n    const vec3d &amp; v\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_1","title":"function operator^","text":"<pre><code>inline vec3d operator^(\n    const vec3d &amp; v\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_2","title":"function operator*","text":"<pre><code>inline double operator*(\n    const vec3d &amp; v\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_3","title":"function operator*","text":"<pre><code>inline vec3d operator*(\n    const double g\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_4","title":"function operator/","text":"<pre><code>inline vec3d operator/(\n    const double g\n) const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_5","title":"function operator+=","text":"<pre><code>inline const vec3d &amp; operator+=(\n    const vec3d &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator-_1","title":"function operator-=","text":"<pre><code>inline const vec3d &amp; operator-=(\n    const vec3d &amp; v\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_6","title":"function operator/=","text":"<pre><code>inline const vec3d &amp; operator/=(\n    const double f\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_7","title":"function operator/=","text":"<pre><code>inline const vec3d &amp; operator/=(\n    const int n\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator_8","title":"function operator*=","text":"<pre><code>inline const vec3d &amp; operator*=(\n    const double f\n)\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-operator-_2","title":"function operator-","text":"<pre><code>inline vec3d operator-() const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-length","title":"function Length","text":"<pre><code>inline double Length() const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-sqrlength","title":"function SqrLength","text":"<pre><code>inline double SqrLength() const\n</code></pre>"},{"location":"api/Classes/classvec3d.html#function-normalize","title":"function Normalize","text":"<pre><code>inline vec3d &amp; Normalize()\n</code></pre>"},{"location":"api/Classes/classvec3d.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classvec3d.html#variable-x","title":"variable x","text":"<pre><code>double x;\n</code></pre>"},{"location":"api/Classes/classvec3d.html#variable-y","title":"variable y","text":"<pre><code>double y;\n</code></pre>"},{"location":"api/Classes/classvec3d.html#variable-z","title":"variable z","text":"<pre><code>double z;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classvec6d.html","title":"vec6d","text":""},{"location":"api/Classes/classvec6d.html#public-functions","title":"Public Functions","text":"Name vec6d()"},{"location":"api/Classes/classvec6d.html#public-attributes","title":"Public Attributes","text":"Name double x double y double z double xy double yz double xz"},{"location":"api/Classes/classvec6d.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classvec6d.html#function-vec6d","title":"function vec6d","text":"<pre><code>inline vec6d()\n</code></pre>"},{"location":"api/Classes/classvec6d.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/classvec6d.html#variable-x","title":"variable x","text":"<pre><code>double x;\n</code></pre>"},{"location":"api/Classes/classvec6d.html#variable-y","title":"variable y","text":"<pre><code>double y;\n</code></pre>"},{"location":"api/Classes/classvec6d.html#variable-z","title":"variable z","text":"<pre><code>double z;\n</code></pre>"},{"location":"api/Classes/classvec6d.html#variable-xy","title":"variable xy","text":"<pre><code>double xy;\n</code></pre>"},{"location":"api/Classes/classvec6d.html#variable-yz","title":"variable yz","text":"<pre><code>double yz;\n</code></pre>"},{"location":"api/Classes/classvec6d.html#variable-xz","title":"variable xz","text":"<pre><code>double xz;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/classvtkPolyDataToImageData.html","title":"vtkPolyDataToImageData","text":"<p>Inherits from vtkImageAlgorithm</p>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#public-functions","title":"Public Functions","text":"Name vtkTypeMacro(vtkPolyDataToImageData , vtkImageAlgorithm ) void PrintSelf(ostream &amp; os, vtkIndent indent) vtkSetMacro(Border , unsigned int ) vtkGetMacro(Border , unsigned int ) vtkSetMacro(Spacing , double ) vtkGetMacro(Spacing , double ) vtkSetMacro(SampleDistance , double ) vtkGetMacro(SampleDistance , double ) vtkSetMacro(InitialBallSize , unsigned int ) vtkGetMacro(InitialBallSize , unsigned int ) vtkSetMacro(FinalBallSize , unsigned int ) vtkGetMacro(FinalBallSize , unsigned int ) virtual int FillInputPortInformation(int port, vtkInformation * info) vtkPolyDataToImageData * New()"},{"location":"api/Classes/classvtkPolyDataToImageData.html#protected-functions","title":"Protected Functions","text":"Name vtkPolyDataToImageData() ~vtkPolyDataToImageData() virtual int RequestInformation(vtkInformation * request, vtkInformationVector ** inputVector, vtkInformationVector * outputVector) virtual int RequestData(vtkInformation * request, vtkInformationVector ** inputVector, vtkInformationVector * outputVector) virtual int RequestUpdateExtent(vtkInformation * request, vtkInformationVector ** inputVector, vtkInformationVector * outputVector)"},{"location":"api/Classes/classvtkPolyDataToImageData.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtktypemacro","title":"function vtkTypeMacro","text":"<pre><code>vtkTypeMacro(\n    vtkPolyDataToImageData ,\n    vtkImageAlgorithm \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-printself","title":"function PrintSelf","text":"<pre><code>void PrintSelf(\n    ostream &amp; os,\n    vtkIndent indent\n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtksetmacro","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    Border ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkgetmacro","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    Border ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtksetmacro_1","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    Spacing ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkgetmacro_1","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    Spacing ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtksetmacro_2","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    SampleDistance ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkgetmacro_2","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    SampleDistance ,\n    double \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtksetmacro_3","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    InitialBallSize ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkgetmacro_3","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    InitialBallSize ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtksetmacro_4","title":"function vtkSetMacro","text":"<pre><code>vtkSetMacro(\n    FinalBallSize ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkgetmacro_4","title":"function vtkGetMacro","text":"<pre><code>vtkGetMacro(\n    FinalBallSize ,\n    unsigned int \n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-fillinputportinformation","title":"function FillInputPortInformation","text":"<pre><code>virtual int FillInputPortInformation(\n    int port,\n    vtkInformation * info\n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-new","title":"function New","text":"<pre><code>static vtkPolyDataToImageData * New()\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkpolydatatoimagedata","title":"function vtkPolyDataToImageData","text":"<pre><code>vtkPolyDataToImageData()\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-vtkpolydatatoimagedata_1","title":"function ~vtkPolyDataToImageData","text":"<pre><code>inline ~vtkPolyDataToImageData()\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-requestinformation","title":"function RequestInformation","text":"<pre><code>virtual int RequestInformation(\n    vtkInformation * request,\n    vtkInformationVector ** inputVector,\n    vtkInformationVector * outputVector\n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-requestdata","title":"function RequestData","text":"<pre><code>virtual int RequestData(\n    vtkInformation * request,\n    vtkInformationVector ** inputVector,\n    vtkInformationVector * outputVector\n)\n</code></pre>"},{"location":"api/Classes/classvtkPolyDataToImageData.html#function-requestupdateextent","title":"function RequestUpdateExtent","text":"<pre><code>virtual int RequestUpdateExtent(\n    vtkInformation * request,\n    vtkInformationVector ** inputVector,\n    vtkInformationVector * outputVector\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/index_classes.html","title":"Classes","text":"<ul> <li>class ColorScheme <ul> <li>struct rgb </li> </ul> </li> <li>class ColorSchemes </li> <li>class CustomSlider </li> <li>class CustomSurfaceReconstructionFilter </li> <li>class FEAreaCoverage <ul> <li>class Surface </li> </ul> </li> <li>class FEAutoMesher </li> <li>class FECVDDecimationModifier <ul> <li>class Cluster </li> <li>struct EDGE </li> <li>class NODE </li> </ul> </li> <li>class FECoreMesh </li> <li>class FEEdge </li> <li>class FEElement </li> <li>class FEElementData </li> <li>class FEElement_ </li> <li>class FEFace </li> <li>class FEFillHole <ul> <li>class EdgeRing </li> <li>struct FACE </li> </ul> </li> <li>class FEFixMesh </li> <li>class FEItem </li> <li>class FEMesh </li> <li>class FEMeshSmoothingModifier </li> <li>class FENode </li> <li>class FENodeElementList </li> <li>class FENodeFaceList </li> <li>class FENodeNodeList </li> <li>class FETri3 </li> <li>class FEVTKExport </li> <li>class FEVTKimport </li> <li>class GLCOLOR </li> <li>struct Intersection </li> <li>class LegacyMeshGenerator </li> <li>class MeshSettings Settings for creating a mesh. </li> <li>class ObjectReader </li> <li>class ObjectWriter </li> <li>class ParticleEvent:: Parent </li> <li>class ParticleImageDomain </li> <li>class ParticleImageDomainWithCurvature </li> <li>class ParticleImageDomainWithGradN </li> <li>class ParticleImageDomainWithGradients </li> <li>class ParticleImplicitSurfaceDomain </li> <li>class ParticleMeanCurvatureAttribute </li> <li>class ParticleProcrustesRegistration </li> <li>class ParticleShapeLinearRegressionMatrixAttribute </li> <li>class ParticleShapeMatrixAttribute Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </li> <li>class ParticleShapeMixedEffectsMatrixAttribute </li> <li>class Preferences Application preferences. </li> <li>class Procrustes3D </li> <li>struct Quad </li> <li>struct Ray </li> <li>class Reconstruction </li> <li>struct SimilarityTransform3D </li> <li>class StudioImageActorPointPlacer </li> <li>class StudioLogger Handle logger callbacks via Qt for thread correctness. </li> <li>class SurfaceReconstructor </li> <li>struct Triangle </li> <li>namespace Ui </li> <li>class Utils </li> <li>struct VTKEXPORT </li> <li>namespace fmt <ul> <li>struct formatter&lt; QString &gt; </li> </ul> </li> <li>namespace itk <ul> <li>class AdvancedTransform Transform maps points, vectors and covariant vectors from an input space to an output space. </li> <li>class BSplineInterpolateImageFunctionWithDoubleCoefficents </li> <li>class CompactlySupportedRBFSparseKernelTransform </li> <li>namespace Functor <ul> <li>class MultiplyByConstant </li> </ul> </li> <li>class KernelTransform2 </li> <li>class MultiplyByConstantImageFilter Multiply input pixels by a constant. </li> <li>class SparseKernelTransform </li> <li>class TPGACLevelSetImageFilter </li> <li>class ThinPlateSplineKernelTransform2 </li> </ul> </li> <li>class mat3d </li> <li>class matrix </li> <li>class meshFIM </li> <li>namespace monailabel <ul> <li>class MonaiLabelJob </li> <li>class MonaiLabelTool </li> <li>class MonaiLabelUtils </li> <li>class UrlValidator </li> </ul> </li> <li>class object_reader </li> <li>class object_writer </li> <li>class quatd </li> <li>namespace shapeworks User usage reporting (telemetry) <ul> <li>class AnalysisTool </li> <li>class AnalysisUtils </li> <li>class Analyze High level analyze API. </li> <li>class AnalyzeCommandGroup </li> <li>class ColorMap </li> <li>class ColorMaps </li> <li>class Command </li> <li>class CompareSettings </li> <li>class CompareWidget </li> <li>class Constraint </li> <li>class Constraints </li> <li>class ContourDomain </li> <li>class CorrespondenceFunction Correspondence term. </li> <li>class DataTool </li> <li>class DeepSSMCommandGroup </li> <li>class DeepSSMJob Qt Wrapper for DeepSSM. </li> <li>class DeepSSMParameters </li> <li>class DeepSSMTool </li> <li>class DisentangledCorrespondenceFunction </li> <li>class DualVectorFunction </li> <li>class EarlyStopping </li> <li>struct EarlyStoppingConfig Configuration for early stopping criteria. </li> <li>class EigenUtils </li> <li>class ExcelProjectReader Excel file format reader for Project. </li> <li>class ExcelProjectWriter Excel file format writer for Project. </li> <li>class Executable </li> <li>class ExportImageDialog </li> <li>class ExportUtils Export utilities for Studio. </li> <li>class FreeFormConstraint </li> <li>class GenericContainer This class seems to be only a wrapper around std::vector implementing ITK DataObject (for smart pointer?) </li> <li>class GenericContainerArray This class appears to be an array of GenericContainers (e.g. std::vector) that implements the Observer interface. The array size tracks the number of domains in the system. E.g. one per domain. </li> <li>class GradientDescentOptimizer Optimizes particle system positions using gradient descent. </li> <li>class Groom High level groom API. </li> <li>class GroomCommandGroup </li> <li>class GroomParameters <ul> <li>struct SharedBoundary </li> </ul> </li> <li>class GroomTool </li> <li>class GroupPvalueJob </li> <li>class Image </li> <li>class ImageCommand </li> <li>class ImageDomain </li> <li>class ImageDomainWithCurvature </li> <li>class ImageDomainWithGradN </li> <li>class ImageDomainWithGradients </li> <li>class ImageLabel An extention of QLabel especially for scaled images. </li> <li>class ImageUtils Helper functions for image. </li> <li>class ImplicitSurfaceDomain </li> <li>class IndexRegion Indices into a 3d region of memory (can be negative, e.g., for the purpose of padding an image) </li> <li>class Job </li> <li>class JsonProjectReader JSON file format reader for Project. </li> <li>class JsonProjectWriter JSON file format writer for Project. </li> <li>class KeyboardShortcuts </li> <li>class LandmarkDefinition Landmark class containing properties of each landmark. </li> <li>class LandmarkItemDelegate </li> <li>class LandmarkTableModel </li> <li>class LandmarkWidget LandmarkWidget. </li> <li>class LegacyCorrespondenceFunction </li> <li>class LegacyShapeMatrix </li> <li>class Lightbox Display multiple Viewers in a tiled display. </li> <li>class LinearRegressionShapeMatrix </li> <li>class LogWindow Log Window. </li> <li>class Logging ShapeWorks Logging Library. </li> <li>class MatrixContainer </li> <li>class MeanCurvatureContainer </li> <li>class Mesh </li> <li>class MeshCache Thread safe cache for meshes index by shape. </li> <li>class MeshCommand </li> <li>class MeshDomain </li> <li>class MeshGenerator </li> <li>struct MeshGeoEntry </li> <li>class MeshGroup Representation of a group of meshes. </li> <li>class MeshManager Class to manage meshes. </li> <li>class MeshReader reads mesh (used only by one of the Mesh constructors) </li> <li>class MeshReconstructors </li> <li>class MeshSlice MeshSlice. </li> <li>class MeshUtils </li> <li>class MeshWarper </li> <li>class MeshWorkItem Provides concurrent access to a list of shapes to work needing reconstruction. </li> <li>class MeshWorkQueue </li> <li>class MeshWorker </li> <li>class MixedEffectsShapeMatrix </li> <li>class MorphologicalDeviationScore </li> <li>struct MultiVariateNormalRandom </li> <li>class NetworkAnalysisJob </li> <li>class Observer This class is an observer interface for classes to monitor for changes to the optimizer (observer pattern) <ul> <li>struct DefinedCallbacksStruct </li> </ul> </li> <li>class OptimizationVisualizer </li> <li>class Optimize </li> <li>class OptimizeCommandGroup </li> <li>class OptimizeParameterFile </li> <li>class OptimizeParameters </li> <li>class OptimizeTool </li> <li>class PaintWidget </li> <li>class Parameters Parameter settings. </li> <li>class ParticleArea </li> <li>class ParticleAreaJob </li> <li>class ParticleAreaPanel </li> <li>class ParticleColors Supplies particle colors. </li> <li>class ParticleDomain </li> <li>class ParticleEvent </li> <li>class ParticleGaussianModeWriter </li> <li>class ParticleGoodBadAssessment Performs good/bad points assessment and reports the bad positions of the particle system. </li> <li>class ParticleNeighborhood </li> <li>class ParticleNormalEvaluation </li> <li>class ParticleNormalEvaluationJob </li> <li>struct ParticlePointIndexPair </li> <li>class ParticleRegionDomain </li> <li>class ParticleShapeStatistics </li> <li>class ParticleSystem A facade class managing interactions with a particle system. </li> <li>class ParticleSystemCommand </li> <li>class ParticleSystemEvaluation </li> <li>class Particles Representation of correspondence points for a shape including multiple domains. </li> <li>class PhysicalRegion physical bounds of a 3d region of space </li> <li>class PickResult </li> <li>class PlaneConstraint </li> <li>class PlaneWidget PlaneWidget. </li> <li>class PlatformUtils Platform utility functions. </li> <li>class PreferencesWindow Qt UI dialog to control preferences. </li> <li>class ProcrustesRegistration </li> <li>struct ProfileEntry </li> <li>class Profiler </li> <li>class Project Representation of a project. </li> <li>class ProjectCommandGroup </li> <li>class ProjectReader Base class for Project readers. </li> <li>class ProjectUtils </li> <li>class PythonWorker </li> <li>class QMeshWarper Wraps MeshWarper as a QObject. </li> <li>class QOptimize Wraps Optimize as a QObject. </li> <li>class ReconstructSurface </li> <li>struct Reconstruction </li> <li>class Sampler <ul> <li>struct CuttingPlaneType </li> <li>struct SphereType </li> </ul> </li> <li>class SamplingFunction <ul> <li>struct CrossDomainNeighborhood </li> </ul> </li> <li>class ScopedTimer </li> <li>class SegmentationToolPanel </li> <li>class Session Representation of a session. </li> <li>class Shape Representation of a single shape/patient/subject. <ul> <li>class Point TODO: replace this wherever it is used. </li> </ul> </li> <li>class ShapeEvaluation </li> <li>class ShapeEvaluationJob The ShapeEvaluationJob class is a worker class that computes shape evaluation metrics of compactness, specificity, and generalization. It runs asynchronously using the Job and Worker interfaces. </li> <li>class ShapeGradientMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </li> <li>class ShapeMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! </li> <li>class ShapeScalarJob </li> <li>class ShapeScalarPanel </li> <li>class ShapeWorksStudioApp Main ShapeWorksStudio window. </li> <li>class ShapeWorksUtils </li> <li>class ShapeWorksVtkOutputWindow Implementation of vtkOutputWindow to capture and display VTK error messages. </li> <li>class ShapeworksCommand </li> <li>class ShapeworksWorker </li> <li>struct SharedCommandData </li> <li>class SliceView SliceView. </li> <li>class SplashScreen </li> <li>class StatsGroupLDAJob </li> <li>class StatusBarWidget StatusBarWidget. </li> <li>class StringUtils String utility functions. </li> <li>class StudioHandleWidget </li> <li>class StudioInteractorStyle </li> <li>class StudioMesh Representation of a single mesh. </li> <li>class StudioSliceInteractorStyle </li> <li>class StudioUtils Utilities for Studio. </li> <li>class Style </li> <li>class Subject Representation of a single subject. </li> <li>class Surface </li> <li>class Telemetry </li> <li>class TimerStackEntry </li> <li>struct TraceEvent </li> <li>class UpdateChecker Update Checker. </li> <li>class Variant Variant class to represent multiple types. </li> <li>class VectorFunction </li> <li>class VectorImage Gradient (vector) image. </li> <li>class Viewer 3D Viewer</li> <li>class Visualizer Controls display of objects in viewers. </li> <li>class WheelEventForwarder </li> <li>class Worker </li> <li>namespace mesh </li> <li>namespace particles </li> <li>namespace project <ul> <li>namespace prefixes </li> <li>namespace types </li> </ul> </li> </ul> </li> <li>namespace std </li> <li>namespace utils </li> <li>class vec2d </li> <li>class vec3d </li> <li>class vec6d </li> <li>class vtkPolyDataToImageData </li> </ul> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Classes/structColorScheme_1_1rgb.html","title":"ColorScheme::rgb","text":""},{"location":"api/Classes/structColorScheme_1_1rgb.html#public-functions","title":"Public Functions","text":"Name rgb() rgb(float l, float m, float n)"},{"location":"api/Classes/structColorScheme_1_1rgb.html#public-attributes","title":"Public Attributes","text":"Name float r float g float b"},{"location":"api/Classes/structColorScheme_1_1rgb.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structColorScheme_1_1rgb.html#function-rgb","title":"function rgb","text":"<pre><code>inline rgb()\n</code></pre>"},{"location":"api/Classes/structColorScheme_1_1rgb.html#function-rgb_1","title":"function rgb","text":"<pre><code>inline rgb(\n    float l,\n    float m,\n    float n\n)\n</code></pre>"},{"location":"api/Classes/structColorScheme_1_1rgb.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structColorScheme_1_1rgb.html#variable-r","title":"variable r","text":"<pre><code>float r;\n</code></pre>"},{"location":"api/Classes/structColorScheme_1_1rgb.html#variable-g","title":"variable g","text":"<pre><code>float g;\n</code></pre>"},{"location":"api/Classes/structColorScheme_1_1rgb.html#variable-b","title":"variable b","text":"<pre><code>float b;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structFECVDDecimationModifier_1_1EDGE.html","title":"FECVDDecimationModifier::EDGE","text":""},{"location":"api/Classes/structFECVDDecimationModifier_1_1EDGE.html#public-attributes","title":"Public Attributes","text":"Name int face int node"},{"location":"api/Classes/structFECVDDecimationModifier_1_1EDGE.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structFECVDDecimationModifier_1_1EDGE.html#variable-face","title":"variable face","text":"<pre><code>int face;\n</code></pre>"},{"location":"api/Classes/structFECVDDecimationModifier_1_1EDGE.html#variable-node","title":"variable node","text":"<pre><code>int node;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structFEFillHole_1_1FACE.html","title":"FEFillHole::FACE","text":""},{"location":"api/Classes/structFEFillHole_1_1FACE.html#public-attributes","title":"Public Attributes","text":"Name vec3d r int n"},{"location":"api/Classes/structFEFillHole_1_1FACE.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structFEFillHole_1_1FACE.html#variable-r","title":"variable r","text":"<pre><code>vec3d r;\n</code></pre>"},{"location":"api/Classes/structFEFillHole_1_1FACE.html#variable-n","title":"variable n","text":"<pre><code>int n;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structIntersection.html","title":"Intersection","text":""},{"location":"api/Classes/structIntersection.html#public-attributes","title":"Public Attributes","text":"Name vec3d point float r int m_index int m_faceIndex"},{"location":"api/Classes/structIntersection.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structIntersection.html#variable-point","title":"variable point","text":"<pre><code>vec3d point;\n</code></pre>"},{"location":"api/Classes/structIntersection.html#variable-r","title":"variable r","text":"<pre><code>float r;\n</code></pre>"},{"location":"api/Classes/structIntersection.html#variable-m_index","title":"variable m_index","text":"<pre><code>int m_index;\n</code></pre>"},{"location":"api/Classes/structIntersection.html#variable-m_faceindex","title":"variable m_faceIndex","text":"<pre><code>int m_faceIndex;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structQuad.html","title":"Quad","text":""},{"location":"api/Classes/structQuad.html#public-attributes","title":"Public Attributes","text":"Name vec3d r0 vec3d r1 vec3d r2 vec3d r3"},{"location":"api/Classes/structQuad.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structQuad.html#variable-r0","title":"variable r0","text":"<pre><code>vec3d r0;\n</code></pre>"},{"location":"api/Classes/structQuad.html#variable-r1","title":"variable r1","text":"<pre><code>vec3d r1;\n</code></pre>"},{"location":"api/Classes/structQuad.html#variable-r2","title":"variable r2","text":"<pre><code>vec3d r2;\n</code></pre>"},{"location":"api/Classes/structQuad.html#variable-r3","title":"variable r3","text":"<pre><code>vec3d r3;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structRay.html","title":"Ray","text":""},{"location":"api/Classes/structRay.html#public-attributes","title":"Public Attributes","text":"Name vec3d origin vec3d direction"},{"location":"api/Classes/structRay.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structRay.html#variable-origin","title":"variable origin","text":"<pre><code>vec3d origin;\n</code></pre>"},{"location":"api/Classes/structRay.html#variable-direction","title":"variable direction","text":"<pre><code>vec3d direction;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structSimilarityTransform3D.html","title":"SimilarityTransform3D","text":""},{"location":"api/Classes/structSimilarityTransform3D.html#public-attributes","title":"Public Attributes","text":"Name vnl_matrix_fixed&lt; double, 3, 3 &gt; rotation double scale vnl_vector_fixed&lt; double, 3 &gt; translation"},{"location":"api/Classes/structSimilarityTransform3D.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structSimilarityTransform3D.html#variable-rotation","title":"variable rotation","text":"<pre><code>vnl_matrix_fixed&lt; double, 3, 3 &gt; rotation;\n</code></pre>"},{"location":"api/Classes/structSimilarityTransform3D.html#variable-scale","title":"variable scale","text":"<pre><code>double scale;\n</code></pre>"},{"location":"api/Classes/structSimilarityTransform3D.html#variable-translation","title":"variable translation","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; translation;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structTriangle.html","title":"Triangle","text":""},{"location":"api/Classes/structTriangle.html#public-attributes","title":"Public Attributes","text":"Name vec3d r0 vec3d r1 vec3d r2 vec3d fn"},{"location":"api/Classes/structTriangle.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structTriangle.html#variable-r0","title":"variable r0","text":"<pre><code>vec3d r0;\n</code></pre>"},{"location":"api/Classes/structTriangle.html#variable-r1","title":"variable r1","text":"<pre><code>vec3d r1;\n</code></pre>"},{"location":"api/Classes/structTriangle.html#variable-r2","title":"variable r2","text":"<pre><code>vec3d r2;\n</code></pre>"},{"location":"api/Classes/structTriangle.html#variable-fn","title":"variable fn","text":"<pre><code>vec3d fn;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structVTKEXPORT.html","title":"VTKEXPORT","text":""},{"location":"api/Classes/structVTKEXPORT.html#public-attributes","title":"Public Attributes","text":"Name bool bshellthick bool bscalar_data"},{"location":"api/Classes/structVTKEXPORT.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structVTKEXPORT.html#variable-bshellthick","title":"variable bshellthick","text":"<pre><code>bool bshellthick;\n</code></pre>"},{"location":"api/Classes/structVTKEXPORT.html#variable-bscalar_data","title":"variable bscalar_data","text":"<pre><code>bool bscalar_data;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structfmt_1_1formatter_3_01QString_01_4.html","title":"fmt::formatter&lt; QString &gt;","text":""},{"location":"api/Classes/structfmt_1_1formatter_3_01QString_01_4.html#public-functions","title":"Public Functions","text":"Name constexpr auto parse(format_parse_context &amp; ctx) template &lt;typename FormatContext &gt; auto format(const QString &amp; str, FormatContext &amp; ctx) const"},{"location":"api/Classes/structfmt_1_1formatter_3_01QString_01_4.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structfmt_1_1formatter_3_01QString_01_4.html#function-parse","title":"function parse","text":"<pre><code>inline constexpr auto parse(\n    format_parse_context &amp; ctx\n)\n</code></pre>"},{"location":"api/Classes/structfmt_1_1formatter_3_01QString_01_4.html#function-format","title":"function format","text":"<pre><code>template &lt;typename FormatContext &gt;\ninline auto format(\n    const QString &amp; str,\n    FormatContext &amp; ctx\n) const\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html","title":"shapeworks::EarlyStoppingConfig","text":"<p>Configuration for early stopping criteria. </p> <p><code>#include &lt;EarlyStoppingConfig.h&gt;</code></p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#public-attributes","title":"Public Attributes","text":"Name bool enabled int frequency how often (in iterations) to check the stopping criterion int window_size number of past values to consider in relative difference or EMA double threshold EarlyStoppingStrategy strategy strategy used for determining early stopping. double ema_alpha higher value of alpha give more weight to recent iterations bool enable_logging std::string logger_name int warmup_iters to prevent premature stoppin"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-enabled","title":"variable enabled","text":"<pre><code>bool enabled = false;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-frequency","title":"variable frequency","text":"<pre><code>int frequency = 100;\n</code></pre> <p>how often (in iterations) to check the stopping criterion </p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-window_size","title":"variable window_size","text":"<pre><code>int window_size = 5;\n</code></pre> <p>number of past values to consider in relative difference or EMA </p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-threshold","title":"variable threshold","text":"<pre><code>double threshold = 0.0001;\n</code></pre> <p>Threshold for stopping: For RelativeDifference: use ~1e-4 or smaller. For EMA: use ~1e-1 or smaller. </p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-strategy","title":"variable strategy","text":"<pre><code>EarlyStoppingStrategy strategy = EarlyStoppingStrategy::RelativeDifference;\n</code></pre> <p>strategy used for determining early stopping. </p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-ema_alpha","title":"variable ema_alpha","text":"<pre><code>double ema_alpha = 0.2;\n</code></pre> <p>higher value of alpha give more weight to recent iterations </p>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-enable_logging","title":"variable enable_logging","text":"<pre><code>bool enable_logging = false;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-logger_name","title":"variable logger_name","text":"<pre><code>std::string logger_name = \"early_stopping_log_stats\";\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1EarlyStoppingConfig.html#variable-warmup_iters","title":"variable warmup_iters","text":"<pre><code>int warmup_iters = 1000;\n</code></pre> <p>to prevent premature stoppin </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html","title":"shapeworks::GroomParameters::SharedBoundary","text":""},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#public-functions","title":"Public Functions","text":"Name std::string to_string() const SharedBoundary from_string(const std::string &amp; str)"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#public-attributes","title":"Public Attributes","text":"Name std::string first_domain std::string second_domain double tolerance"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#function-to_string","title":"function to_string","text":"<pre><code>std::string to_string() const\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#function-from_string","title":"function from_string","text":"<pre><code>static SharedBoundary from_string(\n    const std::string &amp; str\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#variable-first_domain","title":"variable first_domain","text":"<pre><code>std::string first_domain;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#variable-second_domain","title":"variable second_domain","text":"<pre><code>std::string second_domain;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1GroomParameters_1_1SharedBoundary.html#variable-tolerance","title":"variable tolerance","text":"<pre><code>double tolerance;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html","title":"shapeworks::MeshGeoEntry","text":""},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-types","title":"Public Types","text":"Name enum Mode"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-functions","title":"Public Functions","text":"Name void clear() bool is_full_mode() const void update_max_dist() bool has_entry(int target)"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-attributes","title":"Public Attributes","text":"Name Mode mode double max_dist robin_hood::unordered_flat_map&lt; int, Eigen::Vector3d &gt; data_partial std::array&lt; Eigen::VectorXd, 3 &gt; data_full"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#enum-mode","title":"enum Mode","text":"Enumerator Value Description Full Partial"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#function-is_full_mode","title":"function is_full_mode","text":"<pre><code>inline bool is_full_mode() const\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#function-update_max_dist","title":"function update_max_dist","text":"<pre><code>inline void update_max_dist()\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#function-has_entry","title":"function has_entry","text":"<pre><code>inline bool has_entry(\n    int target\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#variable-mode","title":"variable mode","text":"<pre><code>Mode mode {Mode::Partial};\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#variable-max_dist","title":"variable max_dist","text":"<pre><code>double max_dist {0.0};\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#variable-data_partial","title":"variable data_partial","text":"<pre><code>robin_hood::unordered_flat_map&lt; int, Eigen::Vector3d &gt; data_partial;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MeshGeoEntry.html#variable-data_full","title":"variable data_full","text":"<pre><code>std::array&lt; Eigen::VectorXd, 3 &gt; data_full;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html","title":"shapeworks::MultiVariateNormalRandom","text":""},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#public-functions","title":"Public Functions","text":"Name MultiVariateNormalRandom(Eigen::MatrixXd const &amp; covar) MultiVariateNormalRandom(Eigen::VectorXd const &amp; mean, Eigen::MatrixXd const &amp; covar) Eigen::MatrixXd operator()()"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#public-attributes","title":"Public Attributes","text":"Name Eigen::VectorXd mean Eigen::MatrixXd transform boost::mt19937 gen boost::normal_distribution dist"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#function-multivariatenormalrandom","title":"function MultiVariateNormalRandom","text":"<pre><code>inline MultiVariateNormalRandom(\n    Eigen::MatrixXd const &amp; covar\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#function-multivariatenormalrandom_1","title":"function MultiVariateNormalRandom","text":"<pre><code>inline MultiVariateNormalRandom(\n    Eigen::VectorXd const &amp; mean,\n    Eigen::MatrixXd const &amp; covar\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#function-operator","title":"function operator()","text":"<pre><code>inline Eigen::MatrixXd operator()()\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#variable-mean","title":"variable mean","text":"<pre><code>Eigen::VectorXd mean;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#variable-transform","title":"variable transform","text":"<pre><code>Eigen::MatrixXd transform;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#variable-gen","title":"variable gen","text":"<pre><code>boost::mt19937 gen {42};\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1MultiVariateNormalRandom.html#variable-dist","title":"variable dist","text":"<pre><code>boost::normal_distribution dist;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html","title":"shapeworks::Observer::DefinedCallbacksStruct","text":"<p>More...</p> <p><code>#include &lt;Observer.h&gt;</code></p>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#public-functions","title":"Public Functions","text":"Name DefinedCallbacksStruct()"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#public-attributes","title":"Public Attributes","text":"Name bool DomainAddEvent bool TransformSetEvent bool PrefixTransformSetEvent bool PositionSetEvent bool PositionAddEvent bool PositionRemoveEvent"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#detailed-description","title":"Detailed Description","text":"<pre><code>struct shapeworks::Observer::DefinedCallbacksStruct;\n</code></pre> <p>Data structure indicating which callback functions are defined by a subclass. The ParticleSystem class will reference this structure to determine which callbacks to register. </p>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#function-definedcallbacksstruct","title":"function DefinedCallbacksStruct","text":"<pre><code>inline DefinedCallbacksStruct()\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-domainaddevent","title":"variable DomainAddEvent","text":"<pre><code>bool DomainAddEvent;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-transformsetevent","title":"variable TransformSetEvent","text":"<pre><code>bool TransformSetEvent;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-prefixtransformsetevent","title":"variable PrefixTransformSetEvent","text":"<pre><code>bool PrefixTransformSetEvent;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-positionsetevent","title":"variable PositionSetEvent","text":"<pre><code>bool PositionSetEvent;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-positionaddevent","title":"variable PositionAddEvent","text":"<pre><code>bool PositionAddEvent;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Observer_1_1DefinedCallbacksStruct.html#variable-positionremoveevent","title":"variable PositionRemoveEvent","text":"<pre><code>bool PositionRemoveEvent;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html","title":"shapeworks::ParticlePointIndexPair","text":"<p>More...</p> <p><code>#include &lt;ParticlePointIndexPair.h&gt;</code></p>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-types","title":"Public Types","text":"Name typedef itk::Point&lt; double, 3 &gt; PointType"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-functions","title":"Public Functions","text":"Name ParticlePointIndexPair() ParticlePointIndexPair(const PointType &amp; p, unsigned int i =0) ParticlePointIndexPair(const ParticlePointIndexPair &amp; o) const ParticlePointIndexPair &amp; operator=(const ParticlePointIndexPair &amp; o)"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-attributes","title":"Public Attributes","text":"Name PointType Point unsigned int Index"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#detailed-description","title":"Detailed Description","text":"<pre><code>struct shapeworks::ParticlePointIndexPair;\n</code></pre> <p>Struct containing a Point and an index value associated with a point. This object is used mainly by [ParticleNeighborhood.h]</p>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#typedef-pointtype","title":"typedef PointType","text":"<pre><code>typedef itk::Point&lt;double, 3&gt; shapeworks::ParticlePointIndexPair::PointType;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#function-particlepointindexpair","title":"function ParticlePointIndexPair","text":"<pre><code>inline ParticlePointIndexPair()\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#function-particlepointindexpair_1","title":"function ParticlePointIndexPair","text":"<pre><code>inline ParticlePointIndexPair(\n    const PointType &amp; p,\n    unsigned int i =0\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#function-particlepointindexpair_2","title":"function ParticlePointIndexPair","text":"<pre><code>inline ParticlePointIndexPair(\n    const ParticlePointIndexPair &amp; o\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#function-operator","title":"function operator=","text":"<pre><code>inline const ParticlePointIndexPair &amp; operator=(\n    const ParticlePointIndexPair &amp; o\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#variable-point","title":"variable Point","text":"<pre><code>PointType Point;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ParticlePointIndexPair.html#variable-index","title":"variable Index","text":"<pre><code>unsigned int Index;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html","title":"shapeworks::ProfileEntry","text":""},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#public-attributes","title":"Public Attributes","text":"Name QString name double exclusive_time_ms double inclusive_time_ms int call_count int subcall_count Qt::HANDLE thread_id"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-name","title":"variable name","text":"<pre><code>QString name;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-exclusive_time_ms","title":"variable exclusive_time_ms","text":"<pre><code>double exclusive_time_ms;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-inclusive_time_ms","title":"variable inclusive_time_ms","text":"<pre><code>double inclusive_time_ms;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-call_count","title":"variable call_count","text":"<pre><code>int call_count;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-subcall_count","title":"variable subcall_count","text":"<pre><code>int subcall_count;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1ProfileEntry.html#variable-thread_id","title":"variable thread_id","text":"<pre><code>Qt::HANDLE thread_id;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html","title":"shapeworks::Reconstruction","text":""},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html#public-attributes","title":"Public Attributes","text":"Name double dist int shapeIdx Eigen::MatrixXd rec"},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html#variable-dist","title":"variable dist","text":"<pre><code>double dist;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html#variable-shapeidx","title":"variable shapeIdx","text":"<pre><code>int shapeIdx;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Reconstruction.html#variable-rec","title":"variable rec","text":"<pre><code>Eigen::MatrixXd rec;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html","title":"shapeworks::Sampler::CuttingPlaneType","text":"<p>More...</p> <p><code>#include &lt;Sampler.h&gt;</code></p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#public-attributes","title":"Public Attributes","text":"Name vnl_vector_fixed&lt; double, 3 &gt; a vnl_vector_fixed&lt; double, 3 &gt; b vnl_vector_fixed&lt; double, 3 &gt; c"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#detailed-description","title":"Detailed Description","text":"<pre><code>struct shapeworks::Sampler::CuttingPlaneType;\n</code></pre> <p>Convenient typedef for storing cutting plane information </p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#variable-a","title":"variable a","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; a;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#variable-b","title":"variable b","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; b;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1CuttingPlaneType.html#variable-c","title":"variable c","text":"<pre><code>vnl_vector_fixed&lt; double, 3 &gt; c;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html","title":"shapeworks::Sampler::SphereType","text":"<p>More...</p> <p><code>#include &lt;Sampler.h&gt;</code></p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html#public-attributes","title":"Public Attributes","text":"Name vnl_vector_fixed&lt; double, Dimension &gt; center double radius"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html#detailed-description","title":"Detailed Description","text":"<pre><code>struct shapeworks::Sampler::SphereType;\n</code></pre> <p>Convenient typedef for storing sphere information </p>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html#variable-center","title":"variable center","text":"<pre><code>vnl_vector_fixed&lt; double, Dimension &gt; center;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1Sampler_1_1SphereType.html#variable-radius","title":"variable radius","text":"<pre><code>double radius;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html","title":"shapeworks::SamplingFunction::CrossDomainNeighborhood","text":""},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#public-functions","title":"Public Functions","text":"Name CrossDomainNeighborhood(const ParticlePointIndexPair &amp; pi_pair_, double weight_, double distance_, int dom_)"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#public-attributes","title":"Public Attributes","text":"Name ParticlePointIndexPair pi_pair double weight double distance int dom"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#function-crossdomainneighborhood","title":"function CrossDomainNeighborhood","text":"<pre><code>inline CrossDomainNeighborhood(\n    const ParticlePointIndexPair &amp; pi_pair_,\n    double weight_,\n    double distance_,\n    int dom_\n)\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#variable-pi_pair","title":"variable pi_pair","text":"<pre><code>ParticlePointIndexPair pi_pair;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#variable-weight","title":"variable weight","text":"<pre><code>double weight;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#variable-distance","title":"variable distance","text":"<pre><code>double distance;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SamplingFunction_1_1CrossDomainNeighborhood.html#variable-dom","title":"variable dom","text":"<pre><code>int dom;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html","title":"shapeworks::SharedCommandData","text":""},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#public-functions","title":"Public Functions","text":"Name bool validImage() const bool validMesh() const bool validParticleSystem() const"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#public-attributes","title":"Public Attributes","text":"Name Image image std::unique_ptr&lt; Mesh &gt; mesh PhysicalRegion region ParticleSystemEvaluation particleSystem Field field"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#function-validimage","title":"function validImage","text":"<pre><code>inline bool validImage() const\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#function-validmesh","title":"function validMesh","text":"<pre><code>inline bool validMesh() const\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#function-validparticlesystem","title":"function validParticleSystem","text":"<pre><code>inline bool validParticleSystem() const\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#variable-image","title":"variable image","text":"<pre><code>Image image;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#variable-mesh","title":"variable mesh","text":"<pre><code>std::unique_ptr&lt; Mesh &gt; mesh;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#variable-region","title":"variable region","text":"<pre><code>PhysicalRegion region;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#variable-particlesystem","title":"variable particleSystem","text":"<pre><code>ParticleSystemEvaluation particleSystem;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1SharedCommandData.html#variable-field","title":"variable field","text":"<pre><code>Field field;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html","title":"shapeworks::TraceEvent","text":""},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#public-attributes","title":"Public Attributes","text":"Name QString name QString phase qint64 timestamp_us Qt::HANDLE thread_id int process_id"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#variable-name","title":"variable name","text":"<pre><code>QString name;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#variable-phase","title":"variable phase","text":"<pre><code>QString phase;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#variable-timestamp_us","title":"variable timestamp_us","text":"<pre><code>qint64 timestamp_us;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#variable-thread_id","title":"variable thread_id","text":"<pre><code>Qt::HANDLE thread_id;\n</code></pre>"},{"location":"api/Classes/structshapeworks_1_1TraceEvent.html#variable-process_id","title":"variable process_id","text":"<pre><code>int process_id;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/AnalysisTool_8h.html","title":"Studio/Analysis/AnalysisTool.h","text":""},{"location":"api/Files/AnalysisTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/AnalysisTool_8h.html#classes","title":"Classes","text":"Name class shapeworks::AnalysisTool"},{"location":"api/Files/AnalysisTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n\n// Qt\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\n// ShapeWorks\n#include &lt;Analyze/Analyze.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\n// Studio\n#include &lt;Analysis/ShapeEvaluationJob.h&gt;\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Shape.h&gt;\n#include &lt;Visualization/Visualizer.h&gt;\n\nclass Ui_AnalysisTool;\nclass JKQTPlotter;\n\nnamespace shapeworks {\n\nclass Session;\nclass Lightbox;\nclass ShapeWorksStudioApp;\nclass GroupPvalueJob;\nclass NetworkAnalysisJob;\nclass StatsGroupLDAJob;\nclass ParticleAreaPanel;\nclass ShapeScalarPanel;\n\nclass AnalysisTool : public QWidget {\n  Q_OBJECT;\n\n public:\n  using AlignmentType = Analyze::AlignmentType;\n\n  enum GroupAnalysisType { None = 0, Pvalues = 1, NetworkAnalysis = 2, LDA = 3 };\n\n  enum McaMode { Vanilla, Within, Between };\n\n  using PointType = itk::Point&lt;double, 3&gt;;\n\n  AnalysisTool(Preferences&amp; prefs);\n  ~AnalysisTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  QSharedPointer&lt;Session&gt; get_session();\n\n  void set_app(ShapeWorksStudioApp* app);\n  ShapeWorksStudioApp* get_app() { return app_; }\n\n  void set_active(bool active);\n\n  bool get_active();\n\n  bool get_group_difference_mode();\n\n  std::vector&lt;Shape::Point&gt; get_group_difference_vectors();\n\n  std::string get_analysis_mode();\n  void set_analysis_mode(std::string mode);\n\n  void set_labels(QString which, QString value);\n\n  int get_pca_mode();\n\n  double get_group_ratio();\n\n  double get_pca_value();\n\n  bool pca_animate();\n  McaMode get_mca_level() const;\n\n  int get_sample_number();\n\n  bool compute_stats();\n\n  void update_slider();\n\n  void reset_stats();\n  void enable_actions(bool newly_enabled = false);\n\n  Particles get_mean_shape_points();\n  ShapeHandle get_mean_shape();\n\n  Particles get_shape_points(int mode, double value);\n  Particles get_multi_level_shape_points(int mode, double value, McaMode level);\n  ShapeHandle get_mode_shape(int mode, double value);\n  ShapeHandle get_mca_mode_shape(int mode, double value, McaMode level);\n  ShapeHandle get_current_shape();\n\n  ParticleShapeStatistics get_stats();\n  void load_settings();\n  void store_settings();\n\n  void shutdown();\n\n  bool export_variance_graph(QString filename);\n\n  void compute_shape_evaluations();\n\n  static const std::string MODE_ALL_SAMPLES_C;\n  static const std::string MODE_MEAN_C;\n  static const std::string MODE_PCA_C;\n  static const std::string MODE_SINGLE_SAMPLE_C;\n  static const std::string MODE_REGRESSION_C;\n\n  GroupAnalysisType get_group_analysis_type();\n\n  bool pca_scalar_only_mode();\n  bool pca_shape_plus_scalar_mode();\n  bool pca_shape_only_mode();\n\n public Q_SLOTS:\n\n  // analysis mode\n  void on_tabWidget_currentChanged();\n\n  void handle_analysis_options();\n  void handle_median();\n\n  void on_mean_button_clicked();\n  void on_group1_button_clicked();\n  void on_group2_button_clicked();\n  void on_difference_button_clicked();\n\n  // PCA\n  void on_pcaSlider_valueChanged();\n  void on_group_slider_valueChanged();\n  void on_pcaModeSpinBox_valueChanged(int i);\n\n  void handle_pca_animate_state_changed();\n  void handle_pca_timer();\n\n  void handle_group_animate_state_changed();\n  void handle_group_timer();\n\n  void handle_reconstruction_complete();\n\n  void on_reconstructionButton_clicked();\n\n  void set_feature_map(const std::string&amp; feature_map);\n\n  std::string get_display_feature_map();\n\n  void group_changed();\n\n  bool groups_active();\n  bool pca_groups_active();\n  QStringList get_checked_pca_groups();\n\n  void on_view_open_button_toggled();\n\n  void on_surface_open_button_toggled();\n\n  void on_metrics_open_button_toggled();\n\n  void reconstruction_method_changed();\n\n  void initialize_mesh_warper();\n\n  void group_p_values_clicked();\n  void network_analysis_clicked();\n\n  void handle_eval_thread_complete(ShapeEvaluationJob::JobType job_type, Eigen::VectorXd data);\n  void handle_eval_thread_progress(ShapeEvaluationJob::JobType job_type, float progress);\n  void handle_eval_particle_normals_progress(float progress);\n  void handle_eval_particle_normals_complete(std::vector&lt;bool&gt; good_bad);\n\n  void handle_group_pvalues_complete();\n  void handle_alignment_changed(int new_alignment);\n\n  void handle_distance_method_changed();\n\n  void run_good_bad_particles();\n\n  void handle_lda_progress(double progress);\n  void handle_lda_complete();\n\n  void handle_network_analysis_progress(int progress);\n  void handle_network_analysis_complete();\n\n  void show_difference_to_mean_clicked();\n\n  void group_analysis_combo_changed();\n\n  void change_pca_analysis_type();\n\n  Eigen::VectorXd construct_mean_shape();\n\n  void handle_samples_predicted_scalar_options();\n\n  void samples_table_context_menu();\n  void samples_table_copy_to_clipboard();\n\n  // mesh warping options\n  void mesh_warp_median_clicked();\n  void mesh_warp_sample_changed();\n  void mesh_warp_run_clicked();\n\n  void handle_tab_changed();\n\n Q_SIGNALS:\n\n  void update_view();\n  void analysis_mode_changed();\n  void pca_update();\n  void progress(int);\n  void reconstruction_complete();\n\n private:\n  void compute_reconstructed_domain_transforms();\n\n  bool active_ = false;\n\n  void pca_labels_changed(QString value, QString eigen, QString lambda);\n\n  void update_interface();\n\n  bool group_pvalues_valid();\n  bool groups_on();\n\n  Particles convert_from_combined(const Eigen::VectorXd&amp; points);\n\n  void update_group_boxes();\n  void update_group_values();\n  void update_domain_alignment_box();\n  void update_pca_group_options();\n  void handle_pca_group_list_item_changed();\n\n  void update_lda_graph();\n\n  void update_difference_particles();\n\n  Eigen::VectorXd get_mean_shape_particles();\n\n  ShapeHandle create_shape_from_points(Particles points);\n\n  Preferences&amp; preferences_;\n\n  Ui_AnalysisTool* ui_;\n  QSharedPointer&lt;Session&gt; session_;\n  ShapeWorksStudioApp* app_;\n\n  ParticleShapeStatistics stats_;\n  bool stats_ready_ = false;\n  bool evals_ready_ = false;\n  bool large_particle_disclaimer_waived_ = false;\n  bool skip_evals_ = false;\n\n  Eigen::VectorXd eval_specificity_;\n  Eigen::VectorXd eval_compactness_;\n  Eigen::VectorXd eval_generalization_;\n\n  vnl_vector&lt;double&gt; empty_shape_;\n  Eigen::VectorXd temp_shape_;\n  Eigen::VectorXd temp_shape_mca;\n  std::vector&lt;int&gt; number_of_particles_array_;\n\n  Eigen::VectorXd computed_scalars_;\n\n  bool pca_animate_direction_ = true;\n  QTimer pca_animate_timer_;\n\n  bool group_animate_direction_ = true;\n  QTimer group_animate_timer_;\n\n  ShapeHandle computed_shape_;\n\n  ShapeList group1_list_;\n  ShapeList group2_list_;\n\n  std::string feature_map_;\n\n  std::vector&lt;std::string&gt; current_group_names_;\n  std::vector&lt;std::string&gt; current_group_values_;\n  std::vector&lt;std::string&gt; current_pca_group_values_;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt; reconstruction_transforms_;\n\n  QSharedPointer&lt;GroupPvalueJob&gt; group_pvalue_job_;\n  QSharedPointer&lt;StatsGroupLDAJob&gt; group_lda_job_;\n  QSharedPointer&lt;NetworkAnalysisJob&gt; network_analysis_job_;\n\n  bool group_lda_job_running_ = false;\n  bool lda_computed_ = false;\n  bool block_group_change_ = false;\n\n  ParticleAreaPanel* particle_area_panel_{nullptr};\n  ShapeScalarPanel* shape_scalar_panel_{nullptr};\n\n  std::vector&lt;QPointer&lt;Worker&gt;&gt; workers_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/AnalysisUtils_8h.html","title":"Studio/Utils/AnalysisUtils.h","text":""},{"location":"api/Files/AnalysisUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/AnalysisUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::AnalysisUtils"},{"location":"api/Files/AnalysisUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Particles/ParticleSystemEvaluation.h&gt;\n\n#include &lt;QColor&gt;\n#include &lt;QString&gt;\n\nclass JKQTPlotter;\n\nnamespace shapeworks {\n\nclass Session;\n\nclass AnalysisUtils {\n public:\n  static ParticleSystemEvaluation get_local_particle_system(Session* session, int domain);\n\n  static void create_plot(JKQTPlotter* plot, Eigen::VectorXd data, QString title, QString x_label, QString y_label);\n\n  static void create_box_plot(JKQTPlotter* plot, Eigen::VectorXd data, QString title, QString x_label,\n                              QColor color = Qt::blue);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Analyze_8h.html","title":"Libs/Analyze/Analyze.h","text":""},{"location":"api/Files/Analyze_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Analyze_8h.html#classes","title":"Classes","text":"Name class shapeworks::Analyze High level analyze API."},{"location":"api/Files/Analyze_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;ParticleShapeStatistics.h&gt;\n#include &lt;Project/Project.h&gt;\n\n#include \"Shape.h\"\n\nnamespace shapeworks {\n\n\nclass Analyze {\n public:\n\n  enum AlignmentType {\n    Global = -2,\n    Local = -1,\n  };\n\n\n  Analyze(ProjectHandle project);\n\n  void run_offline_analysis(std::string outfile, float range, float steps);\n\n  ShapeList get_shapes();\n\n  int get_num_subjects();\n\n  int get_num_modes();\n\n  int get_num_particles();\n\n  Particles get_mean_shape_points();\n\n  ShapeHandle get_mean_shape();\n\n  Particles get_group_shape_particles(double ratio);\n  ShapeHandle get_group_shape(double ratio);\n\n  Particles get_shape_points(int mode, double value);\n  ShapeHandle get_mode_shape(int mode, double value);\n\n  bool groups_active() { return false; }\n\n  ShapeHandle create_shape_from_points(Particles points);\n\n  Eigen::VectorXd get_subject_features(int subject, std::string feature_name);\n\n  void set_group_selection(std::string group_name, std::string group1, std::string group2);\n\n  ParticleSystemEvaluation get_local_particle_system(int domain);\n\n private:\n  bool update_shapes();\n  bool compute_stats();\n\n  void initialize_mesh_warper();\n\n  Particles convert_from_combined(const Eigen::VectorXd&amp; points);\n\n  ProjectHandle project_;\n\n  // collection of shapes\n  ShapeList shapes_;\n\n  ShapeList group1_list_;\n  ShapeList group2_list_;\n\n  std::shared_ptr&lt;MeshManager&gt; mesh_manager_;\n\n  ParticleShapeStatistics stats_;\n  bool stats_ready_ = false;\n\n  std::string selected_group_;\n  std::string group1_;\n  std::string group2_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ColorMap_8h.html","title":"Studio/Visualization/ColorMap.h","text":""},{"location":"api/Files/ColorMap_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ColorMap_8h.html#classes","title":"Classes","text":"Name class shapeworks::ColorMap class shapeworks::ColorMaps"},{"location":"api/Files/ColorMap_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkColorSeries.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;QColor&gt;\n#include &lt;QStringList&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\nclass ColorMap {\n public:\n  QString name_;\n  vtkSmartPointer&lt;vtkColorSeries&gt; color_series_;\n\n  void construct_lookup_table(vtkSmartPointer&lt;vtkLookupTable&gt; lut);\n\n  static vtkColor3ub convert(QColor color);\n\n  void set_discrete_mode(bool discrete_mode) { discrete_mode_ = discrete_mode; }\n  void set_reverse_mode(bool reverse_mode) { reverse_mode_ = reverse_mode; }\n\n private:\n  bool discrete_mode_ = false;\n  bool reverse_mode_ = false;\n};\n\nclass ColorMaps : public std::vector&lt;ColorMap&gt; {\n public:\n  ColorMaps();\n\n  vtkSmartPointer&lt;vtkColorSeries&gt; get_color_series(int index) {\n    if (index &lt; 0) {\n      index = 0;\n    }\n    if (index &gt; size() - 1) {\n      index = size() - 1;\n    }\n\n    return (*this)[index].color_series_;\n  }\n\n  ColorMap get_color_map(int index) {\n    if (index &lt; 0) {\n      index = 0;\n    }\n    if (index &gt; size() - 1) {\n      index = size() - 1;\n    }\n\n    return (*this)[index];\n  }\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ColorSchemes_8h.html","title":"Studio/Visualization/ColorSchemes.h","text":""},{"location":"api/Files/ColorSchemes_8h.html#classes","title":"Classes","text":"Name class ColorScheme struct ColorScheme::rgb class ColorSchemes"},{"location":"api/Files/ColorSchemes_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QColor&gt;\n#include &lt;vector&gt;\n\nclass ColorScheme {\n public:\n  struct rgb {\n    rgb() : r(1.0), g(1.0), b(1.0) {}\n    rgb(float l, float m, float n) {\n      float q = 255.0;  // sqrt(l*l + m*m + n*n) + 1.0e-6;\n      r = l / q;\n      g = m / q;\n      b = n / q;\n    }\n\n    float r;\n    float g;\n    float b;\n  };\n\n  rgb foreground;\n  rgb background;\n  rgb alt;\n\n  //-----------------------------------------------------------------------------\n  QColor background_qcolor(int alpha) { return QColor(background.r * 255, background.g * 255, background.b * 255, alpha); }\n\n  //-----------------------------------------------------------------------------\n  QColor foreground_qcolor() { return QColor(foreground.r * 255, foreground.g * 255, foreground.b * 255, 255); }\n\n  //-----------------------------------------------------------------------------\n  QColor get_text_color() {\n    double average = (background.r + background.g + background.b) / 3.0;\n\n    double color = 255;\n    if (average &gt; 0.5) {\n      color = 0;\n    }\n    return QColor(color, color, color);\n  }\n\n  double get_text_intensity() {\n    auto color = get_text_color();\n    if (color.red() == 0) {\n      return 0;\n    }\n    return 1;\n  }\n\n  ColorScheme() {}\n  ~ColorScheme() {}\n};\n\nclass ColorSchemes : public std::vector&lt;ColorScheme&gt; {\n public:\n  ColorSchemes() {\n    ColorScheme a;\n\n    // orange on grey\n    a.foreground = ColorScheme::rgb(255, 191, 0);\n    a.background = ColorScheme::rgb(25, 25, 25);\n    a.alt = ColorScheme::rgb(245, 245, 220);\n    this-&gt;push_back(a);\n\n    // purple on grey\n    a.foreground = ColorScheme::rgb(128, 0, 32.0);\n    a.background = ColorScheme::rgb(25, 25, 25);\n    a.alt = ColorScheme::rgb(245, 245, 220);\n    this-&gt;push_back(a);\n\n    // blue on white\n    a.foreground = ColorScheme::rgb(0, 71, 171);\n    a.background = ColorScheme::rgb(245, 245, 245);\n    a.alt = ColorScheme::rgb(175, 64, 53);\n    this-&gt;push_back(a);\n\n    // orange on white\n    a.foreground = ColorScheme::rgb(255, 191, 0);\n    a.background = ColorScheme::rgb(255, 255, 255);\n    a.alt = ColorScheme::rgb(0, 223, 22);\n    this-&gt;push_back(a);\n\n    // grey on white\n    // For Black and White figures\n    a.foreground = ColorScheme::rgb(200, 200, 200);\n    a.background = ColorScheme::rgb(255, 255, 255);\n    a.alt = ColorScheme::rgb(80, 80, 80);\n    this-&gt;push_back(a);\n\n    // orange on blue\n    a.foreground = ColorScheme::rgb(255, 219, 88);\n    a.background = ColorScheme::rgb(0, 0, 128);\n    a.alt = ColorScheme::rgb(173, 255, 47);\n    this-&gt;push_back(a);\n\n    // yellow on grey\n    a.foreground = ColorScheme::rgb(240, 220, 130);\n    a.background = ColorScheme::rgb(25, 25, 25);\n    a.alt = ColorScheme::rgb(0, 223, 22);\n    this-&gt;push_back(a);\n\n    // grey on black\n    a.foreground = ColorScheme::rgb(200, 200, 200);\n    a.background = ColorScheme::rgb(0, 0, 0);\n    a.alt = ColorScheme::rgb(100, 100, 100);\n    this-&gt;push_back(a);\n\n    // blue on black\n    a.foreground = ColorScheme::rgb(0, 191, 255);\n    a.background = ColorScheme::rgb(0, 0, 0);\n    a.alt = ColorScheme::rgb(175, 64, 53);\n    this-&gt;push_back(a);\n\n    // green on black\n    a.foreground = ColorScheme::rgb(137, 232, 148);\n    a.background = ColorScheme::rgb(0, 0, 0);\n    a.alt = ColorScheme::rgb(175, 64, 53);\n    this-&gt;push_back(a);\n  }\n  ~ColorSchemes() {}\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Command_8h.html","title":"Applications/shapeworks/Command.h","text":""},{"location":"api/Files/Command_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Command_8h.html#classes","title":"Classes","text":"Name class shapeworks::Command class shapeworks::ImageCommand class shapeworks::MeshCommand class shapeworks::OptimizeCommandGroup class shapeworks::GroomCommandGroup class shapeworks::AnalyzeCommandGroup class shapeworks::ProjectCommandGroup class shapeworks::ParticleSystemCommand class shapeworks::DeepSSMCommandGroup class shapeworks::ShapeworksCommand"},{"location":"api/Files/Command_8h.html#functions","title":"Functions","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const shapeworks::Command &amp; cmd)"},{"location":"api/Files/Command_8h.html#defines","title":"Defines","text":"Name COMMAND_DECLARE(CommandName, CommandType)"},{"location":"api/Files/Command_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/Command_8h.html#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const shapeworks::Command &amp; cmd\n)\n</code></pre>"},{"location":"api/Files/Command_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/Command_8h.html#define-command_declare","title":"define COMMAND_DECLARE","text":"<pre><code>#define COMMAND_DECLARE(\n    CommandName,\n    CommandType\n)\n  class CommandName : public CommandType                                                   \\\n  {                                                                                        \\\n  public:                                                                                  \\\n    static CommandName &amp;getCommand() { static CommandName instance; return instance; }     \\\n                                                                                           \\\n  private:                                                                                 \\\n    CommandName() { buildParser(); }                                                       \\\n    void buildParser() override;                                                           \\\n    bool execute(const optparse::Values &amp;options, SharedCommandData &amp;sharedData) override; \\\n  }\n</code></pre>"},{"location":"api/Files/Command_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n/*\n * Command provided by unified shapeworks executable.\n */\n\n#include \"OptionParser.h\"\n#include \"SharedCommandData.h\"\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\n#define COMMAND_DECLARE(CommandName, CommandType)                                          \\\n  class CommandName : public CommandType                                                   \\\n  {                                                                                        \\\n  public:                                                                                  \\\n    static CommandName &amp;getCommand() { static CommandName instance; return instance; }     \\\n                                                                                           \\\n  private:                                                                                 \\\n    CommandName() { buildParser(); }                                                       \\\n    void buildParser() override;                                                           \\\n    bool execute(const optparse::Values &amp;options, SharedCommandData &amp;sharedData) override; \\\n  }\n\nnamespace shapeworks {\n\nclass Command {\npublic:\n  virtual const std::string type() { return \"General\"; }\n\n  const std::string name() const { return parser.prog(); }\n  const std::string usage() const { return parser.get_usage(); }\n  const std::string desc() const { return parser.description(); }\n\n  std::vector&lt;std::string&gt; parse_args(const std::vector&lt;std::string&gt; &amp;arguments);\n\n  int run(SharedCommandData &amp;sharedData);\n\nprivate:\n  virtual bool execute(const optparse::Values &amp;options, SharedCommandData &amp;sharedData) = 0;\n\nprotected:\n  virtual void buildParser(); // derived classes should specialize and call this as well\n\n  optparse::OptionParser parser;\n};\n\nclass ImageCommand : public Command\n{\npublic:\n  const std::string type() override { return \"Image\"; }\n\nprivate:\n};\n\nclass MeshCommand : public Command\n{\npublic:\n  const std::string type() override { return \"Mesh\"; }\n\nprivate:\n};\n\nclass OptimizeCommandGroup : public Command\n{\npublic:\n  const std::string type() override { return \"Optimize\"; }\n\nprivate:\n};\n\nclass GroomCommandGroup : public Command\n{\npublic:\n  const std::string type() override { return \"Groom\"; }\n\nprivate:\n};\n\nclass AnalyzeCommandGroup : public Command\n{\npublic:\n  const std::string type() override { return \"Analyze\"; }\n\nprivate:\n};\n\nclass ProjectCommandGroup : public Command\n{\npublic:\n  const std::string type() override { return \"Project\"; }\n\nprivate:\n};\n\nclass ParticleSystemCommand : public Command\n{\npublic:\n  const std::string type() override { return \"ParticleSystem\"; }\n\nprivate:\n};\n\nclass DeepSSMCommandGroup : public Command\n{\npublic:\n  const std::string type() override { return \"DeepSSM\"; }\n\nprivate:\n};\n\n\nclass ShapeworksCommand : public Command\n{\npublic:\n  const std::string type() override { return \"Shapeworks\"; }\n\nprivate:\n};\n\n}; // shapeworks\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const shapeworks::Command &amp;cmd);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Commands_8h.html","title":"Applications/shapeworks/Commands.h","text":""},{"location":"api/Files/Commands_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Commands_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Command.h\"\n\nnamespace shapeworks {\n\n// Image Commands\nCOMMAND_DECLARE(ReadImage, ImageCommand);\nCOMMAND_DECLARE(WriteImage, ImageCommand);\nCOMMAND_DECLARE(ImageInfo, ImageCommand);\nCOMMAND_DECLARE(Antialias, ImageCommand);\nCOMMAND_DECLARE(ResampleImage, ImageCommand);\nCOMMAND_DECLARE(ResizeImage, ImageCommand);\nCOMMAND_DECLARE(RecenterImage, ImageCommand);\nCOMMAND_DECLARE(PadImage, ImageCommand);\nCOMMAND_DECLARE(TranslateImage, ImageCommand);\nCOMMAND_DECLARE(ScaleImage, ImageCommand);\nCOMMAND_DECLARE(Rotate, ImageCommand);\nCOMMAND_DECLARE(ExtractLabel, ImageCommand);\nCOMMAND_DECLARE(CloseHoles, ImageCommand);\nCOMMAND_DECLARE(Binarize, ImageCommand);\nCOMMAND_DECLARE(ComputeDT, ImageCommand);\nCOMMAND_DECLARE(CurvatureFilter, ImageCommand);\nCOMMAND_DECLARE(GradientFilter, ImageCommand);\nCOMMAND_DECLARE(SigmoidFilter, ImageCommand);\nCOMMAND_DECLARE(TPLevelSetFilter, ImageCommand);\nCOMMAND_DECLARE(TopologyPreservingFilter, ImageCommand);\nCOMMAND_DECLARE(IntensityFilter, ImageCommand);\nCOMMAND_DECLARE(Blur, ImageCommand);\nCOMMAND_DECLARE(BoundingBoxImage, ImageCommand);\nCOMMAND_DECLARE(ImageBounds, ImageCommand);\nCOMMAND_DECLARE(CropImage, ImageCommand);\nCOMMAND_DECLARE(ICPRigid, ImageCommand);\nCOMMAND_DECLARE(ClipImage, ImageCommand);\nCOMMAND_DECLARE(ReflectImage, ImageCommand);\nCOMMAND_DECLARE(SetOrigin, ImageCommand);\nCOMMAND_DECLARE(SetSpacing, ImageCommand);\nCOMMAND_DECLARE(WarpImage, ImageCommand);\nCOMMAND_DECLARE(CompareImage, ImageCommand);\nCOMMAND_DECLARE(NegateImage, ImageCommand);\nCOMMAND_DECLARE(AddImage, ImageCommand);\nCOMMAND_DECLARE(SubtractImage, ImageCommand);\nCOMMAND_DECLARE(MultiplyImage, ImageCommand);\nCOMMAND_DECLARE(DivideImage, ImageCommand);\nCOMMAND_DECLARE(ImageToMesh, ImageCommand);\nCOMMAND_DECLARE(SetRegion, ImageCommand);\nCOMMAND_DECLARE(Isolate, ImageCommand);\n\n// Particle System Commands\nCOMMAND_DECLARE(ReadParticleSystem, ParticleSystemCommand);\nCOMMAND_DECLARE(Compactness, ParticleSystemCommand);\nCOMMAND_DECLARE(Generalization, ParticleSystemCommand);\nCOMMAND_DECLARE(Specificity, ParticleSystemCommand);\n\n// Mesh Commands\nCOMMAND_DECLARE(ReadMesh, MeshCommand);\nCOMMAND_DECLARE(WriteMesh, MeshCommand);\nCOMMAND_DECLARE(MeshInfo, MeshCommand);\nCOMMAND_DECLARE(Coverage, MeshCommand);\nCOMMAND_DECLARE(Smooth, MeshCommand);\nCOMMAND_DECLARE(SmoothSinc, MeshCommand);\nCOMMAND_DECLARE(Remesh, MeshCommand);\nCOMMAND_DECLARE(RemeshPercent, MeshCommand);\nCOMMAND_DECLARE(InvertNormals, MeshCommand);\nCOMMAND_DECLARE(ReflectMesh, MeshCommand);\nCOMMAND_DECLARE(TransformMesh, MeshCommand);\nCOMMAND_DECLARE(FillHoles, MeshCommand);\nCOMMAND_DECLARE(ProbeVolume, MeshCommand);\nCOMMAND_DECLARE(ClipMesh, MeshCommand);\nCOMMAND_DECLARE(TranslateMesh, MeshCommand);\nCOMMAND_DECLARE(ScaleMesh, MeshCommand);\nCOMMAND_DECLARE(BoundingBoxMesh, MeshCommand);\nCOMMAND_DECLARE(MeshBounds, MeshCommand);\nCOMMAND_DECLARE(Distance, MeshCommand);\nCOMMAND_DECLARE(ComputeNormals, MeshCommand);\nCOMMAND_DECLARE(SetField, MeshCommand);\nCOMMAND_DECLARE(GetField, MeshCommand);\nCOMMAND_DECLARE(SetFieldValue, MeshCommand);\nCOMMAND_DECLARE(GetFieldValue, MeshCommand);\nCOMMAND_DECLARE(FieldRange, MeshCommand);\nCOMMAND_DECLARE(FieldMean, MeshCommand);\nCOMMAND_DECLARE(FieldStd, MeshCommand);\nCOMMAND_DECLARE(FieldNames, MeshCommand);\nCOMMAND_DECLARE(FixElement, MeshCommand);\nCOMMAND_DECLARE(MeshLargestComponent, MeshCommand);\nCOMMAND_DECLARE(ClipClosedSurface, MeshCommand);\nCOMMAND_DECLARE(ClosestPoint, MeshCommand);\nCOMMAND_DECLARE(GeodesicDistance, MeshCommand);\nCOMMAND_DECLARE(GeodesicDistanceToLandmark, MeshCommand);\nCOMMAND_DECLARE(MeanNormals, MeshCommand);\nCOMMAND_DECLARE(Curvature, MeshCommand);\nCOMMAND_DECLARE(MeshToImage, MeshCommand);\nCOMMAND_DECLARE(MeshToDT, MeshCommand);\nCOMMAND_DECLARE(CompareMesh, MeshCommand);\nCOMMAND_DECLARE(WarpMesh, MeshCommand);\nCOMMAND_DECLARE(ComputeThickness, MeshCommand);\nCOMMAND_DECLARE(LandmarkGeodesics, MeshCommand);\n\n// Misc Commands\nCOMMAND_DECLARE(Seed, ShapeworksCommand);\nCOMMAND_DECLARE(OptimizeCommand, OptimizeCommandGroup);\nCOMMAND_DECLARE(GroomCommand, GroomCommandGroup);\nCOMMAND_DECLARE(AnalyzeCommand, AnalyzeCommandGroup);\nCOMMAND_DECLARE(ConvertProjectCommand, ProjectCommandGroup);\nCOMMAND_DECLARE(DeepSSMCommand, DeepSSMCommandGroup);\n\n} // shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/CompareWidget_8h.html","title":"Studio/Interface/CompareWidget.h","text":""},{"location":"api/Files/CompareWidget_8h.html#namespaces","title":"Namespaces","text":"Name Ui shapeworks User usage reporting (telemetry)"},{"location":"api/Files/CompareWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::CompareWidget"},{"location":"api/Files/CompareWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Session.h&gt;\n\n#include &lt;QWidget&gt;\n\nnamespace Ui {\nclass CompareWidget;\n}\n\nnamespace shapeworks {\n\nclass CompareWidget : public QWidget {\n  Q_OBJECT\n\n public:\n  explicit CompareWidget(QWidget *parent = nullptr);\n  ~CompareWidget();\n\n  CompareSettings get_settings();\n  void set_available(DisplayMode mode, bool available);\n  void set_mean_shape_available(bool available);\n\n  bool check_any_available();\n\n Q_SIGNALS:\n  void settings_changed();\n\n private:\n  Ui::CompareWidget *ui_;\n  CompareSettings settings_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ConstraintType_8h.html","title":"Libs/Optimize/Constraints/ConstraintType.h","text":""},{"location":"api/Files/ConstraintType_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ConstraintType_8h.html#defines","title":"Defines","text":"Name DIMENSION"},{"location":"api/Files/ConstraintType_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/ConstraintType_8h.html#define-dimension","title":"define DIMENSION","text":"<pre><code>#define DIMENSION 3\n</code></pre>"},{"location":"api/Files/ConstraintType_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#define DIMENSION 3\n\nnamespace shapeworks {\n  enum class ConstraintType : char {\n    CuttingPlane = 'C',\n    FreeForm = 'F'\n  };\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Constraint_8h.html","title":"Libs/Optimize/Constraints/Constraint.h","text":""},{"location":"api/Files/Constraint_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Constraint_8h.html#classes","title":"Classes","text":"Name class shapeworks::Constraint"},{"location":"api/Files/Constraint_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vnl/vnl_math.h&gt;\n#include &lt;vnl/vnl_vector.h&gt;\n#include &lt;vector&gt;\n\n#include &lt;Eigen/Core&gt;\n\n#include \"ConstraintType.h\"\n\nnamespace shapeworks {\n\nclass Constraint {\n public:\n  bool isViolated(const vnl_vector&lt;double&gt; &amp;pt) const { return isViolated(Eigen::Vector3d(pt[0], pt[1], pt[2])); }\n  virtual bool isViolated(const Eigen::Vector3d &amp;pt) const = 0;\n  virtual void print() const = 0;\n\n  // For augmented lagrangian\n  void setMus(std::vector&lt;double&gt; inmu) { mus_ = inmu; }\n  std::vector&lt;double&gt; getMus() { return mus_; }\n\n  virtual Eigen::Vector3d constraintGradient(const Eigen::Vector3d &amp;pt) const = 0;\n  virtual double constraintEval(const Eigen::Vector3d &amp;pt) const = 0;\n\n  void updateMu(const Eigen::Vector3d &amp;pt, double C, size_t index);\n\n  Eigen::Vector3d lagragianGradient(const Eigen::Vector3d &amp;pt, double C, size_t index) const;\n\n protected:\n  int sgn(double val) { return (double(0) &lt; val) - (val &lt; double(0)); }\n\n  // For augmented lagrangian\n  std::vector&lt;double&gt; mus_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Constraints_8h.html","title":"Libs/Optimize/Constraints/Constraints.h","text":""},{"location":"api/Files/Constraints_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Constraints_8h.html#classes","title":"Classes","text":"Name class shapeworks::Constraints"},{"location":"api/Files/Constraints_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"Constraint.h\"\n#include \"Eigen/Dense\"\n#include \"FreeFormConstraint.h\"\n#include \"Libs/Mesh/Mesh.h\"\n#include \"PlaneConstraint.h\"\n#include \"itkPoint.h\"\n#include \"vnl/vnl_cross.h\"\n#include \"vnl/vnl_inverse.h\"\n\nnamespace shapeworks {\n\n/* Constraints Roadmap\n * For future tinkerers, this is a guide to all the code relevant to constraints to help you navigate the optimizer and change things if desired. In simple terms,\n *      constraints define areas of interest by getting violation regions to repel particles by attaching a mechanism to all gradient updates that push them back\n *      if a violation does occur. \"Look up quadratic penalty method\" for more information.\n *\n * - Reading json constraints: From Libs/Optimize/OptimizeParameters::set_up_optimize -&gt; Libs/Optimize/Constraints/Constraints::read\n *\n * - Initialization: The various steps in the constraints initialization are\n *          +Libs/Optimize/Optimize::Initialize and ParticleSystem::AdvancedAllParticleSplitting initialize quadratic penalty mus.\n *          +Libs/Optimize/Domain/{Image,Contour,Mesh}Domain determine the picking of the initial particle position to be optimized which is assured not to violate any constraint here\n *          +Libs/Optimize/Sampler::AllocateDomainsAndNeighborhoods sets the constraints within the constraints class via Libs/Optimize/Constraints/Constraints::addSphere and addPlane, and initializes FFCs via Sampler::initialize_ffcs -&gt; Constraints::addFreeFormConstraint\n *          +Libs/Optimize/Sampler::initialize_ffcs also computes the gradient fields to allow distance and gradient queries\n *\n * - Optimization: For optimization, the relevant constraints code is in Libs/Optimize/GradientDescentOptimizer::StartAdaptiveGaussSeidelOptimization in Step B,\n *      where it calls GradientDescentOptimizer::AugmentedLagrangianConstraints to tweak any updates by our constraints class corrections to not violate constraints.\n *      See constraints class.\n *\n * - Constraints class: This class implements a quadratic penalty style optimizer for the entire ShapeWorks particle system to apply boundary constraints.\n *      This Libs/Optimize/Constraints/ directory contains the following files\n *          +Constraints: Contains the processing of multiple interacting constraints and computing gradients for the optimizer. Constains all constraints for a full particle system (multiple shapes/domains).\n *          +Constraint: A general class for any type of constraint. Contains only one constraint, but has quadratic penalty equations to facilitate any single-constraint operations.\n *              *PlaneConstraint: Cutting plane constraints that use the equation of a plane to compute distances and gradients.\n *              *SphereConstraint(deprecated): It uses the equation of a sphere.\n *              *Free-form constraints: Use a signed geodesic mesh field to represent regions of interest of arbitrary shape, see below.\n *\n * - Mesh fields used for FFCs: FFCs use mesh field representations which are of class shapeworks::Mesh, located in Libs/Mesh/Mesh. Within Libs/Mesh/Mesh, the relevant functions are\n *          +Mesh::clip: Clips by cutting plane\n *          +Mesh::clipByField: Clips by a value field\n *          +Mesh::getFFCValue: Allows getting the shortest signed geodesic distance of a point to any boundary\n *          +Mesh::getFFCGradient: Allows getting the direction to the boundary. This might be the opposite direction for violated\n *\n * - The Parameter mesh_ffc_mode is exposed through Libs/Optimize/OptimizeParameters and are passed to Libs/Optimize/Optimize\n *          +mesh_ffc_mode: when running on meshes, 0 is for mesh clipping (default) and 1 is for the quadratic penalty\n *\n * - DEPRECATED: Reading xml constraints: Constraints from xmls are read via Libs/Optimize/OptimizeParameterFile::read_cutting_planes and read_cutting_spheres,\n *      then go through Optimize.cpp::SetCuttingPlane -&gt; Sampler-&gt;SetCuttingPlane and Libs/Optimize/Constraints/Constraints::addPlane. Same for spheres and FFCs (both deprecated).\n *\n*/\n\nclass Constraints {\n public:\n  using Point3 = itk::Point&lt;double, 3&gt;;\n\n  Constraints() { active_ = false; }\n\n  ~Constraints() {}\n\n  // Set constraints\n  void addPlane(const vnl_vector&lt;double&gt; &amp;a, const vnl_vector&lt;double&gt; &amp;b, const vnl_vector&lt;double&gt; &amp;c);\n  void addFreeFormConstraint(std::shared_ptr&lt;shapeworks::Mesh&gt; mesh);\n\n  // Transforms\n  bool transformConstraints(const vnl_matrix_fixed&lt;double, 4, 4&gt; &amp;transform);\n  bool transformPlanes(const vnl_matrix_fixed&lt;double, 4, 4&gt; &amp;transform);\n\n  // Constraint get function\n  std::vector&lt;PlaneConstraint&gt; &amp;getPlaneConstraints() { return planeConstraints_; }\n  FreeFormConstraint&amp; getFreeformConstraint();\n\n  bool isAnyViolated(const Point3 &amp;pos);\n\n  void printAll();\n\n  std::string violationReport(const Point3 &amp;pos, size_t index);\n\n  std::vector&lt;std::vector&lt;double&gt;&gt; violationReportData(const Point3 &amp;pos);\n\n  // ============================\n  // Augmented Lagragian Fuctions\n  // ============================\n\n  vnl_vector_fixed&lt;double, 3&gt; constraintsLagrangianGradient(const Point3 &amp;pos, const Point3 &amp;prepos, double C, size_t index);\n\n  void InitializeLagrangianParameters(std::vector&lt;double&gt; mus);\n\n  void UpdateMus(const Point3 &amp;pos, double C, size_t index);\n\n  bool GetActive() { return active_; }\n  void SetActive(bool ac) { active_ = ac; }\n\n  void read(std::string filename);\n  void write(std::string filename);\n\n  bool hasConstraints();\n\n  void clipMesh(Mesh&amp; mesh);\n\n private:\n  std::vector&lt;PlaneConstraint&gt; planeConstraints_;\n  FreeFormConstraint freeFormConstraint_;\n\n  bool active_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ContourDomain_8h.html","title":"Libs/Optimize/Domain/ContourDomain.h","text":""},{"location":"api/Files/ContourDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ContourDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::ContourDomain"},{"location":"api/Files/ContourDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkObjectFactory.h&gt;\n#include &lt;vtkCellLocator.h&gt;\n#include &lt;vtkGenericCell.h&gt;\n#include &lt;vtkLine.h&gt;\n#include &lt;vtkPolyData.h&gt;\n\n#include &lt;Eigen/Dense&gt;\n\n#include \"ParticleDomain.h\"\n\nnamespace shapeworks {\n\nclass ContourDomain : public ParticleDomain {\n public:\n  using Pointer = std::shared_ptr&lt;ContourDomain&gt;;\n\n  explicit ContourDomain() {}\n  virtual ~ContourDomain() {}\n\n  void SetPolyLine(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n\n  DomainType GetDomainType() const override { return DomainType::Contour; }\n\n  virtual bool ApplyConstraints(PointType&amp; p, int idx, bool dbg = false) const override;\n\n  virtual PointType UpdateParticlePosition(const PointType&amp; point, int idx, VectorDoubleType&amp; update) const override;\n\n  virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType&amp; gradE, const PointType&amp; pos,\n                                                         int idx) const override;\n\n  virtual VectorFloatType SampleNormalAtPoint(const PointType&amp; point, int idx) const override {\n    throw std::runtime_error(\"Contours do not have normals\");\n  }\n\n  virtual VectorFloatType SampleGradientAtPoint(const PointType&amp; point, int idx) const override {\n    throw std::runtime_error(\"Contours do not have gradients\");\n  }\n\n  virtual GradNType SampleGradNAtPoint(const PointType&amp; p, int idx) const override {\n    throw std::runtime_error(\"Contours do not have gradient of normals\");\n  }\n\n  virtual PointType GetValidLocationNear(PointType p) const override {\n    this-&gt;ApplyConstraints(p, -1);\n    return p;\n  }\n\n  virtual double GetMaxDiameter() const override {\n    // todo copied from MeshDomain: should this not be the length of the bounding box diagonal?\n    const PointType bb = upper_bound_ - lower_bound_;\n    return std::max({bb[0], bb[1], bb[2]});\n  }\n\n  virtual void UpdateZeroCrossingPoint() override {}\n\n  double GetCurvature(const PointType&amp; p, int idx) const override { return GetSurfaceMeanCurvature(); }\n\n  virtual double GetSurfaceMeanCurvature() const override {\n    // This function is used by MeanCurvatureAttribute which is used for good/bad assessment\n    // These arbitrary values should eventually be replaced with actual computation\n    return 0.15;\n  }\n\n  virtual double GetSurfaceStdDevCurvature() const override {\n    // This function is used by MeanCurvatureAttribute which is used for good/bad assessment\n    // These arbitrary values should eventually be replaced with actual computation\n    return 0.02;\n  }\n\n  double Distance(const PointType&amp; a, int idx_a, const PointType&amp; b, int idx_b,\n                  VectorDoubleType* out_grad = nullptr) const override;\n\n  double SquaredDistance(const PointType&amp; a, int idx_a, const PointType&amp; b, int idx_b) const override;\n\n  const PointType&amp; GetLowerBound() const override { return lower_bound_; }\n\n  const PointType&amp; GetUpperBound() const override { return upper_bound_; }\n\n  PointType GetZeroCrossingPoint() const override {\n    PointType out;\n    double dist;\n    int closest_line = GetLineForPoint(upper_bound_.GetDataPointer(), -1, dist, out.GetDataPointer());\n    return out;\n  }\n\n  double GetSurfaceArea() const override { throw std::runtime_error(\"Contours do not have area\"); }\n\n  void DeleteImages() override {\n    // TODO what?\n  }\n  void DeletePartialDerivativeImages() override {\n    // TODO what?\n  }\n\n  void InvalidateParticlePosition(int idx) const override;\n\n  PointType GetPositionAfterSplit(const PointType&amp; pt, const VectorDoubleType&amp; local_direction,\n                                  const VectorDoubleType&amp; global_direction, double epsilon) const override;\n\n private:\n\n  double ComputeLineCoordinate(const double pt[3], int line) const;\n\n  // Return the number of lines that consist of i-th point\n  int NumberOfLinesIncidentOnPoint(int i) const;\n\n  PointType GeodesicWalk(const PointType&amp; start_pt, int idx, const Eigen::Vector3d&amp; update_vec) const;\n\n  int NumberOfLines() const;\n  int NumberOfPoints() const;\n\n  Eigen::Vector3d GetPoint(int id) const;\n\n  PointType lower_bound_, upper_bound_;\n\n  vtkSmartPointer&lt;vtkPolyData&gt; poly_data_;\n  vtkSmartPointer&lt;vtkCellLocator&gt; cell_locator_;\n  std::vector&lt;vtkSmartPointer&lt;vtkLine&gt;&gt; lines_;\n\n  // Geodesics between all point pairs. Assumes the number of points is very small\n  Eigen::MatrixXd geodesics_;\n\n  // cache which line a particle is on\n  mutable std::vector&lt;int&gt; particle_lines_;\n  // store some information about the last geodesic query. The next one will most likely reuse this\n  mutable int geo_lq_idx_ = -1;\n  mutable int geo_lq_line_ = -1;\n  mutable double geo_lq_dist_ = -1;\n\n  double avg_edge_length_{0.0};\n\n  void ComputeBounds();\n  void ComputeGeodesics(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n  void ComputeAvgEdgeLength();\n\n  int GetLineForPoint(const double pt[3], int idx, double&amp; closest_distance, double closest_pt[3]) const;\n\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/CorrespondenceFunction_8h.html","title":"Libs/Optimize/Function/CorrespondenceFunction.h","text":""},{"location":"api/Files/CorrespondenceFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/CorrespondenceFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::CorrespondenceFunction Correspondence term."},{"location":"api/Files/CorrespondenceFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\n#include \"Libs/Optimize/Matrix/ShapeGradientMatrix.h\"\n#include \"Libs/Optimize/Matrix/ShapeMatrix.h\"\n#include \"VectorFunction.h\"\n\nnamespace shapeworks {\n\nclass CorrespondenceFunction : public VectorFunction {\n public:\n  constexpr static int VDimension = 3;\n  constexpr static unsigned int Dimension = VDimension;\n\n  typedef shapeworks::ShapeMatrix ShapeDataType;\n  typedef shapeworks::ShapeGradientMatrix ShapeGradientType;\n\n  typedef ShapeDataType::DataType DataType;\n\n  typedef VectorFunction::VectorType VectorType;\n  typedef ParticleSystem::PointType PointType;\n  typedef vnl_vector&lt;DataType&gt; vnl_vector_type;\n  typedef vnl_matrix&lt;DataType&gt; vnl_matrix_type;\n\n  static std::shared_ptr&lt;CorrespondenceFunction&gt; New() {\n    return std::make_shared&lt;CorrespondenceFunction&gt;();\n  }\n\n  void SetShapeData(ShapeDataType* s) { m_ShapeData = s; }\n  ShapeDataType* GetShapeData() { return m_ShapeData.GetPointer(); }\n  const ShapeDataType* GetShapeData() const { return m_ShapeData.GetPointer(); }\n\n  void SetShapeGradient(ShapeGradientType* s) { m_ShapeGradient = s; }\n  ShapeGradientType* GetShapeGradient() { return m_ShapeGradient.GetPointer(); }\n  const ShapeGradientType* GetShapeGradient() const { return m_ShapeGradient.GetPointer(); }\n\n  virtual VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp;, double&amp;) const;\n\n  virtual VectorType evaluate(unsigned int a, unsigned int b, const ParticleSystem* c, double&amp; d) const {\n    double e;\n    return this-&gt;evaluate(a, b, c, d, e);\n  }\n\n  virtual double energy(unsigned int a, unsigned int b, const ParticleSystem* c) const {\n    double e, d;\n    this-&gt;evaluate(a, b, c, d, e);\n    return e;\n  }\n\n  virtual void before_iteration() { this-&gt;ComputeUpdates(this-&gt;particle_system_); }\n\n  virtual void after_iteration() {\n    // Update the annealing parameter.\n    if (m_HoldMinimumVariance != true &amp;&amp; !m_UseMeanEnergy) {\n      m_Counter++;\n      if (m_Counter &gt;= m_RecomputeCovarianceInterval) {\n        m_Counter = 0;\n        m_MinimumVariance *= m_MinimumVarianceDecayConstant;\n      }\n    }\n  }\n  void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) {\n    m_MinimumVarianceDecayConstant = exp(log(final_value / initial_value) / time_period);\n    m_MinimumVariance = initial_value;\n    m_HoldMinimumVariance = false;\n  }\n\n  void SetMinimumVariance(double d) { m_MinimumVariance = d; }\n  double GetMinimumVariance() const { return m_MinimumVariance; }\n\n  bool GetHoldMinimumVariance() const { return m_HoldMinimumVariance; }\n  void SetHoldMinimumVariance(bool b) { m_HoldMinimumVariance = b; }\n\n  void SetRecomputeCovarianceInterval(int i) { m_RecomputeCovarianceInterval = i; }\n  int GetRecomputeCovarianceInterval() const { return m_RecomputeCovarianceInterval; }\n\n  void SetAttributeScales(const std::vector&lt;double&gt;&amp; s) { m_AttributeScales = s; }\n\n  void SetDomainsPerShape(int i) { m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  void SetAttributesPerDomain(const std::vector&lt;int&gt;&amp; i) { m_AttributesPerDomain = i; }\n\n  void UseMeanenergy() { m_UseMeanEnergy = true; }\n  void UseEntropy() { m_UseMeanEnergy = false; }\n\n  void SetXYZ(int i, bool val) {\n    if (m_UseXYZ.size() != m_DomainsPerShape) m_UseXYZ.resize(m_DomainsPerShape);\n    m_UseXYZ[i] = val;\n  }\n  void SetNormals(int i, bool val) {\n    if (m_UseNormals.size() != m_DomainsPerShape) m_UseNormals.resize(m_DomainsPerShape);\n    m_UseNormals[i] = val;\n  }\n\n  bool CheckForNans(vnl_matrix_type mat) {\n    bool flag = false;\n    for (int i = 0; i &lt; mat.rows(); i++) {\n      for (int j = 0; j &lt; mat.cols(); j++) {\n        if (std::isnan(mat(i, j))) {\n          flag = true;\n          break;\n        }\n      }\n    }\n    return flag;\n  }\n\n  std::shared_ptr&lt;VectorFunction&gt; clone() override {\n    auto copy = CorrespondenceFunction::New();\n\n    // from itkParticleVectorFunction\n    copy-&gt;domain_number_ = this-&gt;domain_number_;\n    copy-&gt;particle_system_ = this-&gt;particle_system_;\n\n    // local\n    copy-&gt;m_AttributeScales = this-&gt;m_AttributeScales;\n    copy-&gt;m_Counter = this-&gt;m_Counter;\n    copy-&gt;m_CurrentEnergy = this-&gt;m_CurrentEnergy;\n    copy-&gt;m_HoldMinimumVariance = this-&gt;m_HoldMinimumVariance;\n    copy-&gt;m_MinimumEigenValue = this-&gt;m_MinimumEigenValue;\n    copy-&gt;m_MinimumVariance = this-&gt;m_MinimumVariance;\n    copy-&gt;m_MinimumVarianceDecayConstant = this-&gt;m_MinimumVarianceDecayConstant;\n    copy-&gt;m_PointsUpdate = this-&gt;m_PointsUpdate;\n    copy-&gt;m_RecomputeCovarianceInterval = this-&gt;m_RecomputeCovarianceInterval;\n    copy-&gt;m_AttributesPerDomain = this-&gt;m_AttributesPerDomain;\n    copy-&gt;m_DomainsPerShape = this-&gt;m_DomainsPerShape;\n    copy-&gt;m_UseMeanEnergy = this-&gt;m_UseMeanEnergy;\n    copy-&gt;m_points_mean = this-&gt;m_points_mean;\n    copy-&gt;m_UseNormals = this-&gt;m_UseNormals;\n    copy-&gt;m_UseXYZ = this-&gt;m_UseXYZ;\n    copy-&gt;m_InverseCovMatrix = this-&gt;m_InverseCovMatrix;\n\n    copy-&gt;m_ShapeData = this-&gt;m_ShapeData;\n    copy-&gt;m_ShapeGradient = this-&gt;m_ShapeGradient;\n\n    return copy;\n  }\n\n  CorrespondenceFunction() {\n    // m_MinimumVarianceBase = 1.0;//exp(log(1.0e-5)/10000.0);\n    m_HoldMinimumVariance = true;\n    m_MinimumVariance = 1.0e-5;\n    m_MinimumEigenValue = 0.0;\n    m_MinimumVarianceDecayConstant = 1.0;  // log(2.0) / 50000.0;\n    m_RecomputeCovarianceInterval = 1;\n    m_Counter = 0;\n    m_UseMeanEnergy = true;\n    m_UseNormals.clear();\n    m_UseXYZ.clear();\n    num_dims = 0;\n    num_samples = 0;\n    m_PointsUpdate = std::make_shared&lt;vnl_matrix_type&gt;(10, 10);\n    m_InverseCovMatrix = std::make_shared&lt;Eigen::MatrixXd&gt;(10, 10);\n    m_points_mean = std::make_shared&lt;vnl_matrix_type&gt;(10, 10);\n  }\n  ~CorrespondenceFunction() override = default;\n\n protected:\n  CorrespondenceFunction(const CorrespondenceFunction&amp;) = delete;\n  CorrespondenceFunction&amp; operator=(const CorrespondenceFunction&amp;) = delete;\n\n  typename ShapeDataType::Pointer m_ShapeData;\n  typename ShapeGradientType::Pointer m_ShapeGradient;\n\n  virtual void ComputeUpdates(const ParticleSystem* c);\n  std::shared_ptr&lt;vnl_matrix_type&gt; m_PointsUpdate;\n\n  double m_MinimumVariance;\n  double m_MinimumEigenValue;\n  //  double m_MinimumVarianceBase;\n  bool m_HoldMinimumVariance;\n  int m_RecomputeCovarianceInterval;\n  double m_MinimumVarianceDecayConstant;\n  int m_Counter;\n  std::vector&lt;double&gt; m_AttributeScales;  // size \\sum_i n_i\n  int m_DomainsPerShape;\n  std::vector&lt;int&gt; m_AttributesPerDomain;  // n\n  double m_CurrentEnergy;\n  bool m_UseMeanEnergy;\n  std::vector&lt;bool&gt; m_UseXYZ;\n  std::vector&lt;bool&gt; m_UseNormals;\n  std::shared_ptr&lt;vnl_matrix_type&gt; m_points_mean;\n  std::shared_ptr&lt;Eigen::MatrixXd&gt; m_InverseCovMatrix;\n  int num_dims, num_samples;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/CorrespondenceMode_8h.html","title":"Libs/Optimize/CorrespondenceMode.h","text":""},{"location":"api/Files/CorrespondenceMode_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/CorrespondenceMode_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace shapeworks {\n\n  enum class CorrespondenceMode : int {\n    MeanEnergy = 0,\n    EnsembleEntropy = 1,\n    EnsembleRegressionEntropy = 3,\n    EnsembleMixedEffectsEntropy = 4,\n    MeshBasedGeneralEntropy = 5,\n    MeshBasedGeneralMeanEnergy = 6,\n    DisentagledEnsembleEntropy = 7,\n    DisentangledEnsembleMeanEnergy = 8\n  };\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/CustomSlider_8h.html","title":"Studio/Interface/CustomSlider.h","text":""},{"location":"api/Files/CustomSlider_8h.html#classes","title":"Classes","text":"Name class CustomSlider"},{"location":"api/Files/CustomSlider_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QSlider&gt;\n\n// adapted from:\n// https://stackoverflow.com/questions/69890284/qslider-in-qt-misbehaves-in-new-macos-monterey-v12-0-1-any-workaround/69890285#69890285\nclass CustomSlider : public QSlider {\n public:\n  explicit CustomSlider(Qt::Orientation orientation, QWidget* parent = nullptr) : QSlider(orientation, parent){};\n  explicit CustomSlider(QWidget* parent = nullptr);\n\n protected:\n  virtual void paintEvent(QPaintEvent* ev);\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/CustomSurfaceReconstructionFilter_8h.html","title":"Libs/Analyze/CustomSurfaceReconstructionFilter.h","text":""},{"location":"api/Files/CustomSurfaceReconstructionFilter_8h.html#classes","title":"Classes","text":"Name class CustomSurfaceReconstructionFilter"},{"location":"api/Files/CustomSurfaceReconstructionFilter_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    CustomSurfaceReconstructionFilter.h\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// .NAME CustomSurfaceReconstructionFilter - reconstructs a surface from unorganized points\n// .SECTION Description\n// CustomSurfaceReconstructionFilter takes a list of points assumed to lie on\n// the surface of a solid 3D object. A signed measure of the distance to the\n// surface is computed and sampled on a regular grid. The grid can then be\n// contoured at zero to extract the surface. The default values for\n// neighborhood size and sample spacing should give reasonable results for\n// most uses but can be set if desired. This procedure is based on the PhD\n// work of Hugues Hoppe: http://www.research.microsoft.com/~hoppe\n\n#ifndef __CustomSurfaceReconstructionFilter_h\n#define __CustomSurfaceReconstructionFilter_h\n\n#include \"vtkImageAlgorithm.h\"\n\nclass CustomSurfaceReconstructionFilter : public vtkImageAlgorithm\n{\npublic:\n  vtkTypeMacro(CustomSurfaceReconstructionFilter,vtkImageAlgorithm);\n  void PrintSelf(ostream&amp; os, vtkIndent indent);\n\n  // Description:\n  // Construct with NeighborhoodSize=20.\n  static CustomSurfaceReconstructionFilter* New();\n\n  // Description: \n  // Specify the number of neighbors each point has, used for estimating the\n  // local surface orientation.  The default value of 20 should be OK for\n  // most applications, higher values can be specified if the spread of\n  // points is uneven. Values as low as 10 may yield adequate results for\n  // some surfaces. Higher values cause the algorithm to take longer. Higher\n  // values will cause errors on sharp boundaries.\n  vtkGetMacro(NeighborhoodSize,int);\n  vtkSetMacro(NeighborhoodSize,int);\n\n  // Description: \n  // Specify the spacing of the 3D sampling grid. If not set, a\n  // reasonable guess will be made.\n  vtkGetMacro(SampleSpacing,double);\n  vtkSetMacro(SampleSpacing,double);\n\nprotected:\n  CustomSurfaceReconstructionFilter();\n  ~CustomSurfaceReconstructionFilter() {};\n\n  virtual int RequestInformation (vtkInformation *, \n                                  vtkInformationVector **, \n                                  vtkInformationVector *);\n  virtual int RequestData (vtkInformation *, \n                           vtkInformationVector **, \n                           vtkInformationVector *);\n\n  int NeighborhoodSize;\n  double SampleSpacing;\n\n  virtual int FillInputPortInformation(int, vtkInformation*);\n\nprivate:\n  CustomSurfaceReconstructionFilter(const CustomSurfaceReconstructionFilter&amp;);  // Not implemented.\n  void operator=(const CustomSurfaceReconstructionFilter&amp;);  // Not implemented.\n};\n\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/DataTool_8h.html","title":"Studio/Data/DataTool.h","text":""},{"location":"api/Files/DataTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DataTool_8h.html#classes","title":"Classes","text":"Name class shapeworks::DataTool"},{"location":"api/Files/DataTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n\n#include &lt;QElapsedTimer&gt;\n#include &lt;QObject&gt;\n#include &lt;QProgressDialog&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nclass Ui_DataTool;\nclass QComboBox;\n\nnamespace shapeworks {\n\nclass SegmentationToolPanel;\nclass Session;\nclass LandmarkTableModel;\n\nclass DataTool : public QWidget {\n  Q_OBJECT;\n\n public:\n  DataTool(Preferences&amp; prefs);\n  ~DataTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void activate();\n\n  void disable_actions();\n\n  void enable_actions();\n\n  void update_table(bool clean = true);\n\n  void update_landmark_table();\n\n  void landmark_domain_changed();\n\n  void constraints_domain_changed();\n\n  void delete_planes_clicked();\n\n  void delete_ffc_clicked();\n\n  void update_notes();\n\n  std::string get_notes();\n\n  void store_data();\n\n public Q_SLOTS:\n\n  void delete_button_clicked();\n\n  void delete_landmarks_clicked();\n\n  void set_placing_button_clicked(int id);\n\n  void handle_landmark_mode_changed();\n  void handle_constraints_mode_changed();\n\n  void constraints_table_right_click(const QPoint&amp; point);\n  void data_table_right_click(const QPoint&amp; point);\n  void copy_ffc_clicked();\n\n  void table_selection_changed();\n  void subject_notes_changed();\n  void table_data_edited();\n\n Q_SIGNALS:\n  void import_button_clicked();\n\n private:\n  void update_plane_table();\n  void update_ffc_table();\n\n  Preferences&amp; preferences_;\n\n  Ui_DataTool* ui_;\n  SegmentationToolPanel* segmentation_tool_panel_;\n  QSharedPointer&lt;Session&gt; session_;\n\n  std::shared_ptr&lt;LandmarkTableModel&gt; landmark_table_model_;\n\n  bool block_table_update_{false};\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/DeepSSMJob_8h.html","title":"Libs/Application/DeepSSM/DeepSSMJob.h","text":""},{"location":"api/Files/DeepSSMJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DeepSSMJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::DeepSSMJob Qt Wrapper for DeepSSM."},{"location":"api/Files/DeepSSMJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;mutex&gt;\n#include &lt;Job/Job.h&gt;\n#include &lt;Project/Project.h&gt;\n\n#include &lt;QObject&gt;\n\nnamespace shapeworks {\n\n\nclass DeepSSMJob : public Job {\n  Q_OBJECT;\n\n public:\n  enum class JobType {\n    DeepSSM_PrepType = 0,\n    DeepSSM_AugmentationType = 1,\n    DeepSSM_TrainingType = 2,\n    DeepSSM_TestingType = 3\n  };\n\n  enum PrepStep {\n    NOT_STARTED = 0,\n    GROOM_TRAINING = 1,\n    OPTIMIZE_TRAINING = 2,\n    OPTIMIZE_VALIDATION = 3,\n    GROOM_IMAGES = 4,\n    DONE = 5\n  };\n\n  enum class SplitType { TRAIN, VAL, TEST };\n\n  DeepSSMJob(std::shared_ptr&lt;Project&gt; project, DeepSSMJob::JobType tool_mode,\n             DeepSSMJob::PrepStep prep_step = DeepSSMJob::NOT_STARTED);\n  ~DeepSSMJob();\n\n  void run() override;\n\n  QString name() override;\n\n  void run_prep();\n  void run_augmentation();\n  void run_training();\n  void run_testing();\n\n  void python_message(std::string str);\n\n  static std::vector&lt;int&gt; get_split(ProjectHandle project, DeepSSMJob::SplitType split_type);\n\n  void set_num_dataloader_workers(int num_workers);\n  int get_num_dataloader_workers();\n\n  void set_prep_step(DeepSSMJob::PrepStep step) {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    prep_step_ = step;\n  }\n\n private:\n  void update_prep_stage(DeepSSMJob::PrepStep step);\n  void process_test_results();\n\n  std::shared_ptr&lt;Project&gt; project_;\n\n  DeepSSMJob::JobType job_type_;\n\n  QString prep_message_;\n  DeepSSMJob::PrepStep prep_step_{DeepSSMJob::NOT_STARTED};\n\n  int num_dataloader_workers_{0};\n\n  // mutex\n  std::mutex mutex_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/DeepSSMParameters_8h.html","title":"Libs/Project/DeepSSMParameters.h","text":""},{"location":"api/Files/DeepSSMParameters_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DeepSSMParameters_8h.html#classes","title":"Classes","text":"Name class shapeworks::DeepSSMParameters"},{"location":"api/Files/DeepSSMParameters_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Project/Project.h&gt;\n\nnamespace shapeworks {\n\nclass DeepSSMParameters {\n  enum class SamplerTypeOption { gaussian, gaussian_mixture, kde };\n\n public:\n  explicit DeepSSMParameters(ProjectHandle project);\n  void save_to_project();\n\n  int get_aug_num_samples();\n  void set_aug_num_samples(int num_samples);\n\n  int get_aug_num_dims();\n  void set_aug_num_dims(int num_dims);\n\n  int get_training_num_dims();\n  void set_training_num_dims(int num_dims);\n\n  double get_aug_percent_variability();\n  void set_aug_percent_variability(double percent_variability);\n\n  std::string get_aug_sampler_type();\n  void set_aug_sampler_type(std::string sampler_type);\n\n  int get_training_epochs();\n  void set_training_epochs(int epochs);\n\n  double get_training_learning_rate();\n  void set_training_learning_rate(double rate);\n\n  bool get_training_decay_learning_rate();\n  void set_training_decay_learning_rate(bool decay);\n\n  bool get_training_fine_tuning();\n  void set_training_fine_tuning(bool fine_tuning);\n\n  int get_training_fine_tuning_epochs();\n  void set_training_fine_tuning_epochs(int epochs);\n\n  double get_training_fine_tuning_learning_rate();\n  void set_training_fine_tuning_learning_rate(double rate);\n\n  int get_training_batch_size();\n  void set_training_batch_size(int batch_size);\n\n  double get_training_split();\n  void set_training_split(double value);\n\n  double get_validation_split();\n  void set_validation_split(double value);\n\n  double get_testing_split();\n  void set_testing_split(double value);\n\n  bool get_prep_step_complete();\n  void set_prep_step_complete(bool value);\n\n  int get_prep_stage();\n  void set_prep_stage(int stage);\n\n  bool get_aug_step_complete();\n  void set_aug_step_complete(bool value);\n\n  std::string get_aug_message();\n  void set_aug_message(std::string message);\n\n  bool get_training_step_complete();\n  void set_training_step_complete(bool value);\n\n  std::string get_training_message();\n  void set_training_message(std::string message);\n\n  std::vector&lt;double&gt; get_spacing();\n  void set_spacing(std::vector&lt;double&gt; spacing);\n\n  std::string get_loss_function();\n  void set_loss_function(std::string loss_function);\n\n  bool get_tl_net_enabled();\n  void set_tl_net_enabled(bool enabled);\n\n  int get_tl_net_ae_epochs();\n  void set_tl_net_ae_epochs(int num_epochs);\n\n  int get_tl_net_tf_epochs();\n  void set_tl_net_tf_epochs(int num_epochs);\n\n  int get_tl_net_joint_epochs();\n  void set_tl_net_joint_epochs(int num_epochs);\n\n  double get_tl_net_alpha();\n  void set_tl_net_alpha(double alpha);\n\n  double get_tl_net_a_ae();\n  void set_tl_net_a_ae(double a_ae);\n\n  double get_tl_net_c_ae();\n  void set_tl_net_c_ae(double c_ae);\n\n  double get_tl_net_a_lat();\n  void set_tl_net_a_lat(double a_lat);\n\n  double get_tl_net_c_lat();\n  void set_tl_net_c_lat(double c_lat);\n\n  void restore_split_defaults();\n  void restore_augmentation_defaults();\n  void restore_training_defaults();\n\n  void restore_defaults();\n\n  // constants\n  const static std::string DEEPSSM_SAMPLER_GAUSSIAN_C;\n  const static std::string DEEPSSM_SAMPLER_MIXTURE_C;\n  const static std::string DEEPSSM_SAMPLER_KDE_C;\n\n private:\n  Parameters params_;\n  ProjectHandle project_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/DeepSSMTool_8h.html","title":"Studio/DeepSSM/DeepSSMTool.h","text":""},{"location":"api/Files/DeepSSMTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DeepSSMTool_8h.html#classes","title":"Classes","text":"Name class shapeworks::DeepSSMTool"},{"location":"api/Files/DeepSSMTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// qt\n#include &lt;QElapsedTimer&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\n#include &lt;DeepSSM/DeepSSMJob.h&gt;\n\n// studio\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Project.h&gt;\n#include &lt;Shape.h&gt;\n\nclass Ui_DeepSSMTool;\nclass QLabel;\nclass QTableWidget;\nclass QLineEdit;\n\nnamespace shapeworks {\n\nclass Session;\nclass Lightbox;\nclass DeepSSMJob;\nclass ShapeWorksStudioApp;\n\nclass DeepSSMTool : public QWidget {\n  Q_OBJECT;\n\n public:\n\n  DeepSSMTool(Preferences&amp; prefs);\n  ~DeepSSMTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void set_app(ShapeWorksStudioApp* app);\n\n  bool is_active();\n\n  void load_params();\n  void store_params();\n\n  void shutdown();\n\n  ShapeList get_shapes();\n\n  void resizeEvent(QResizeEvent* event) override;\n\n  std::string get_display_feature();\n\n\n public Q_SLOTS:\n\n  void run_clicked();\n  void run_prep_clicked(int step);\n  void restore_defaults();\n\n  void handle_thread_complete();\n\n  void handle_progress(int val, QString message);\n  void handle_error(QString msg);\n\n  void tab_changed(int tab);\n\n  void update_panels();\n  void update_split();\n\n  void handle_new_mesh();\n\n  void training_fine_tuning_changed();\n\n Q_SIGNALS:\n\n  void update_view();\n  void progress(int);\n\n private:\n  void update_meshes();\n  void run_tool(DeepSSMJob::JobType type);\n  void show_augmentation_meshes();\n  void update_tables();\n  void show_training_meshes();\n  void show_testing_meshes();\n  void update_testing_meshes();\n  void load_plots();\n  void resize_plots();\n\n  std::string get_feature_name();\n  void set_subject_image_filename(const std::shared_ptr&lt;Subject&gt;&amp; subject, const std::string&amp; filename);\n\n  QPixmap load_plot(QString filename);\n  void set_plot(QLabel* qlabel, QPixmap pixmap);\n\n  void populate_table_from_csv(QTableWidget* table, QString filename, bool header);\n\n  QStringList read_images_from_csv(QString filename);\n\n  Preferences&amp; preferences_;\n\n  Ui_DeepSSMTool* ui_;\n  QSharedPointer&lt;Session&gt; session_;\n  ShapeWorksStudioApp* app_;\n  DeepSSMJob::PrepStep prep_step_ = DeepSSMJob::PrepStep::NOT_STARTED;\n\n  bool tool_is_running_ = false;\n  DeepSSMJob::JobType current_tool_ = DeepSSMJob::JobType::DeepSSM_AugmentationType;\n  QSharedPointer&lt;DeepSSMJob&gt; deep_ssm_;\n  QElapsedTimer timer_;\n\n  ShapeList shapes_;\n  QPixmap violin_plot_;\n  QPixmap training_plot_;\n  QPixmap training_plot_ft_;\n  // training plots for TL mode\n  QPixmap training_plot_tl1_;\n  QPixmap training_plot_tl2_;\n  QPixmap training_plot_tl3_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/DisentangledCorrespondenceFunction_8h.html","title":"Libs/Optimize/Function/DisentangledCorrespondenceFunction.h","text":""},{"location":"api/Files/DisentangledCorrespondenceFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DisentangledCorrespondenceFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::DisentangledCorrespondenceFunction"},{"location":"api/Files/DisentangledCorrespondenceFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;vector&gt;\n#include \"DisentangledCorrespondenceFunction.h\"\n#include \"Libs/Optimize/Matrix/LegacyShapeMatrix.h\"\n#include \"VectorFunction.h\"\n\nnamespace shapeworks {\n\nclass DisentangledCorrespondenceFunction : public VectorFunction {\n public:\n  constexpr static unsigned int VDimension = 3;\n  constexpr static unsigned int Dimension = VDimension;\n\n  typedef LegacyShapeMatrix ShapeMatrixType;\n\n  typedef typename ShapeMatrixType::DataType DataType;\n\n  typedef VectorFunction::VectorType VectorType;\n  typedef ParticleSystem::PointType PointType;\n  typedef vnl_vector&lt;DataType&gt; vnl_vector_type;\n  typedef vnl_matrix&lt;DataType&gt; vnl_matrix_type;\n  typedef std::shared_ptr&lt;std::vector&lt;vnl_matrix_type&gt;&gt; shared_vnl_matrix_array_type;\n\n  static std::shared_ptr&lt;DisentangledCorrespondenceFunction&gt; New() {\n    return std::make_shared&lt;DisentangledCorrespondenceFunction&gt;();\n  }\n\n  virtual VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp;, double&amp;) const;\n  virtual VectorType evaluate(unsigned int a, unsigned int b, const ParticleSystem* c, double&amp; d) const {\n    double e;\n    return this-&gt;evaluate(a, b, c, d, e);\n  }\n\n  virtual double energy(unsigned int a, unsigned int b, const ParticleSystem* c) const {\n    double e, d;\n    this-&gt;evaluate(a, b, c, d, e);\n    return e;\n  }\n\n  void WriteModes(const std::string&amp;, int) const;\n\n  void SetShapeMatrix(ShapeMatrixType* s) { m_ShapeMatrix = s; }\n  ShapeMatrixType* GetShapeMatrix() { return m_ShapeMatrix.GetPointer(); }\n  const ShapeMatrixType* GetShapeMatrix() const { return m_ShapeMatrix.GetPointer(); }\n\n  virtual void before_iteration() {\n    m_ShapeMatrix-&gt;before_iteration();\n\n    if (m_Counter == 0) {\n      this-&gt;ComputeCovarianceMatrices();\n    }\n  }\n\n  virtual void after_iteration() override {\n    m_ShapeMatrix-&gt;after_iteration();\n    // Update the annealing parameter.\n    if (m_HoldMinimumVariance != true &amp;&amp; !m_UseMeanEnergy) {\n      m_Counter++;\n      if (m_Counter &gt;= m_RecomputeCovarianceInterval) {\n        m_Counter = 0;\n        m_MinimumVariance *= m_MinimumVarianceDecayConstant;\n      }\n    }\n  }\n\n  void SetMinimumVariance(double d) { m_MinimumVariance = d; }\n  double GetMinimumVariance() const { return m_MinimumVariance; }\n\n  void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) {\n    m_MinimumVarianceDecayConstant = exp(log(final_value / initial_value) / time_period);\n    m_MinimumVariance = initial_value;\n    m_HoldMinimumVariance = false;\n  }\n  bool GetMinimumVarianceDecayConstant() const { return m_MinimumVarianceDecayConstant; }\n\n  void PrintShapeMatrix() { m_ShapeMatrix-&gt;PrintMatrix(); }\n\n  void UseMeanenergy() { m_UseMeanEnergy = true; }\n  void UseEntropy() { m_UseMeanEnergy = false; }\n\n  bool GetHoldMinimumVariance() const { return m_HoldMinimumVariance; }\n  void SetHoldMinimumVariance(bool b) { m_HoldMinimumVariance = b; }\n\n  void SetRecomputeCovarianceInterval(int i) { m_RecomputeCovarianceInterval = i; }\n  int GetRecomputeCovarianceInterval() const { return m_RecomputeCovarianceInterval; }\n\n  std::shared_ptr&lt;VectorFunction&gt; clone() override {\n    auto copy = DisentangledCorrespondenceFunction::New();\n\n    copy-&gt;m_Shape_PointsUpdate = this-&gt;m_Shape_PointsUpdate;\n    copy-&gt;m_Time_PointsUpdate = this-&gt;m_Time_PointsUpdate;\n    copy-&gt;m_MinimumVariance = this-&gt;m_MinimumVariance;\n    copy-&gt;m_MinimumEigenValue_shape_cohort = this-&gt;m_MinimumEigenValue_shape_cohort;\n    copy-&gt;m_MinimumEigenValue_time_cohort = this-&gt;m_MinimumEigenValue_time_cohort;\n\n    copy-&gt;m_CurrentEnergy = this-&gt;m_CurrentEnergy;\n    copy-&gt;m_HoldMinimumVariance = this-&gt;m_HoldMinimumVariance;\n    copy-&gt;m_MinimumVarianceDecayConstant = this-&gt;m_MinimumVarianceDecayConstant;\n    copy-&gt;m_RecomputeCovarianceInterval = this-&gt;m_RecomputeCovarianceInterval;\n    copy-&gt;m_Counter = m_Counter;\n\n    copy-&gt;domain_number_ = this-&gt;domain_number_;\n    copy-&gt;particle_system_ = this-&gt;particle_system_;\n    copy-&gt;m_ShapeMatrix = this-&gt;m_ShapeMatrix;\n\n\n    copy-&gt;m_InverseCovMatrices_time_cohort = this-&gt;m_InverseCovMatrices_time_cohort;\n    copy-&gt;m_InverseCovMatrices_shape_cohort = this-&gt;m_InverseCovMatrices_shape_cohort;\n\n    copy-&gt;m_points_mean_time_cohort = this-&gt;m_points_mean_time_cohort;\n    copy-&gt;m_points_mean_shape_cohort = this-&gt;m_points_mean_shape_cohort;\n\n    return copy;\n  }\n\n  DisentangledCorrespondenceFunction() {\n    // m_MinimumVarianceBase = 1.0;//exp(log(1.0e-5)/10000.0);\n    m_HoldMinimumVariance = true;\n    m_MinimumVariance = 1.0e-5;\n    m_MinimumEigenValue = 0.0;\n    m_MinimumVarianceDecayConstant = 1.0;  // log(2.0) / 50000.0;\n    m_RecomputeCovarianceInterval = 1;\n    m_Counter = 0;\n    m_UseMeanEnergy = true;\n    m_InverseCovMatrices_time_cohort = std::make_shared&lt;std::vector&lt;Eigen::MatrixXd&gt;&gt;();\n    m_InverseCovMatrices_shape_cohort = std::make_shared&lt;std::vector&lt;Eigen::MatrixXd&gt;&gt;();\n    m_points_mean_time_cohort = std::make_shared&lt;std::vector&lt;vnl_matrix_type&gt;&gt;();\n    m_points_mean_shape_cohort = std::make_shared&lt;std::vector&lt;vnl_matrix_type&gt;&gt;();\n    m_Time_PointsUpdate = std::make_shared&lt;std::vector&lt;vnl_matrix_type&gt;&gt;();\n    m_Shape_PointsUpdate = std::make_shared&lt;std::vector&lt;vnl_matrix_type&gt;&gt;();\n  }\n  ~DisentangledCorrespondenceFunction() override = default;\n\n protected:\n  DisentangledCorrespondenceFunction(const DisentangledCorrespondenceFunction&amp;) = delete;\n  DisentangledCorrespondenceFunction&amp; operator=(const DisentangledCorrespondenceFunction&amp;) = delete;\n  typename ShapeMatrixType::Pointer m_ShapeMatrix;\n\n  // Computes Covariance Matrices across time and shape domain and then generate gradient updates for them.\n  virtual void ComputeCovarianceMatrices();\n\n  // Initialize size and clear relevant variables from previous iteration, before gradient updates computation.\n  void Initialize(){\n    const unsigned int total_time_points = m_ShapeMatrix-&gt;GetDomainsPerShape();\n    int total_subjects = m_ShapeMatrix-&gt;cols();\n    m_points_mean_time_cohort-&gt;clear();\n    m_points_mean_shape_cohort-&gt;clear();\n    m_InverseCovMatrices_time_cohort-&gt;clear();\n    m_InverseCovMatrices_shape_cohort-&gt;clear();\n    m_Shape_PointsUpdate-&gt;clear();\n    m_Time_PointsUpdate-&gt;clear();\n    m_MinimumEigenValue_shape_cohort.resize(total_subjects, 0.0);\n    m_MinimumEigenValue_time_cohort.resize(total_time_points, 0.0);\n    for(int i = 0; i &lt; total_time_points; ++i){\n      Eigen::MatrixXd temp_cov_matrix;\n      vnl_matrix_type temp_points_matrix;\n      vnl_matrix_type temp_mean_matrix;\n      m_InverseCovMatrices_time_cohort-&gt;push_back(temp_cov_matrix);\n      m_points_mean_time_cohort-&gt;push_back(temp_mean_matrix);\n      m_Time_PointsUpdate-&gt;push_back(temp_points_matrix);\n    }\n    for(int i = 0; i &lt; total_subjects; ++i){\n      Eigen::MatrixXd temp_cov_matrix;\n      vnl_matrix_type temp_points_matrix;\n      vnl_matrix_type temp_mean_matrix;\n      m_InverseCovMatrices_shape_cohort-&gt;push_back(temp_cov_matrix);\n      m_points_mean_shape_cohort-&gt;push_back(temp_mean_matrix);\n      m_Shape_PointsUpdate-&gt;push_back(temp_points_matrix);\n    }\n  }\n\n  double m_MinimumVariance;\n  double m_MinimumEigenValue;\n  std::vector&lt;double&gt; m_MinimumEigenValue_time_cohort;\n  std::vector&lt;double&gt; m_MinimumEigenValue_shape_cohort;\n  double m_CurrentEnergy;\n  bool m_HoldMinimumVariance;\n  double m_MinimumVarianceDecayConstant;\n  int m_RecomputeCovarianceInterval;\n  int m_Counter;\n  bool m_UseMeanEnergy;\n\n  // Inverse Covariance matrices across time and shape cohort\n  std::shared_ptr&lt;std::vector&lt;Eigen::MatrixXd&gt;&gt; m_InverseCovMatrices_time_cohort; // T obj matrices each of dimensionality dM X N\n  std::shared_ptr&lt;std::vector&lt;Eigen::MatrixXd&gt;&gt; m_InverseCovMatrices_shape_cohort; // N obj matrices each of dimensionality dM X T\n  // mean vectors across time and shape cohort\n  shared_vnl_matrix_array_type m_points_mean_time_cohort; // T mean vectors each of dimension dM\n  shared_vnl_matrix_array_type m_points_mean_shape_cohort; // N mean vectors each of dimension dM\n  // Matrices for Gradient Updates across time and shape cohort\n  shared_vnl_matrix_array_type m_Time_PointsUpdate; // T update matrices each of dimensionality dM X N\n  shared_vnl_matrix_array_type m_Shape_PointsUpdate; // N update matrices each of dimensionality dM X T\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/DomainType_8h.html","title":"Libs/Optimize/Domain/DomainType.h","text":""},{"location":"api/Files/DomainType_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DomainType_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace shapeworks {\nenum class DomainType { Image, Mesh, Contour };\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/DualVectorFunction_8h.html","title":"Libs/Optimize/Function/DualVectorFunction.h","text":""},{"location":"api/Files/DualVectorFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/DualVectorFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::DualVectorFunction"},{"location":"api/Files/DualVectorFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ParticleSystemEvaluation.h\"\n#include \"itkLightObject.h\"\n#include \"itkObjectFactory.h\"\n#include \"itkWeakPointer.h\"\n#include \"vnl/vnl_vector_fixed.h\"\n\nnamespace shapeworks {\n\nclass DualVectorFunction : public VectorFunction {\n public:\n  constexpr static int VDimension = 3;\n  constexpr static unsigned int Dimension = VDimension;\n\n  using VectorType = VectorFunction::VectorType;\n\n  static std::shared_ptr&lt;DualVectorFunction&gt; New() { return std::make_shared&lt;DualVectorFunction&gt;(); }\n\n  VectorType evaluate(unsigned int idx, unsigned int d, const ParticleSystem* system, double&amp; maxmove) const override {\n    double maxA = 0;\n    double maxB = 0;\n    VectorType ansA;\n    ansA.fill(0.0);\n    VectorType ansB;\n    ansB.fill(0.0);\n\n    const_cast&lt;DualVectorFunction*&gt;(this)-&gt;counter_ = counter_ + 1.0;\n\n    // evaluate individual functions: A = surface energy, B = correspondence\n    if (a_on_) {\n      ansA = function_a_-&gt;evaluate(idx, d, system, maxA);\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_grad_mag_a_ = average_grad_mag_a_ + ansA.magnitude();\n    }\n\n    if (b_on_) {\n      ansB = function_b_-&gt;evaluate(idx, d, system, maxB);\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_grad_mag_b_ = average_grad_mag_b_ + ansB.magnitude();\n    }\n\n    if (relative_gradient_scaling_ == 0.0) {\n      ansB.fill(0.0);\n      maxB = 0.0;\n    }\n\n    // get maxmove and predicted move for current configuration\n    VectorType predictedMove;\n    predictedMove.fill(0.0);\n\n    // both A and B are active\n    if (a_on_ &amp;&amp; b_on_) {\n      maxmove = maxA;  // always driven by the sampling to decrease the sensitivity to covariance regularization\n      predictedMove = ansA + relative_gradient_scaling_ * ansB;\n      return predictedMove;\n    }\n\n    // B is active, A is not active\n    if (b_on_) {\n      maxmove = maxB;\n      predictedMove = ansB;\n      return predictedMove;\n    }\n\n    // else only A is active (or if both are off, 0 will be return)\n    maxmove = maxA;\n    return ansA;\n  }\n\n  double EnergyA(unsigned int idx, unsigned int d, const ParticleSystem* system) const {\n    function_a_-&gt;before_evaluate(idx, d, system);\n    double ansA = 0.0;\n    if (a_on_) {\n      ansA = function_a_-&gt;energy(idx, d, system);\n    }\n    return ansA;\n  }\n\n  virtual double EnergyB(unsigned int idx, unsigned int d, const ParticleSystem* system) const {\n    function_b_-&gt;before_evaluate(idx, d, system);\n    double ansB = 0.0;\n    if (b_on_ == true) {\n      ansB = function_b_-&gt;energy(idx, d, system);\n    }\n    ansB *= relative_energy_scaling_;\n    return ansB;\n  }\n\n  virtual double energy(unsigned int idx, unsigned int d, const ParticleSystem* system) const {\n    double ansA = 0.0;\n    double ansB = 0.0;\n    double ansC = 0.0;\n    double finalEnergy = 0.0;\n\n    // evaluate individual functions: A = surface energy, B = correspondence\n    if (a_on_ == true) {\n      ansA = function_a_-&gt;energy(idx, d, system);\n    }\n\n    if (b_on_ == true) {\n      ansB = function_b_-&gt;energy(idx, d, system);\n    }\n\n    if (relative_energy_scaling_ == 0) {\n      ansB = 0.0;\n    }\n\n    // compute final energy for current configuration\n    if (b_on_ == true) {\n      if (a_on_ == true)  // both A and B are active\n      {\n        finalEnergy = ansA + relative_energy_scaling_ * ansB;\n        return (finalEnergy);\n      } else  // B is active, A is not active\n      {\n        finalEnergy = ansB;\n        return finalEnergy;\n      }\n    } else  // only A is active\n    {\n      return ansA;\n    }\n\n    return 0.0;\n  }\n\n  virtual VectorType evaluate(unsigned int idx, unsigned int d, const ParticleSystem* system, double&amp; maxmove,\n                              double&amp; energy) const {\n    double maxA = 0.0;\n    double maxB = 0.0;\n    double energyA = 0.0;\n    double energyB = 0.0;\n    VectorType ansA;\n    ansA.fill(0.0);\n    VectorType ansB;\n    ansB.fill(0.0);\n\n    const_cast&lt;DualVectorFunction*&gt;(this)-&gt;counter_ = counter_ + 1.0;\n\n    // evaluate individual functions: A = surface energy, B = correspondence\n    if (a_on_ == true) {\n      ansA = function_a_-&gt;evaluate(idx, d, system, maxA, energyA);\n\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_grad_mag_a_ = average_grad_mag_a_ + ansA.magnitude();\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_energy_a_ = average_energy_a_ + energyA;\n    }\n\n    if (b_on_ == true) {\n      ansB = function_b_-&gt;evaluate(idx, d, system, maxB, energyB);\n\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_grad_mag_b_ = average_grad_mag_b_ + ansB.magnitude();\n      const_cast&lt;DualVectorFunction*&gt;(this)-&gt;average_energy_b_ = average_energy_b_ + energyB;\n    }\n\n    if (relative_energy_scaling_ == 0.0) {\n      energyB = 0.0;\n      ansB.fill(0.0);\n    }\n\n    if (relative_gradient_scaling_ == 0.0) {\n      maxB = 0.0;\n      ansB.fill(0.0);\n    }\n\n    // compute final energy, maxmove and predicted move based on current configuration\n    VectorType predictedMove;\n    predictedMove.fill(0.0);\n    if (b_on_ == true) {\n      if (a_on_ == true)  // both A and B are active\n      {\n        if (maxB &gt; maxA) {\n          maxmove = maxB;\n        } else {\n          maxmove = maxA;\n        }\n\n        energy = energyA + relative_energy_scaling_ * energyB;\n\n        maxmove = maxA;  // always driven by the sampling to decrease the senstivity to covariance regularization\n\n        predictedMove = ansA + relative_gradient_scaling_ * ansB;\n\n        return (predictedMove);\n      } else  // only B is active, A is not active\n      {\n        maxmove = maxB;\n        energy = energyB;\n        predictedMove = ansB;\n\n        return (predictedMove);\n      }\n    } else  // only A is active\n    {\n      maxmove = maxA;\n      energy = energyA;\n      return ansA;\n    }\n    maxmove = 0.0;\n    return ansA;\n  }\n\n  virtual void before_evaluate(unsigned int idx, unsigned int d, const ParticleSystem* system) {\n    if (a_on_ == true) {\n      function_a_-&gt;before_evaluate(idx, d, system);\n    }\n\n    if (b_on_ == true) {\n      function_b_-&gt;before_evaluate(idx, d, system);\n    }\n  }\n\n  void after_iteration() override {\n    if (a_on_) {\n      function_a_-&gt;after_iteration();\n    }\n    if (b_on_) {\n      function_b_-&gt;after_iteration();\n    }\n  }\n\n  void before_iteration() override {\n    if (a_on_) {\n      function_a_-&gt;before_iteration();\n    }\n    if (b_on_) {\n      function_b_-&gt;before_iteration();\n    }\n    average_grad_mag_a_ = 0.0;\n    average_grad_mag_b_ = 0.0;\n    average_energy_a_ = 0.0;\n    counter_ = 0.0;\n  }\n\n  void set_particle_system(ParticleSystem* p) override {\n    VectorFunction::set_particle_system(p);\n    if (function_a_ != nullptr) {\n      function_a_-&gt;set_particle_system(p);\n    }\n    if (function_b_ != nullptr) {\n      function_b_-&gt;set_particle_system(p);\n    }\n  }\n\n  void set_domain_number(unsigned int i) override {\n    VectorFunction::set_domain_number(i);\n    if (function_a_ != nullptr) {\n      function_a_-&gt;set_domain_number(i);\n    }\n    if (function_b_ != nullptr) {\n      function_b_-&gt;set_domain_number(i);\n    }\n  }\n\n  void set_function_a(std::shared_ptr&lt;VectorFunction&gt; o) {\n    function_a_ = o;\n    function_a_-&gt;set_domain_number(this-&gt;get_domain_number());\n    function_a_-&gt;set_particle_system(this-&gt;get_particle_system());\n  }\n\n  std::shared_ptr&lt;VectorFunction&gt; get_function_a() { return function_a_; }\n\n  std::shared_ptr&lt;VectorFunction&gt; get_function_b() { return function_b_; }\n\n  void set_function_b(std::shared_ptr&lt;VectorFunction&gt; o) {\n    function_b_ = o;\n    function_b_-&gt;set_domain_number(this-&gt;get_domain_number());\n    function_b_-&gt;set_particle_system(this-&gt;get_particle_system());\n  }\n\n  void set_a_on() { a_on_ = true; }\n  void set_a_off() { a_on_ = false; }\n  void set_a_on(bool s) { a_on_ = s; }\n  bool get_a_on() const { return a_on_; }\n  void set_b_on() { b_on_ = true; }\n  void set_b_off() { b_on_ = false; }\n  void set_b_on(bool s) { b_on_ = s; }\n  bool get_b_on() const { return b_on_; }\n\n  void set_relative_energy_scaling(double r) override { relative_energy_scaling_ = r; }\n  double get_relative_energy_scaling() const override { return relative_energy_scaling_; }\n\n  void set_relative_gradient_scaling(double r) { relative_gradient_scaling_ = r; }\n  double get_relative_gradient_scaling() const { return relative_gradient_scaling_; }\n\n  double get_average_grad_mag_a() const {\n    if (counter_ != 0.0) {\n      return average_grad_mag_a_ / counter_;\n    } else {\n      return 0.0;\n    }\n  }\n  double get_average_grad_mag_b() const {\n    if (counter_ != 0.0) {\n      return average_grad_mag_b_ / counter_;\n    } else {\n      return 0.0;\n    }\n  }\n\n  double get_average_energy_a() const {\n    if (counter_ != 0.0) {\n      return average_energy_a_ / counter_;\n    } else {\n      return 0.0;\n    }\n  }\n  double get_average_energy_b() const {\n    if (counter_ != 0.0) {\n      return average_energy_b_ / counter_;\n    } else {\n      return 0.0;\n    }\n  }\n\n  std::shared_ptr&lt;VectorFunction&gt; clone() override {\n    auto copy = DualVectorFunction::New();\n    copy-&gt;a_on_ = this-&gt;a_on_;\n    copy-&gt;b_on_ = this-&gt;b_on_;\n\n    copy-&gt;relative_gradient_scaling_ = this-&gt;relative_gradient_scaling_;\n    copy-&gt;relative_energy_scaling_ = this-&gt;relative_energy_scaling_;\n    copy-&gt;average_grad_mag_a_ = this-&gt;average_grad_mag_a_;\n    copy-&gt;average_grad_mag_b_ = this-&gt;average_grad_mag_b_;\n    copy-&gt;average_energy_a_ = this-&gt;average_energy_a_;\n    copy-&gt;average_energy_b_ = this-&gt;average_energy_b_;\n    copy-&gt;counter_ = this-&gt;counter_;\n\n    if (this-&gt;function_a_) {\n      copy-&gt;function_a_ = this-&gt;function_a_-&gt;clone();\n    }\n    if (this-&gt;function_b_) {\n      copy-&gt;function_b_ = this-&gt;function_b_-&gt;clone();\n    }\n\n    if (!copy-&gt;function_a_) {\n      copy-&gt;a_on_ = false;\n    }\n    if (!copy-&gt;function_b_) {\n      copy-&gt;b_on_ = false;\n    }\n\n    copy-&gt;domain_number_ = this-&gt;domain_number_;\n    copy-&gt;particle_system_ = this-&gt;particle_system_;\n\n    return copy;\n  }\n\n  DualVectorFunction() : a_on_(true), b_on_(false), relative_gradient_scaling_(1.0), relative_energy_scaling_(1.0) {}\n\n  ~DualVectorFunction() override = default;\n\n protected:\n  DualVectorFunction(const DualVectorFunction&amp;) = delete;\n  DualVectorFunction&amp; operator=(const DualVectorFunction&amp;) = delete;\n\n  bool a_on_;\n  bool b_on_;\n  double relative_gradient_scaling_;\n  double relative_energy_scaling_;\n  double average_grad_mag_a_;\n  double average_grad_mag_b_;\n  double average_energy_a_;\n  double average_energy_b_;\n  double counter_;\n\n  std::shared_ptr&lt;VectorFunction&gt; function_a_;\n  std::shared_ptr&lt;VectorFunction&gt; function_b_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/EarlyStoppingConfig_8h.html","title":"Libs/Optimize/EarlyStoppingConfig.h","text":""},{"location":"api/Files/EarlyStoppingConfig_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/EarlyStoppingConfig_8h.html#classes","title":"Classes","text":"Name struct shapeworks::EarlyStoppingConfig Configuration for early stopping criteria."},{"location":"api/Files/EarlyStoppingConfig_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n\nnamespace shapeworks {\n\nenum class EarlyStoppingStrategy {\n  RelativeDifference,\n  ExponentialMovingAverage\n};\n\nstruct EarlyStoppingConfig {\n  bool enabled = false;\n\n  int frequency = 100;\n\n  int window_size = 5;\n\n  double threshold = 0.0001;\n\n  EarlyStoppingStrategy strategy = EarlyStoppingStrategy::RelativeDifference;\n\n  double ema_alpha = 0.2;\n\n  bool enable_logging = false;\n\n  std::string logger_name = \"early_stopping_log_stats\";\n\n  int warmup_iters = 1000;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/EarlyStopping_8h.html","title":"Libs/Optimize/Function/EarlyStop/EarlyStopping.h","text":""},{"location":"api/Files/EarlyStopping_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/EarlyStopping_8h.html#classes","title":"Classes","text":"Name class shapeworks::EarlyStopping"},{"location":"api/Files/EarlyStopping_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Eigen/Dense&gt;\n\n#include \"Libs/Optimize/ParticleSystem.h\"\n#include \"Libs/Optimize/EarlyStoppingConfig.h\"\n#include \"MorphologicalDeviationScore.h\"\n\nnamespace shapeworks {\n\nclass EarlyStopping {\npublic:\n    typedef typename ParticleSystem::PointType PointType;\n    constexpr static int VDimension = 3;\n    EarlyStopping();\n    void SetConfigParams(int frequency,\n                  int window_size,\n                  double threshold,\n                  EarlyStoppingStrategy strategy = EarlyStoppingStrategy::RelativeDifference,\n                  double ema_alpha = 0.2,\n                  bool enable_logging = false,\n                  const std::string&amp; logger_name = \"\",\n                  int warmup_iters = 1000);\n\n    void reset();\n    void update(int iteration, const ParticleSystem* p);\n    bool ShouldStop() const;\n    bool SetControlShapes(const ParticleSystem* p);\n    Eigen::MatrixXd GetTestShapes(const ParticleSystem* p);\n\nprivate:\n    std::deque&lt;Eigen::VectorXd&gt; score_history_;\n    int frequency_, window_size_;\n    double threshold_, ema_alpha_;\n    int last_checked_iter_;\n    int warmup_iters_;\n    // bool stop_flag_;\n    mutable std::atomic&lt;bool&gt; stop_flag_{false};\n    bool enable_logging_;\n    std::string logger_name_;\n    Eigen::MatrixXd control_shapes_; \n    MorphologicalDeviationScore score_func_;\n    EarlyStoppingStrategy strategy_;\n    mutable Eigen::VectorXd ema_diff_;\n    mutable bool ema_initialized_ = false;\n\n    Eigen::VectorXd ComputeScore(const Eigen::MatrixXd&amp; X) ;\n    Eigen::VectorXd ComputeRelativeDiff(const Eigen::VectorXd&amp; a, const Eigen::VectorXd&amp; b) const;\n    bool HasConverged() const;\n    bool CheckRelativeDifference() const;\n    bool CheckExponentialMovingAverage() const;\n    void LogStatus(int iter,\n                   const Eigen::VectorXd&amp; current_score,\n                   const Eigen::VectorXd&amp; diff,\n                   const std::vector&lt;bool&gt;&amp; per_subject_convergence) const;\n};\n\n} // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/EigenUtils_8h.html","title":"Libs/Utils/EigenUtils.h","text":""},{"location":"api/Files/EigenUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/EigenUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::EigenUtils"},{"location":"api/Files/EigenUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Core&gt;\n\n#include \"Shapeworks.h\"\n\nnamespace shapeworks {\n\n// Returns a 4x4 Eigen (col-major) from the given 3x4 (left-hand) itk::Transform.\nEigen::MatrixXd itkTransformToEigen(TransformPtr itk_xform);\n\n// Returns a 3x4 itk::AffineTransform from the given (col-major) 4x4 Eigen::Matrix\nTransformPtr eigen44ToItkTransform(const Eigen::Matrix&lt;double, 4, 4&gt; &amp;eigen_mat);\n\n// Returns a 4x4 Eigen (row-major) from the given vtkTransform4x4.\nEigen::Matrix&lt;double, 4, 4, Eigen::RowMajor&gt; vtkTransformToEigen(MeshTransform vtk_xform);\n\n// Returns a 4x4 vtkMatrix4x4 from the given (row-major) 4x4 Eigen::Matrix\nMeshTransform eigen44ToVtkTransform(const Eigen::Matrix&lt;double, 4, 4, Eigen::RowMajor&gt; &amp;eigen_mat);\n\ntemplate &lt;typename T&gt;\nusing VnlMatrix = Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;;\n\ntemplate &lt;typename T, unsigned NRows, unsigned NCols&gt;\nEigen::Matrix&lt;T, NRows, NCols, Eigen::RowMajor&gt; itkToEigen(const itk::Matrix&lt;T, NRows, NCols&gt; &amp;itk_mat) {\n  return Eigen::Matrix&lt;T, NRows, NCols, Eigen::RowMajor&gt;(itk_mat.GetVnlMatrix().data_block());\n}\n\n// With any luck, rvalue assignment will be used here (though it's explicit in the vxl code).\ntemplate &lt;typename T, int NRows, int NCols&gt;\nitk::Matrix&lt;T, NRows, NCols&gt; eigenToItk(const Eigen::Matrix&lt;T, NRows, NCols, Eigen::RowMajor&gt; &amp;eigen_mat) {\n  return itk::Matrix&lt;T, NRows, NCols&gt;(vnl_matrix_fixed&lt;T, NRows, NCols&gt;(eigen_mat.data()));\n}\n\ntemplate &lt;typename T&gt;\nEigen::Map&lt;VnlMatrix&lt;T&gt;&gt; vnlToEigen(const vnl_matrix&lt;T&gt; &amp;vnl_mat) {\n  return Eigen::Map&lt;VnlMatrix&lt;T&gt;&gt;(const_cast&lt;T *&gt;(vnl_mat.data_block()), vnl_mat.rows(), vnl_mat.cols());\n}\n\ntemplate &lt;int NRows, int NCols, typename T&gt;\nEigen::Map&lt;Eigen::Matrix&lt;T, NRows, NCols, Eigen::RowMajor&gt;&gt; wrapDataWithEigen(T *data) {\n  return Eigen::Map&lt;Eigen::Matrix&lt;T, NRows, NCols, Eigen::RowMajor&gt;&gt;(data);\n}\n\ntemplate &lt;typename T&gt;\nEigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&gt; wrapDataWithEigen(T *data, size_t nrows,\n                                                                                                size_t ncols) {\n  return Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&gt;(data, nrows, ncols);\n}\n\ntemplate &lt;unsigned NRows, unsigned NCols, typename T&gt;\nitk::Matrix&lt;T, NRows, NCols&gt; wrapDataWithItk(T *data) {\n  std::cerr &lt;&lt; \"WARNING: vnl cannot wrap data, so this just copies input array\\n\";\n  itk::Matrix&lt;T, NRows, NCols&gt; itk_mat;\n  vnl_matrix_fixed&lt;T, NRows, NCols&gt; &amp;vnl_mat = itk_mat.GetVnlMatrix();\n  vnl_mat.copy_in(data);\n  return itk_mat;\n}\n\nclass EigenUtils {\n public:\n  static std::pair&lt;double, double&gt; compute_mean_and_stddev(const Eigen::MatrixXd &amp;matrix, int row_index);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/EvaluationUtil_8h.html","title":"Libs/Particles/EvaluationUtil.h","text":""},{"location":"api/Files/EvaluationUtil_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/EvaluationUtil_8h.html#classes","title":"Classes","text":"Name struct shapeworks::MultiVariateNormalRandom struct shapeworks::Reconstruction"},{"location":"api/Files/EvaluationUtil_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Core&gt;\n#include &lt;Eigen/Dense&gt;\n\n#include &lt;boost/random/mersenne_twister.hpp&gt;\n#include &lt;boost/random/normal_distribution.hpp&gt;\n\nnamespace shapeworks {\nstruct MultiVariateNormalRandom\n{\n  Eigen::VectorXd mean;\n  Eigen::MatrixXd transform;\n\n  // seed set as constant 42 for test repeatability\n  boost::mt19937 gen{42};\n  boost::normal_distribution&lt;&gt; dist;\n\n  MultiVariateNormalRandom(Eigen::MatrixXd const &amp;covar)\n          : MultiVariateNormalRandom(Eigen::VectorXd::Zero(covar.rows()), covar)\n  {}\n\n  MultiVariateNormalRandom(Eigen::VectorXd const &amp;mean, Eigen::MatrixXd const &amp;covar)\n          : mean(mean)\n  {\n    Eigen::SelfAdjointEigenSolver&lt;Eigen::MatrixXd&gt; eigenSolver(covar);\n    transform = eigenSolver.eigenvectors() * eigenSolver.eigenvalues().cwiseSqrt().asDiagonal();\n  }\n\n  Eigen::MatrixXd operator()()\n  {\n    return mean + transform * Eigen::VectorXd{mean.size()}.unaryExpr([&amp;](double x) { return dist(gen); });\n  }\n\n};\n\nstruct Reconstruction\n{\n  double dist;\n  int shapeIdx;\n  Eigen::MatrixXd rec;\n};\n\n// Sorts the reconstructions in place according to `dist` and saves them to the specified folder.\n// This generates XML files which can be opened in ShapeWorksStudio\nvoid SaveReconstructions(std::vector&lt;Reconstruction&gt; &amp;reconstructions, const std::vector&lt;std::string&gt; &amp;srcPaths,\n                         const std::string &amp;saveTo)\n{\n  std::sort(reconstructions.begin(), reconstructions.end(),\n            [](const Reconstruction &amp;l, const Reconstruction &amp;r) { return l.dist &lt; r.dist; });\n\n  for (int i = 0; i &lt; reconstructions.size(); i++) {\n    const int percentile =\n            i == reconstructions.size() - 1 ? 100 : std::floor(((double) i / reconstructions.size()) * 100.0);\n\n    // Save the reconstruction\n    const std::string recPath = saveTo + \"/\" + std::to_string(percentile) + \"perc.particles\";\n    std::ofstream recOF(recPath);\n    if (!recOF) { throw std::runtime_error(\"Unable to open file: \" + recPath); }\n    recOF &lt;&lt; reconstructions[i].rec &lt;&lt; std::endl;\n    recOF.close();\n\n    // Create an XML file\n    const std::string xmlPath = saveTo + \"/\" + std::to_string(percentile) + \"perc.xml\";\n    std::ofstream xmlOF(xmlPath);\n    if (!xmlOF) { throw std::runtime_error(\"Unable to open file: \" + xmlPath); }\n\n    xmlOF &lt;&lt; \"&lt;point_files&gt;\"\n          &lt;&lt; srcPaths[reconstructions[i].shapeIdx] &lt;&lt; std::endl &lt;&lt; recPath\n          &lt;&lt; \"&lt;/point_files&gt;\" &lt;&lt; std::endl\n          &lt;&lt; \"&lt;group_ids&gt;\"\n          &lt;&lt; 1 &lt;&lt; std::endl &lt;&lt; 2\n          &lt;&lt; \"&lt;/group_ids&gt;\";\n    xmlOF.close();\n  }\n}\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ExcelProjectReader_8h.html","title":"Libs/Project/ExcelProjectReader.h","text":""},{"location":"api/Files/ExcelProjectReader_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ExcelProjectReader_8h.html#classes","title":"Classes","text":"Name class shapeworks::ExcelProjectReader Excel file format reader for Project."},{"location":"api/Files/ExcelProjectReader_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ProjectReader.h\"\n\nnamespace shapeworks {\n\n\nclass ExcelProjectReader : public ProjectReader {\n public:\n  ExcelProjectReader(Project &amp;project);\n  ~ExcelProjectReader();\n\n  bool read_project(std::string filename) override;\n\n  StringMap get_parameters(std::string name) override;\n\n  StringMultiMap get_multi_parameters(std::string name) override;\n\n private:\n\n  // pimpl container\n  class Container;\n  std::unique_ptr&lt;Container&gt; container_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ExcelProjectWriter_8h.html","title":"Libs/Project/ExcelProjectWriter.h","text":""},{"location":"api/Files/ExcelProjectWriter_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ExcelProjectWriter_8h.html#classes","title":"Classes","text":"Name class shapeworks::ExcelProjectWriter Excel file format writer for Project."},{"location":"api/Files/ExcelProjectWriter_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Project.h\"\n\nnamespace shapeworks {\n\n\nclass ExcelProjectWriter {\n public:\n  static bool write_project(Project&amp; project, const std::string&amp; filename);\n\n private:\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Executable_8h.html","title":"Applications/shapeworks/Executable.h","text":""},{"location":"api/Files/Executable_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Executable_8h.html#classes","title":"Classes","text":"Name class shapeworks::Executable"},{"location":"api/Files/Executable_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n/*\n * Unified shapeworks executable.\n */\n\n#include \"Command.h\"\n#include &lt;optparse.h&gt;\n\nnamespace shapeworks {\n\nclass Executable {\npublic:\n  Executable();\n\n  void addCommand(Command &amp;command);\n  int run(int argc, char const *const *argv);\n\nprivate:\n  void buildParser();\n  optparse::OptionParser parser;\n  std::map&lt;std::string, Command&amp;&gt; commands;\n  std::map&lt;std::string, std::map&lt;std::string, std::string&gt; &gt; parser_epilog; // &lt;command_type, &lt;command_name, desc&gt; &gt;\n\n  int run(std::vector&lt;std::string&gt; arguments, SharedCommandData &amp;sharedData);\n};\n\n}; // shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ExportImageDialog_8h.html","title":"Studio/Interface/ExportImageDialog.h","text":""},{"location":"api/Files/ExportImageDialog_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ExportImageDialog_8h.html#classes","title":"Classes","text":"Name class shapeworks::ExportImageDialog"},{"location":"api/Files/ExportImageDialog_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// qt\n#include &lt;QDialog&gt;\n#include &lt;QTimer&gt;\n\n// studio\n#include &lt;Data/Preferences.h&gt;\n\nclass Ui_ExportImageDialog;\n\nnamespace shapeworks {\n\nclass Visualizer;\nclass AnalysisTool;\n\nclass ExportImageDialog : public QDialog {\n  Q_OBJECT\n\n public:\n  ExportImageDialog(QWidget* parent, Preferences&amp; prefs, QSharedPointer&lt;AnalysisTool&gt; analysis_tool,\n                    QSharedPointer&lt;Visualizer&gt; visualizer, bool pca_mode);\n\n private Q_SLOTS:\n\n  void export_clicked();\n\n Q_SIGNALS:\n\n private:\n  void update_preview();\n\n  void drawRotatedText(QPainter&amp; painter, QString text, QPointF point, qreal angle, QRect rect);\n\n  QVector&lt;int&gt; get_modes(QString string);\n\n  Ui_ExportImageDialog* ui_;\n  QSharedPointer&lt;Visualizer&gt; visualizer_;\n  Preferences&amp; prefs_;\n  QPixmap pixmap_;\n  bool pca_mode_ = false;\n  QTimer update_preview_timer_;\n  QSharedPointer&lt;AnalysisTool&gt; analysis_tool_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ExportUtils_8h.html","title":"Studio/Data/ExportUtils.h","text":""},{"location":"api/Files/ExportUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ExportUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::ExportUtils Export utilities for Studio."},{"location":"api/Files/ExportUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\nclass vtkPolyData;\nnamespace shapeworks {\nclass Session;\nclass ShapeWorksStudioApp;\nclass Shape;\nclass ParticleShapeStatistics;\n\nclass ExportUtils {\n public:\n  static QString get_save_filename(ShapeWorksStudioApp* parent, QString title, QString filetypes, QString default_ext);\n\n  static void export_all_subjects_particle_scalars(ShapeWorksStudioApp* parent, QSharedPointer&lt;Session&gt; session);\n\n  static bool write_scalars(ShapeWorksStudioApp* app, vtkSmartPointer&lt;vtkPolyData&gt; poly_data, QString filename);\n\n  static bool write_particle_scalars(ShapeWorksStudioApp* app, std::shared_ptr&lt;Shape&gt; shape, QString filename);\n\n  static bool write_pca_scores(ShapeWorksStudioApp* app, ParticleShapeStatistics* stats, QString filename);\n\n  static QString get_mesh_file_filter();\n\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEAreaCoverage_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEAreaCoverage.h","text":""},{"location":"api/Files/FEAreaCoverage_8h.html#namespaces","title":"Namespaces","text":"Name std"},{"location":"api/Files/FEAreaCoverage_8h.html#classes","title":"Classes","text":"Name class FEAreaCoverage"},{"location":"api/Files/FEAreaCoverage_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"FEMesh.h\"\n#include \"Intersect.h\"\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass FEAreaCoverage\n{\n  class Surface\n  {\n\n  public:\n    Surface() {}\n    int Faces() { return (int)m_face.size(); }\n\n    void Create(std::shared_ptr&lt;FEMesh&gt; m);\n\n    int Nodes() { return (int)m_node.size(); }\n\n    std::shared_ptr&lt;FEMesh&gt; m_mesh;\n    vector&lt;int&gt;   m_face;                     // face list\n    vector&lt;int&gt;   m_node;                     // node list\n    vector&lt;vec3d&gt; m_pos;                      // node positions\n    vector&lt;int&gt;   m_lnode;                    // local node list\n    vector&lt;vec3d&gt; m_norm;                     // node normals\n    vector&lt;vec3d&gt; m_fnorm;                    // face normals\n\n    vector&lt;vector&lt;int&gt;&gt; m_NLT;                // node-facet look-up table\n  };\n\npublic:\n  FEAreaCoverage();\n\n  // assign selections\n  void SetSelection1(vector&lt;int&gt;&amp; s) { m_surf1.m_face = s; }\n  void SetSelection2(vector&lt;int&gt;&amp; s) { m_surf2.m_face = s; }\n\n  // apply the map\n  // returns one value per node\n  vector&lt;double&gt; Apply(std::shared_ptr&lt;FEMesh&gt; mesh1, std::shared_ptr&lt;FEMesh&gt; mesh2);\n\n  // get/set back intersection flag\n    void AllowBackIntersection(bool b);\n    bool AllowBackIntersection() const;\n\n  // set/get the angle threshold (w between 0 and 1)\n    void SetAngleThreshold(double w);\n    double GetAngleThreshold() const;\n\n  // set/get back-intersection search radius (0 ignores the search radius)\n    void SetBackSearchRadius(double R);\n    double GetBackSearchRadius() const;\n\nprotected:\n  // build node normal list\n  void UpdateSurface(FEAreaCoverage::Surface&amp; s);\n\n  // see if a ray intersects with a surface\n  bool intersect(const vec3d&amp; r, const vec3d&amp; N, FEAreaCoverage::Surface&amp; surf, Intersection&amp; q);\n  bool faceIntersect(FEAreaCoverage::Surface&amp; surf, const Ray&amp; ray, int nface, Intersection&amp; q);\n\nprotected:\n  Surface m_surf1;\n  Surface m_surf2;\n\n    bool          m_ballowBackIntersections;    // include back intersections\n  double        m_angleThreshold;                 // angular threshold (between 0 and 1)\n    double      m_backSearchRadius;             // search radius for back intersections (set to 0 to ignore)\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEAutoMesher_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEAutoMesher.h","text":""},{"location":"api/Files/FEAutoMesher_8h.html#classes","title":"Classes","text":"Name class FEAutoMesher"},{"location":"api/Files/FEAutoMesher_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nclass FEMesh;\n\n//-----------------------------------------------------------------------------\nclass FEAutoMesher\n{\npublic:\n    FEAutoMesher();\n    void BuildMesh(FEMesh* pm);\n\npublic:\n    void AutoPartitionSurface(FEMesh&amp; m);\n    void AutoPartitionEdges(FEMesh&amp; m);\n    void AutoPartitionNodes(FEMesh&amp; m);\n\n    void Repartition(FEMesh&amp; m);\n\n    void SetSmoothingAngle(double w) { m_wsmooth = w; }\n    double GetSmoothingAngle() { return m_wsmooth; }\n\nprotected:\n    void BuildFaces(FEMesh&amp; m);\n    void BuildEdges(FEMesh&amp; m);\n\nprotected:\n    FEMesh*     m_pm;\n\n    double  m_wsmooth;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FECVDDecimationModifier_8h.html","title":"Libs/Mesh/PreviewMeshQC/FECVDDecimationModifier.h","text":""},{"location":"api/Files/FECVDDecimationModifier_8h.html#classes","title":"Classes","text":"Name class FECVDDecimationModifier"},{"location":"api/Files/FECVDDecimationModifier_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"math3d.h\"\n#include \"FEMesh.h\"\n#include &lt;list&gt;\nusing namespace std;\n\n//-----------------------------------------------------------------------------\nclass FECVDDecimationModifier\n{\nprivate:\n    class Cluster\n    {\n    public:\n        Cluster() : m_sgamma(vec3d(0,0,0)), m_srho(0.0) {}\n\n        int faces() const { return (int) m_fid.size(); }\n\n    public:\n        vec3d   m_sgamma;   // sum of \"gamma's\"\n        double  m_srho;     // sum of \"rho's\"\n        vector&lt;int&gt; m_fid; //face ids of the faces in this cluster\n\n    };\n\n    struct EDGE\n    {\n        int face[2];    // the indices of the two faces sharing this edge\n        int node[2];    // the nodes of the edge\n    };\n\n    // a node which contains a list of clusters it belongs to\n    class NODE\n    {\n    public:\n        enum {MAX_CLUSTERS=23};\n    public:\n        NODE() : nc(0){}\n\n        bool AttachToCluster(int n);\n    public:\n        int c[MAX_CLUSTERS];    // cluster ID's\n        int nc;                 // nr of clusters\n    };\n\npublic:\n    FECVDDecimationModifier();\n\n    FEMesh* Apply(FEMesh* pm);\n\nprivate:\n    bool Initialize(FEMesh* pm);\n\n    bool Minimize(FEMesh* pm);\n\n    FEMesh* Triangulate(FEMesh* pm);\n    FEMesh* Triangulate2(FEMesh* pm);   // uses hole-filling algorithm\n\n    FEMesh* CalculateCVD(FEMesh* pm);\n    void InterpolateShellThickness(FEMesh* pm); // to interpolate shell thickness\n\n    bool Swap(FEFace&amp; face, int nface, int ncluster);\n\npublic:\n    double  m_pct;  \n    bool    m_bcvd;\n    double  m_sel_pct; // percentage of clusters in selected region\n    double  m_gradient; //gradiant for curvature\n\nprivate:\n    vector&lt;Cluster&gt; m_Cluster;\n    vector&lt;int&gt;     m_tag;\n    vector&lt;double&gt;  m_rho;      // rho for all triangles\n    vector&lt;vec3d&gt;   m_gamma;    // centroids of all triangles\n    list&lt;EDGE&gt;      m_Edge;     // edge list\n    vector&lt;double&gt; m_st;//each node shell thickness\n    //vector&lt;int&gt; hashmap;      //hashmap for selected faces\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FECoreMesh_8h.html","title":"Libs/Mesh/PreviewMeshQC/FECoreMesh.h","text":""},{"location":"api/Files/FECoreMesh_8h.html#classes","title":"Classes","text":"Name class FECoreMesh"},{"location":"api/Files/FECoreMesh_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"FEElement.h\"\n#include &lt;vector&gt;\n\n//-----------------------------------------------------------------------------\nclass FECoreMesh\n{\npublic:\n    FECoreMesh();\n\n    virtual ~FECoreMesh();\n\n    virtual void Create(int nodes, int elems, int faces = 0, int edges = 0) = 0;\n\n    bool IsType(int ntype);\n\npublic: // interface for accessing elements\n\n    virtual int Elements() const = 0;\n\n    virtual FEElement_&amp; ElementRef(int n) = 0;\n\n    virtual  FEElement* ElementPtr(int n=0) = 0;\n\npublic: // interface for accessing mesh items (except elements)\n\n    int Nodes   () const { return m_Node.size(); }\n    int Edges   () const { return m_Edge.size(); }\n    int Faces   () const { return m_Face.size(); }\n\n    FENode&amp;    Node   (int n) { return m_Node[n]; }\n    FEEdge&amp;    Edge   (int n) { return m_Edge[n]; }\n    FEFace&amp;    Face   (int n) { return m_Face[n]; }\n\n    FENode*    NodePtr   (int n=0) { return ((n&gt;=0) &amp;&amp; (n&lt;(int)m_Node.size())? &amp;m_Node[n] : 0); }\n    FEEdge*    EdgePtr   (int n=0) { return ((n&gt;=0) &amp;&amp; (n&lt;(int)m_Edge.size())? &amp;m_Edge[n] : 0); }\n    FEFace*    FacePtr   (int n=0) { return ((n&gt;=0) &amp;&amp; (n&lt;(int)m_Face.size())? &amp;m_Face[n] : 0); }\n\nprotected:\n    std::vector&lt;FENode&gt;     m_Node; \n    std::vector&lt;FEEdge&gt;     m_Edge; \n    std::vector&lt;FEFace&gt;     m_Face; \n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEElement_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEElement.h","text":""},{"location":"api/Files/FEElement_8h.html#classes","title":"Classes","text":"Name class FEItem class FENode class FEEdge class FEFace class FEElement_ class FETri3 class FEElement"},{"location":"api/Files/FEElement_8h.html#defines","title":"Defines","text":"Name FE_VISIBLE FE_SELECTED FE_HEX8 FE_TET4 FE_PENTA6 FE_QUAD4 FE_TRI3 FE_BEAM2 FE_HEX20 FE_QUAD8 FE_BEAM3 FE_TET10 FE_TRI6 FE_TET15 FE_HEX27 MAX_ELEM"},{"location":"api/Files/FEElement_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/FEElement_8h.html#define-fe_visible","title":"define FE_VISIBLE","text":"<pre><code>#define FE_VISIBLE 0x01\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_selected","title":"define FE_SELECTED","text":"<pre><code>#define FE_SELECTED 0x02\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_hex8","title":"define FE_HEX8","text":"<pre><code>#define FE_HEX8 1\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_tet4","title":"define FE_TET4","text":"<pre><code>#define FE_TET4 2\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_penta6","title":"define FE_PENTA6","text":"<pre><code>#define FE_PENTA6 3\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_quad4","title":"define FE_QUAD4","text":"<pre><code>#define FE_QUAD4 4\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_tri3","title":"define FE_TRI3","text":"<pre><code>#define FE_TRI3 5\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_beam2","title":"define FE_BEAM2","text":"<pre><code>#define FE_BEAM2 6\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_hex20","title":"define FE_HEX20","text":"<pre><code>#define FE_HEX20 7\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_quad8","title":"define FE_QUAD8","text":"<pre><code>#define FE_QUAD8 8\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_beam3","title":"define FE_BEAM3","text":"<pre><code>#define FE_BEAM3 9\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_tet10","title":"define FE_TET10","text":"<pre><code>#define FE_TET10 10\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_tri6","title":"define FE_TRI6","text":"<pre><code>#define FE_TRI6 11\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_tet15","title":"define FE_TET15","text":"<pre><code>#define FE_TET15 12\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-fe_hex27","title":"define FE_HEX27","text":"<pre><code>#define FE_HEX27 13\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#define-max_elem","title":"define MAX_ELEM","text":"<pre><code>#define MAX_ELEM 13\n</code></pre>"},{"location":"api/Files/FEElement_8h.html#source-code","title":"Source code","text":"<pre><code>// FEElement.h: interface for the FEElement class.\n//\n\n#if !defined(AFX_FEELEMENT_H__4A869671_045F_4EDD_AC13_25C849922373__INCLUDED_)\n#define AFX_FEELEMENT_H__4A869671_045F_4EDD_AC13_25C849922373__INCLUDED_\n\n#if _MSC_VER &gt; 1000\n#pragma once\n#endif // _MSC_VER &gt; 1000\n\n#include &lt;assert.h&gt;\n#include \"math3d.h\"\n\n//-----------------------------------------------------------------------------\n// FE State Flags\n#define FE_VISIBLE  0x01\n#define FE_SELECTED 0x02\n\n//-----------------------------------------------------------------------------\n// The FEItem class is the base class for all FEMesh items. It stores the \n// common attributes such as the state flags and the group ID.\n//\nclass FEItem\n{\npublic:\n    FEItem() { m_state = FE_VISIBLE; m_gid = -1; }\n\n    bool IsVisible () const { return ((m_state &amp; FE_VISIBLE ) != 0); }\n    bool IsSelected() const { return ((m_state &amp; FE_SELECTED) != 0); }\n\n    void Select()   { m_state = m_state | FE_SELECTED; }\n    void UnSelect() { m_state = m_state &amp; ~FE_SELECTED; }\n    void Show  () { m_state = m_state | FE_VISIBLE;  }\n    void Hide  () { m_state = 0;  }\n\n    unsigned int GetFEState() const { return m_state; }\n    void SetFEState(unsigned int state) { m_state = state; }\n\npublic:\n    int m_ntag; // tag of item\n    int m_gid;  // group id\n    int m_nid;  // item id (used e.g. in export).\n    //double    m_ndata;        //scalar data associated with a node\nprivate:\n    unsigned int m_state;   // the state flag of the mesh(-item)\n};\n\n//-----------------------------------------------------------------------------\n// The FENode class stores the nodal data.\n//\nclass FENode : public FEItem\n{\npublic:\n    FENode(){ m_bext = false; }\n\npublic:\n    vec3d   r;              // nodal position\n    bool    m_bext;         // exterior node or not?\n    double  m_ndata;\n};\n\n//-----------------------------------------------------------------------------\n// The FEEdge class stores the edge data.\n// An edge can be either linear or quadratic. In the linear case, only the\n// first two nodes are used, the third one is set to -1. In the latter case,\n// all three nodes are used, with the first two being the outside nodes and\n// the third one being the inside node.\n//\n//   1         3          2\n//   +---------o----------+\n//\nclass FEEdge : public FEItem\n{\npublic:\n    enum {MAX_NODES = 3};\n\npublic:\n    FEEdge();\n\n    bool operator == (const FEEdge&amp; e);\n\n    int Nodes() { return (n[2] == -1? 2 : 3); }\n\n    int FindNode(int node);\n\npublic:\n    int n[MAX_NODES];   \n    int m_elem;         \n    int m_nbr[2];       \n};\n\n//-----------------------------------------------------------------------------\n// FEFace class stores face data. \n// A face can either have 3, 4, 6, 8 or 9 nodes. It is a triangle if it has 3 nodes and\n// a quad if it has 4. If it has 6 it is a quadratic triangle. The first three are the\n// cornder nodes, the other three are the midpoints of the edges. If it has 8 or 9 it is \n// a quadratic quad. The first four nodes are the corner nodes, the next four the \n// interior edge nodes and in the case of a 9-node quad, the last node is in the center.\n//\n//   4       7       3      3\n//   +-------o-------+      +\n//   |               |      |\\\n//   |               |      | \\\n//  8o       x9      o6    6o  o5\n//   |               |      |   \\\n//   |               |      |    \\\n//   +-------o-------+      +--o--+\n//   1       5       2      1  4  2\n//\nclass FEFace : public FEItem\n{\npublic:\n    enum {MAX_NODES = 9};\n\npublic:\n    FEFace();\n\n    bool operator == (const FEFace&amp; f);\n\n    int Nodes() { return m_nodes; }\n\n    int Edges();\n\n    void GetEdgeNodes(int i, int* n);\n\n    bool HasEdge(int n1, int n2);\n\n    bool HasNode(int i);\n\n    int FindNode(int i);\n\n    bool IsExternal() { return (m_elem[1] == -1); }\n\npublic:\n    int n[MAX_NODES];   \n    int m_nodes;        \n\n    int     m_nbr[4];   \n\n    vec3d   m_fn;               \n    vec3d   m_nn[MAX_NODES];    \n    int     m_sid;              \n\n    int m_elem[2];  \n};\n\n//-----------------------------------------------------------------------------\n// element types\n// NOTE: do not change the order or values of these macros.\n#define FE_HEX8     1\n#define FE_TET4     2\n#define FE_PENTA6   3\n#define FE_QUAD4    4\n#define FE_TRI3     5\n#define FE_BEAM2    6\n#define FE_HEX20    7\n#define FE_QUAD8    8\n#define FE_BEAM3    9\n#define FE_TET10    10\n#define FE_TRI6     11\n#define FE_TET15    12\n#define FE_HEX27    13\n\n#define MAX_ELEM    13\n\n//-----------------------------------------------------------------------------\n// The FEElement_ class defines the data interface to the element data. \n// Specialized element classes are then defined by deriving from this base class.\nclass FEElement_ : public FEItem\n{\npublic:\n    FEElement_();\n\n    // comparison operator\n    bool is_equal(FEElement_&amp; e);\n\n    int GetType() const { return m_ntype; }\n\n    bool IsType(int ntype) const { return m_ntype == ntype; }\n\n    int Nodes() const { return m_nodes; }\n\n    int Faces() const { return m_nfaces; }\n\n    int Edges() const { return m_nedges; }\n\n    int GetFace(int i, int* n);\n\n    FEFace GetFace(int i);\n\n    FEFace GetShellFace();\n\n    FEEdge GetEdge(int i);\n\n    bool IsExterior();\n\nprotected:\n    // help class for copy-ing element data\n    void copy(const FEElement_&amp; el);\n\npublic:\n    // Check the element class\n    bool IsSolid() { return (m_ntype == FE_HEX8) || (m_ntype == FE_HEX20) || (m_ntype == FE_HEX27) || (m_ntype == FE_PENTA6) || (m_ntype == FE_TET4) || (m_ntype == FE_TET10) || (m_ntype == FE_TET15); }\n    bool IsShell() { return (m_ntype == FE_TRI3) || (m_ntype == FE_QUAD4) || (m_ntype == FE_TRI6); }\n    bool IsBeam () { return (m_ntype == FE_BEAM2); }\n\npublic:\n    int*        m_node;     \n    int*        m_nbr;      \n    int*        m_face;     \n    double*     m_h;        \n\npublic:\n    vec3d   m_fiber;    \n    mat3d   m_Q;        \n    bool    m_Qactive;  \n    double  m_a0;       \n\nprotected:\n    int     m_ntype;    \n    int     m_nodes;    \n    int     m_nfaces;   \n    int     m_nedges;   \n};\n\n//-----------------------------------------------------------------------------\n// Class for 3-node triangular elements\nclass FETri3 : public FEElement_\n{\npublic:\n    FETri3();\n\n    FETri3(FETri3&amp; el);\n\n    FETri3&amp; operator = (FETri3&amp; el);\n\nprivate:\n    int     _node[3];\n    int     _nbr[3];\n    int     _face[1];\n    double  _h[3];\n};\n\n//-----------------------------------------------------------------------------\n// The FEElement class can be used to represent a general purpose element. \n// This class can represent an element of all different types. \nclass FEElement : public FEElement_\n{\npublic:\n    enum { MAX_NODES = 27 };\n\npublic:\n    FEElement();\n\n    FEElement(const FEElement&amp; el);\n\n    FEElement&amp; operator = (const FEElement&amp; el);\n\n    void SetType(int ntype);\n\nprivate:\n    int     _node[MAX_NODES];   \n    int     _nbr[6];            \n    int     _face[6];           \n    double  _h[9];              \n};\n\n#endif // !defined(AFX_FEELEMENT_H__4A869671_045F_4EDD_AC13_25C849922373__INCLUDED_)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEFillHole_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEFillHole.h","text":""},{"location":"api/Files/FEFillHole_8h.html#classes","title":"Classes","text":"Name class FEFillHole class FEFillHole::EdgeRing struct FEFillHole::FACE"},{"location":"api/Files/FEFillHole_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"FEMesh.h\"\n\n//-----------------------------------------------------------------------------\n// This class implements a modifier that fills a hole in a mesh. \nclass FEFillHole\n{\npublic:\n    // helper class for defining a closed loop of edges\n    class EdgeRing\n    {\n    public:\n        EdgeRing(){ m_winding = 1; }\n        EdgeRing(const EdgeRing&amp; ring) { m_node = ring.m_node; m_r = ring.m_r; m_winding = ring.m_winding; m_normal = ring.m_normal; }\n        void operator = (const EdgeRing&amp; ring) { m_node = ring.m_node; m_r = ring.m_r; m_winding = ring.m_winding;  m_normal = ring.m_normal; }\n\n        bool empty() { return m_node.empty(); }\n\n        void add(int n, const vec3d&amp; r, const vec3d&amp; nn) { m_node.push_back(n); m_r.push_back(r); m_normal.push_back(nn); }\n\n        void clear() { m_node.clear(); m_r.clear(); m_normal.clear(); }\n\n        int size() { return (int)m_node.size(); }\n\n        int operator [] (int i) { return m_node[i]; }\n\n        void GetLeftEar(int n0, int n1, EdgeRing&amp; ear);\n        void GetRightEar(int n0, int n1, EdgeRing &amp; ear);\n\n    public:\n        vector&lt;vec3d&gt;   m_r;        // nodal positions\n        vector&lt;int&gt;     m_node;     // sorted list of nodes defining the closed loop\n        int             m_winding;  // +1 or -1 depending on the winding\n        vector&lt;vec3d&gt;   m_normal;   //node normals\n    };\n\n    // helper class for representing a new face\n    struct FACE\n    {\n        vec3d   r[3];   // nodal positions\n        int     n[3];   // the three nodes of the face\n    };\n\npublic:\n    FEFillHole(){}\n    FEMesh* Apply(FEMesh* pm);\n\n    bool optimize;\n    bool insertNodes;\n    //AFM\n    bool AFM(FEMesh&amp; mesh, EdgeRing&amp; ring, vector&lt;FACE&gt;&amp; tri_list, vector&lt;vec3d&gt; &amp;node_list);\n    //Addd node\n    vec3d newNode(vec3d current_node, vec3d next_node, vec3d prev_node, vec3d node_normal, double scale, bool concave);\n    // divide a ring\n    bool DivideRing(EdgeRing&amp; ring, vector&lt;FACE&gt;&amp; tri_list);\n\n    // divide a ring\n    bool DivideRing1(EdgeRing&amp; ring, vector&lt;FACE&gt;&amp; tri_list);\n\n    // fill all holes\n    void FillAllHoles(FEMesh* pm);\n\n\nprivate:\n    // Find the ring based on a node (TODO: should I move this to the FEMesh class?)\n    bool FindEdgeRing(FEMesh&amp; mesh, int node, EdgeRing&amp; ring);\n\n    // Find the approximate normal of a ring\n    vec3d RingNormal(EdgeRing&amp; ring);\n\n    // check if the split is valid\n    bool IsValidSplit(EdgeRing&amp; left, EdgeRing&amp; right, const vec3d&amp; p, const vec3d&amp; t);\n\n    // get location sign (+1 on positive side, -1 on negative side, 0 = on both sides)\n    int GetPlaneOrientation(EdgeRing&amp; ring, const vec3d&amp; p, const vec3d&amp; t);\n\n    // get the area of the smallest triangle\n    double min_tri_area(vector&lt;FACE&gt;&amp; tri);\n\n    // get the quality of the worst triangle\n    double min_tri_quality(vector&lt;FACE&gt;&amp; tri);\n\n    // get the triangle quality\n    double tri_quality(vec3d r[3]);\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEFixMesh_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEFixMesh.h","text":""},{"location":"api/Files/FEFixMesh_8h.html#classes","title":"Classes","text":"Name class FEFixMesh"},{"location":"api/Files/FEFixMesh_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"FEMesh.h\"\n\n//-----------------------------------------------------------------------------\n// This modifier implements a list of tools to fixing meshes\nclass FEFixMesh\n{\npublic:\n    FEFixMesh() { m_ntask = 0; }\n    FEMesh* Apply(FEMesh* pm);\n\n    // set the task to do\n    void SetTask(int n);\n    //set max thickness in case 6\n    void SetThickness(double m);\n\npublic:\n    FEMesh* RemoveDuplicateElements  (FEMesh* pm);\n    FEMesh* RemoveNonManifoldElements(FEMesh* pm);\n    FEMesh* FixElementWinding        (FEMesh* pm);\n    FEMesh* FillAllHoles             (FEMesh* pm);\n    FEMesh* FixinvertedElements      (FEMesh* pm);\n    FEMesh* FixReferenceSurface      (FEMesh* pm);\n    FEMesh* InterpolateShellThickness(FEMesh* pm);\nprivate:\n    int m_ntask;\n    double m_limitThickness;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEMeshSmoothingModifier_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEMeshSmoothingModifier.h","text":""},{"location":"api/Files/FEMeshSmoothingModifier_8h.html#classes","title":"Classes","text":"Name class FEMeshSmoothingModifier"},{"location":"api/Files/FEMeshSmoothingModifier_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"math3d.h\"\n\nclass FEMesh;\n\n//-----------------------------------------------------------------------------\nclass FEMeshSmoothingModifier\n{\n\npublic:\n    FEMeshSmoothingModifier();\n\n    FEMesh* Apply(FEMesh* pm);\n\nprotected:\n    double area_triangle(vec3d r[3]);\n    double distance(vec3d x,vec3d y );\n    double random();\n    void Laplacian_Smoothing(FEMesh* pm,vector&lt;int&gt; hashmap);\n    void Laplacian_Smoothing2(FEMesh* pm,vector&lt;int&gt; hashmap);\n    void Taubin_Smoothing(FEMesh* pm,vector&lt;int&gt; hashmap);\n    void Crease_Enhancing_Diffusion(FEMesh* pm,vector&lt;int&gt; hashmap);\n    void Add_Noise(FEMesh* pm,vector&lt;int&gt; hashmap);\n\npublic:\n    double  m_threshold1;\n    double  m_threshold2;\n    double m_iteration;\n    int m_method;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEMesh_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEMesh.h","text":""},{"location":"api/Files/FEMesh_8h.html#classes","title":"Classes","text":"Name class FEElementData class FEMesh"},{"location":"api/Files/FEMesh_8h.html#functions","title":"Functions","text":"Name double bias(double b, double x) double gain(double g, double x) double area_triangle(vec3d r[3])"},{"location":"api/Files/FEMesh_8h.html#attributes","title":"Attributes","text":"Name int FTHEX8 int FTHEX20 int FTHEX27 int FTPENTA int FTTET int FTTET10 int FTTET15"},{"location":"api/Files/FEMesh_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/FEMesh_8h.html#function-bias","title":"function bias","text":"<pre><code>double bias(\n    double b,\n    double x\n)\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#function-gain","title":"function gain","text":"<pre><code>double gain(\n    double g,\n    double x\n)\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#function-area_triangle","title":"function area_triangle","text":"<pre><code>double area_triangle(\n    vec3d r[3]\n)\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Files/FEMesh_8h.html#variable-fthex8","title":"variable FTHEX8","text":"<pre><code>int FTHEX8;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-fthex20","title":"variable FTHEX20","text":"<pre><code>int FTHEX20;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-fthex27","title":"variable FTHEX27","text":"<pre><code>int FTHEX27;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-ftpenta","title":"variable FTPENTA","text":"<pre><code>int FTPENTA;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-fttet","title":"variable FTTET","text":"<pre><code>int FTTET;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-fttet10","title":"variable FTTET10","text":"<pre><code>int FTTET10;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#variable-fttet15","title":"variable FTTET15","text":"<pre><code>int FTTET15;\n</code></pre>"},{"location":"api/Files/FEMesh_8h.html#source-code","title":"Source code","text":"<pre><code>// FEMesh.h: interface for the FEMesh class.\n//\n\n#if !defined(AFX_FEMESH_H__CB7EC714_E3FD_46A4_A397_FEFB23429520__INCLUDED_)\n#define AFX_FEMESH_H__CB7EC714_E3FD_46A4_A397_FEFB23429520__INCLUDED_\n\n#if _MSC_VER &gt; 1000\n#pragma once\n#endif // _MSC_VER &gt; 1000\n\n#include \"FECoreMesh.h\"\n#include &lt;vector&gt;\n#include &lt;set&gt;\nusing namespace std;\n\n//-----------------------------------------------------------------------------\nclass FEMesh;\n\n//-----------------------------------------------------------------------------\n// Element data field\nclass FEElementData\n{\npublic:\n    FEElementData();\n    FEElementData(const FEElementData&amp; d);\n    FEElementData&amp; operator = (const FEElementData&amp; d);\n\n    // create a data field\n    void Create(FEMesh* pm, double v = 0.0);\n\n    // size of data field\n    int Size() { return (int) m_data.size(); }\n\n    // get/set\n    double get(int i) { return m_data[i]; }\n    void set(int i, double v) { m_data[i] = v; }\n\n    // access operator\n    double&amp; operator [] (int i) { return m_data[i]; }\n\n    // get/set name\n    void SetName(const char* sz);\n    const char* GetName() { return m_szname; }\n\n    void FillRandomBox(double fmin, double fmax);\n\nprivate:\n    char            m_szname[256];  \n    FEMesh*         m_pMesh;        \n    vector&lt;double&gt;  m_data;         \n};\n\n//-----------------------------------------------------------------------------\n// This class describes a finite element mesh. Every FEMesh must be owned by a\n// GObject class. \nclass FEMesh : public FECoreMesh\n{\npublic:\n    // --- C O N S T R U C T I O N ---\n    FEMesh();\n    FEMesh(FEMesh&amp; m);\n    virtual ~FEMesh();\n\n    // allocate space for mesh\n    void Create(int nodes, int elems, int faces = 0, int edges = 0);\n\n    // copy part of the mesh\n    void ShallowCopy(FEMesh* pm);\n\n    void Clear();\n    void DeleteEdges() { if (!m_Edge.empty()) m_Edge.clear(); }\n\npublic: // --- E L E M E N T   A C C E S S ---\n\n    int Elements() const { return m_Elem.size(); }\n\n    FEElement&amp; Element(int n) { return m_Elem[n]; }\n\n    FEElement_&amp; ElementRef(int n) { return m_Elem[n]; }\n\n    FEElement* ElementPtr(int n=0) { return ((n&gt;=0) &amp;&amp; (n&lt;(int)m_Elem.size())? &amp;m_Elem[n] : 0); }\n\npublic:\n    // --- S U B M E S H ---\n    int FindFace(FEElement* pe, FEFace&amp; f, FEFace&amp; fe);\n\n    void FindNodesFromPart(int gid, vector&lt;int&gt;&amp; node);\n\n    std::vector&lt;FENode&gt;&amp;    NodeArray   () { return m_Node; }\n    std::vector&lt;FEFace&gt;&amp;    FaceArray   () { return m_Face; }\n    std::vector&lt;FEElement&gt;&amp; ElementArray() { return m_Elem; }\n\n    // --- E V A L U A T I O N ---\n\n    // get the current element value\n    double GetElementValue(int n) { return m_data[n]; }\n\n    // set the element value\n    void SetElementValue(int n, double v) { m_data[n] = v; }\n\n    // update the range of values\n    void UpdateValueRange();\n\n    // get the value range\n    void GetValueRange(double&amp; vmin, double&amp; vmax);\n\n    vec3d ProjectToSurface(vec3d r, vec3d t);\n    vec3d ProjectToFace(vec3d p, FEFace&amp; f, double&amp; r, double&amp; s);\n    vec3d ProjectToEdge(vec3d e1, vec3d e2, vec3d p, double&amp; r);\n\n    bool FindIntersection(FEFace&amp; f, vec3d x, vec3d n, vec3d&amp; q, double&amp; g);\n\n    // --- U P D A T E ---\n    void Update();\n    void UpdateElementNeighbors();\n    void UpdateFaces();\n    void UpdateEdges();\n    void UpdateNodes();\n    void AutoSmooth(double w);\n    void UpdateNormals();\n    void PartitionSelection();\n\n    // --- O P E R A T I O N S ---\n    void RemoveIsolatedNodes();\n\n    void AddNode(FENode&amp; n) { m_Node.push_back(n); }\n\n    // detach the selected elements and create a new mesh\n    FEMesh* DetachSelectedMesh();\n\n    // detach selected elements and create a new part\n    void DetachSelectedPart();\n\n    FEMesh* ExtractSelectedFaces();\n\n    void DeleteTaggedElements(int tag);\n    void DeleteTaggedFaces   (int tag);\n    void DeleteTaggedEdges   (int tag);\n\n    void FindDuplicateFaces(vector&lt;int&gt;&amp; l);\n    void FindDuplicateEdges(vector&lt;int&gt;&amp; l);\n\n    void DeleteSelectedElements();\n    void DeleteSelectedFaces();\n    void DeleteSelectedNodes();\n\n    void InvertTaggedElements(int ntag);\n    void InvertSelectedElements();\n\n    double ShellJacobian(FEElement&amp; el);\n\n    // Remove duplicated elements\n    void RemoveDuplicateElements();\n    //Fix inverted elements\n    void FixinvertedElements();\n    //Fix the reference surface\n    void FixReferenceSurface();\n    //Interpolate shell thickness for elements whose thickness is unknown\n    void InterpolateShellThickness(double);\n    // Remove non-manifold elements\n    void RemoveNonManifoldElements();\n\n    // fix element winding\n    void FixElementWinding();\n    void FixElementWinding2();\n\n    // tag all elements\n    void TagAllElements(int ntag);\n\npublic:\n    int DataFields() { return (int) m_map.size(); }\n    FEElementData* AddDataField(const char* szname, double v = 0.0);\n    FEElementData&amp; GetDataField(int i) { return m_map[i]; }\n\npublic:\n    double ShortestEdge();\n\nprotected:\n    bool IntersectTri (vec3d* y, vec3d x, vec3d n, vec3d&amp; q, double&amp; g);\n    bool IntersectQuad(vec3d* y, vec3d x, vec3d n, vec3d&amp; q, double&amp; g);\n\npublic:\n    void BuildNodeElementTable(vector&lt; vector&lt;int&gt; &gt;&amp; NET);\n    void BuildNodeFaceTable(vector&lt; vector&lt;int&gt; &gt;&amp; NFT);\n    void BuildNodeEdgeTable(vector&lt; vector&lt;int&gt; &gt;&amp; NET);\n    void BuildEdgeTable(vector&lt; pair&lt;int, int&gt; &gt;&amp; ET);\n    void BuildNodeNodeTable(vector&lt; set&lt;int&gt; &gt;&amp; NNT);\n    void BuildSurfaceNodeNodeTable(vector&lt; set&lt;int&gt; &gt;&amp; NNT);\n    void BuildElementEdgeTable(vector&lt; vector&lt;int&gt; &gt;&amp; EET, vector&lt; pair&lt;int, int&gt; &gt;&amp; ET);\n    void BuildFaceTable(vector&lt;FEFace&gt;&amp; FT);\n    void BuildElementFaceTable(vector&lt; vector&lt;int&gt; &gt;&amp; EFT, vector&lt;FEFace&gt;&amp; FT);\n    void BuildFaceEdgeTable(vector&lt; vector&lt;int&gt; &gt;&amp; FET, vector&lt; pair&lt;int, int&gt; &gt;&amp; ET);\n    void BuildFaceFaceTable(vector&lt;int&gt;&amp; FFT, vector&lt;FEFace&gt;&amp; FT);\n    void BuildEdgeEdgeTable(vector&lt;int&gt;&amp; EET, vector&lt; pair&lt;int,int&gt; &gt;&amp; ET);\n\nprotected:\n    // element data\n    std::vector&lt;FEElement&gt;  m_Elem; \n    std::vector&lt;double&gt;     m_data; \n    double  m_min, m_max;       \n\n    // data fields (currently used as material maps)\n    vector&lt;FEElementData&gt;   m_map;\n};\n\nextern int FTHEX8[6][4];\nextern int FTHEX20[6][8];\nextern int FTHEX27[6][9];\nextern int FTPENTA[5][4];\nextern int FTTET[4][3];\nextern int FTTET10[4][6];\nextern int FTTET15[4][7];\n\ndouble bias(double b, double x);\ndouble gain(double g, double x);\n\ndouble area_triangle(vec3d r[3]);\n\n#endif // !defined(AFX_FEMESH_H__CB7EC714_E3FD_46A4_A397_FEFB23429520__INCLUDED_)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FENodeElementList_8h.html","title":"Libs/Mesh/PreviewMeshQC/FENodeElementList.h","text":""},{"location":"api/Files/FENodeElementList_8h.html#classes","title":"Classes","text":"Name class FENodeElementList"},{"location":"api/Files/FENodeElementList_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\nusing namespace std;\n\n#include \"FEMesh.h\"\n\nclass FENodeElementList\n{\npublic:\n    FENodeElementList(FEMesh* pm);\n    ~FENodeElementList();\n\n    void Build();\n\n    int Valence(int n) { return m_val[n]; }\n    FEElement* Element(int n, int j) { return m_pelem[m_off[n] + j]; }\n\nprotected:\n    FEMesh* m_pm;\n\n    vector&lt;int&gt; m_val;\n    vector&lt;int&gt; m_off;\n    vector&lt;FEElement*&gt;  m_pelem;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FENodeFaceList_8h.html","title":"Libs/Mesh/PreviewMeshQC/FENodeFaceList.h","text":""},{"location":"api/Files/FENodeFaceList_8h.html#classes","title":"Classes","text":"Name class FENodeFaceList"},{"location":"api/Files/FENodeFaceList_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\nusing namespace std;\n\n#include \"FEMesh.h\"\n\nclass FENodeFaceList\n{\npublic:\n    FENodeFaceList(FEMesh* pm);\n    ~FENodeFaceList(void);\n\n    void Build();\n    void BuildSorted();\n\n    int Nodes() { return (int) m_node.size(); }\n    FENode&amp; Node(int i) { return m_pm-&gt;Node(m_node[i]); }\n\n    int Valence(int i) { return m_val[i]; }\n    FEFace* Face(int n, int i) { return m_pface[m_off[n] + i]; }\n\n    bool HasFace(int n, FEFace* pf);\n\nprotected:\n    void Sort(int node);\n\nprotected:\n    FEMesh* m_pm;\n    vector&lt;int&gt; m_node;\n    vector&lt;int&gt; m_val;\n    vector&lt;FEFace*&gt; m_pface;\n    vector&lt;int&gt; m_off;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FENodeNodeList_8h.html","title":"Libs/Mesh/PreviewMeshQC/FENodeNodeList.h","text":""},{"location":"api/Files/FENodeNodeList_8h.html#classes","title":"Classes","text":"Name class FENodeNodeList"},{"location":"api/Files/FENodeNodeList_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FEMesh;\n\nclass FENodeNodeList\n{\npublic:\n    FENodeNodeList(FEMesh* pm);\n    ~FENodeNodeList();\n\n    void Build();\n\n    int Valence(int n) { return m_val[n]; }\n    int Node(int n, int j) { return m_node[ m_off[n] + j]; }\n\nprotected:\n    FEMesh* m_pm;\n\n    vector&lt;int&gt; m_val;\n    vector&lt;int&gt; m_off;\n    vector&lt;int&gt; m_node;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEVTKExport_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEVTKExport.h","text":""},{"location":"api/Files/FEVTKExport_8h.html#classes","title":"Classes","text":"Name struct VTKEXPORT class FEVTKExport"},{"location":"api/Files/FEVTKExport_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;ostream&gt;\n\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;vtkPolyData.h&gt;\n\nclass FEMesh;\n\n//-----------------------------------------------------------------------------\nstruct VTKEXPORT\n{\n  bool bshellthick;             // shell thickness\n  bool bscalar_data;            // user scalar data\n};\n\nclass FEVTKExport\n{\npublic:\n  FEVTKExport();\n  ~FEVTKExport() = default;\n\n  bool Export(FEMesh&amp; mesh, const char* szfile);\n  std::string ExportToString(FEMesh&amp; mesh);\n  bool ExportToStream(FEMesh&amp; mesh, std::ostream&amp; out);\n  void SetOptions(VTKEXPORT o) { m_ops = o; }\n\n  vtkSmartPointer&lt;vtkPolyData&gt; ExportToVTK(FEMesh &amp;mesh);\n\nprivate:\n  VTKEXPORT m_ops;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FEVTKImport_8h.html","title":"Libs/Mesh/PreviewMeshQC/FEVTKImport.h","text":""},{"location":"api/Files/FEVTKImport_8h.html#classes","title":"Classes","text":"Name class FEVTKimport"},{"location":"api/Files/FEVTKImport_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\n#include &lt;istream&gt;\nusing namespace std;\n\nclass FEMesh;\nclass vtkPolyData;\n\nclass FEVTKimport\n{\npublic:\n  FEVTKimport();\n  ~FEVTKimport(void);\n\n  FEMesh* Load(const char* szfile);\n\n  FEMesh* Load(istream&amp; stream);\n\n  FEMesh* Load(vtkPolyData *polydata);\n\n\nprotected:\n  bool BuildMesh();\n  FEMesh* errf(const char* sz, ...);\n  void Close();\n\nprivate:\n  FILE*   m_fp;\n\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/FreeFormConstraint_8h.html","title":"Libs/Optimize/Constraints/FreeFormConstraint.h","text":""},{"location":"api/Files/FreeFormConstraint_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/FreeFormConstraint_8h.html#classes","title":"Classes","text":"Name class shapeworks::FreeFormConstraint"},{"location":"api/Files/FreeFormConstraint_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Constraint.h\"\n#include \"Libs/Mesh/Mesh.h\"\n\nclass vtkFloatArray;\n\nnamespace shapeworks {\n\nclass FreeFormConstraint : public Constraint {\n public:\n  FreeFormConstraint() {}\n\n  void setMesh(std::shared_ptr&lt;shapeworks::Mesh&gt; mesh) { mesh_ = mesh; }\n\n  std::shared_ptr&lt;shapeworks::Mesh&gt; getMesh() { return mesh_; }\n\n  bool readyForOptimize() const;\n\n  bool isViolated(const Eigen::Vector3d&amp; pt) const override;\n\n  void print() const override { std::cout &lt;&lt; \"FF\" &lt;&lt; std::endl; }\n\n  Eigen::Vector3d constraintGradient(const Eigen::Vector3d&amp; pt) const override { return mesh_-&gt;getFFCGradient(pt); }\n\n  double constraintEval(const Eigen::Vector3d&amp; pt) const override { return mesh_-&gt;getFFCValue(pt); }\n\n  void setDefinition(vtkSmartPointer&lt;vtkPolyData&gt; polyData);\n\n  vtkSmartPointer&lt;vtkPolyData&gt; getDefinition() { return definitionPolyData_; };\n\n  void applyToPolyData(vtkSmartPointer&lt;vtkPolyData&gt; polyData);\n\n  std::vector&lt;std::vector&lt;Eigen::Vector3d&gt;&gt;&amp; boundaries();\n\n  Eigen::Vector3d getQueryPoint() { return queryPoint_; };\n\n  void setQueryPoint(Eigen::Vector3d queryPoint) { queryPoint_ = queryPoint; };\n\n  void computeBoundaries();\n\n  void setInoutPolyData(vtkSmartPointer&lt;vtkPolyData&gt; polyData) { inoutPolyData_ = polyData; }\n\n  vtkSmartPointer&lt;vtkPolyData&gt; getInoutPolyData() { return inoutPolyData_; };\n\n  void createInoutPolyData();\n\n  bool isSet();\n\n  void setPainted(bool painted);\n\n  void reset();\n\n  void computeGradientFields(std::shared_ptr&lt;Mesh&gt; mesh);\n\n  void convertLegacyFFC(vtkSmartPointer&lt;vtkPolyData&gt; polyData);\n\n\n private:\n\n  vtkSmartPointer&lt;vtkFloatArray&gt; computeInOutForFFCs(vtkSmartPointer&lt;vtkPolyData&gt; polyData, Eigen::Vector3d query,\n                                                     vtkSmartPointer&lt;vtkPolyData&gt; halfmesh);\n\n  std::vector&lt;Eigen::Matrix3d&gt; setGradientFieldForFFCs(std::shared_ptr&lt;Mesh&gt; mesh,\n                                                       vtkSmartPointer&lt;vtkDoubleArray&gt; absvalues, Eigen::MatrixXd V,\n                                                       Eigen::MatrixXi F);\n\n  vtkFloatArray* getInOutScalars();\n  vtkFloatArray* createFFCPaint(vtkSmartPointer&lt;vtkPolyData&gt; polyData);\n\n  std::shared_ptr&lt;shapeworks::Mesh&gt; mesh_;\n\n  vtkSmartPointer&lt;vtkPolyData&gt; definitionPolyData_;\n  bool painted_ = false;\n\n  std::vector&lt;std::vector&lt;Eigen::Vector3d&gt;&gt; boundaries_;\n  Eigen::Vector3d queryPoint_;\n  vtkSmartPointer&lt;vtkPolyData&gt; inoutPolyData_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/GenericContainerArray_8h.html","title":"Libs/Optimize/Container/GenericContainerArray.h","text":""},{"location":"api/Files/GenericContainerArray_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GenericContainerArray_8h.html#classes","title":"Classes","text":"Name class shapeworks::GenericContainerArray This class appears to be an array of GenericContainers (e.g. std::vector) that implements the Observer interface. The array size tracks the number of domains in the system. E.g. one per domain."},{"location":"api/Files/GenericContainerArray_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"GenericContainer.h\"\n#include \"Observer.h\"\n#include \"itkDataObject.h\"\n#include \"ParticleEvents.h\"\n#include \"itkWeakPointer.h\"\n\nnamespace shapeworks {\n\ntemplate &lt;class T&gt;\nclass GenericContainerArray : public std::vector&lt;typename GenericContainer&lt;T&gt;::Pointer&gt;, public Observer {\n public:\n  typedef T DataType;\n  typedef GenericContainerArray Self;\n  typedef Observer Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(GenericContainerArray, Observer);\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp;) {\n    this-&gt;resize(this-&gt;size() + 1);\n    this-&gt;operator[](this-&gt;size() - 1) = GenericContainer&lt;T&gt;::New();\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    this-&gt;operator[](event.GetDomainIndex())-&gt;operator[](event.GetPositionIndex()) = 0.0;\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n  void ZeroAllValues() {\n    for (unsigned d = 0; d &lt; this-&gt;size(); d++) {\n      for (unsigned int i = 0; i &lt; this-&gt;operator[](d)-&gt;GetSize(); i++) {\n        this-&gt;operator[](d)-&gt;operator[](i) = 0.0;\n      }\n    }\n  }\n\n protected:\n  GenericContainerArray() {\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n  }\n  virtual ~GenericContainerArray(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  GenericContainerArray(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);         // purposely not implemented\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/GenericContainer_8h.html","title":"Libs/Optimize/Container/GenericContainer.h","text":""},{"location":"api/Files/GenericContainer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GenericContainer_8h.html#classes","title":"Classes","text":"Name class shapeworks::GenericContainer This class seems to be only a wrapper around std::vector implementing ITK DataObject (for smart pointer?)"},{"location":"api/Files/GenericContainer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;map&gt;\n\n#include \"itkCommand.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass GenericContainer : public itk::DataObject {\n public:\n  typedef T DataType;\n  typedef GenericContainer Self;\n  typedef DataObject Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(GenericContainer, itk::DataObject);\n\n  inline T&amp; operator[](size_t k) {\n    if (k &gt;= data.size()) {\n      data.resize(k + 1);\n    }\n    return data[k];\n  }\n\n  inline T&amp; Get(size_t k) { return (*this)[k]; }\n\n  unsigned long int GetSize() const { return data.size(); }\n\n protected:\n  GenericContainer() {}\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const {\n    Superclass::PrintSelf(os, indent);\n\n    os &lt;&lt; indent &lt;&lt; \"ParticleContainer: \" &lt;&lt; std::endl;\n  }\n  virtual ~GenericContainer(){};\n\n private:\n  GenericContainer(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);     // purposely not implemented\n\n  std::vector&lt;T&gt; data;\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/GradientDescentOptimizer_8h.html","title":"Libs/Optimize/GradientDescentOptimizer.h","text":""},{"location":"api/Files/GradientDescentOptimizer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GradientDescentOptimizer_8h.html#classes","title":"Classes","text":"Name class shapeworks::GradientDescentOptimizer Optimizes particle system positions using gradient descent."},{"location":"api/Files/GradientDescentOptimizer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n\n#include \"EarlyStoppingConfig.h\"\n#include \"Libs/Optimize/Domain/ImageDomainWithGradients.h\"\n#include \"Libs/Optimize/Function/EarlyStop/EarlyStopping.h\"\n#include \"Libs/Optimize/Function/VectorFunction.h\"\n#include \"ParticleSystem.h\"\n\nnamespace shapeworks {\n\nclass GradientDescentOptimizer {\n public:\n  static constexpr unsigned int Dimension = 3;\n\n  using VectorType = VectorFunction::VectorType;\n\n  using PointType = ParticleSystem::PointType;\n\n  void start_optimization() { start_adaptive_gauss_seidel_optimization(); }\n  void start_adaptive_gauss_seidel_optimization();\n  void set_early_stopping_config(const EarlyStoppingConfig&amp; config);\n  void initialize_early_stopping_score_function(const ParticleSystem* p);\n\n  void augmented_lagrangian_constraints(VectorType&amp; gradient, const PointType&amp; pt, const size_t&amp; dom,\n                                        const double&amp; maximum_update_allowed, size_t index);\n\n  void stop_optimization() { stop_optimization_ = true; }\n\n  void abort_processing() {\n    stop_optimization_ = true;\n    abort_processing_ = true;\n  }\n\n  unsigned int get_number_of_iterations() const { return number_of_iterations_; }\n\n  void set_number_of_iterations(unsigned int val) { number_of_iterations_ = val; }\n\n  void set_verbosity(unsigned int val) { verbosity_ = val; }\n\n  unsigned int get_verbosity() const { return verbosity_; }\n\n  double get_time_step() const { return time_step_; }\n\n  void set_time_step(double val) { time_step_ = val; }\n\n  unsigned int get_maximum_number_of_iterations() const { return max_iterations_; }\n\n  void set_maximum_number_of_iterations(unsigned int val) { max_iterations_ = val; }\n\n  double get_tolerance() const { return tolerance_; }\n\n  void set_tolerance(double val) { tolerance_ = val; }\n\n  ParticleSystem* get_particle_system() { return particle_system_.GetPointer(); }\n\n  const ParticleSystem* get_particle_system() const { return particle_system_.GetPointer(); }\n\n  void set_particle_system(ParticleSystem* val) { particle_system_ = val; }\n\n  std::shared_ptr&lt;VectorFunction&gt; get_gradient_function() { return gradient_function_; }\n\n  std::shared_ptr&lt;const VectorFunction&gt; get_gradient_function() const { return gradient_function_; }\n\n  void set_gradient_function(std::shared_ptr&lt;VectorFunction&gt; val) { gradient_function_ = val; }\n\n  void set_initialization_mode(bool b) { initialization_mode_ = b; }\n\n  void set_check_iterations(size_t si) { check_iterations_ = si; }\n\n  void set_initialization_start_scaling_factor(double si) { init_start_scaling_factor_ = si; }\n\n  void set_iteration_callback(std::function&lt;void()&gt; callback) { iteration_callback_ = callback; }\n\n  std::function&lt;void()&gt; get_iteration_callback() const { return iteration_callback_; }\n\n  GradientDescentOptimizer();\n\n  ~GradientDescentOptimizer() = default;\n\n private:\n  GradientDescentOptimizer(const GradientDescentOptimizer&amp;) = delete;\n\n  GradientDescentOptimizer&amp; operator=(const GradientDescentOptimizer&amp;) = delete;\n\n  void reset_time_step_vectors();\n\n  ParticleSystem::Pointer particle_system_;\n  std::shared_ptr&lt;VectorFunction&gt; gradient_function_;\n  bool stop_optimization_ = false;\n  bool abort_processing_ = false;\n  unsigned int number_of_iterations_ = 0;\n  unsigned int max_iterations_ = 0;\n  double tolerance_ = 0.0;\n  double time_step_ = 1.0;\n  std::vector&lt;std::vector&lt;double&gt;&gt; time_steps_;\n  unsigned int verbosity_ = 0;\n  EarlyStopping early_stopping_;\n  bool early_stopping_enabled_ = false;\n  bool early_stopping_score_ready_ = false;\n\n  // Adaptive Initialization variables\n  bool initialization_mode_ = false;\n  size_t check_iterations_ = 50;\n  double init_start_scaling_factor_ = 0.0;\n\n  // Iteration callback\n  std::function&lt;void()&gt; iteration_callback_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/GroomParameters_8h.html","title":"Libs/Groom/GroomParameters.h","text":""},{"location":"api/Files/GroomParameters_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GroomParameters_8h.html#classes","title":"Classes","text":"Name class shapeworks::GroomParameters struct shapeworks::GroomParameters::SharedBoundary"},{"location":"api/Files/GroomParameters_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Project/Project.h&gt;\n\nnamespace shapeworks {\n\nclass GroomParameters {\n public:\n  struct SharedBoundary {\n    std::string first_domain;\n    std::string second_domain;\n    double tolerance;\n\n    // Helper methods for serialization\n    std::string to_string() const;\n    static SharedBoundary from_string(const std::string&amp; str);\n  };\n\n  enum class MeshSmoothingOption { laplacian, sinc };\n\n  enum class AlignmentOption { none, center, icp };\n\n public:\n  explicit GroomParameters(ProjectHandle project, std::string domain_name = \"\");\n  void set_domain_name(std::string domain_name);\n  void save_to_project();\n\n  std::string get_groom_output_prefix();\n  void set_groom_output_prefix(std::string prefix);\n\n  bool get_groom_all_domains_the_same();\n  void set_groom_all_domains_the_same(bool value);\n\n  bool get_alignment_enabled();\n  void set_alignment_enabled(bool value);\n\n  std::string get_alignment_method();\n  void set_alignment_method(std::string method);\n\n  int get_alignment_reference();\n  void set_alignment_reference(int reference);\n\n  int get_alignment_reference_chosen();\n  void set_alignment_reference_chosen(int reference);\n\n  int get_alignment_subset_size();\n  void set_alignment_subset_size(int size);\n\n  bool get_isolate_tool();\n  void set_isolate_tool(bool value);\n\n  bool get_fill_holes_tool();\n  void set_fill_holes_tool(bool value);\n\n  bool get_fill_mesh_holes_tool();\n  void set_fill_mesh_holes_tool(bool value);\n\n  bool get_auto_pad_tool();\n  void set_auto_pad_tool(bool value);\n\n  int get_padding_amount();\n  void set_padding_amount(int padding_amount);\n\n  bool get_antialias_tool();\n  void set_antialias_tool(bool value);\n\n  int get_antialias_iterations();\n  void set_antialias_iterations(int iterations);\n\n  bool get_blur_tool();\n  void set_blur_tool(bool value);\n\n  double get_blur_amount();\n  void set_blur_amount(double blur_amount);\n\n  bool get_fast_marching();\n  void set_fast_marching(bool value);\n\n  bool get_mesh_smooth();\n  void set_mesh_smooth(bool value);\n\n  std::string get_mesh_smoothing_method();\n  void set_mesh_smoothing_method(std::string method);\n\n  int get_mesh_vtk_laplacian_iterations();\n  void set_mesh_vtk_laplacian_iterations(int iterations);\n\n  double get_mesh_vtk_laplacian_relaxation();\n  void set_mesh_vtk_laplacian_relaxation(double relaxation);\n\n  int get_mesh_vtk_windowed_sinc_iterations();\n  void set_mesh_vtk_windowed_sinc_iterations(int iterations);\n\n  double get_mesh_vtk_windowed_sinc_passband();\n  void set_mesh_vtk_windowed_sinc_passband(double passband);\n\n  bool get_use_icp();\n  bool get_use_center();\n  bool get_use_landmarks();\n\n  bool get_crop();\n  void set_crop(bool crop);\n\n  bool get_convert_to_mesh();\n  void set_convert_to_mesh(bool value);\n\n  // reflection\n  bool get_reflect();\n  void set_reflect(bool reflect);\n  std::string get_reflect_column();\n  void set_reflect_column(std::string column);\n  std::string get_reflect_choice();\n  void set_reflect_choice(std::string choice);\n  std::string get_reflect_axis();\n  void set_reflect_axis(std::string axies);\n\n  // resampling\n  bool get_resample();\n  void set_resample(bool resample);\n  bool get_isotropic();\n  void set_isotropic(bool isotropic);\n  double get_iso_spacing();\n  void set_iso_spacing(double spacing);\n  std::vector&lt;double&gt; get_spacing();\n  void set_spacing(std::vector&lt;double&gt; spacing);\n\n  bool get_remesh();\n  void set_remesh(bool remesh);\n\n  bool get_remesh_percent_mode();\n  void set_remesh_percent_mode(bool mode);\n\n  double get_remesh_percent();\n  void set_remesh_percent(double percent);\n\n  int get_remesh_num_vertices();\n  void set_remesh_num_vertices(int num_vertices);\n\n  double get_remesh_gradation();\n  void set_remesh_gradation(double gradation);\n\n  bool get_skip_grooming();\n  void set_skip_grooming(bool skip);\n\n  bool get_shared_boundaries_enabled();\n  void set_shared_boundaries_enabled(bool enabled);\n\n  std::vector&lt;SharedBoundary&gt; get_shared_boundaries();\n  void set_shared_boundaries(const std::vector&lt;SharedBoundary&gt;&amp; boundaries);\n  void add_shared_boundary(const std::string&amp; first_domain, const std::string&amp; second_domain, double tolerance);\n  void remove_shared_boundary(size_t index);\n  void clear_shared_boundaries();\n\n  void restore_defaults();\n\n  Parameters get_parameters() const { return params_; }\n\n  // constants\n  const static std::string GROOM_SMOOTH_VTK_LAPLACIAN_C;\n  const static std::string GROOM_SMOOTH_VTK_WINDOWED_SINC_C;\n\n  const static std::string GROOM_ALIGNMENT_CENTER_C;\n  const static std::string GROOM_ALIGNMENT_ICP_C;\n  const static std::string GROOM_ALIGNMENT_LANDMARK_C;\n\n private:\n  Parameters params_;\n  ProjectHandle project_;\n  std::string domain_name_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/GroomTool_8h.html","title":"Studio/Groom/GroomTool.h","text":""},{"location":"api/Files/GroomTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GroomTool_8h.html#classes","title":"Classes","text":"Name class shapeworks::GroomTool"},{"location":"api/Files/GroomTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Data/Telemetry.h&gt;\n#include &lt;Groom/Groom.h&gt;\n#include &lt;Groom/GroomParameters.h&gt;\n\n#include &lt;QElapsedTimer&gt;\n#include &lt;QObject&gt;\n#include &lt;QProgressDialog&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n#include &lt;string&gt;\n\nclass Ui_GroomTool;\n\nQ_DECLARE_METATYPE(std::string)\n\nnamespace shapeworks {\n\nclass Session;\n\nclass GroomTool : public QWidget {\n  Q_OBJECT;\n\n public:\n  GroomTool(Preferences&amp; prefs, Telemetry&amp; telemetry);\n  ~GroomTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void activate();\n\n  void load_params();\n  void store_params();\n\n  void disable_actions();\n  void enable_actions();\n\n  void shutdown_threads();\n\n Q_SIGNALS:\n  void groom_start();\n  void groom_complete();\n  void progress(int);\n\n public Q_SLOTS:\n\n  void on_antialias_checkbox_stateChanged(int state);\n  void on_blur_checkbox_stateChanged(int state);\n  void on_autopad_checkbox_stateChanged(int state);\n  void skip_grooming_toggled();\n  void on_restore_defaults_clicked();\n\n  void update_ui();\n\n  void domain_changed();\n\n  void alignment_checkbox_changed(int state);\n  void alignment_option_changed(int index);\n\n  void reflect_checkbox_changed(int state);\n  void reflect_column_changed(int index);\n  void reflect_choice_changed(int index);\n  void reflect_axis_changed(int index);\n\n  void on_run_groom_button_clicked();\n\n  void handle_thread_complete();\n  void handle_progress(int val);\n  void handle_error(QString msg);\n\n  void add_shared_boundary_clicked();\n  void delete_shared_boundary_clicked();\n\n private:\n  void set_ui_from_params(GroomParameters params);\n\n  void update_page();\n  void update_domain_box();\n  void apply_to_all_domains_changed();\n  void update_shared_boundary_table();\n\n  void update_reflect_columns();\n  void update_reflect_choices();\n\n  void set_session_modified();\n\n  Preferences&amp; preferences_;\n  Telemetry&amp; telemetry_;\n\n  QList&lt;QThread*&gt; threads_;\n\n  Ui_GroomTool* ui_;\n  QSharedPointer&lt;Session&gt; session_;\n\n  QSharedPointer&lt;shapeworks::Groom&gt; groom_;\n\n  QElapsedTimer timer_;\n\n  bool groom_is_running_ = false;\n\n  std::string current_domain_;\n\n  QStringList reflect_columns_;\n\n  bool block_signals_ = false;\n\n  bool block_session_modify_ = false;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Groom_8h.html","title":"Libs/Groom/Groom.h","text":""},{"location":"api/Files/Groom_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Groom_8h.html#classes","title":"Classes","text":"Name class shapeworks::Groom High level groom API."},{"location":"api/Files/Groom_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Image/Image.h&gt;\n#include &lt;Project/Project.h&gt;\n\n#include \"GroomParameters.h\"\n\nnamespace shapeworks {\n\n\nclass Groom {\n public:\n  Groom(ProjectHandle project);\n\n  bool run();\n\n  void abort();\n\n  bool get_aborted();\n\n  static double compute_landmark_distance(vtkSmartPointer&lt;vtkPoints&gt; one, vtkSmartPointer&lt;vtkPoints&gt; two);\n\n  static vtkSmartPointer&lt;vtkMatrix4x4&gt; compute_landmark_transform(vtkSmartPointer&lt;vtkPoints&gt; source,\n                                                                  vtkSmartPointer&lt;vtkPoints&gt; target);\n\n protected:\n  std::atomic&lt;float&gt; progress_ = 0;\n  std::atomic&lt;int&gt; total_ops_ = 0;\n  std::atomic&lt;int&gt; progress_counter_ = 0;\n\n private:\n  enum class MeshSource { Original, Groomed };\n\n  int get_total_ops();\n\n  void increment_progress(int amount = 1);\n\n  bool image_pipeline(std::shared_ptr&lt;Subject&gt; subject, size_t domain);\n\n  bool run_image_pipeline(Image&amp; image, GroomParameters params);\n\n  bool mesh_pipeline(std::shared_ptr&lt;Subject&gt; subject, size_t domain);\n\n  bool run_mesh_pipeline(Mesh&amp; mesh, GroomParameters params, const std::string&amp; filename);\n\n  bool contour_pipeline(std::shared_ptr&lt;Subject&gt; subject, size_t domain);\n\n  std::string get_output_filename(std::string input, DomainType domain_type);\n\n  bool run_alignment();\n\n  bool run_shared_boundaries();\n\n  void clear_unused_shared_boundaries();\n\n  void assign_transforms(std::vector&lt;std::vector&lt;double&gt;&gt; transforms, int domain, bool global = false);\n\n  Mesh check_and_fix_mesh(Mesh&amp; mesh, const std::string&amp; step, const std::string&amp; filename);\n\n  static std::vector&lt;std::vector&lt;double&gt;&gt; get_icp_transforms(const std::vector&lt;Mesh&gt; meshes, Mesh reference);\n  static std::vector&lt;std::vector&lt;double&gt;&gt; get_landmark_transforms(\n      const std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; landmarks, size_t reference);\n\n  static std::vector&lt;double&gt; get_identity_transform();\n  static void add_reflect_transform(vtkSmartPointer&lt;vtkTransform&gt; transform, const std::string&amp; reflect_axis);\n  static void add_center_transform(vtkSmartPointer&lt;vtkTransform&gt; transform, const Image&amp; image);\n  static void add_center_transform(vtkSmartPointer&lt;vtkTransform&gt; transform, const Mesh&amp; mesh);\n  static void add_center_transform(vtkSmartPointer&lt;vtkTransform&gt; transform, vtkSmartPointer&lt;vtkPoints&gt; points);\n\n  std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; get_combined_points();\n\n  Mesh get_mesh(int subject, int domain, bool transformed = false, MeshSource source = MeshSource::Groomed);\n\n  vtkSmartPointer&lt;vtkPoints&gt; get_landmarks(int subject, int domain);\n\n  int find_reference_landmarks(std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; landmarks);\n\n  void fix_origin(Image&amp; image);\n\n  bool verbose_ = false;\n\n  ProjectHandle project_;\n\n  bool abort_ = false;\n\n  std::mutex mutex_;\n\n  std::set&lt;std::string&gt; used_names_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/GroupPvalueJob_8h.html","title":"Studio/Job/GroupPvalueJob.h","text":""},{"location":"api/Files/GroupPvalueJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/GroupPvalueJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::GroupPvalueJob"},{"location":"api/Files/GroupPvalueJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Job/Job.h&gt;\n\n#include &lt;ParticleShapeStatistics.h&gt;\n\nnamespace shapeworks {\n\nclass GroupPvalueJob : public Job {\n  Q_OBJECT\npublic:\n\n  GroupPvalueJob(ParticleShapeStatistics stats);\n  void run() override;\n  QString name() override;\n\n  Eigen::VectorXd get_group_pvalues();\n\nprivate:\n\n  ParticleShapeStatistics stats_;\n  Eigen::VectorXd group_pvalues_;\n\n};\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageDomainWithCurvature_8h.html","title":"Libs/Optimize/Domain/ImageDomainWithCurvature.h","text":""},{"location":"api/Files/ImageDomainWithCurvature_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageDomainWithCurvature_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageDomainWithCurvature"},{"location":"api/Files/ImageDomainWithCurvature_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ImageDomainWithGradN.h\"\n#include \"Logging.h\"\n#include \"itkDiscreteGaussianImageFilter.h\"\n#include \"itkImageRegionIterator.h\"\n#include \"itkImageRegionIteratorWithIndex.h\"\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass ImageDomainWithCurvature : public ImageDomainWithGradN&lt;T&gt; {\n public:\n  typedef ImageDomainWithGradN&lt;T&gt; Superclass;\n\n  typedef typename Superclass::PointType PointType;\n  typedef typename Superclass::ImageType ImageType;\n  typedef typename Superclass::VnlMatrixType VnlMatrixType;\n\n  void SetImage(ImageType* I, double narrow_band) {\n    // Computes partial derivatives in parent class\n    Superclass::SetImage(I, narrow_band);\n    m_VDBCurvature = openvdb::tools::meanCurvature(*this-&gt;GetVDBImage());\n    this-&gt;ComputeSurfaceStatistics(I);\n  }\n\n  double GetCurvature(const PointType&amp; p, int idx) const override {\n    if (this-&gt;m_FixedDomain) {\n      return 0;\n    }\n    const auto coord = this-&gt;ToVDBCoord(p);\n    return openvdb::tools::BoxSampler::sample(m_VDBCurvature-&gt;tree(), coord);\n  }\n\n  inline double GetSurfaceMeanCurvature() const override { return m_SurfaceMeanCurvature; }\n\n  inline double GetSurfaceStdDevCurvature() const override { return m_SurfaceStdDevCurvature; }\n\n protected:\n  ImageDomainWithCurvature() {}\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const {\n    Superclass::PrintSelf(os, indent);\n    os &lt;&lt; indent &lt;&lt; \"VDB Active Voxels = \" &lt;&lt; m_VDBCurvature-&gt;activeVoxelCount() &lt;&lt; std::endl;\n  }\n  virtual ~ImageDomainWithCurvature(){};\n\n private:\n  openvdb::FloatGrid::Ptr m_VDBCurvature;\n\n  // Cache surface statistics\n  double m_SurfaceMeanCurvature;\n  double m_SurfaceStdDevCurvature;\n\n  void ComputeSurfaceStatistics(ImageType* I) {\n    // TODO: This computation is copied from itkParticleMeanCurvatureAttribute\n    // Since the entire Image is not available after the initial load, its simplest\n    // to calculate it now. But it should be a part of itkParticleMeanCurvatureAttribute\n\n    // Loop through a zero crossing image, project all the zero crossing points\n    // to the surface, and use those points to comput curvature stats.\n    typedef itk::ZeroCrossingImageFilter&lt;ImageType, ImageType&gt; ZeroCrossingImageFilterType;\n    typename ZeroCrossingImageFilterType::Pointer zc = ZeroCrossingImageFilterType::New();\n\n    zc-&gt;SetInput(I);\n    zc-&gt;Update();\n\n    itk::ImageRegionConstIteratorWithIndex&lt;ImageType&gt; it(zc-&gt;GetOutput(), zc-&gt;GetOutput()-&gt;GetRequestedRegion());\n    std::vector&lt;double&gt; datalist;\n    m_SurfaceMeanCurvature = 0.0;\n    m_SurfaceStdDevCurvature = 0.0;\n\n    for (; !it.IsAtEnd(); ++it) {\n      if (it.Get() == 1.0) {\n        // Find closest pixel location to surface.\n        PointType pos;\n        // dynamic_cast&lt;const DomainType\n        //*&gt;(system-&gt;GetDomain(d))-&gt;GetImage()-&gt;TransformIndexToPhysicalPoint(it.GetIndex(), pos);\n        I-&gt;TransformIndexToPhysicalPoint(it.GetIndex(), pos);\n\n        // Project point to surface.\n        // Make sure constraints are enabled\n        //      bool c = domain-&gt;GetConstraintsEnabled();\n\n        //      domain-&gt;EnableConstraints();\n        this-&gt;ApplyConstraints(pos);\n\n        //      domain-&gt;SetConstraintsEnabled(c);\n\n        // Compute curvature at point.\n        //      std::cout &lt;&lt; \"pos : \" &lt;&lt; pos[0] &lt;&lt; ' ' &lt;&lt; pos[1] &lt;&lt; ' ' &lt;&lt; pos[2] &lt;&lt; std::endl;\n        double mc = this-&gt;GetCurvature(pos, -1);\n        m_SurfaceMeanCurvature += mc;\n        datalist.push_back(mc);\n      }\n    }\n    double n = static_cast&lt;double&gt;(datalist.size());\n    m_SurfaceMeanCurvature /= n;\n\n    // Compute std deviation using point list\n    for (unsigned int i = 0; i &lt; datalist.size(); i++) {\n      m_SurfaceStdDevCurvature += (datalist[i] - m_SurfaceMeanCurvature) * (datalist[i] - m_SurfaceMeanCurvature);\n    }\n    m_SurfaceStdDevCurvature = sqrt(m_SurfaceStdDevCurvature / (n - 1));\n  }\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageDomainWithGradN_8h.html","title":"Libs/Optimize/Domain/ImageDomainWithGradN.h","text":""},{"location":"api/Files/ImageDomainWithGradN_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageDomainWithGradN_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageDomainWithGradN"},{"location":"api/Files/ImageDomainWithGradN_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ImageDomainWithGradients.h\"\n#include \"itkDerivativeImageFilter.h\"\n#include \"itkDiscreteGaussianImageFilter.h\"\n#include \"itkFixedArray.h\"\n#include \"itkGradientImageFilter.h\"\n#include \"itkImage.h\"\n#include \"itkImageDuplicator.h\"\n#include \"vnl/vnl_matrix_fixed.h\"\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass ImageDomainWithGradN : public ImageDomainWithGradients&lt;T&gt; {\n public:\n  typedef ImageDomainWithGradients&lt;T&gt; Superclass;\n  using Pointer = std::shared_ptr&lt;ImageDomainWithGradN&gt;;\n\n  typedef typename Superclass::PointType PointType;\n  typedef typename Superclass::ImageType ImageType;\n\n  typedef typename Superclass::GradNType GradNType;\n  typedef typename Superclass::GradNType VnlMatrixType;\n\n  void SetImage(ImageType* I, double narrow_band) {\n    Superclass::SetImage(I, narrow_band);\n\n    const auto grad = this-&gt;GetVDBGradient();\n\n    // Compute the gradient of normals component-wise\n    for (int i = 0; i &lt; 3; i++) {\n      auto norm_i = openvdb::FloatGrid::create();\n      norm_i-&gt;setTransform(this-&gt;transform());\n      auto norm_i_accessor = norm_i-&gt;getAccessor();\n      for (openvdb::VectorGrid::ValueOnCIter it = grad-&gt;cbeginValueOn(); it.test(); ++it) {\n        const openvdb::Vec3f&amp; v = *it;\n        norm_i_accessor.setValue(it.getCoord(), v[i] / v.length());\n      }\n\n      m_VDBGradNorms[i] = openvdb::tools::gradient(*norm_i);\n    }\n  }  // end setimage\n\n  inline GradNType SampleGradNAtPoint(const PointType&amp; p, int idx) const override {\n    const auto coord = this-&gt;ToVDBCoord(p);\n\n    GradNType grad_n;\n    for (int i = 0; i &lt; 3; i++) {\n      auto grad_ni = openvdb::tools::BoxSampler::sample(m_VDBGradNorms[i]-&gt;tree(), coord);\n      grad_n.set(i, 0, grad_ni[0]);\n      grad_n.set(i, 1, grad_ni[1]);\n      grad_n.set(i, 2, grad_ni[2]);\n    }\n    return grad_n;\n  }\n\n  void DeletePartialDerivativeImages() override {\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n      m_VDBGradNorms[i] = 0;\n    }\n  }\n\n  void DeleteImages() override {\n    Superclass::DeleteImages();\n    DeletePartialDerivativeImages();\n  }\n\n protected:\n  ImageDomainWithGradN() {}\n  virtual ~ImageDomainWithGradN(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  typename openvdb::VectorGrid::Ptr m_VDBGradNorms[3];\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageDomainWithGradients_8h.html","title":"Libs/Optimize/Domain/ImageDomainWithGradients.h","text":""},{"location":"api/Files/ImageDomainWithGradients_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageDomainWithGradients_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageDomainWithGradients"},{"location":"api/Files/ImageDomainWithGradients_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ImageDomain.h\"\n#include \"itkFixedArray.h\"\n#include \"itkGradientImageFilter.h\"\n#include \"itkImage.h\"\n#include \"itkImageDuplicator.h\"\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass ImageDomainWithGradients : public ImageDomain&lt;T&gt; {\n public:\n  using Pointer = std::shared_ptr&lt;ImageDomainWithGradients&lt;T&gt;&gt;;\n\n  typedef typename ImageDomain&lt;T&gt;::PointType PointType;\n  typedef typename ImageDomain&lt;T&gt;::ImageType ImageType;\n\n  typedef itk::FixedArray&lt;T, DIMENSION&gt; VectorType;\n  typedef vnl_vector_fixed&lt;T, DIMENSION&gt; VnlVectorType;\n\n  void SetImage(ImageType* I, double narrow_band) {\n    ImageDomain&lt;T&gt;::SetImage(I, narrow_band);\n    m_VDBGradient = openvdb::tools::gradient(*this-&gt;GetVDBImage());\n  }\n\n  inline vnl_vector_fixed&lt;float, DIMENSION&gt; SampleGradientAtPoint(const PointType&amp; p, int idx) const {\n    return this-&gt;SampleGradientVnl(p, idx);\n  }\n\n  inline vnl_vector_fixed&lt;float, DIMENSION&gt; SampleNormalAtPoint(const PointType&amp; p, int idx) const {\n    vnl_vector_fixed&lt;float, DIMENSION&gt; grad = this-&gt;SampleGradientVnl(p, idx);\n    return grad.normalize();\n  }\n\n  vnl_vector_fixed&lt;double, DIMENSION&gt; ProjectVectorToSurfaceTangent(vnl_vector_fixed&lt;double, DIMENSION&gt;&amp; gradE,\n                                                                    const PointType&amp; pos, int idx) const override {\n    double dotprod = 0.0;\n    VnlVectorType normal = this-&gt;SampleNormalAtPoint(pos, idx);\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n      dotprod += normal[i] * gradE[i];\n    }\n    vnl_vector_fixed&lt;double, DIMENSION&gt; result;\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n      result[i] = gradE[i] - normal[i] * dotprod;\n    }\n    return result;\n  }\n\n  void DeleteImages() override {\n    ImageDomain&lt;T&gt;::DeleteImages();\n    m_VDBGradient = 0;\n  }\n\n protected:\n  ImageDomainWithGradients() {}\n  virtual ~ImageDomainWithGradients() {}\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const {\n    ImageDomain&lt;T&gt;::PrintSelf(os, indent);\n    os &lt;&lt; indent &lt;&lt; \"VDB Active Voxels = \" &lt;&lt; m_VDBGradient-&gt;activeVoxelCount() &lt;&lt; std::endl;\n  }\n\n  openvdb::VectorGrid::Ptr GetVDBGradient() { return m_VDBGradient; }\n\n private:\n  inline VnlVectorType SampleGradientVnl(const PointType&amp; p, int idx) const {\n    return VnlVectorType(this-&gt;SampleGradient(p, idx).GetDataPointer());\n  }\n  inline VectorType SampleGradient(const PointType&amp; p, int idx) const {\n    if (this-&gt;IsInsideBuffer(p)) {\n      const auto coord = this-&gt;ToVDBCoord(p);\n      const auto _v = openvdb::tools::BoxSampler::sample(m_VDBGradient-&gt;tree(), coord);\n      const VectorType v(_v.asPointer());  // This copies 3 floats from a VDB vector to a vnl vector\n      return v;\n    } else {\n      std::ostringstream message;\n      message &lt;&lt; \"Gradient queried for a Point, \" &lt;&lt; p &lt;&lt; \", outside the given image domain.\";\n      throw std::runtime_error(message.str());\n    }\n  }\n\n  openvdb::VectorGrid::Ptr m_VDBGradient;\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageDomain_8h.html","title":"Libs/Optimize/Domain/ImageDomain.h","text":""},{"location":"api/Files/ImageDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageDomain"},{"location":"api/Files/ImageDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkImage.h&gt;\n#include &lt;itkImageRegionConstIteratorWithIndex.h&gt;\n#include &lt;itkImageToVTKImageFilter.h&gt;\n#include &lt;itkZeroCrossingImageFilter.h&gt;\n#include &lt;vtkContourFilter.h&gt;\n#include &lt;vtkMassProperties.h&gt;\n\n#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n\n#include \"ParticleRegionDomain.h\"\n\n// we have to undef foreach here because both Qt and OpenVDB define foreach\n#undef foreach\n#ifndef Q_MOC_RUN\n#include &lt;openvdb/math/Math.h&gt;\n#include &lt;openvdb/math/Transform.h&gt;\n#include &lt;openvdb/openvdb.h&gt;\n#include &lt;openvdb/tools/GridOperators.h&gt;\n#include &lt;openvdb/tools/Interpolation.h&gt;\n#include &lt;openvdb/tools/SignedFloodFill.h&gt;\n#endif\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass ImageDomain : public ParticleRegionDomain {\n public:\n  using Pointer = std::shared_ptr&lt;ImageDomain&gt;;\n\n  using ImageType = itk::Image&lt;T, DIMENSION&gt;;\n\n  using PointType = ParticleRegionDomain::PointType;\n\n  void SetImage(ImageType* I, double narrow_band) {\n    this-&gt;m_FixedDomain = false;\n    // this-&gt;Modified();\n\n    openvdb::initialize();  // It is safe to initialize multiple times.\n\n    // Set a large background value, so that we quickly catch particles outside or on the edge the narrow band.\n    // (Downside: its more difficult to display the correct location of the point of failure.)\n    m_VDBImage = openvdb::FloatGrid::create(1e8);\n    m_VDBImage-&gt;setGridClass(openvdb::GRID_LEVEL_SET);\n    auto vdbAccessor = m_VDBImage-&gt;getAccessor();\n\n    // Save properties of the Image needed for the optimizer\n    m_Size = I-&gt;GetRequestedRegion().GetSize();\n    m_Spacing = I-&gt;GetSpacing();\n    m_Origin = I-&gt;GetOrigin();\n    m_Index = I-&gt;GetRequestedRegion().GetIndex();\n\n    // Transformation from index space to world space\n    openvdb::math::Mat4f mat;\n    mat.setIdentity();\n    mat.postScale(openvdb::Vec3f(m_Spacing[0], m_Spacing[1], m_Spacing[2]));\n    mat.postTranslate(openvdb::Vec3f(m_Origin[0], m_Origin[1], m_Origin[2]));\n    const auto xform = openvdb::math::Transform::createLinearTransform(mat);\n    m_VDBImage-&gt;setTransform(xform);\n\n    itk::ImageRegionIterator&lt;ImageType&gt; it(I, I-&gt;GetRequestedRegion());\n    it.GoToBegin();\n\n    while (!it.IsAtEnd()) {\n      const auto idx = it.GetIndex();\n      const auto pixel = it.Get();\n      if (abs(pixel) &gt; narrow_band) {\n        ++it;\n        continue;\n      }\n      const auto coord = openvdb::Coord(idx[0], idx[1], idx[2]);\n      vdbAccessor.setValue(coord, pixel);\n      ++it;\n    }\n\n    typename ImageType::PointType l0;\n    I-&gt;TransformIndexToPhysicalPoint(m_Index, l0);\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) m_Index[i] += m_Size[i] - 1;\n\n    typename ImageType::PointType u0;\n    I-&gt;TransformIndexToPhysicalPoint(m_Index, u0);\n\n    // Cast points to higher precision if needed.  Parent class uses doubles\n    // because they are compared directly with points in the particle system,\n    // which are always double precision.\n    PointType l;\n    PointType u;\n\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n      l[i] = static_cast&lt;double&gt;(l0[i]);\n      u[i] = static_cast&lt;double&gt;(u0[i]);\n    }\n\n    this-&gt;SetLowerBound(l);\n    this-&gt;SetUpperBound(u);\n\n    // Precompute and save values that are used in parts of the optimizer\n    this-&gt;SetupImageForCrossingPointUpdate(I);  // this-&gt;UpdateZeroCrossingPoint(I);\n    this-&gt;UpdateSurfaceArea(I);\n  }\n\n  inline double GetSurfaceArea() const override {\n    throw std::runtime_error(\"Surface area is not computed currently.\");\n    return m_SurfaceArea;\n  }\n\n  inline PointType GetOrigin() const { return m_Origin; }\n\n  inline typename ImageType::SizeType GetSize() const { return m_Size; }\n\n  inline typename ImageType::SpacingType GetSpacing() const { return m_Spacing; }\n\n  inline typename ImageType::RegionType::IndexType GetIndex() const { return m_Index; }\n\n  inline PointType GetValidLocationNear(PointType p) const override {\n    // todo why is this function ignoring the argument? Also see Optimize::AddSinglePoint\n    return m_ZeroCrossingPoint;\n  }\n\n  inline T Sample(const PointType&amp; p) const {\n    if (this-&gt;IsInsideBuffer(p)) {\n      const auto coord = this-&gt;ToVDBCoord(p);\n      return openvdb::tools::BoxSampler::sample(m_VDBImage-&gt;tree(), coord);\n    } else {\n      std::ostringstream message;\n      message &lt;&lt; \"Domain \" &lt;&lt; m_DomainID &lt;&lt; \": \" &lt;&lt; m_DomainName &lt;&lt; \" : Distance transform queried for a Point, \" &lt;&lt; p\n              &lt;&lt; \", outside the given image domain. Consider increasing the padding in grooming or the narrow band optimization parameter\";\n      throw std::runtime_error(message.str());\n    }\n  }\n\n  inline double GetMaxDiameter() const override {\n    double bestRadius = 0;\n    double maxdim = 0;\n    for (unsigned int i = 0; i &lt; ImageType::ImageDimension; i++) {\n      if (GetSize()[i] &gt; maxdim) {\n        maxdim = GetSize()[i];\n        bestRadius = maxdim * GetSpacing()[i];\n      }\n    }\n    return bestRadius;\n  }\n\n  void DeleteImages() override { m_VDBImage = 0; }\n\n  // Updates zero crossing points. Raster scans candidate zero crossing points, and finds one that does not violate any\n  // constraints.\n  void UpdateZeroCrossingPoint() override {\n    for (size_t i = 0; i &lt; m_possible_zero_crossings.size(); i++) {\n      this-&gt;m_ZeroCrossingPoint = m_possible_zero_crossings[i];\n      if (!this-&gt;GetConstraints()-&gt;isAnyViolated(this-&gt;m_ZeroCrossingPoint)) {\n        // std::cout &lt;&lt; \"Chosen initial point \" &lt;&lt; this-&gt;m_ZeroCrossingPoint &lt;&lt; std::endl;\n        break;\n      }\n    }\n\n    if (this-&gt;GetConstraints()-&gt;isAnyViolated(this-&gt;m_ZeroCrossingPoint)) {\n      std::cerr &lt;&lt; \"A particle initialization violates at least one constraint. Make sure at least one point satisfies \"\n                   \"all constraints\"\n                &lt;&lt; std::endl;\n    }\n  }\n\n protected:\n  openvdb::FloatGrid::Ptr GetVDBImage() const { return m_VDBImage; }\n\n  ImageDomain() {}\n  virtual ~ImageDomain(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const {\n    ParticleRegionDomain::PrintSelf(os, indent);\n    os &lt;&lt; indent &lt;&lt; \"VDB Active Voxels = \" &lt;&lt; m_VDBImage-&gt;activeVoxelCount() &lt;&lt; std::endl;\n  }\n\n  inline openvdb::math::Transform::Ptr transform() const { return this-&gt;m_VDBImage-&gt;transformPtr(); }\n\n  // Converts a coordinate from an ITK Image point in world space to the corresponding\n  // coordinate in OpenVDB Index space. Raises an exception if the narrow band is not\n  // sufficiently large to sample the point.\n  inline openvdb::Vec3R ToVDBCoord(const PointType&amp; p) const {\n    const auto worldCoord = openvdb::Vec3R(p[0], p[1], p[2]);\n    const auto idxCoord = this-&gt;transform()-&gt;worldToIndex(worldCoord);\n\n    // Make sure the coordinate is part of the narrow band\n    if (m_VDBImage-&gt;tree().isValueOff(\n            openvdb::Coord::round(idxCoord))) {  // `isValueOff` requires an integer coordinate\n      // If multiple threads crash here at the same time, the error message displayed is just \"terminate called\n      // recursively\", which isn't helpful. So we std::cerr the error to make sure its printed to the console.\n      std::cerr &lt;&lt; \"Sampled point outside the narrow band: \" &lt;&lt; p &lt;&lt; std::endl;\n\n      std::ostringstream message;\n      message &lt;&lt; \"Attempt to sample at a point outside the narrow band: \" &lt;&lt; p\n              &lt;&lt; \". Consider increasing the narrow band\";\n      throw std::runtime_error(message.str());\n    }\n\n    return idxCoord;\n  }\n\n private:\n  openvdb::FloatGrid::Ptr m_VDBImage;\n  typename ImageType::SizeType m_Size;\n  typename ImageType::SpacingType m_Spacing;\n  PointType m_Origin;\n  PointType m_ZeroCrossingPoint;\n  typename ImageType::RegionType::IndexType m_Index;  // Index defining the corner of the region\n  double m_SurfaceArea;\n  std::vector&lt;PointType&gt; m_possible_zero_crossings;\n\n  // Computes possible zero crossing points. Later on, one can find the ones that do not violate constraints.\n  void SetupImageForCrossingPointUpdate(ImageType* I) {\n    typename itk::ZeroCrossingImageFilter&lt;ImageType, ImageType&gt;::Pointer zc =\n        itk::ZeroCrossingImageFilter&lt;ImageType, ImageType&gt;::New();\n    zc-&gt;SetInput(I);\n    zc-&gt;Update();\n    typename itk::ImageRegionConstIteratorWithIndex&lt;ImageType&gt; zcIt(zc-&gt;GetOutput(),\n                                                                    zc-&gt;GetOutput()-&gt;GetRequestedRegion());\n\n    for (zcIt.GoToReverseBegin(); !zcIt.IsAtReverseEnd(); --zcIt) {\n      if (zcIt.Get() == 1.0) {\n        PointType pos;\n        I-&gt;TransformIndexToPhysicalPoint(zcIt.GetIndex(), pos);\n        this-&gt;m_ZeroCrossingPoint = pos;\n        m_possible_zero_crossings.push_back(pos);\n      }\n    }\n  }\n\n  void UpdateSurfaceArea(ImageType* I) {\n    // TODO: This code has been copied from Optimize.cpp. It does not work\n    /*\n    typename itk::ImageToVTKImageFilter &lt; ImageType &gt; ::Pointer itk2vtkConnector;\n    itk2vtkConnector = itk::ImageToVTKImageFilter &lt; ImageType &gt; ::New();\n    itk2vtkConnector-&gt;SetInput(I);\n    vtkSmartPointer &lt; vtkContourFilter &gt; ls = vtkSmartPointer &lt; vtkContourFilter &gt; ::New();\n    ls-&gt;SetInputData(itk2vtkConnector-&gt;GetOutput());\n    ls-&gt;SetValue(0, 0.0);\n    ls-&gt;Update();\n    vtkSmartPointer &lt; vtkMassProperties &gt; mp = vtkSmartPointer &lt; vtkMassProperties &gt; ::New();\n    mp-&gt;SetInputData(ls-&gt;GetOutput());\n    mp-&gt;Update();\n    m_SurfaceArea = mp-&gt;GetSurfaceArea();\n    */\n  }\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageLabel_8h.html","title":"Studio/Utils/ImageLabel.h","text":""},{"location":"api/Files/ImageLabel_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageLabel_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageLabel An extention of QLabel especially for scaled images."},{"location":"api/Files/ImageLabel_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QLabel&gt;\n#include &lt;QResizeEvent&gt;\n\nnamespace shapeworks {\n\nclass ImageLabel : public QLabel {\n public:\n  ImageLabel(QWidget *parent) : QLabel(parent) {}\n  void setPixmap(const QPixmap &amp;pixmap) { setPixmap(pixmap, size()); }\n\n protected:\n  void resizeEvent(QResizeEvent *reisze_event) override;\n\n private:\n  void setPixmap(const QPixmap &amp;pixmap, const QSize &amp;size);\n\n private:\n  QPixmap pixmap_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ImageUtils_8h.html","title":"Libs/Image/ImageUtils.h","text":""},{"location":"api/Files/ImageUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImageUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImageUtils Helper functions for image."},{"location":"api/Files/ImageUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkThinPlateSplineKernelTransform.h&gt;\n\n#include \"Image.h\"\n\nnamespace shapeworks {\n\nusing PixelType = float;\nusing ImageType = itk::Image&lt;PixelType, 3&gt;;\n\nclass ImageUtils {\n public:\n  static PhysicalRegion boundingBox(const std::vector&lt;std::string&gt;&amp; filenames, Image::PixelType isoValue = 1.0);\n\n  static PhysicalRegion boundingBox(const std::vector&lt;std::reference_wrapper&lt;const Image&gt;&gt;&amp; images,\n                                    Image::PixelType isoValue = 1.0);\n\n  using TPSTransform = itk::ThinPlateSplineKernelTransform&lt;double, 3&gt;;\n  static TPSTransform::Pointer createWarpTransform(const std::string&amp; source_landmarks_file,\n                                                   const std::string&amp; target_landmarks_file, const int stride = 1);\n\n  static void register_itk_factories();\n\n  static ImageType::Pointer make_axis_aligned(ImageType::Pointer input);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Image_8h.html","title":"Libs/Image/Image.h","text":""},{"location":"api/Files/Image_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Image_8h.html#classes","title":"Classes","text":"Name class shapeworks::Image"},{"location":"api/Files/Image_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;StringUtils.h&gt;\n#include &lt;itkImage.h&gt;\n#include &lt;itkImageRegionIterator.h&gt;\n#include &lt;itkLinearInterpolateImageFunction.h&gt;\n#include &lt;itkStatisticsImageFilter.h&gt;\n#include &lt;vtkImageData.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;limits&gt;\n\n#include \"Region.h\"\n#include \"Shapeworks.h\"\n\nnamespace shapeworks {\n\nclass Mesh;\n\nclass Image {\n public:\n  enum InterpolationType { Linear, NearestNeighbor };\n\n  using PixelType = float;\n  using ImageType = itk::Image&lt;PixelType, 3&gt;;\n  using StatsPtr = itk::StatisticsImageFilter&lt;ImageType&gt;::Pointer;\n  using ImageIterator = itk::ImageRegionIterator&lt;ImageType&gt;;\n  using InterpolatorType = itk::LinearInterpolateImageFunction&lt;ImageType&gt;;\n\n  // constructors and assignment operators //\n  explicit Image(const Dims dims);\n  explicit Image(const std::string&amp; pathname) : itk_image_(read(pathname)) {}\n  explicit Image(ImageType::Pointer imagePtr) : itk_image_(imagePtr) {\n    if (!itk_image_) throw std::invalid_argument(\"null imagePtr\");\n  }\n  explicit Image(const vtkSmartPointer&lt;vtkImageData&gt; vtkImage);\n\n  Image(Image&amp;&amp; img) : itk_image_(nullptr) { this-&gt;itk_image_.Swap(img.itk_image_); }\n  Image(const Image&amp; img) : itk_image_(cloneData(img.itk_image_)) {}\n  Image&amp; operator=(const Image&amp; img);  \n  Image&amp; operator=(Image&amp;&amp; img);       \n\n  operator ImageType::Pointer() { return itk_image_; }\n  ImageType::Pointer getITKImage() const { return itk_image_; }\n\n  vtkSmartPointer&lt;vtkImageData&gt; getVTKImage() const;\n\n  // modification functions //\n\n  Image&amp; operator-();\n\n  Image operator+(const Image&amp; other) const;\n  Image&amp; operator+=(const Image&amp; other);\n\n  Image operator-(const Image&amp; other) const;\n  Image&amp; operator-=(const Image&amp; other);\n\n  Image operator*(const Image&amp; other) const;\n\n  Image operator*(const PixelType x) const;\n  Image&amp; operator*=(const PixelType x);\n\n  Image operator/(const PixelType x) const;\n  Image&amp; operator/=(const PixelType x);\n\n  Image operator+(const PixelType x) const;\n  Image&amp; operator+=(const PixelType x);\n\n  Image operator-(const PixelType x) const;\n  Image&amp; operator-=(const PixelType x);\n\n  Image&amp; antialias(unsigned iterations = 50, double maxRMSErr = 0.01f, int layers = 3);\n\n  Image&amp; recenter();\n\n  Image&amp; resample(const TransformPtr transform, const Point3 origin, const Dims dims, const Vector3 spacing,\n                  const ImageType::DirectionType direction, InterpolationType interp = NearestNeighbor);\n\n  Image&amp; resample(const Vector&amp; physicalSpacing, InterpolationType interp = Linear);\n\n  Image&amp; resample(double isoSpacing = 1.0, InterpolationType interp = Linear);\n\n  Image&amp; resize(Dims logicalDims, InterpolationType interp = Linear);\n\n  Image&amp; pad(int padding, PixelType value = 0.0);\n\n  Image&amp; pad(int padx, int pady, int padz, PixelType value = 0.0);\n\n  Image&amp; pad(IndexRegion&amp; region, PixelType value = 0.0);\n\n  Image&amp; translate(const Vector3&amp; v);\n\n  Image&amp; scale(const Vector3&amp; v);\n\n  Image&amp; rotate(const double angle, const Vector3&amp; axis);\n\n  Image&amp; rotate(const double angle, Axis axis);\n\n  TransformPtr createCenterOfMassTransform();\n\n  TransformPtr createRigidRegistrationTransform(const Image&amp; target_dt, float isoValue = 0.0, unsigned iterations = 20);\n\n  Image&amp; applyTransform(const TransformPtr transform, InterpolationType interp = Linear);\n\n  Image&amp; applyTransform(const TransformPtr transform, const Point3 origin, const Dims dims, const Vector3 spacing,\n                        const ImageType::DirectionType direction, InterpolationType interp = NearestNeighbor);\n\n  Image&amp; applyTransform(const TransformPtr transform, const Image&amp; referenceImage, InterpolationType interp = Linear);\n\n  Image&amp; extractLabel(const PixelType label = 1.0);\n\n  Image&amp; closeHoles(const PixelType foreground = 0.0);\n\n  Image&amp; binarize(PixelType minVal = 0.0, PixelType maxVal = std::numeric_limits&lt;PixelType&gt;::max(),\n                  PixelType innerVal = 1.0, PixelType outerVal = 0.0);\n\n  Image&amp; computeDT(PixelType isoValue = 0.0);\n\n  Image&amp; applyCurvatureFilter(unsigned iterations = 10);\n\n  Image&amp; applyGradientFilter();\n\n  Image&amp; applySigmoidFilter(double alpha = 10.0, double beta = 10.0);\n\n  Image&amp; applyTPLevelSetFilter(const Image&amp; featureImage, double scaling = 20.0);\n\n  Image&amp; topologyPreservingSmooth(float scaling = 20.0, float sigmoidAlpha = 10.5, float sigmoidBeta = 10.0);\n\n  Image&amp; applyIntensityFilter(double minVal, double maxVal);\n\n  Image&amp; gaussianBlur(double sigma = 0.0);\n\n  Image&amp; crop(PhysicalRegion region, const int padding = 0);\n\n  Image&amp; fitRegion(PhysicalRegion region, const PixelType value = 0.0);\n\n  Image&amp; clip(const Plane plane, const PixelType val = 0.0);\n\n  Image&amp; reflect(const Axis&amp; axis);\n\n  Image&amp; setOrigin(Point3 origin = Point3({0, 0, 0}));\n\n  Image&amp; setSpacing(Vector3 spacing);\n\n  Image&amp; setCoordsys(ImageType::DirectionType coordsys);\n\n  Image&amp; isolate();\n\n  // query functions //\n\n  Dims dims() const { return itk_image_-&gt;GetLargestPossibleRegion().GetSize(); }\n\n  Point3 size() const { return toPoint(spacing()) * toPoint(dims()); }\n\n  double get_largest_dimension_size() const;\n\n  Vector spacing() const { return itk_image_-&gt;GetSpacing(); }\n\n  double get_minimum_spacing() const;\n\n  Point3 origin() const { return itk_image_-&gt;GetOrigin(); }\n\n  Point3 center() const { return origin() + size() / 2.0; }\n\n  ImageType::DirectionType coordsys() const { return itk_image_-&gt;GetDirection(); };\n\n  Point3 centerOfMass(PixelType minVal = 0.0, PixelType maxVal = 1.0) const;\n\n  PixelType min();\n\n  PixelType max();\n\n  PixelType mean();\n\n  PixelType std();\n\n  IndexRegion logicalBoundingBox() const;\n\n  PhysicalRegion physicalBoundingBox() const;\n\n  PhysicalRegion physicalBoundingBox(PixelType isovalue) const;\n\n  PhysicalRegion logicalToPhysical(IndexRegion region) const;\n\n  IndexRegion physicalToLogical(PhysicalRegion region) const;\n\n  Point3 logicalToPhysical(const Coord&amp; c) const;\n\n  Coord physicalToLogical(const Point3&amp; p) const;\n\n  bool isInside(const Point3&amp; p) const;\n\n  ImageIterator iterator();\n\n  bool compare(const Image&amp; other, bool verifyall = true, double tolerance = 0.0, double precision = 1e-6) const;\n\n  bool operator==(const Image&amp; other) const { return compare(other); }\n\n  // export functions //\n\n  Image&amp; write(const std::string&amp; filename, bool compressed = true);\n\n  Mesh toMesh(PixelType isovalue) const;\n\n  Image::PixelType evaluate(Point p);\n\n  void paintSphere(Point p, double radius, PixelType value);\n\n  void paintCircle(Point p, double radius, unsigned int axis, PixelType value);\n\n  bool isPainted() const { return painted_; }\n\n  Image&amp; fill(PixelType value);\n\n  bool isDistanceTransform() const;\n\n  static std::vector&lt;std::string&gt; getSupportedTypes() {\n    return {\"nrrd\", \"nii\", \"nii.gz\", \"mhd\", \"tiff\", \"jpeg\", \"jpg\", \"png\", \"dcm\", \"ima\"};\n  }\n\n  static bool isSupportedType(const std::string&amp; filename) {\n    for (const auto&amp; type : Image::getSupportedTypes()) {\n      if (StringUtils::hasSuffix(filename, type)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n private:\n  friend struct SharedCommandData;\n  Image()\n      : itk_image_(nullptr) {\n  }  // only for use by SharedCommandData since an Image should always be valid, never \"empty\"\n\n  static ImageType::Pointer read(const std::string&amp; filename);\n  static ImageType::Pointer readDICOMImage(const std::string&amp; pathname);\n\n  static ImageType::Pointer cloneData(const ImageType::Pointer img);\n\n  static vtkSmartPointer&lt;vtkPolyData&gt; getPolyData(const Image&amp; image, PixelType isoValue = 0.0);\n\n  Image&amp; pad(Dims lowerExtendRegion, Dims upperExtendRegion, PixelType value = 0.0);\n\n  StatsPtr statsFilter() const;\n\n  ImageType::Pointer itk_image_;\n\n  bool painted_ = false;\n\n  InterpolatorType::Pointer interpolator_;\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Image&amp; img);\n\ntemplate &lt;&gt;\nImage operator*(const Image&amp; img, const double x);\ntemplate &lt;&gt;\nImage operator/(const Image&amp; img, const double x);\ntemplate &lt;&gt;\nImage&amp; operator*=(Image&amp; img, const double x);\ntemplate &lt;&gt;\nImage&amp; operator/=(Image&amp; img, const double x);\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ImplicitSurfaceDomain_8h.html","title":"Libs/Optimize/Domain/ImplicitSurfaceDomain.h","text":""},{"location":"api/Files/ImplicitSurfaceDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ImplicitSurfaceDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::ImplicitSurfaceDomain"},{"location":"api/Files/ImplicitSurfaceDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ImageDomainWithCurvature.h\"\n#include \"vnl/vnl_cross.h\"\n#include \"vnl/vnl_inverse.h\"\n#include \"vnl/vnl_math.h\"\n\nnamespace shapeworks {\ntemplate &lt;class T&gt;\nclass ImplicitSurfaceDomain : public ImageDomainWithCurvature&lt;T&gt; {\n public:\n  typedef ImageDomainWithCurvature&lt;T&gt; Superclass;\n  typedef std::shared_ptr&lt;ImplicitSurfaceDomain&gt; Pointer;\n\n  typedef typename Superclass::ImageType ImageType;\n  typedef typename Superclass::PointType PointType;\n\n  virtual void SetTolerance(const T _Tolerance) {\n    if (this-&gt;m_Tolerance != _Tolerance) {\n      this-&gt;m_Tolerance = _Tolerance;\n      // this-&gt;Modified();\n    }\n  }\n  virtual T GetTolerance() { return this-&gt;m_Tolerance; }\n\n  shapeworks::DomainType GetDomainType() const override { return shapeworks::DomainType::Image; }\n\n  virtual bool ApplyConstraints(PointType&amp; p, int idx, bool dbg = false) const override {\n    // First apply and constraints imposed by superclasses.  This will\n    // guarantee the point starts in the correct image domain.\n    bool flag = Superclass::ApplyConstraints(p);\n\n    const T epsilon = m_Tolerance * 0.001;\n    T value = this-&gt;Sample(p);\n\n    // Early exit if already close enough\n    if (fabs(value) &lt;= m_Tolerance) {\n      return flag;\n    }\n\n    const unsigned int MAX_ITERATIONS = 50;\n    unsigned int k = 0;\n    T prev_value = value;\n\n    while (k &lt; MAX_ITERATIONS) {\n      // Sample gradient\n      vnl_vector_fixed&lt;float, DIMENSION&gt; gradf = this-&gt;SampleGradientAtPoint(p, idx);\n      vnl_vector_fixed&lt;double, DIMENSION&gt; grad;\n      grad[0] = double(gradf[0]);\n      grad[1] = double(gradf[1]);\n      grad[2] = double(gradf[2]);\n\n      double gradient_magnitude = grad.magnitude();\n\n      // If gradient is too small, we're stuck\n      if (gradient_magnitude &lt; epsilon) {\n        break;\n      }\n\n      // Normalize gradient to get direction\n      vnl_vector_fixed&lt;double, DIMENSION&gt; direction = grad / gradient_magnitude;\n\n      // For smoothed distance fields:\n      // - Neither value nor gradient_magnitude are exactly correct\n      // - But their RATIO is approximately correct (within ~20%)\n      // - Use damping to handle the residual error\n\n      const double DAMPING = 0.7;  // Conservative for ~20% overshoot\n      double step_size = (double(value) / gradient_magnitude) * DAMPING;\n\n      // Safety check: if gradient is very weak, cap step by distance value\n      // This handles pathological cases (critical points, field edges)\n      if (gradient_magnitude &lt; 0.5) {\n        double max_step = fabs(double(value)) * DAMPING;\n        if (fabs(step_size) &gt; max_step) {\n          step_size = (step_size &gt; 0 ? max_step : -max_step);\n        }\n      }\n\n      for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n        p[i] -= step_size * direction[i];\n      }\n\n      // Re-evaluate\n      prev_value = value;\n      value = this-&gt;Sample(p);\n\n      // Check convergence\n      if (fabs(value) &lt;= m_Tolerance) {\n        break;  // Success!\n      }\n\n      // Check if we're oscillating or making no progress\n      if (k &gt; 5) {\n        double value_change = fabs(value - prev_value);\n        if (value_change &lt; m_Tolerance * 0.1) {\n          // Making very little progress, close enough\n          break;\n        }\n\n        // Check for oscillation (sign keeps flipping)\n        if ((value &gt; 0 &amp;&amp; prev_value &lt; 0) || (value &lt; 0 &amp;&amp; prev_value &gt; 0)) {\n          // We're bouncing across the surface\n          // If we're close enough, accept it\n          if (fabs(value) &lt; m_Tolerance * 2.0) {\n            break;\n          }\n        }\n      }\n\n      k++;\n    }\n\n    return flag;\n  }\n\n  inline PointType UpdateParticlePosition(const PointType&amp; point, int idx,\n                                          vnl_vector_fixed&lt;double, DIMENSION&gt;&amp; update) const override {\n    PointType newpoint;\n\n    for (unsigned int i = 0; i &lt; 3; i++) {\n      newpoint[i] = point[i] - update[i];\n    }\n\n    ApplyConstraints(newpoint, idx);\n\n    return newpoint;\n  }\n\n  PointType GetZeroCrossingPoint() const override {\n    PointType p;\n    // TODO Hong\n    // Return point that doesn't violate plane constraints.\n    return p;\n  }\n\n  ImplicitSurfaceDomain() : m_Tolerance(1.0e-4) {}\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const {\n    Superclass::PrintSelf(os, indent);\n    os &lt;&lt; indent &lt;&lt; \"m_Tolerance = \" &lt;&lt; m_Tolerance &lt;&lt; std::endl;\n  }\n  virtual ~ImplicitSurfaceDomain(){};\n\n private:\n  T m_Tolerance;\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Intersect_8h.html","title":"Libs/Mesh/PreviewMeshQC/Intersect.h","text":""},{"location":"api/Files/Intersect_8h.html#classes","title":"Classes","text":"Name struct Ray struct Intersection struct Triangle struct Quad"},{"location":"api/Files/Intersect_8h.html#functions","title":"Functions","text":"Name bool IntersectTriangle(const Ray &amp; ray, const Triangle &amp; tri, Intersection &amp; q, bool evalNormal =true) bool IntersectQuad(const Ray &amp; ray, const Quad &amp; quad, Intersection &amp; q) bool FastIntersectQuad(const Ray &amp; ray, const Quad &amp; quad, Intersection &amp; q)"},{"location":"api/Files/Intersect_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/Intersect_8h.html#function-intersecttriangle","title":"function IntersectTriangle","text":"<pre><code>bool IntersectTriangle(\n    const Ray &amp; ray,\n    const Triangle &amp; tri,\n    Intersection &amp; q,\n    bool evalNormal =true\n)\n</code></pre>"},{"location":"api/Files/Intersect_8h.html#function-intersectquad","title":"function IntersectQuad","text":"<pre><code>bool IntersectQuad(\n    const Ray &amp; ray,\n    const Quad &amp; quad,\n    Intersection &amp; q\n)\n</code></pre>"},{"location":"api/Files/Intersect_8h.html#function-fastintersectquad","title":"function FastIntersectQuad","text":"<pre><code>bool FastIntersectQuad(\n    const Ray &amp; ray,\n    const Quad &amp; quad,\n    Intersection &amp; q\n)\n</code></pre>"},{"location":"api/Files/Intersect_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include \"math3d.h\"\n\n// tools for finding intersections\nstruct Ray\n{\n    vec3d   origin;         // origin of ray\n    vec3d   direction;      // direction of ray (must be unit vector!)\n};\n\n//-----------------------------------------------------------------------------\nstruct Intersection\n{\n    vec3d   point;          // point of intersection\n    float   r[2];           // natural coordinates\n    int     m_index;        // index of item that was intersected (context dependent)\n    int     m_faceIndex;    // index of face that was intersected (context dependent)\n};\n\n//-----------------------------------------------------------------------------\nstruct Triangle\n{\n    vec3d   r0;\n    vec3d   r1;\n    vec3d   r2;\n    vec3d   fn; // face normal\n};\n\n//-----------------------------------------------------------------------------\nstruct Quad\n{\n    vec3d   r0;\n    vec3d   r1;\n    vec3d   r2;\n    vec3d   r3;\n};\n\n//-----------------------------------------------------------------------------\n// Find intersection of a ray with a triangle\n// To evaluate the normal automatically, set evalNormal to true. Otherwise, the normal in Triangle is used\nbool IntersectTriangle(const Ray&amp; ray, const Triangle&amp; tri, Intersection&amp; q, bool evalNormal = true);\n\n//-----------------------------------------------------------------------------\n// Find intersection of a ray with a quad\nbool IntersectQuad(const Ray&amp; ray, const Quad&amp; quad, Intersection&amp; q);\nbool FastIntersectQuad(const Ray&amp; ray, const Quad&amp; quad, Intersection&amp; q);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ItkToVtk_8h.html","title":"Libs/Analyze/ItkToVtk.h","text":""},{"location":"api/Files/ItkToVtk_8h.html#functions","title":"Functions","text":"Name template &lt;typename ITK_Exporter ,typename VTK_Importer &gt; void ConnectPipelines(ITK_Exporter exporter, VTK_Importer * importer)"},{"location":"api/Files/ItkToVtk_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ItkToVtk_8h.html#function-connectpipelines","title":"function ConnectPipelines","text":"<pre><code>template &lt;typename ITK_Exporter ,\ntypename VTK_Importer &gt;\nvoid ConnectPipelines(\n    ITK_Exporter exporter,\n    VTK_Importer * importer\n)\n</code></pre> <p>This function will connect the given itk::VTKImageExport filter to the given vtkImageImport filter. </p>"},{"location":"api/Files/ItkToVtk_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\ntemplate &lt;typename ITK_Exporter, typename VTK_Importer&gt;\nvoid ConnectPipelines(ITK_Exporter exporter, VTK_Importer* importer)\n{\n  importer-&gt;SetUpdateInformationCallback(exporter-&gt;GetUpdateInformationCallback());\n  importer-&gt;SetPipelineModifiedCallback(exporter-&gt;GetPipelineModifiedCallback());\n  importer-&gt;SetWholeExtentCallback(exporter-&gt;GetWholeExtentCallback());\n  importer-&gt;SetSpacingCallback(exporter-&gt;GetSpacingCallback());\n  importer-&gt;SetOriginCallback(exporter-&gt;GetOriginCallback());\n  importer-&gt;SetScalarTypeCallback(exporter-&gt;GetScalarTypeCallback());\n  importer-&gt;SetNumberOfComponentsCallback(exporter-&gt;GetNumberOfComponentsCallback());\n  importer-&gt;SetPropagateUpdateExtentCallback(exporter-&gt;GetPropagateUpdateExtentCallback());\n  importer-&gt;SetUpdateDataCallback(exporter-&gt;GetUpdateDataCallback());\n  importer-&gt;SetDataExtentCallback(exporter-&gt;GetDataExtentCallback());\n  importer-&gt;SetBufferPointerCallback(exporter-&gt;GetBufferPointerCallback());\n  importer-&gt;SetCallbackUserData(exporter-&gt;GetCallbackUserData());\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Job_8h.html","title":"Libs/Application/Job/Job.h","text":""},{"location":"api/Files/Job_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Job_8h.html#classes","title":"Classes","text":"Name class shapeworks::Job"},{"location":"api/Files/Job_8h.html#functions","title":"Functions","text":"Name Q_DECLARE_METATYPE(QSharedPointer&lt; shapeworks::Job &gt; )"},{"location":"api/Files/Job_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/Job_8h.html#function-q_declare_metatype","title":"function Q_DECLARE_METATYPE","text":"<pre><code>Q_DECLARE_METATYPE(\n    QSharedPointer&lt; shapeworks::Job &gt; \n)\n</code></pre>"},{"location":"api/Files/Job_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;QElapsedTimer&gt;\n#include &lt;QObject&gt;\n#include &lt;QSharedPointer&gt;\n\nnamespace shapeworks {\n\nclass Job : public QObject {\n  Q_OBJECT\n\n public:\n  Job();\n  virtual ~Job();\n\n  virtual void run() = 0;\n\n  virtual QString name() = 0;\n\n  virtual QString get_completion_message();\n\n  virtual QString get_abort_message();\n\n  void start_timer();\n\n  qint64 timer_elapsed();\n\n  void set_complete(bool complete) { complete_ = complete; }\n\n  bool is_complete() const { return complete_; }\n\n  void abort() { abort_ = true; }\n\n  bool is_aborted() const { return abort_; }\n\n  void set_quiet_mode(bool quiet) { quiet_mode_ = quiet; }\n\n  bool get_quiet_mode() { return quiet_mode_; }\n\n public Q_SLOTS:\n\n Q_SIGNALS:\n\n  void progress(double, QString = \"\");\n  void finished();\n\n private:\n  std::atomic&lt;bool&gt; complete_ = false;\n  std::atomic&lt;bool&gt; abort_ = false;\n  std::atomic&lt;bool&gt; quiet_mode_ = false;\n\n  QElapsedTimer timer_;\n};\n}  // namespace shapeworks\n\n\nQ_DECLARE_METATYPE(QSharedPointer&lt;shapeworks::Job&gt;);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/JsonProjectReader_8h.html","title":"Libs/Project/JsonProjectReader.h","text":""},{"location":"api/Files/JsonProjectReader_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/JsonProjectReader_8h.html#classes","title":"Classes","text":"Name class shapeworks::JsonProjectReader JSON file format reader for Project."},{"location":"api/Files/JsonProjectReader_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ProjectReader.h\"\n\nnamespace shapeworks {\n\n\nclass JsonProjectReader : public ProjectReader {\n public:\n  JsonProjectReader(Project &amp;project);\n  ~JsonProjectReader();\n\n  bool read_project(std::string filename) override;\n\n  StringMap get_parameters(std::string name) override;\n\n  StringMultiMap get_multi_parameters(std::string name) override;\n\n private:\n  // pimpl container\n  class Container;\n  std::unique_ptr&lt;Container&gt; container_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/JsonProjectWriter_8h.html","title":"Libs/Project/JsonProjectWriter.h","text":""},{"location":"api/Files/JsonProjectWriter_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/JsonProjectWriter_8h.html#classes","title":"Classes","text":"Name class shapeworks::JsonProjectWriter JSON file format writer for Project."},{"location":"api/Files/JsonProjectWriter_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Project.h\"\n\nnamespace shapeworks {\n\n\nclass JsonProjectWriter {\n public:\n  static bool write_project(Project&amp; project, std::string filename);\n\n private:\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/KeyboardShortcuts_8h.html","title":"Studio/Interface/KeyboardShortcuts.h","text":""},{"location":"api/Files/KeyboardShortcuts_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/KeyboardShortcuts_8h.html#classes","title":"Classes","text":"Name class shapeworks::KeyboardShortcuts"},{"location":"api/Files/KeyboardShortcuts_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// qt\n#include &lt;QDialog&gt;\n\nclass Ui_KeyboardShortcuts;\n\nnamespace shapeworks {\n\nclass KeyboardShortcuts : public QDialog {\nQ_OBJECT\n\npublic:\n\n  KeyboardShortcuts(QWidget* parent);\n\n  virtual ~KeyboardShortcuts();\n\nprivate:\n\n  Ui_KeyboardShortcuts* ui_;\n\n};\n\n} // end namespace\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LandmarkItemDelegate_8h.html","title":"Studio/Data/LandmarkItemDelegate.h","text":""},{"location":"api/Files/LandmarkItemDelegate_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LandmarkItemDelegate_8h.html#classes","title":"Classes","text":"Name class shapeworks::LandmarkItemDelegate"},{"location":"api/Files/LandmarkItemDelegate_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;memory&gt;\n\n// Qt includes\n#include &lt;QStyledItemDelegate&gt;\n\nnamespace shapeworks {\n\nclass LandmarkItemDelegatePrivate;\nclass LandmarkTableModel;\n\n// Delegate for editing length and note columns in measurement table.  Note that only one delegate\n// can be set per view, so this delegate handles all custom columns in the table.\nclass LandmarkItemDelegate : public QStyledItemDelegate {\n  Q_OBJECT\n\n public:\n  LandmarkItemDelegate(QObject* parent = 0);\n\n  void paint(QPainter* painter, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const override;\n  QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem&amp; option,\n                        const QModelIndex&amp; index) const override;\n  void setEditorData(QWidget* editor, const QModelIndex&amp; index) const override;\n  void setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex&amp; index) const override;\n  QSize sizeHint(const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const override;\n\n  void updateEditorGeometry(QWidget* editor,\n                            const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const override;\n\n  void set_button_text(std::string button_text);\n\n  void set_model(std::shared_ptr&lt;LandmarkTableModel&gt; model);\n\n Q_SIGNALS:\n  void button_clicked(int row);\n\n private Q_SLOTS:\n  void set_button_pressed(int row);\n  void cell_entered(QModelIndex index);\n\n private:\n  std::shared_ptr&lt;LandmarkItemDelegatePrivate&gt; private_;\n  std::shared_ptr&lt;LandmarkTableModel&gt; model_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LandmarkTableModel_8h.html","title":"Studio/Data/LandmarkTableModel.h","text":""},{"location":"api/Files/LandmarkTableModel_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LandmarkTableModel_8h.html#classes","title":"Classes","text":"Name class shapeworks::LandmarkTableModel"},{"location":"api/Files/LandmarkTableModel_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// QT Includes\n#include &lt;Data/Session.h&gt;\n#include &lt;Project/Project.h&gt;\n\n#include &lt;QAbstractTableModel&gt;\n#include &lt;QIcon&gt;\n#include &lt;QItemSelection&gt;\n#include &lt;QModelIndex&gt;\n\nnamespace shapeworks {\n\nclass Project;\n\nenum LandmarkColumns { VISIBLE_E, COLOR_E, NAME_E, POSITION_E, SET_BUTTON_E, COMMENT_E, END_E };\n\nenum LandmarkVisibility { ALL_VISIBLE_E, NONE_VISIBLE_E, SOME_VISIBLE_E };\n\nclass LandmarkTableModel : public QAbstractTableModel {\n  Q_OBJECT\n\n public:\n  LandmarkTableModel(QObject *parent = 0);\n\n  virtual ~LandmarkTableModel();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void store_landmarks();\n\n  void set_active_domain(int domain);\n\n  void update_table();\n\n  void update_cells();\n\n  void remove_rows(const std::vector&lt;int&gt; &amp;rows);\n\n  void toggle_visible();\n\n  void set_placing_landmark(int row);\n\n  void delete_landmarks(const QModelIndexList &amp;list);\n\n  //------------------  QAbstractTableModel implementation ------------------\n\n  int rowCount(const QModelIndex &amp;index) const override;\n\n  int columnCount(const QModelIndex &amp;index) const override;\n\n  QVariant data(const QModelIndex &amp;index, int role) const override;\n\n  bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role) override;\n\n  QVariant headerData(int section, Qt::Orientation orientation, int role) const override;\n\n  Qt::ItemFlags flags(const QModelIndex &amp;index) const override;\n\n public Q_SLOTS:\n\n  void new_landmark();\n\n  void handle_click(const QModelIndex &amp;index);\n\n  void handle_double_click(const QModelIndex &amp;index);\n\n  void handle_header_click(int index);\n\n private:\n  void update_visibility();\n\n  static void remove_eigen_row(Eigen::MatrixXd &amp;matrix, unsigned int row_to_remove);\n\n  std::shared_ptr&lt;Project&gt; project_;\n  QSharedPointer&lt;Session&gt; session_;\n\n  int visibility_ = LandmarkVisibility::ALL_VISIBLE_E;\n  std::string button_text_ = \"  Place  \";\n\n  std::vector&lt;LandmarkDefinition&gt; landmarks_;\n\n  QIcon visible_;\n  QIcon visible_off_;\n\n  int active_domain_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LandmarkWidget_8h.html","title":"Studio/Visualization/LandmarkWidget.h","text":""},{"location":"api/Files/LandmarkWidget_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LandmarkWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::LandmarkWidget LandmarkWidget."},{"location":"api/Files/LandmarkWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;vector&gt;\n\nclass vtkHandleWidget;\nclass vtkSphereSource;\nclass vtkPolyDataMapper;\nclass vtkPoints;\nclass vtkPolyData;\nclass vtkGlyph3D;\nclass vtkActor;\nclass vtkLookupTable;\n\nnamespace shapeworks {\n\nclass Viewer;\nclass LandmarkCallback;\n\n\nclass LandmarkWidget {\n public:\n  LandmarkWidget(Viewer* viewer);\n  ~LandmarkWidget();\n\n  void update_landmarks();\n\n  void store_positions();\n\n  void update_glyph_properties();\n\n  void clear_landmark_handles();\n\n private:\n  vtkSmartPointer&lt;vtkHandleWidget&gt; create_handle();\n\n  bool is_drag_mode();\n\n  bool is_glyph_mode();\n\n  void update_glyphs();\n\n  void assign_handle_to_domain(vtkSmartPointer&lt;vtkHandleWidget&gt; handle, int domain_id);\n\n  Viewer* viewer_ = nullptr;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkHandleWidget&gt;&gt; handles_;\n\n  vtkSmartPointer&lt;vtkSphereSource&gt; sphere_;\n  vtkSmartPointer&lt;LandmarkCallback&gt; callback_;\n\n  vtkSmartPointer&lt;vtkPoints&gt; glyph_points_;\n  vtkSmartPointer&lt;vtkPolyData&gt; glyph_point_set_;\n  vtkSmartPointer&lt;vtkGlyph3D&gt; glyphs_;\n  vtkSmartPointer&lt;vtkPolyDataMapper&gt; glyph_mapper_;\n  vtkSmartPointer&lt;vtkActor&gt; glyph_actor_;\n  vtkSmartPointer&lt;vtkLookupTable&gt; glyph_lut_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LegacyCorrespondenceFunction_8h.html","title":"Libs/Optimize/Function/LegacyCorrespondenceFunction.h","text":""},{"location":"api/Files/LegacyCorrespondenceFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LegacyCorrespondenceFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::LegacyCorrespondenceFunction"},{"location":"api/Files/LegacyCorrespondenceFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"LegacyCorrespondenceFunction.h\"\n#include \"Libs/Optimize/Matrix/LegacyShapeMatrix.h\"\n#include \"VectorFunction.h\"\n\nnamespace shapeworks {\n\nclass LegacyCorrespondenceFunction : public VectorFunction {\n public:\n  constexpr static unsigned int VDimension = 3;\n  constexpr static unsigned int Dimension = VDimension;\n\n  typedef LegacyShapeMatrix ShapeMatrixType;\n\n  typedef typename ShapeMatrixType::DataType DataType;\n\n  typedef VectorFunction::VectorType VectorType;\n  typedef ParticleSystem::PointType PointType;\n  typedef vnl_vector&lt;DataType&gt; vnl_vector_type;\n  typedef vnl_matrix&lt;DataType&gt; vnl_matrix_type;\n\n  static std::shared_ptr&lt;LegacyCorrespondenceFunction&gt; New() {\n    return std::make_shared&lt;LegacyCorrespondenceFunction&gt;();\n  }\n\n  virtual VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp;, double&amp;) const;\n  virtual VectorType evaluate(unsigned int a, unsigned int b, const ParticleSystem* c, double&amp; d) const {\n    double e;\n    return this-&gt;evaluate(a, b, c, d, e);\n  }\n\n  virtual double energy(unsigned int a, unsigned int b, const ParticleSystem* c) const {\n    double e, d;\n    this-&gt;evaluate(a, b, c, d, e);\n    return e;\n  }\n\n  void WriteModes(const std::string&amp;, int) const;\n\n  void SetShapeMatrix(ShapeMatrixType* s) { m_ShapeMatrix = s; }\n  ShapeMatrixType* GetShapeMatrix() { return m_ShapeMatrix.GetPointer(); }\n  const ShapeMatrixType* GetShapeMatrix() const { return m_ShapeMatrix.GetPointer(); }\n\n  virtual void before_iteration() {\n    m_ShapeMatrix-&gt;before_iteration();\n\n    if (m_Counter == 0) {\n      this-&gt;ComputeCovarianceMatrix();\n    }\n  }\n\n  virtual void after_iteration() override {\n    m_ShapeMatrix-&gt;after_iteration();\n    // Update the annealing parameter.\n    if (m_HoldMinimumVariance != true &amp;&amp; !m_UseMeanEnergy) {\n      m_Counter++;\n      if (m_Counter &gt;= m_RecomputeCovarianceInterval) {\n        m_Counter = 0;\n        m_MinimumVariance *= m_MinimumVarianceDecayConstant;\n      }\n    }\n  }\n\n  void SetMinimumVariance(double d) { m_MinimumVariance = d; }\n  double GetMinimumVariance() const { return m_MinimumVariance; }\n\n  void SetMinimumVarianceDecay(double initial_value, double final_value, double time_period) {\n    m_MinimumVarianceDecayConstant = exp(log(final_value / initial_value) / time_period);\n    m_MinimumVariance = initial_value;\n    m_HoldMinimumVariance = false;\n  }\n  bool GetMinimumVarianceDecayConstant() const { return m_MinimumVarianceDecayConstant; }\n\n  void PrintShapeMatrix() { m_ShapeMatrix-&gt;PrintMatrix(); }\n\n  void UseMeanenergy() { m_UseMeanEnergy = true; }\n  void UseEntropy() { m_UseMeanEnergy = false; }\n\n  bool GetHoldMinimumVariance() const { return m_HoldMinimumVariance; }\n  void SetHoldMinimumVariance(bool b) { m_HoldMinimumVariance = b; }\n\n  void SetRecomputeCovarianceInterval(int i) { m_RecomputeCovarianceInterval = i; }\n  int GetRecomputeCovarianceInterval() const { return m_RecomputeCovarianceInterval; }\n\n  std::shared_ptr&lt;VectorFunction&gt; clone() override {\n    auto copy = LegacyCorrespondenceFunction::New();\n\n    copy-&gt;m_PointsUpdate = this-&gt;m_PointsUpdate;\n    copy-&gt;m_MinimumVariance = this-&gt;m_MinimumVariance;\n    copy-&gt;m_MinimumEigenValue = this-&gt;m_MinimumEigenValue;\n    copy-&gt;m_CurrentEnergy = this-&gt;m_CurrentEnergy;\n    copy-&gt;m_HoldMinimumVariance = this-&gt;m_HoldMinimumVariance;\n    copy-&gt;m_MinimumVarianceDecayConstant = this-&gt;m_MinimumVarianceDecayConstant;\n    copy-&gt;m_RecomputeCovarianceInterval = this-&gt;m_RecomputeCovarianceInterval;\n    copy-&gt;m_Counter = m_Counter;\n\n    copy-&gt;domain_number_ = this-&gt;domain_number_;\n    copy-&gt;particle_system_ = this-&gt;particle_system_;\n    copy-&gt;m_ShapeMatrix = this-&gt;m_ShapeMatrix;\n\n    copy-&gt;m_InverseCovMatrix = this-&gt;m_InverseCovMatrix;\n    copy-&gt;m_points_mean = this-&gt;m_points_mean;\n    copy-&gt;m_UseMeanEnergy = this-&gt;m_UseMeanEnergy;\n\n    return copy;\n  }\n\n  LegacyCorrespondenceFunction() {\n    // m_MinimumVarianceBase = 1.0;//exp(log(1.0e-5)/10000.0);\n    m_HoldMinimumVariance = true;\n    m_MinimumVariance = 1.0e-5;\n    m_MinimumEigenValue = 0.0;\n    m_MinimumVarianceDecayConstant = 1.0;  // log(2.0) / 50000.0;\n    m_RecomputeCovarianceInterval = 1;\n    m_Counter = 0;\n    m_UseMeanEnergy = true;\n    m_PointsUpdate = std::make_shared&lt;vnl_matrix_type&gt;(10, 10);\n    m_InverseCovMatrix = std::make_shared&lt;Eigen::MatrixXd&gt;(10, 10);\n    m_points_mean = std::make_shared&lt;vnl_matrix_type&gt;(10, 10);\n  }\n  ~LegacyCorrespondenceFunction() override = default;\n\n protected:\n  LegacyCorrespondenceFunction(const LegacyCorrespondenceFunction&amp;) = delete;\n  LegacyCorrespondenceFunction&amp; operator=(const LegacyCorrespondenceFunction&amp;) = delete;\n  typename ShapeMatrixType::Pointer m_ShapeMatrix;\n\n  virtual void ComputeCovarianceMatrix();\n  std::shared_ptr&lt;vnl_matrix_type&gt; m_PointsUpdate;\n  double m_MinimumVariance;\n  double m_MinimumEigenValue;\n  double m_CurrentEnergy;\n  bool m_HoldMinimumVariance;\n  double m_MinimumVarianceDecayConstant;\n  int m_RecomputeCovarianceInterval;\n  int m_Counter;\n  bool m_UseMeanEnergy;\n\n  std::shared_ptr&lt;vnl_matrix_type&gt; m_points_mean;       // 3Nx3N - used for energy computation\n  std::shared_ptr&lt;Eigen::MatrixXd&gt; m_InverseCovMatrix;  // 3NxM - used for energy computation\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LegacyMeshGenerator_8h.html","title":"Libs/Analyze/LegacyMeshGenerator.h","text":"<p>Mesh generation.  More...</p>"},{"location":"api/Files/LegacyMeshGenerator_8h.html#classes","title":"Classes","text":"Name class LegacyMeshGenerator"},{"location":"api/Files/LegacyMeshGenerator_8h.html#detailed-description","title":"Detailed Description","text":"<p>Mesh generation. </p> <p>The LegacyMeshGenerator performs the actual work of reconstructing a mesh from a shape (list of points). </p>"},{"location":"api/Files/LegacyMeshGenerator_8h.html#source-code","title":"Source code","text":"<pre><code>/*\n * Shapeworks license\n */\n\n#pragma once\n\n#include \"vnl/vnl_vector.h\"\n\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;Eigen/Eigen&gt;\n\n//#include &lt;SurfaceReconstructor.h&gt;\n\n//#define SW_USE_POWERCRUST\n\nclass CustomSurfaceReconstructionFilter;\nclass vtkPowerCrustSurfaceReconstruction;\nclass vtkContourFilter;\nclass vtkReverseSense;\nclass vtkSmoothPolyDataFilter;\nclass vtkPolyDataNormals;\nclass vtkPoints;\nclass vtkPolyData;\nclass vtkTriangleFilter;\nclass vtkWindowedSincPolyDataFilter;\nclass vtkPolyDataToImageData;\n\nclass LegacyMeshGenerator\n{\npublic:\n  LegacyMeshGenerator();\n  ~LegacyMeshGenerator();\n\n  void setNeighborhoodSize( int size );\n  void setSampleSpacing( double spacing );\n  void setUsePowerCrust( bool enabled );\n  void setSmoothingAmount( float amount ); // 0-100\n\n  vtkSmartPointer&lt;vtkPolyData&gt; buildMesh( const Eigen::VectorXd&amp; shape );\n\n  //void set_surface_reconstructor(QSharedPointer&lt;SurfaceReconstructor&gt; reconstructor);\n\nprivate:\n\n  void updatePipeline();\n\n  vtkSmartPointer&lt;CustomSurfaceReconstructionFilter&gt;  surfaceReconstruction;\n  vtkSmartPointer&lt;vtkPowerCrustSurfaceReconstruction&gt; powercrust;\n\n  vtkSmartPointer&lt;vtkPoints&gt;               points;\n  vtkSmartPointer&lt;vtkPolyData&gt;             pointSet;\n  vtkSmartPointer&lt;vtkContourFilter&gt;        contourFilter;\n  vtkSmartPointer&lt;vtkReverseSense&gt;         reverseSense;\n  vtkSmartPointer&lt;vtkPolyDataNormals&gt;      polydataNormals;\n  vtkSmartPointer&lt;vtkTriangleFilter&gt;       triangleFilter;\n  vtkSmartPointer&lt;vtkWindowedSincPolyDataFilter&gt; windowSincFilter;\n  vtkSmartPointer&lt;vtkPolyDataToImageData&gt;  polydataToImageData;\n\n  bool usePowerCrust;\n  bool smoothingEnabled;\n\n  //QSharedPointer&lt;SurfaceReconstructor&gt; surface_reconstructor_;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/LegacyShapeMatrix_8h.html","title":"Libs/Optimize/Matrix/LegacyShapeMatrix.h","text":""},{"location":"api/Files/LegacyShapeMatrix_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LegacyShapeMatrix_8h.html#classes","title":"Classes","text":"Name class shapeworks::LegacyShapeMatrix"},{"location":"api/Files/LegacyShapeMatrix_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#include \"Libs/Optimize/Container/GenericContainer.h\"\n#include \"Observer.h\"\n#include \"ParticleSystem.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n#include \"vnl/vnl_matrix.h\"\n\nnamespace shapeworks {\nclass LegacyShapeMatrix : public vnl_matrix&lt;double&gt;, public Observer {\n public:\n  typedef double DataType;\n  typedef LegacyShapeMatrix Self;\n  typedef Observer Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self)\n\n\n      itkTypeMacro(LegacyShapeMatrix, Observer)\n\n\n      virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp; e) {\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    unsigned int d = event.GetDomainIndex();\n\n    if (d % m_DomainsPerShape == 0) this-&gt;ResizeMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n  }\n\n  virtual void ResizeMatrix(int rs, int cs) {\n    vnl_matrix&lt;double&gt; tmp(*this);  // copy existing  matrix\n\n    // Create new column (shape)\n    this-&gt;set_size(rs, cs);\n\n    // Copy old data into new matrix.\n    for (unsigned int c = 0; c &lt; tmp.cols(); c++) {\n      for (unsigned int r = 0; r &lt; tmp.rows(); r++) this-&gt;operator()(r, c) = tmp(r, c);\n    }\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const int VDimension = 3;\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n\n    int numRows = 0;\n    for (int i = 0; i &lt; m_DomainsPerShape; i++) {\n      numRows += VDimension * ps-&gt;GetNumberOfParticles(i);\n    }\n\n    if (numRows &gt; this-&gt;rows()) {\n      this-&gt;ResizeMatrix(numRows, this-&gt;cols());\n    }\n\n    unsigned int k = 0;\n    int dom = d % m_DomainsPerShape;\n    for (int i = 0; i &lt; dom; i++) {\n      k += VDimension * ps-&gt;GetNumberOfParticles(i);\n    }\n    k += idx * VDimension;\n\n    for (unsigned int i = 0; i &lt; VDimension; i++) {\n      if (i + k &gt;= this-&gt;rows()) {\n        throw std::runtime_error(\n            \"PositionSetEventCallback: index out of bounds! Different number of particles per shape?\");\n      }\n      this-&gt;operator()(i + k, d / m_DomainsPerShape) = pos[i];\n    }\n  }\n\n  virtual void PositionSetEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const int VDimension = 3;\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n\n    unsigned int k = 0;\n    int dom = d % m_DomainsPerShape;\n    for (int i = 0; i &lt; dom; i++) {\n      k += VDimension * ps-&gt;GetNumberOfParticles(i);\n    }\n    k += idx * VDimension;\n\n    for (unsigned int i = 0; i &lt; VDimension; i++) {\n      if (i + k &gt;= this-&gt;rows()) {\n        throw std::runtime_error(\n            \"PositionSetEventCallback: index out of bounds! Different number of particles per shape?\");\n      }\n      this-&gt;operator()(i + k, d / m_DomainsPerShape) = pos[i];\n    }\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n  // For debugging purposes.\n  void PrintMatrix() {\n    std::cout &lt;&lt; std::endl;\n    for (unsigned int r = 0; r &lt; this-&gt;rows(); r++) {\n      for (unsigned int c = 0; c &lt; this-&gt;cols(); c++) {\n        std::cout &lt;&lt; this-&gt;operator()(r, c) &lt;&lt; \"  \";\n      }\n      std::cout &lt;&lt; std::endl;\n    }\n  }\n\n  bool CheckForNans() {\n    bool flag = false;\n    for (unsigned int r = 0; r &lt; this-&gt;rows(); r++) {\n      for (unsigned int c = 0; c &lt; this-&gt;cols(); c++) {\n        if (std::isnan(this-&gt;operator()(r, c))) {\n          flag = true;\n          break;\n        }\n      }\n    }\n    return flag;\n  }\n\n  void SetDomainsPerShape(int i) { m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  virtual void before_iteration() {}\n  virtual void after_iteration() {}\n\n  virtual void SetMatrix(const vnl_matrix&lt;double&gt;&amp; m) { vnl_matrix&lt;double&gt;::operator=(m); }\n\n protected:\n  LegacyShapeMatrix() : m_DomainsPerShape(1) {\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n  }\n  virtual ~LegacyShapeMatrix() {}\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n  int m_DomainsPerShape;\n\n private:\n  LegacyShapeMatrix(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);     // purposely not implemented\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Lightbox_8h.html","title":"Studio/Visualization/Lightbox.h","text":""},{"location":"api/Files/Lightbox_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Lightbox_8h.html#classes","title":"Classes","text":"Name class shapeworks::Lightbox Display multiple Viewers in a tiled display."},{"location":"api/Files/Lightbox_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Visualization/Viewer.h&gt;\n#include &lt;vtkActor.h&gt;\n#include &lt;vtkCamera.h&gt;\n#include &lt;vtkPoints.h&gt;\n#include &lt;vtkPolyDataMapper.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;QSharedPointer&gt;\n#include &lt;QTimer&gt;\n#include &lt;QVector&gt;\n\nclass vtkOrientationMarkerWidget;\n\nnamespace shapeworks {\n\nclass StudioMesh;\nclass Shape;\nclass StudioInteractorStyle;\nclass StudioSliceInteractorStyle;\nclass Visualizer;\n\nclass Lightbox;\ntypedef QSharedPointer&lt;Lightbox&gt; LightboxHandle;\n\n\nclass Lightbox : public QObject {\n  Q_OBJECT;\n\n public:\n  Lightbox();\n  ~Lightbox();\n\n  void set_shapes(ShapeList shapes);\n  ShapeList get_shapes();\n\n  void set_interactor(vtkRenderWindowInteractor* interactor);\n\n  void set_render_window(vtkRenderWindow* render_window);\n\n  void set_tile_layout(int width, int height);\n\n  void setup_renderers();\n\n  int get_num_rows();\n  int get_num_rows_visible();\n\n  void set_start_row(int row);\n\n  ViewerList get_viewers();\n\n  void redraw();\n\n  void handle_pick(int* click_pos, bool one, bool ctrl, vtkRenderer* renderer);\n\n  void handle_hover(int* click_pos);\n\n  void handle_key(int* click_pos, std::string key);\n\n  void handle_right_click(int* click_pos, vtkRenderer* renderer);\n\n  void set_glyph_lut(vtkSmartPointer&lt;vtkLookupTable&gt; lut);\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void set_visualizer(Visualizer* visualizer);\n\n  bool render_window_ready() { return render_window_ != NULL; }\n\n  void clear_renderers();\n\n  std::array&lt;double, 3&gt; initPos();\n\n  void handle_new_mesh();\n\n  void reset_camera();\n\n  void reset_camera_clipping_range();\n\n  void set_orientation_marker(Preferences::OrientationMarkerType type, Preferences::OrientationMarkerCorner corner);\n\n  void set_orientation_marker_viewport();\n\n  void update_feature_range();\n\n  void update_interactor_style();\n\n  void set_shared_brightness_and_contrast(double brightness, double contrast);\n\n  vtkRenderWindow* get_render_window();\n\n  int get_start_shape();\n\n public Q_SLOTS:\n  void handle_timer_callback();\n\n Q_SIGNALS:\n  void right_click(int index);\n\n private:\n  vtkSmartPointer&lt;vtkOrientationMarkerWidget&gt; create_orientation_marker();\n\n  void check_for_first_draw();\n\n  void display_shapes();\n\n  void insert_shape_into_viewer(std::shared_ptr&lt;Shape&gt; shape, int position);\n\n  vtkSmartPointer&lt;vtkRenderer&gt; renderer_;\n\n  ShapeList shapes_;\n\n  // there is one viewer for every tile in the lightbox display\n  ViewerList viewers_;\n\n  vtkRenderWindow* render_window_ = nullptr;\n\n  vtkRenderWindowInteractor* interactor_ = nullptr;\n\n  vtkCamera* camera_ = nullptr;\n\n  int tile_layout_width_ = 4;\n  int tile_layout_height_ = 4;\n\n  int start_row_ = 0;\n\n  bool first_draw_ = true;\n\n  vtkSmartPointer&lt;StudioInteractorStyle&gt; style_;\n  vtkSmartPointer&lt;StudioSliceInteractorStyle&gt; slice_style_;\n\n  Visualizer* visualizer_{nullptr};\n\n  std::vector&lt;vtkSmartPointer&lt;vtkImageData&gt;&gt; spinner_images_;\n\n  QTimer loading_timer_;\n\n  int timer_callback_count_ = 0;\n\n  std::array&lt;double, 3&gt; initPos_;\n\n  vtkSmartPointer&lt;vtkOrientationMarkerWidget&gt; orientation_marker_widget_;\n\n  Preferences::OrientationMarkerType current_orientation_marker_type_ = Preferences::OrientationMarkerType::none;\n  Preferences::OrientationMarkerCorner current_orientation_marker_corner_ =\n      Preferences::OrientationMarkerCorner::upper_right;\n\n  QSharedPointer&lt;Session&gt; session_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LinearRegressionShapeMatrix_8h.html","title":"Libs/Optimize/Matrix/LinearRegressionShapeMatrix.h","text":""},{"location":"api/Files/LinearRegressionShapeMatrix_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LinearRegressionShapeMatrix_8h.html#classes","title":"Classes","text":"Name class shapeworks::LinearRegressionShapeMatrix"},{"location":"api/Files/LinearRegressionShapeMatrix_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"LegacyShapeMatrix.h\"\n#include \"ParticleSystem.h\"\n#include \"vnl/vnl_vector.h\"\n\nnamespace shapeworks {\nclass LinearRegressionShapeMatrix : public LegacyShapeMatrix {\n public:\n  typedef double DataType;\n  typedef LinearRegressionShapeMatrix Self;\n  typedef LegacyShapeMatrix Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(LinearRegressionShapeMatrix, LegacyShapeMatrix);\n\n  void UpdateMeanMatrix() {\n    // for each sample\n    for (unsigned int i = 0; i &lt; m_MeanMatrix.cols(); i++) {\n      // compute the mean\n      m_MeanMatrix.set_column(i, m_Intercept + m_Slope * m_Expl(i));\n    }\n  }\n\n  inline vnl_vector&lt;double&gt; ComputeMean(double k) const { return m_Intercept + m_Slope * k; }\n\n  void ResizeParameters(unsigned int n) {\n    vnl_vector&lt;double&gt; tmpA = m_Intercept;  // copy existing  matrix\n    vnl_vector&lt;double&gt; tmpB = m_Slope;      // copy existing  matrix\n\n    // Create new\n    m_Intercept.set_size(n);\n    m_Slope.set_size(n);\n\n    // Copy old data into new vector.\n    for (unsigned int r = 0; r &lt; tmpA.size(); r++) {\n      m_Intercept(r) = tmpA(r);\n      m_Slope(r) = tmpB(r);\n    }\n  }\n\n  virtual void ResizeMeanMatrix(int rs, int cs) {\n    vnl_matrix&lt;double&gt; tmp = m_MeanMatrix;  // copy existing  matrix\n\n    // Create new column (shape)\n    m_MeanMatrix.set_size(rs, cs);\n\n    m_MeanMatrix.fill(0.0);\n\n    // Copy old data into new matrix.\n    for (unsigned int c = 0; c &lt; tmp.cols(); c++) {\n      for (unsigned int r = 0; r &lt; tmp.rows(); r++) {\n        m_MeanMatrix(r, c) = tmp(r, c);\n      }\n    }\n  }\n\n  void ResizeExplanatory(unsigned int n) {\n    if (n &gt; m_Expl.size()) {\n      vnl_vector&lt;double&gt; tmp = m_Expl;  // copy existing  matrix\n\n      // Create new\n      m_Expl.set_size(n);\n      m_Expl.fill(0.0);\n\n      // Copy old data into new vector.\n      for (unsigned int r = 0; r &lt; tmp.size(); r++) {\n        m_Expl(r) = tmp(r);\n      }\n    }\n  }\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp; e) {\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    unsigned int d = event.GetDomainIndex();\n\n    if (d % this-&gt;m_DomainsPerShape == 0) {\n      this-&gt;ResizeMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n      this-&gt;ResizeMeanMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n      this-&gt;ResizeExplanatory(this-&gt;cols());\n    }\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n\n    const unsigned int PointsPerDomain = ps-&gt;GetNumberOfParticles(d);\n\n    // Make sure we have enough rows.\n    if ((ps-&gt;GetNumberOfParticles(d) * 3 * this-&gt;m_DomainsPerShape) &gt; this-&gt;rows()) {\n      this-&gt;ResizeParameters(PointsPerDomain * 3 * this-&gt;m_DomainsPerShape);\n      this-&gt;ResizeMatrix(PointsPerDomain * 3 * this-&gt;m_DomainsPerShape, this-&gt;cols());\n      this-&gt;ResizeMeanMatrix(PointsPerDomain * 3 * this-&gt;m_DomainsPerShape, this-&gt;cols());\n    }\n\n    // CANNOT ADD POSITION INFO UNTIL ALL POINTS PER DOMAIN IS KNOWN\n    // Add position info to the matrix\n    unsigned int k = ((d % this-&gt;m_DomainsPerShape) * PointsPerDomain * 3) + (idx * 3);\n    for (unsigned int i = 0; i &lt; 3; i++) {\n      this-&gt;operator()(i + k, d / this-&gt;m_DomainsPerShape) = pos[i];\n    }\n\n    //   std::cout &lt;&lt; \"Row \" &lt;&lt; k &lt;&lt; \" Col \" &lt;&lt; d / this-&gt;m_DomainsPerShape &lt;&lt; \" = \" &lt;&lt; pos &lt;&lt; std::endl;\n  }\n\n  virtual void PositionSetEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n    const unsigned int PointsPerDomain = ps-&gt;GetNumberOfParticles(d);\n\n    // Modify matrix info\n    //    unsigned int k = 3 * idx;\n    unsigned int k = ((d % this-&gt;m_DomainsPerShape) * PointsPerDomain * 3) + (idx * 3);\n\n    for (unsigned int i = 0; i &lt; 3; i++) {\n      this-&gt;operator()(i + k, d / this-&gt;m_DomainsPerShape) = pos[i] - m_MeanMatrix(i + k, d / this-&gt;m_DomainsPerShape);\n    }\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n  void SetDomainsPerShape(int i) { this-&gt;m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return this-&gt;m_DomainsPerShape; }\n\n  void SetExplanatory(std::vector&lt;double&gt; v) {\n    ResizeExplanatory(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      m_Expl[i] = v[i];\n    }\n  }\n  void SetExplanatory(unsigned int i, double q) { m_Expl[i] = q; }\n  const double&amp; GetExplanatory(unsigned int i) const { return m_Expl[i]; }\n  double&amp; GetExplanatory(unsigned int i) { return m_Expl[i]; }\n\n  const vnl_vector&lt;double&gt;&amp; GetSlope() const { return m_Slope; }\n  const vnl_vector&lt;double&gt;&amp; GetIntercept() const { return m_Intercept; }\n\n  void SetSlope(const std::vector&lt;double&gt;&amp; v) {\n    ResizeParameters(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      m_Slope[i] = v[i];\n    }\n  }\n\n  void SetIntercept(const std::vector&lt;double&gt;&amp; v) {\n    ResizeParameters(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      m_Intercept[i] = v[i];\n    }\n  }\n\n  void EstimateParameters() {\n    //    std::cout &lt;&lt; \"Estimating params\" &lt;&lt; std::endl;\n    //    std::cout &lt;&lt; \"Explanatory: \" &lt;&lt; m_Expl &lt;&lt; std::endl;\n\n    vnl_matrix&lt;double&gt; X = *this + m_MeanMatrix;\n\n    // Number of samples\n    double n = static_cast&lt;double&gt;(X.cols());\n\n    vnl_vector&lt;double&gt; sumtx = m_Expl[0] * X.get_column(0);\n    vnl_vector&lt;double&gt; sumx = X.get_column(0);\n    double sumt = m_Expl[0];\n    double sumt2 = m_Expl[0] * m_Expl[0];\n    for (unsigned int k = 1; k &lt; X.cols(); k++)  // k is the sample number\n    {\n      sumtx += m_Expl[k] * X.get_column(k);\n      sumx += X.get_column(k);\n      sumt += m_Expl[k];\n      sumt2 += m_Expl[k] * m_Expl[k];\n    }\n\n    m_Slope = (n * sumtx - (sumx * sumt)) / (n * sumt2 - (sumt * sumt));\n\n    vnl_vector&lt;double&gt; sumbt = m_Slope * m_Expl[0];\n    for (unsigned int k = 1; k &lt; X.cols(); k++) {\n      sumbt += m_Slope * m_Expl[k];\n    }\n\n    m_Intercept = (sumx - sumbt) / n;\n  }\n\n  //\n  void Initialize() {\n    m_Intercept.fill(0.0);\n    m_Slope.fill(0.0);\n    m_MeanMatrix.fill(0.0);\n  }\n\n  virtual void BeforeIteration() {\n    m_UpdateCounter++;\n    if (m_UpdateCounter &gt;= m_RegressionInterval) {\n      m_UpdateCounter = 0;\n      this-&gt;EstimateParameters();\n      this-&gt;UpdateMeanMatrix();\n    }\n  }\n\n  void SetRegressionInterval(int i) { m_RegressionInterval = i; }\n  int GetRegressionInterval() const { return m_RegressionInterval; }\n\n protected:\n  LinearRegressionShapeMatrix() {\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n    m_UpdateCounter = 0;\n    m_RegressionInterval = 1;\n  }\n  virtual ~LinearRegressionShapeMatrix(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  LinearRegressionShapeMatrix(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);                                // purposely not implemented\n\n  int m_UpdateCounter;\n  int m_RegressionInterval;\n\n  // Parameters for the linear model\n  vnl_vector&lt;double&gt; m_Intercept;\n  vnl_vector&lt;double&gt; m_Slope;\n\n  // The explanatory variable value for each sample (matrix column)\n  vnl_vector&lt;double&gt; m_Expl;\n\n  // A matrix to store the mean estimated for each explanatory variable (each sample)\n  vnl_matrix&lt;double&gt; m_MeanMatrix;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/LogWindow_8h.html","title":"Studio/Interface/LogWindow.h","text":""},{"location":"api/Files/LogWindow_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/LogWindow_8h.html#classes","title":"Classes","text":"Name class shapeworks::LogWindow Log Window."},{"location":"api/Files/LogWindow_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QDialog&gt;\n\n#include &lt;Interface/StatusBarWidget.h&gt;\n\n// Forward Qt class declarations\nclass Ui_LogWindow;\n\nnamespace shapeworks {\n\n\nclass LogWindow : public QDialog {\nQ_OBJECT\n\npublic:\n\n  LogWindow(QWidget* parent = 0);\n\n  void add_message(MessageType message_type, QString message);\n\nprivate:\n\n  Ui_LogWindow* ui_;\n\n};\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Logging_8h.html","title":"Libs/Common/Logging.h","text":""},{"location":"api/Files/Logging_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Logging_8h.html#classes","title":"Classes","text":"Name struct fmt::formatter&lt; QString &gt; class shapeworks::Logging ShapeWorks Logging Library."},{"location":"api/Files/Logging_8h.html#functions","title":"Functions","text":"Name template &lt;typename... Args&gt; std::string safe_format(const std::string &amp; fmt_str, const Args &amp;... args)"},{"location":"api/Files/Logging_8h.html#defines","title":"Defines","text":"Name SW_LOG_STACK(message) Log stack macro. SW_LOG(message, ...) Log message macro. SW_LOG_ONLY(message, ...) Log only macro. SW_WARN(message, ...) Log warning macro. SW_ERROR(message, ...) Log error macro. SW_DEBUG(message, ...) Log debug macro. SW_TRACE(x) Variable trace macro (e.g. output variable name = ) SW_MESSAGE(message, ...) Log show message macro. SW_STATUS(message, ...) Don't write to log, but set status (e.g. in the Studio statusbar) SW_PROGRESS(value, message, ...) SW_CLOSE_LOG() Close session macro. SW_LOG_ONCE(message, ...) Log once macro, will only log the message once."},{"location":"api/Files/Logging_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/Logging_8h.html#function-safe_format","title":"function safe_format","text":"<pre><code>template &lt;typename... Args&gt;\nstd::string safe_format(\n    const std::string &amp; fmt_str,\n    const Args &amp;... args\n)\n</code></pre>"},{"location":"api/Files/Logging_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/Logging_8h.html#define-sw_log_stack","title":"define SW_LOG_STACK","text":"<pre><code>#define SW_LOG_STACK(\n    message\n)\nshapeworks::Logging::Instance().log_stack(message)\n</code></pre> <p>Log stack macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_log","title":"define SW_LOG","text":"<pre><code>#define SW_LOG(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().log_message(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__);\n</code></pre> <p>Log message macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_log_only","title":"define SW_LOG_ONLY","text":"<pre><code>#define SW_LOG_ONLY(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().log_only(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__, __FUNCTION__);\n</code></pre> <p>Log only macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_warn","title":"define SW_WARN","text":"<pre><code>#define SW_WARN(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().log_warning(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n</code></pre> <p>Log warning macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_error","title":"define SW_ERROR","text":"<pre><code>#define SW_ERROR(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().log_error(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n</code></pre> <p>Log error macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_debug","title":"define SW_DEBUG","text":"<pre><code>#define SW_DEBUG(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().log_debug(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__, __FUNCTION__)\n</code></pre> <p>Log debug macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_trace","title":"define SW_TRACE","text":"<pre><code>#define SW_TRACE(\n    x\n)\nSW_DEBUG(#x \" = {}\", x);\n</code></pre> <p>Variable trace macro (e.g. output variable name = )"},{"location":"api/Files/Logging_8h.html#define-sw_message","title":"define SW_MESSAGE","text":"<pre><code>#define SW_MESSAGE(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().show_message(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n</code></pre> <p>Log show message macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_status","title":"define SW_STATUS","text":"<pre><code>#define SW_STATUS(\n    message,\n    ...\n)\nshapeworks::Logging::Instance().show_status(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n</code></pre> <p>Don't write to log, but set status (e.g. in the Studio statusbar) </p>"},{"location":"api/Files/Logging_8h.html#define-sw_progress","title":"define SW_PROGRESS","text":"<pre><code>#define SW_PROGRESS(\n    value,\n    message,\n    ...\n)\nshapeworks::Logging::Instance().show_progress(value, safe_format(message, ##__VA_ARGS__));\n</code></pre>"},{"location":"api/Files/Logging_8h.html#define-sw_close_log","title":"define SW_CLOSE_LOG","text":"<pre><code>#define SW_CLOSE_LOG(\n\n)\nshapeworks::Logging::Instance().close_log();\n</code></pre> <p>Close session macro. </p>"},{"location":"api/Files/Logging_8h.html#define-sw_log_once","title":"define SW_LOG_ONCE","text":"<pre><code>#define SW_LOG_ONCE(\n    message,\n    ...\n)\n  {                                   \\\n    static bool logged = false;       \\\n    if (!logged) {                    \\\n      SW_LOG(message, ##__VA_ARGS__); \\\n      logged = true;                  \\\n    }                                 \\\n  }\n</code></pre> <p>Log once macro, will only log the message once. </p>"},{"location":"api/Files/Logging_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;spdlog/fmt/fmt.h&gt;\n\n#include &lt;QString&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;&gt;\nstruct fmt::formatter&lt;QString&gt; {\n  constexpr auto parse(format_parse_context&amp; ctx) -&gt; decltype(ctx.begin()) { return ctx.end(); }\n\n  template &lt;typename FormatContext&gt;\n  auto format(const QString&amp; str, FormatContext&amp; ctx) const -&gt; decltype(ctx.out()) {\n    return fmt::format_to(ctx.out(), \"{}\", qUtf8Printable(str));\n  }\n};\n\ntemplate &lt;typename... Args&gt;\nstd::string safe_format(const std::string&amp; fmt_str, const Args&amp;... args) {\n  std::string result;\n  try {\n    result = fmt::format(fmt_str, args...);\n  } catch (const std::exception&amp; e) {\n    // Handle formatting errors here, example:\n    std::cerr &lt;&lt; \"Error formatting string: \" &lt;&lt; fmt_str &lt;&lt; \" : \" &lt;&lt; e.what() &lt;&lt; std::endl;\n  }\n  return result;\n}\n\nnamespace shapeworks {\n\nclass Logging {\n public:\n  static Logging&amp; Instance();\n\n  void open_file_log(const std::string&amp; filename);\n\n  bool check_log_open() const;\n\n  std::string get_log_filename() const;\n\n  void log_message(const std::string&amp; message, const int line, const char* file) const;\n\n  void log_only(const std::string&amp; message, const int line, const char* file, const char *function) const;\n\n  void log_stack(const std::string&amp; message) const;\n\n  void log_error(const std::string&amp; message, const int line, const char* file) const;\n\n  void show_message(const std::string&amp; message, const int line, const char* file) const;\n\n  void show_status(const std::string&amp; message, const int line, const char* file) const;\n\n  void show_progress(double value, const std::string&amp; message);\n\n  void log_debug(const std::string&amp; message, const int line, const char* file, const char* function) const;\n\n  void log_warning(const std::string&amp; message, const int line, const char* file) const;\n\n  void close_log();\n\n  void set_error_callback(const std::function&lt;void(std::string)&gt;&amp; callback);\n\n  void set_message_callback(const std::function&lt;void(std::string)&gt;&amp; callback);\n\n  void set_warning_callback(const std::function&lt;void(std::string)&gt;&amp; callback);\n\n  void set_debug_callback(const std::function&lt;void(std::string)&gt;&amp; callback);\n\n  void set_status_callback(const std::function&lt;void(std::string)&gt;&amp; callback);\n\n  void set_progress_callback(const std::function&lt;void(double, std::string)&gt;&amp; callback);\n\n private:\n  Logging();\n\n  std::string log_filename_;\n  bool log_open_ = false;\n\n  std::function&lt;void(std::string)&gt; error_callback_;\n\n  std::function&lt;void(std::string)&gt; message_callback_;\n\n  std::function&lt;void(std::string)&gt; warning_callback_;\n\n  std::function&lt;void(std::string)&gt; debug_callback_;\n\n  std::function&lt;void(std::string)&gt; status_callback_;\n\n  std::function&lt;void(double, std::string)&gt; progress_callback_;\n};\n\n#define SW_LOG_STACK(message) shapeworks::Logging::Instance().log_stack(message)\n\n#define SW_LOG(message, ...) \\\n  shapeworks::Logging::Instance().log_message(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__);\n\n#define SW_LOG_ONLY(message, ...) \\\n  shapeworks::Logging::Instance().log_only(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__, __FUNCTION__);\n\n#define SW_WARN(message, ...) \\\n  shapeworks::Logging::Instance().log_warning(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n\n#define SW_ERROR(message, ...) \\\n  shapeworks::Logging::Instance().log_error(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n\n#define SW_DEBUG(message, ...) \\\n  shapeworks::Logging::Instance().log_debug(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__, __FUNCTION__)\n\n#define SW_TRACE(x) SW_DEBUG(#x \" = {}\", x);\n\n#define SW_MESSAGE(message, ...) \\\n  shapeworks::Logging::Instance().show_message(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n\n#define SW_STATUS(message, ...) \\\n  shapeworks::Logging::Instance().show_status(safe_format(message, ##__VA_ARGS__), __LINE__, __FILE__)\n\n#define SW_PROGRESS(value, message, ...) \\\n  shapeworks::Logging::Instance().show_progress(value, safe_format(message, ##__VA_ARGS__));\n\n#define SW_CLOSE_LOG() shapeworks::Logging::Instance().close_log();\n\n#define SW_LOG_ONCE(message, ...)     \\\n  {                                   \\\n    static bool logged = false;       \\\n    if (!logged) {                    \\\n      SW_LOG(message, ##__VA_ARGS__); \\\n      logged = true;                  \\\n    }                                 \\\n  }\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeanCurvatureContainer_8h.html","title":"Libs/Optimize/Container/MeanCurvatureContainer.h","text":""},{"location":"api/Files/MeanCurvatureContainer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeanCurvatureContainer_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeanCurvatureContainer"},{"location":"api/Files/MeanCurvatureContainer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"GenericContainer.h\"\n#include \"GenericContainerArray.h\"\n#include \"Libs/Optimize/Domain/ImageDomainWithCurvature.h\"\n#include \"ParticleSystem.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n\nnamespace shapeworks {\ntemplate &lt;class TNumericType, unsigned int VDimension&gt;\nclass MeanCurvatureContainer : public GenericContainerArray&lt;TNumericType&gt; {\n public:\n  typedef TNumericType NumericType;\n  typedef MeanCurvatureContainer Self;\n  typedef GenericContainerArray&lt;TNumericType&gt; Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  typedef ParticleSystem ParticleSystemType;\n  typedef typename ParticleSystemType::PointType PointType;\n  typedef vnl_vector_fixed&lt;TNumericType, VDimension&gt; VnlVectorType;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(MeanCurvatureContainer, GenericContainerArray);\n\n  void SetVerbosity(unsigned int val) { m_verbosity = val; }\n\n  unsigned int GetVerbosity() { return m_verbosity; }\n\n  virtual void PositionAddEventCallback(itk::Object* o, const itk::EventObject&amp; e) {\n    Superclass::PositionAddEventCallback(o, e);\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystemType* ps = dynamic_cast&lt;const ParticleSystemType*&gt;(o);\n    this-&gt;ComputeMeanCurvature(ps, event.GetPositionIndex(), event.GetDomainIndex());\n  }\n\n  virtual void PositionSetEventCallback(itk::Object* o, const itk::EventObject&amp; e) {\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n    const ParticleSystemType* ps = dynamic_cast&lt;const ParticleSystemType*&gt;(o);\n    this-&gt;ComputeMeanCurvature(ps, event.GetPositionIndex(), event.GetDomainIndex());\n  }\n\n  virtual void DomainAddEventCallback(itk::Object* o, const itk::EventObject&amp; e) {\n    Superclass::DomainAddEventCallback(o, e);\n    m_MeanCurvatureList.push_back(0.0);\n    m_CurvatureStandardDeviationList.push_back(0.0);\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    const ParticleSystemType* ps = dynamic_cast&lt;const ParticleSystemType*&gt;(o);\n\n    if (!ps-&gt;GetDomainFlag(event.GetDomainIndex())) {\n      this-&gt;ComputeCurvatureStatistics(ps, event.GetDomainIndex());\n    }\n  }\n\n  inline void ComputeMeanCurvature(const ParticleSystemType* system, unsigned int idx, unsigned int dom) {\n    //  Get the position and index.\n    PointType pos = system-&gt;GetPosition(idx, dom);\n    this-&gt;operator[](dom)-&gt;operator[](idx) = system-&gt;GetDomain(dom)-&gt;GetCurvature(pos, idx);\n  }\n\n  virtual void ComputeCurvatureStatistics(const ParticleSystemType*, unsigned int d);\n\n  double GetMeanCurvature(int d) { return m_MeanCurvatureList[d]; }\n  double GetCurvatureStandardDeviation(int d) { return m_CurvatureStandardDeviationList[d]; }\n\n protected:\n  MeanCurvatureContainer() {\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n  }\n  virtual ~MeanCurvatureContainer(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  MeanCurvatureContainer(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);                  // purposely not implemented\n\n  std::vector&lt;double&gt; m_MeanCurvatureList;\n  std::vector&lt;double&gt; m_CurvatureStandardDeviationList;\n  unsigned int m_verbosity;\n};\n\n}  // namespace shapeworks\n\n#include \"MeanCurvatureContainer.txx\"\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MemoryUsage_8h.html","title":"Libs/Optimize/Utils/MemoryUsage.h","text":""},{"location":"api/Files/MemoryUsage_8h.html#functions","title":"Functions","text":"Name void process_mem_usage(double &amp; vm_usage, double &amp; resident_set)"},{"location":"api/Files/MemoryUsage_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/MemoryUsage_8h.html#function-process_mem_usage","title":"function process_mem_usage","text":"<pre><code>void process_mem_usage(\n    double &amp; vm_usage,\n    double &amp; resident_set\n)\n</code></pre>"},{"location":"api/Files/MemoryUsage_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n//TODO: Figure out memory logging in Windows or get rid of this\n// Disabled by default because this code is *nix specific.\n// #define LOG_MEMORY_USAGE\n\nvoid process_mem_usage(double&amp; vm_usage, double&amp; resident_set);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshCache_8h.html","title":"Libs/Analyze/MeshCache.h","text":""},{"location":"api/Files/MeshCache_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshCache_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshCache Thread safe cache for meshes index by shape."},{"location":"api/Files/MeshCache_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"MeshWorkQueue.h\"\n#include \"StudioMesh.h\"\n\n// qt\n#include &lt;QMutex&gt;\n\n// std\n#include &lt;list&gt;\n#include &lt;map&gt;\n\nnamespace shapeworks {\n\n// mesh cache type\nusing CacheMap = std::map&lt;MeshWorkItem, MeshHandle&gt;;\n\n// LRU list\nusing CacheList = std::list&lt;MeshWorkItem&gt;;\n\nclass MeshCache {\n public:\n  MeshCache();\n\n  void set_cache_enabled(bool enabled) { cache_enabled_ = enabled; }\n\n  void set_memory_percent(int percent) { cache_memory_percent_ = percent; }\n\n  MeshHandle get_mesh(const MeshWorkItem&amp; vector);\n\n  void insert_mesh(const MeshWorkItem&amp; item, MeshHandle mesh);\n\n  void clear();\n\n private:\n  void freeSpaceForAmount(size_t allocation);\n\n  static long long get_total_physical_memory();\n  static long long get_total_addressable_memory();\n  static long long get_total_addressable_physical_memory();\n\n  // mesh cache\n  CacheMap mesh_cache_;\n\n  // lrc list\n  CacheList cache_list_;\n\n  // size of memory in use by the cache\n  size_t current_memory_size_ = 0;\n\n  // maximum memory\n  long long max_memory_ = 0;\n\n  // for concurrent access\n  QMutex mutex_;\n\n  bool cache_enabled_ = true;\n  int cache_memory_percent_ = 0;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeshComputeThickness_8h.html","title":"Libs/Mesh/MeshComputeThickness.h","text":""},{"location":"api/Files/MeshComputeThickness_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) shapeworks::mesh"},{"location":"api/Files/MeshComputeThickness_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Image.h&gt;\n#include &lt;Mesh.h&gt;\n\nnamespace shapeworks::mesh {\n\nvoid compute_thickness(Mesh &amp;mesh, Image &amp;image, Image *dt, double max_dist, double median_radius,\n                       std::string distance_mesh);\n\nMesh compute_inner_mesh(const Mesh &amp;mesh, std::string array_name);\n\nvoid summarize_internal_intensities(Mesh &amp;outer_mesh, Mesh &amp;inner_mesh, Image &amp;image);\n\n}  // namespace shapeworks::mesh\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshDomain_8h.html","title":"Libs/Optimize/Domain/MeshDomain.h","text":""},{"location":"api/Files/MeshDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshDomain"},{"location":"api/Files/MeshDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkObjectFactory.h&gt;\n\n#include \"Surface.h\"\n#include \"ParticleDomain.h\"\n\nnamespace shapeworks {\n\nclass MeshDomain : public ParticleDomain {\n public:\n  using Pointer = std::shared_ptr&lt;MeshDomain&gt;;\n\n  DomainType GetDomainType() const override { return DomainType::Mesh; }\n\n  bool ApplyConstraints(PointType &amp;p, int idx, bool dbg = false) const override;\n  bool ApplyVectorConstraints(VectorDoubleType &amp;gradE, const PointType &amp;pos) const;\n  VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp;gradE, const PointType &amp;pos, int idx) const override;\n  PointType UpdateParticlePosition(const PointType &amp;point, int idx, VectorDoubleType &amp;update) const override;\n\n  virtual void InvalidateParticlePosition(int idx) const override;\n\n  double GetCurvature(const PointType &amp;p, int idx) const override {\n    // TODO Why not return the actual curvature\n    return GetSurfaceMeanCurvature();\n  }\n\n  inline double GetSurfaceMeanCurvature() const override {\n    // This function is used by MeanCurvatureAttribute which is used for good/bad assessment\n    // These arbitrary values should eventually be replaced with actual computation\n    return 0.15;\n  }\n\n  inline double GetSurfaceStdDevCurvature() const override {\n    // This function is used by MeanCurvatureAttribute which is used for good/bad assessment\n    // These arbitrary values should eventually be replaced with actual computation\n    return 0.02;\n  }\n\n  const PointType &amp;GetLowerBound() const override { return surface_-&gt;get_mesh_lower_bound(); }\n  const PointType &amp;GetUpperBound() const override { return surface_-&gt;get_mesh_upper_bound(); }\n\n  PointType GetZeroCrossingPoint() const override;\n\n  PointType GetValidLocationNear(PointType p) const override;\n\n  double GetSurfaceArea() const override {\n    // TODO return actual surface area\n    return 0;\n  }\n\n  double GetMaxDiameter() const override;\n\n  vnl_vector_fixed&lt;float, DIMENSION&gt; SampleGradientAtPoint(const PointType &amp;point, int idx) const override;\n\n  vnl_vector_fixed&lt;float, DIMENSION&gt; SampleNormalAtPoint(const PointType &amp;point, int idx) const override;\n\n  GradNType SampleGradNAtPoint(const PointType &amp;p, int idx) const override;\n\n  double Distance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b,\n                  vnl_vector_fixed&lt;double, DIMENSION&gt; *out_grad = nullptr) const override;\n\n  double SquaredDistance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b) const override;\n\n  bool IsWithinDistance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b, double test_dist,\n                        double &amp;dist) const override;\n\n  void DeleteImages() override {\n    // TODO Change this to a generic delete function\n  }\n\n  void DeletePartialDerivativeImages() override {\n    // TODO Change this to a generic delete function\n  }\n\n  void SetMesh(std::shared_ptr&lt;Surface&gt; mesh_, double geodesic_remesh_percent);\n\n  std::shared_ptr&lt;Mesh&gt; GetSWMesh() const { return sw_mesh_; }\n\n  void UpdateZeroCrossingPoint() override {}\n\n  std::shared_ptr&lt;Surface&gt; get_surface() const { return surface_; }\n\n private:\n  std::shared_ptr&lt;Surface&gt; surface_;\n  std::shared_ptr&lt;Surface&gt; geodesics_mesh_;\n  std::shared_ptr&lt;Mesh&gt; sw_mesh_;\n  PointType zero_crossing_point_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshGenerator_8h.html","title":"Libs/Analyze/MeshGenerator.h","text":"<p>Mesh generation.  More...</p>"},{"location":"api/Files/MeshGenerator_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshGenerator_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshReconstructors class shapeworks::MeshGenerator"},{"location":"api/Files/MeshGenerator_8h.html#detailed-description","title":"Detailed Description","text":"<p>Mesh generation. </p> <p>The MeshGenerator performs the actual work of reconstructing a mesh from a shape (list of points). </p>"},{"location":"api/Files/MeshGenerator_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;QSharedPointer&gt;\n\n#include \"vnl/vnl_vector.h\"\n\n#include \"StudioMesh.h\"\n#include \"MeshWorkQueue.h\"\n\nclass SurfaceReconstructor;\n\nnamespace shapeworks {\n\nclass QMeshWarper;\n\nclass MeshReconstructors {\npublic:\n  std::vector&lt;std::shared_ptr&lt;SurfaceReconstructor&gt;&gt; surface_reconstructors_;\n  std::vector&lt;std::shared_ptr&lt;QMeshWarper&gt;&gt; mesh_warpers_;\n};\n\nclass MeshGenerator {\npublic:\n\n  MeshGenerator();\n\n  ~MeshGenerator();\n\n  MeshHandle build_mesh(const MeshWorkItem&amp; item);\n\n  MeshHandle build_mesh_from_points(const Eigen::VectorXd&amp; shape, int domain);\n\n  MeshHandle build_mesh_from_image(ImageType::Pointer image, float iso_value = 0.0001);\n\n  MeshHandle build_mesh_from_file(std::string filename, float iso_value = 0.0001);\n\n  void set_mesh_reconstructors(std::shared_ptr&lt;MeshReconstructors&gt; reconstructors);\n\n  void set_reconstruction_method(std::string method);\n  std::string get_reconstruction_method();\n\n  static const std::string RECONSTRUCTION_LEGACY_C;\n  static const std::string RECONSTRUCTION_DISTANCE_TRANSFORM_C;\n  static const std::string RECONSTRUCTION_MESH_WARPER_C;\n\nprivate:\n\n  std::shared_ptr&lt;MeshReconstructors&gt; reconstructors_ = std::make_shared&lt;MeshReconstructors&gt;();\n\n  std::string reconstruction_method_ = RECONSTRUCTION_MESH_WARPER_C;\n\n};\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeshGeoEntry_8h.html","title":"Libs/Optimize/Domain/MeshGeoEntry.h","text":""},{"location":"api/Files/MeshGeoEntry_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshGeoEntry_8h.html#classes","title":"Classes","text":"Name struct shapeworks::MeshGeoEntry"},{"location":"api/Files/MeshGeoEntry_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"robin_hood.h\"\n#include &lt;Eigen/Dense&gt;\n\nnamespace shapeworks {\nstruct MeshGeoEntry {\n  // in \"Full\" mode, the entry contains geodesics to every vertex. Access via `data_full`\n  // in \"Partial\" mode, the entry only contains geodesics upto max_dist. Access via `data_partial`\n  enum Mode {\n    Full,\n    Partial,\n  };\n\n  Mode mode{Mode::Partial};\n\n  double max_dist{0.0};\n  robin_hood::unordered_flat_map&lt;int, Eigen::Vector3d&gt; data_partial;\n  std::array&lt;Eigen::VectorXd, 3&gt; data_full;\n\n  void clear() {\n    mode = Mode::Partial;\n\n    max_dist = 0.0;\n\n    // calling `data_partial.clear()` doesn't free the backing memory, so we have to swap to an empty\n    robin_hood::unordered_flat_map&lt;int, Eigen::Vector3d&gt; new_data_partial;\n    std::swap(new_data_partial, data_partial);\n\n    data_full[0].resize(0);\n    data_full[1].resize(0);\n    data_full[2].resize(0);\n  }\n\n  bool is_full_mode() const {\n    return mode == Mode::Full;\n  }\n\n  void update_max_dist() {\n    assert(is_full_mode()); // the caller most likely has a more efficient way to compute this if partial mode\n    const auto max0 = data_full[0].maxCoeff();\n    const auto max1 = data_full[1].maxCoeff();\n    const auto max2 = data_full[2].maxCoeff();\n    max_dist = std::max({max0, max1, max2});\n  }\n\n  bool has_entry(int target) {\n    return is_full_mode() || data_partial.find(target) != data_partial.end();\n  }\n};\n\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshGroup_8h.html","title":"Libs/Analyze/MeshGroup.h","text":""},{"location":"api/Files/MeshGroup_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshGroup_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshGroup Representation of a group of meshes."},{"location":"api/Files/MeshGroup_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"StudioMesh.h\"\n\nnamespace shapeworks {\n\n\nclass MeshGroup {\n public:\n  MeshGroup();\n\n  MeshGroup(unsigned long num_meshes);\n\n  ~MeshGroup();\n\n  void set_number_of_meshes(int n);\n\n  bool valid();\n\n  void set_mesh(int i, MeshHandle mesh);\n\n  MeshList&amp; meshes();\n\n  vtkSmartPointer&lt;vtkPolyData&gt; get_combined_poly_data();\n\n private:\n  MeshList meshes_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeshManager_8h.html","title":"Libs/Analyze/MeshManager.h","text":""},{"location":"api/Files/MeshManager_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshManager_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshManager Class to manage meshes."},{"location":"api/Files/MeshManager_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"MeshCache.h\"\n#include \"MeshGenerator.h\"\n#include \"MeshWorkQueue.h\"\n#include \"MeshWorker.h\"\n\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;QThreadPool&gt;\n#include &lt;QWaitCondition&gt;\n\nclass SurfaceReconstructor;\n\nnamespace shapeworks {\n\nclass MeshWarper;\n\nclass MeshManager : public QObject {\n  Q_OBJECT\n\n public:\n  MeshManager();\n  ~MeshManager();\n\n  void set_cache_enabled(bool enabled);\n\n  void set_cache_memory_percent(int percent);\n\n  void set_parallel_enabled(bool enabled) { parallel_enabled_ = enabled; }\n\n  void set_num_threads(int num_threads) { num_threads_ = num_threads; }\n\n  void generate_mesh(const MeshWorkItem item);\n\n  MeshHandle get_mesh(const MeshWorkItem&amp; item, bool wait = false);\n\n  MeshHandle get_mesh(const Eigen::VectorXd&amp; points, int domain, bool wait = false);\n\n  std::shared_ptr&lt;SurfaceReconstructor&gt; get_surface_reconstructor(int domain);\n\n  std::shared_ptr&lt;MeshWarper&gt; get_mesh_warper(int domain);\n\n  std::shared_ptr&lt;MeshGenerator&gt; get_mesh_generator() { return this-&gt;mesh_generator_; }\n\n  void clear_cache();\n\n public Q_SLOTS:\n\n  void handle_thread_complete(const MeshWorkItem&amp; item, MeshHandle mesh);\n\n  void handle_warper_progress();\n\n Q_SIGNALS:\n\n  void new_mesh();\n\n  void error_encountered(QString message);\n\n  void progress(int);\n  void status(std::string);\n\n private:\n  std::shared_ptr&lt;MeshReconstructors&gt; reconstructors_ = std::make_shared&lt;MeshReconstructors&gt;();\n\n  void check_error_status(MeshHandle mesh);\n\n  // cache of shape meshes\n  MeshCache mesh_cache_;\n\n  // the mesh generator\n  std::shared_ptr&lt;MeshGenerator&gt; mesh_generator_ = std::make_shared&lt;MeshGenerator&gt;();\n\n  // queue of meshes to build\n  MeshWorkQueue work_queue_;\n\n  QThreadPool thread_pool_;\n\n  bool cache_enabled_ = true;\n  bool parallel_enabled_ = true;\n  int num_threads_ = 1;\n\n  bool error_emitted_ = false;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeshSettings_8h.html","title":"Studio/Data/MeshSettings.h","text":""},{"location":"api/Files/MeshSettings_8h.html#classes","title":"Classes","text":"Name class MeshSettings Settings for creating a mesh."},{"location":"api/Files/MeshSettings_8h.html#types","title":"Types","text":"Name typedef QSharedPointer&lt; MeshSettings &gt; MeshSettingsHandle"},{"location":"api/Files/MeshSettings_8h.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/MeshSettings_8h.html#typedef-meshsettingshandle","title":"typedef MeshSettingsHandle","text":"<pre><code>typedef QSharedPointer&lt; MeshSettings &gt; MeshSettingsHandle;\n</code></pre>"},{"location":"api/Files/MeshSettings_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QString&gt;\n#include &lt;QSharedPointer&gt;\n\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;vnl/vnl_vector.h&gt;\n\nclass MeshSettings;\ntypedef QSharedPointer&lt; MeshSettings &gt; MeshSettingsHandle;\n\n\nclass MeshSettings\n{\n\npublic:\n\n  MeshSettings();\n\n  ~MeshSettings();\n\nprivate:\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshSlice_8h.html","title":"Studio/Visualization/MeshSlice.h","text":""},{"location":"api/Files/MeshSlice_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshSlice_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshSlice MeshSlice."},{"location":"api/Files/MeshSlice_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkSmartPointer.h&gt;\n\nclass vtkImageSlice;\nclass vtkImageSliceMapper;\nclass vtkImageData;\n\nnamespace shapeworks {\n\nclass Viewer;\n\nclass MeshSlice {\n public:\n  MeshSlice(Viewer* viewer);\n\n  void set_volume(vtkSmartPointer&lt;vtkImageData&gt; volume);\n\n  bool is_image_loaded();\n\n  void update_renderer();\n\n  void update_camera();\n\n  void handle_key(std::string key);\n\n private:\n  Viewer *viewer_;\n\n  vtkSmartPointer&lt;vtkImageSlice&gt; image_slice_;\n  vtkSmartPointer&lt;vtkImageSliceMapper&gt; slice_mapper_;\n  vtkSmartPointer&lt;vtkImageData&gt; volume_;\n  int image_slice_number_ = 0;\n\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshUtils_8h.html","title":"Libs/Mesh/MeshUtils.h","text":""},{"location":"api/Files/MeshUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshUtils"},{"location":"api/Files/MeshUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Eigen/Core\"\n#include \"Eigen/Dense\"\n#include \"Mesh.h\"\n#include \"ShapeworksUtils.h\"\n\nclass vtkActor;\n\nnamespace shapeworks {\nclass MeshUtils {\n  public:\n    static const vtkSmartPointer&lt;vtkMatrix4x4&gt; createICPTransform(const Mesh source,\n                                                                  const Mesh target,\n                                                                  Mesh::AlignmentType align,\n                                                                  const unsigned iterations = 20,\n                                                                  bool meshTransform = false);\n\n    static Mesh create_mesh_from_file(std::string filename, double iso_value = 0.5);\n\n    static Mesh threadSafeReadMesh(std::string filename);\n\n    static void threadSafeWriteMesh(std::string filename, Mesh mesh);\n\n    static PhysicalRegion boundingBox(const std::vector&lt;std::string&gt;&amp; filenames, bool center = false);\n\n    static PhysicalRegion boundingBox(const std::vector&lt;std::reference_wrapper&lt;const Mesh&gt; &gt;&amp; meshes,\n                                      bool center = false);\n\n    static PhysicalRegion boundingBox(const std::vector&lt;Mesh&gt;&amp; meshes, bool center = false);\n\n    static int findReferenceMesh(std::vector&lt;Mesh&gt;&amp; meshes, int random_subset_size = -1);\n\n    static Mesh extract_boundary_loop(Mesh mesh);\n\n    static std::array&lt;Mesh, 3&gt; shared_boundary_extractor(const Mesh&amp; mesh_l, const Mesh&amp; mesh_r, double tol);\n\n    static void generateNormals(const std::vector&lt;std::reference_wrapper&lt;Mesh&gt; &gt;&amp; meshes, bool forceRegen = false);\n\n    static Field computeMeanNormals(const std::vector&lt;std::string&gt;&amp; filenames, bool autoGenerateNormals = true);\n\n    static Field computeMeanNormals(const std::vector&lt;std::reference_wrapper&lt;const Mesh&gt; &gt;&amp; meshes);\n\n    void visualizeVectorFieldForFFCs(std::shared_ptr&lt;Mesh&gt; mesh);\n\n    vtkSmartPointer&lt;vtkActor&gt; getArrow(Eigen::Vector3d start, Eigen::Vector3d end);\n\n    static int evaluate_triangle_position(const double x[3],\n                                          double closestPoint[3],\n                                          int&amp; subId,\n                                          double pcoords[3],\n                                          double&amp; dist2,\n                                          double weights[],\n                                          double pt3[3],\n                                          double pt1[3],\n                                          double pt2[3]);\n\n    static vtkSmartPointer&lt;vtkPolyData&gt; clean_mesh(vtkSmartPointer&lt;vtkPolyData&gt; mesh);\n\n    static vtkSmartPointer&lt;vtkPolyData&gt; remove_zero_area_triangles(vtkSmartPointer&lt;vtkPolyData&gt; mesh);\n\n    static vtkSmartPointer&lt;vtkPolyData&gt; recreate_mesh(vtkSmartPointer&lt;vtkPolyData&gt; mesh);\n\n    static vtkSmartPointer&lt;vtkPolyData&gt; repair_mesh(vtkSmartPointer&lt;vtkPolyData&gt; mesh);\n};\n} // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshWarper_8h.html","title":"Libs/Mesh/MeshWarper.h","text":"<p>Mesh warping capability.  More...</p>"},{"location":"api/Files/MeshWarper_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshWarper_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshWarper"},{"location":"api/Files/MeshWarper_8h.html#detailed-description","title":"Detailed Description","text":"<p>Mesh warping capability. </p> <p>The MeshWarper provides an object to warp meshes for surface reconstruction </p>"},{"location":"api/Files/MeshWarper_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkPolyData.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\nclass MeshWarper {\n public:\n  void set_reference_mesh(vtkSmartPointer&lt;vtkPolyData&gt; reference_mesh, const Eigen::MatrixXd&amp; reference_particles,\n                          const Eigen::MatrixXd&amp; landmarks = {});\n\n  bool generate_warp();\n\n  bool get_warp_available();\n\n  bool is_contour() const { return is_contour_; }\n\n  vtkSmartPointer&lt;vtkPolyData&gt; build_mesh(const Eigen::MatrixXd&amp; particles);\n\n  Eigen::MatrixXd extract_landmarks(vtkSmartPointer&lt;vtkPolyData&gt; warped_mesh);\n\n  bool is_contour() { return this-&gt;is_contour_; }\n\n  std::map&lt;int, int&gt; get_landmarks_map() const { return landmarks_map_; }\n\n  std::vector&lt;int&gt; get_good_particle_indices() const { return good_particles_; }\n\n  const Eigen::MatrixXd&amp; get_warp_matrix() const { return this-&gt;warp_; }\n\n  bool has_bad_particles() const { return this-&gt;bad_particle_count() &gt; 0; }\n\n  vtkSmartPointer&lt;vtkPolyData&gt; get_reference_mesh() { return this-&gt;reference_mesh_; }\n\n  const Eigen::MatrixXd&amp; get_reference_particles() const { return this-&gt;reference_particles_; }\n\n protected:\n  virtual void update_progress(float p) {}\n\n private:\n  bool check_warp_ready();\n\n  void add_particle_vertices(Eigen::MatrixXd&amp; vertices);\n\n  Eigen::MatrixXd remove_bad_particles(const Eigen::MatrixXd&amp; particles);\n\n  void split_cell_on_edge(int cell_id, int new_vertex, int v0, int v1,\n                          std::vector&lt;vtkSmartPointer&lt;vtkIdList&gt;&gt;&amp; new_triangles);\n\n  void find_good_particles();\n\n  bool find_landmarks_vertices_on_ref_mesh();\n\n  bool generate_warp_matrix(Eigen::MatrixXd target_vertices, Eigen::MatrixXi target_faces,\n                            const Eigen::MatrixXd&amp; references_vertices, Eigen::MatrixXd&amp; warp);\n\n  vtkSmartPointer&lt;vtkPolyData&gt; warp_mesh(const Eigen::MatrixXd&amp; points);\n\n  size_t bad_particle_count() const { return size_t(reference_particles_.rows()) - good_particles_.size(); }\n\n  void diagnose_biharmonic_failure(const Eigen::MatrixXd&amp; TV, const Eigen::MatrixXi&amp; TF,\n                                   const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; S, int k);\n\n\n  // Members\n  Eigen::MatrixXi faces_;\n  Eigen::MatrixXd vertices_;\n  Eigen::MatrixXd warp_;\n  Eigen::MatrixXd landmarks_points_;\n\n  std::vector&lt;int&gt; good_particles_;\n\n  bool needs_warp_ = true;\n\n  bool warp_available_ = false;\n\n  std::map&lt;int, int&gt; landmarks_map_;  // map the landmarks id (Key) to the vertex(point) id (Value) belonging to the\n                                      // clean Reference mesh\n  vtkSmartPointer&lt;vtkPolyData&gt; incoming_reference_mesh_;\n  vtkSmartPointer&lt;vtkPolyData&gt; reference_mesh_;\n  Eigen::MatrixXd reference_particles_;\n  bool is_contour_ = false;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MeshWorkQueue_8h.html","title":"Libs/Analyze/MeshWorkQueue.h","text":""},{"location":"api/Files/MeshWorkQueue_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshWorkQueue_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshWorkItem Provides concurrent access to a list of shapes to work needing reconstruction. class shapeworks::MeshWorkQueue"},{"location":"api/Files/MeshWorkQueue_8h.html#functions","title":"Functions","text":"Name Q_DECLARE_METATYPE(shapeworks::MeshWorkItem )"},{"location":"api/Files/MeshWorkQueue_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/MeshWorkQueue_8h.html#function-q_declare_metatype","title":"function Q_DECLARE_METATYPE","text":"<pre><code>Q_DECLARE_METATYPE(\n    shapeworks::MeshWorkItem \n)\n</code></pre>"},{"location":"api/Files/MeshWorkQueue_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// stl\n#include &lt;list&gt;\n\n// qt\n#include &lt;QMetaType&gt;\n#include &lt;QMutex&gt;\n\n// eigen\n#include &lt;Eigen/Eigen&gt;\n\nnamespace shapeworks {\n\nclass MeshWorkItem {\n public:\n  std::string filename;\n  Eigen::VectorXd points;\n  int domain{0};\n\n  size_t memory_size{0};\n\n  friend bool operator&lt;(const MeshWorkItem &amp;a, const MeshWorkItem &amp;b);\n\n  friend bool operator==(const MeshWorkItem &amp;a, const MeshWorkItem &amp;b);\n};\n\nclass MeshWorkQueue {\n public:\n  using WorkList = std::list&lt;MeshWorkItem&gt;;\n\n  MeshWorkQueue();\n  ~MeshWorkQueue();\n\n  void push(const MeshWorkItem &amp;item);\n\n  MeshWorkItem *get_next_work_item();\n\n  bool is_inside(const MeshWorkItem &amp;item);\n\n  void remove(const MeshWorkItem &amp;item);\n\n  bool is_empty();\n\n  int size();\n\n private:\n  bool in_inside_list(const MeshWorkItem &amp;item, const WorkList &amp;list);\n\n  // for concurrent access\n  QMutex mutex_;\n\n  WorkList work_list_;\n\n  WorkList processing_list_;\n};\n}  // namespace shapeworks\n\nQ_DECLARE_METATYPE(shapeworks::MeshWorkItem);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/MeshWorker_8h.html","title":"Libs/Analyze/MeshWorker.h","text":"<p>Worker class for parallel mesh reconstruction.  More...</p>"},{"location":"api/Files/MeshWorker_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MeshWorker_8h.html#classes","title":"Classes","text":"Name class shapeworks::MeshWorker"},{"location":"api/Files/MeshWorker_8h.html#functions","title":"Functions","text":"Name Q_DECLARE_METATYPE(vtkSmartPointer&lt; vtkPolyData &gt; )"},{"location":"api/Files/MeshWorker_8h.html#detailed-description","title":"Detailed Description","text":"<p>Worker class for parallel mesh reconstruction. </p> <p>The MeshWorker implements each thread's mesh construction management </p>"},{"location":"api/Files/MeshWorker_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/MeshWorker_8h.html#function-q_declare_metatype","title":"function Q_DECLARE_METATYPE","text":"<pre><code>Q_DECLARE_METATYPE(\n    vtkSmartPointer&lt; vtkPolyData &gt; \n)\n</code></pre>"},{"location":"api/Files/MeshWorker_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QObject&gt;\n#include &lt;QWaitCondition&gt;\n#include &lt;QMetaType&gt;\n#include &lt;QRunnable&gt;\n\n#include \"MeshWorkQueue.h\"\n#include \"MeshCache.h\"\n#include \"MeshGenerator.h\"\n\nQ_DECLARE_METATYPE(vtkSmartPointer&lt;vtkPolyData&gt;);\n\nnamespace shapeworks {\n\nclass MeshWorker : public QObject, public QRunnable {\nQ_OBJECT\n\npublic:\n  MeshWorker(MeshWorkQueue* queue, std::shared_ptr&lt;MeshGenerator&gt; generator);\n  ~MeshWorker();\n\n  void run();\n\nQ_SIGNALS:\n  void result_ready(const MeshWorkItem&amp; item, MeshHandle mesh);\n  void finished();\n\nprivate:\n  std::shared_ptr&lt;MeshGenerator&gt; mesh_generator_;\n  MeshWorkQueue* queue_;\n};\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Mesh_8h.html","title":"Libs/Mesh/Mesh.h","text":""},{"location":"api/Files/Mesh_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Mesh_8h.html#classes","title":"Classes","text":"Name class shapeworks::Mesh class shapeworks::MeshReader reads mesh (used only by one of the Mesh constructors)"},{"location":"api/Files/Mesh_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Image/ImageUtils.h&gt;\n\n#include \"Shapeworks.h\"\n\nclass vtkStaticCellLocator;\nclass vtkKdTreePointLocator;\n\nnamespace shapeworks {\n\nclass Mesh {\n public:\n  enum FieldType { Point, Face };\n  enum AlignmentType { Rigid, Similarity, Affine };\n  enum DistanceMethod { PointToPoint, PointToCell };\n  enum CurvatureType { Principal, Gaussian, Mean };\n  enum SubdivisionType { Butterfly, Loop };\n\n  Mesh(const std::string&amp; pathname);\n\n  void set_id(int id) { id_ = id; }\n  int get_id() const { return id_; }\n\n  Mesh(vtkSmartPointer&lt;vtkPolyData&gt; meshPtr) : poly_data_(meshPtr) {\n    if (!poly_data_) throw std::invalid_argument(\"null meshPtr\");\n    invalidateLocators();\n  }\n\n  Mesh(const Mesh&amp; orig) : poly_data_(vtkSmartPointer&lt;vtkPolyData&gt;::New()) {\n    poly_data_-&gt;DeepCopy(orig.poly_data_);\n    id_ = orig.id_;\n    invalidateLocators();\n  }\n\n  Mesh(Mesh&amp;&amp; orig) : poly_data_(orig.poly_data_), id_{orig.id_} { orig.poly_data_ = nullptr; }\n\n  Mesh&amp; operator=(const Mesh&amp; orig) {\n    poly_data_ = vtkSmartPointer&lt;vtkPolyData&gt;::New();\n    poly_data_-&gt;DeepCopy(orig.poly_data_);\n    id_ = orig.id_;\n    invalidateLocators();\n    return *this;\n  }\n\n  Mesh(const Eigen::MatrixXd&amp; points, const Eigen::MatrixXi&amp; faces);\n\n  Mesh&amp; operator=(Mesh&amp;&amp; orig) {\n    poly_data_ = orig.poly_data_;\n    id_ = orig.id_;\n    orig.poly_data_ = nullptr;\n    orig.id_ = -1;\n    return *this;\n  }\n\n  Mesh&amp; operator+=(const Mesh&amp; otherMesh);\n\n  vtkSmartPointer&lt;vtkPolyData&gt; getVTKMesh() const { return this-&gt;poly_data_; }\n\n  Mesh&amp; write(const std::string&amp; pathname, bool binaryFile = false);\n\n  Mesh&amp; coverage(const Mesh&amp; otherMesh, bool allowBackIntersections = true, double angleThreshold = 0,\n                 double backSearchRadius = 0);\n\n  Mesh&amp; smooth(int iterations = 0, double relaxation = 0.0);\n\n  Mesh&amp; smoothSinc(int iterations = 0, double passband = 0.0);\n\n  Mesh&amp; remesh(int numVertices, double adaptivity = 1.0);\n\n  Mesh&amp; remeshPercent(double percentage, double adaptivity = 1.0);\n\n  Mesh&amp; invertNormals();\n\n  Mesh&amp; reflect(const Axis&amp; axis, const Vector3&amp; origin = makeVector({0.0, 0.0, 0.0}));\n\n  MeshTransform createTransform(const Mesh&amp; target, AlignmentType align = Similarity, unsigned iterations = 10);\n\n  Mesh&amp; applyTransform(const MeshTransform transform);\n\n  Mesh&amp; rotate(const double angle, const Axis axis);\n\n  Mesh&amp; fillHoles(double hole_size = 1000.0);\n\n  Mesh&amp; clean();\n\n  Mesh&amp; probeVolume(const Image&amp; image);\n\n  Mesh&amp; clip(const Plane plane);\n\n  Mesh&amp; translate(const Vector3&amp; v);\n\n  Mesh&amp; scale(const Vector3&amp; v);\n\n  PhysicalRegion boundingBox() const;\n\n  Mesh&amp; fixElement();\n\n  Mesh&amp; fixNonManifold();\n\n  Mesh&amp; extractLargestComponent();\n\n  bool detectNonManifold();\n\n  bool detectTriangular();\n\n  std::vector&lt;Field&gt; distance(const Mesh&amp; target, const DistanceMethod method = PointToCell) const;\n\n  Mesh&amp; clipClosedSurface(const Plane plane);\n\n  Mesh&amp; computeNormals();\n\n  Point3 closestPoint(const Point3 point, double&amp; distance, vtkIdType&amp; face_id) const;\n\n  int closestPointId(const Point3 point) const;\n\n  bool isPointInside(const Point3 point) const;\n\n  double geodesicDistance(int source, int target) const;\n\n  Field geodesicDistance(const Point3 landmark) const;\n\n  Field geodesicDistance(const std::vector&lt;Point3&gt; curve) const;\n\n  Field curvature(const CurvatureType type = Principal) const;\n\n  void computeFieldGradient(const std::string&amp; field) const;\n\n  Eigen::Vector3d computeFieldGradientAtPoint(const std::string&amp; field, const Point3&amp; query) const;\n\n  double interpolateFieldAtPoint(const std::string&amp; field, const Point3&amp; query) const;\n\n  Mesh&amp; applySubdivisionFilter(const SubdivisionType type = Butterfly, int subdivision = 1);\n\n  Image toImage(PhysicalRegion region = PhysicalRegion(), Point3 spacing = Point3({1., 1., 1.})) const;\n\n  Image toDistanceTransform(PhysicalRegion region = PhysicalRegion(), const Point3 spacing = Point3({1., 1., 1.}),\n                            const Dims padding = Dims({1, 1, 1})) const;\n\n  Mesh&amp; computeThickness(Image&amp; image, Image* dt = nullptr, double max_dist = 10000, double median_radius = 5.0,\n                         std::string distance_mesh = \"\");\n\n  Mesh&amp; computeLandmarkGeodesics(const std::vector&lt;Point3&gt;&amp; landmarks);\n\n  // query functions //\n\n  Point3 center() const;\n\n  Point3 centerOfMass() const;\n\n  int numPoints() const { return poly_data_-&gt;GetNumberOfPoints(); }\n\n  int numFaces() const { return poly_data_-&gt;GetNumberOfCells(); }\n\n  Eigen::MatrixXd points() const;\n\n  Eigen::MatrixXi faces() const;\n\n  Point3 getPoint(int id) const;\n\n  IPoint3 getFace(int id) const;\n\n  // fields of mesh points //\n\n  std::vector&lt;std::string&gt; getFieldNames() const;\n\n  Mesh&amp; setField(const std::string name, Array array, const FieldType type);\n\n  Field getField(const std::string&amp; name, const FieldType type) const;\n\n  void setFieldValue(const std::string&amp; name, int idx, double value);\n\n  double getFieldValue(const std::string&amp; name, int idx) const;\n\n  Eigen::VectorXd getMultiFieldValue(const std::string&amp; name, int idx) const;\n\n  // mesh comparison //\n\n  bool compareAllPoints(const Mesh&amp; other_mesh) const;\n\n  bool compareAllFaces(const Mesh&amp; other_mesh) const;\n\n  bool compareAllFields(const Mesh&amp; other_mesh, const double eps = 1e4) const;\n\n  bool compareField(const Mesh&amp; other_mesh, const std::string&amp; name1, const std::string&amp; name2 = \"\",\n                    const double eps = -1.0) const;\n\n  // todo: add support for comparison of fields of mesh faces (ex: their normals)\n\n  bool compare(const Mesh&amp; other_mesh, const double eps = -1.0) const;\n\n  bool operator==(const Mesh&amp; other) const { return compare(other); }\n\n  // public static functions //\n\n  static std::vector&lt;std::string&gt; getSupportedTypes() { return {\"vtk\", \"vtp\", \"ply\", \"stl\", \"obj\"}; }\n\n  double getFFCValue(Eigen::Vector3d query) const;\n\n  Eigen::Vector3d getFFCGradient(Eigen::Vector3d query) const;\n\n  vtkSmartPointer&lt;vtkPoints&gt; getIGLMesh(Eigen::MatrixXd&amp; V, Eigen::MatrixXi&amp; F)\n      const;  // Copied directly from Surface. this-&gt;poly_data_ becomes this-&gt;mesh. // WARNING: Copied directly\n              // from Surface. TODO: When refactoring, take this into account.\n\n  vtkSmartPointer&lt;vtkPolyData&gt; clipByField(const std::string&amp; name, double value);\n\n  vtkSmartPointer&lt;vtkStaticCellLocator&gt; getCellLocator() const {\n    updateCellLocator();\n    return cellLocator;\n  }\n\n  int getClosestFace(const Point3&amp; point) const;\n\n  Eigen::Vector3d computeBarycentricCoordinates(const Eigen::Vector3d&amp; pt, int face)\n      const;  // // WARNING: Copied directly from Surface. TODO: When refactoring, take this into account.\n\n  void interpolate_scalars_to_mesh(std::string name, Eigen::VectorXd positions, Eigen::VectorXd scalar_values);\n\n  std::string checkIntegrity() const;\n\n private:\n  friend struct SharedCommandData;\n  Mesh()\n      : poly_data_(nullptr) {}  // only for use by SharedCommandData since a Mesh should always be valid, never \"empty\"\n\n  MeshTransform createRegistrationTransform(const Mesh&amp; target, AlignmentType align = Similarity,\n                                            unsigned iterations = 10) const;\n\n  Mesh&amp; setFieldForFaces(const std::string name, Array array);\n\n  Field getFieldForFaces(const std::string&amp; name) const;\n\n  void invalidateLocators() const;\n\n  mutable vtkSmartPointer&lt;vtkStaticCellLocator&gt; cellLocator;\n  void updateCellLocator() const;\n\n  mutable vtkSmartPointer&lt;vtkKdTreePointLocator&gt; pointLocator;\n  void updatePointLocator() const;\n\n  vtkSmartPointer&lt;vtkPolyData&gt; poly_data_;\n\n  int id_{-1};\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mesh&amp; mesh);\n\nclass MeshReader {\n  static vtkSmartPointer&lt;vtkPolyData&gt; read(const std::string&amp; pathname);\n  friend Mesh::Mesh(const std::string&amp; pathname);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MixedEffectsShapeMatrix_8h.html","title":"Libs/Optimize/Matrix/MixedEffectsShapeMatrix.h","text":""},{"location":"api/Files/MixedEffectsShapeMatrix_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MixedEffectsShapeMatrix_8h.html#classes","title":"Classes","text":"Name class shapeworks::MixedEffectsShapeMatrix"},{"location":"api/Files/MixedEffectsShapeMatrix_8h.html#source-code","title":"Source code","text":"<pre><code>/* Class for Mixed-effects regression */\n\n#pragma once\n\n#include \"Libs/Optimize/Matrix/LegacyShapeMatrix.h\"\n#include \"ParticleSystem.h\"\n#include \"vnl/vnl_trace.h\"\n#include \"vnl/vnl_vector.h\"\n\nnamespace shapeworks {\nclass MixedEffectsShapeMatrix : public LegacyShapeMatrix {\n public:\n  typedef double DataType;\n  typedef MixedEffectsShapeMatrix Self;\n  typedef LegacyShapeMatrix Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(MixedEffectsShapeMatrix, LegacyShapeMatrix);\n\n  void UpdateMeanMatrix() {\n    // for each sample\n    vnl_vector&lt;double&gt; tempvect;\n    tempvect.set_size(m_MeanMatrix.rows());\n    tempvect.fill(0.0);\n    for (unsigned int i = 0; i &lt; m_MeanMatrix.cols(); i++) {\n      int group_indx = i / m_TimeptsPerIndividual;\n      tempvect = m_Intercept + m_Slope * m_Expl(i);\n      tempvect = tempvect + m_InterceptRand.get_row(group_indx);\n      tempvect = tempvect + m_SlopeRand.get_row(group_indx) * m_Expl(i);\n      // compute the mean\n      m_MeanMatrix.set_column(i, tempvect);\n    }\n  }\n\n  inline vnl_vector&lt;double&gt; ComputeMean(double k) const { return m_Intercept + m_Slope * k; }\n\n  void ResizeParameters(unsigned int n) {\n    vnl_vector&lt;double&gt; tmpA = m_Intercept;  // copy existing  matrix\n    vnl_vector&lt;double&gt; tmpB = m_Slope;      // copy existing  matrix\n\n    // Create new\n    m_Intercept.set_size(n);\n    m_Slope.set_size(n);\n\n    // Copy old data into new vector.\n    for (unsigned int r = 0; r &lt; tmpA.size(); r++) {\n      m_Intercept(r) = tmpA(r);\n      m_Slope(r) = tmpB(r);\n    }\n  }\n\n  virtual void ResizeMeanMatrix(int rs, int cs) {\n    vnl_matrix&lt;double&gt; tmp = m_MeanMatrix;  // copy existing  matrix\n\n    // Create new column (shape)\n    m_MeanMatrix.set_size(rs, cs);\n\n    m_MeanMatrix.fill(0.0);\n\n    // Copy old data into new matrix.\n    for (unsigned int c = 0; c &lt; tmp.cols(); c++) {\n      for (unsigned int r = 0; r &lt; tmp.rows(); r++) {\n        m_MeanMatrix(r, c) = tmp(r, c);\n      }\n    }\n  }\n\n  void ResizeExplanatory(unsigned int n) {\n    if (n &gt; m_Expl.size()) {\n      vnl_vector&lt;double&gt; tmp = m_Expl;  // copy existing  matrix\n\n      // Create new\n      m_Expl.set_size(n);\n      m_Expl.fill(0.0);\n\n      // Copy old data into new vector.\n      for (unsigned int r = 0; r &lt; tmp.size(); r++) {\n        m_Expl(r) = tmp(r);\n      }\n    }\n  }\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp; e) {\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    unsigned int d = event.GetDomainIndex();\n\n    if (d % this-&gt;m_DomainsPerShape == 0) {\n      this-&gt;ResizeMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n      this-&gt;ResizeMeanMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n      this-&gt;ResizeExplanatory(this-&gt;cols());\n    }\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const int VDimension = 3;\n\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n\n    const unsigned int PointsPerDomain = ps-&gt;GetNumberOfParticles(d);\n\n    // Make sure we have enough rows.\n    if ((ps-&gt;GetNumberOfParticles(d) * VDimension * this-&gt;m_DomainsPerShape) &gt; this-&gt;rows()) {\n      this-&gt;ResizeParameters(PointsPerDomain * VDimension * this-&gt;m_DomainsPerShape);\n      this-&gt;ResizeMatrix(PointsPerDomain * VDimension * this-&gt;m_DomainsPerShape, this-&gt;cols());\n      this-&gt;ResizeMeanMatrix(PointsPerDomain * VDimension * this-&gt;m_DomainsPerShape, this-&gt;cols());\n    }\n\n    // CANNOT ADD POSITION INFO UNTIL ALL POINTS PER DOMAIN IS KNOWN\n    // Add position info to the matrix\n    unsigned int k = ((d % this-&gt;m_DomainsPerShape) * PointsPerDomain * VDimension) + (idx * VDimension);\n    for (unsigned int i = 0; i &lt; VDimension; i++) {\n      this-&gt;operator()(i + k, d / this-&gt;m_DomainsPerShape) = pos[i];\n    }\n\n    //   std::cout &lt;&lt; \"Row \" &lt;&lt; k &lt;&lt; \" Col \" &lt;&lt; d / this-&gt;m_DomainsPerShape &lt;&lt; \" = \" &lt;&lt; pos &lt;&lt; std::endl;\n  }\n\n  virtual void PositionSetEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const int VDimension = 3;\n\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n    const unsigned int PointsPerDomain = ps-&gt;GetNumberOfParticles(d);\n\n    // Modify matrix info\n    //    unsigned int k = VDimension * idx;\n    unsigned int k = ((d % this-&gt;m_DomainsPerShape) * PointsPerDomain * VDimension) + (idx * VDimension);\n\n    for (unsigned int i = 0; i &lt; VDimension; i++) {\n      this-&gt;operator()(i + k, d / this-&gt;m_DomainsPerShape) = pos[i] - m_MeanMatrix(i + k, d / this-&gt;m_DomainsPerShape);\n    }\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n  void SetDomainsPerShape(int i) { this-&gt;m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return this-&gt;m_DomainsPerShape; }\n\n  void SetTimeptsPerIndividual(int i) { this-&gt;m_TimeptsPerIndividual = i; }\n\n  int GetTimeptsPerIndividual() const { return this-&gt;m_TimeptsPerIndividual; }\n\n  void SetExplanatory(std::vector&lt;double&gt; v) {\n    //    std::cout &lt;&lt; \"Setting expl \" &lt;&lt; std::endl;\n    ResizeExplanatory(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      //      std::cout &lt;&lt; v[i] &lt;&lt; std::endl;\n      m_Expl[i] = v[i];\n    }\n  }\n  void SetExplanatory(unsigned int i, double q) { m_Expl[i] = q; }\n  const double&amp; GetExplanatory(unsigned int i) const { return m_Expl[i]; }\n  double&amp; GetExplanatory(unsigned int i) { return m_Expl[i]; }\n\n  const vnl_vector&lt;double&gt;&amp; GetSlope() const { return m_Slope; }\n  const vnl_vector&lt;double&gt;&amp; GetIntercept() const { return m_Intercept; }\n  const vnl_matrix&lt;double&gt;&amp; GetSlopeRandom() const { return m_SlopeRand; }\n  const vnl_matrix&lt;double&gt;&amp; GetInterceptRandom() const { return m_InterceptRand; }\n\n  void SetSlope(const std::vector&lt;double&gt;&amp; v) {\n    ResizeParameters(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      m_Slope[i] = v[i];\n    }\n  }\n\n  void SetIntercept(const std::vector&lt;double&gt;&amp; v) {\n    ResizeParameters(v.size());\n    for (unsigned int i = 0; i &lt; v.size(); i++) {\n      m_Intercept[i] = v[i];\n    }\n  }\n\n  void EstimateParameters() {\n    //    std::cout &lt;&lt; \"Estimating params\" &lt;&lt; std::endl;\n    //    std::cout &lt;&lt; \"Explanatory: \" &lt;&lt; m_Expl &lt;&lt; std::endl;\n\n    vnl_matrix&lt;double&gt; X = *this + m_MeanMatrix;\n\n    // Number of samples\n    int num_shapes = static_cast&lt;double&gt;(X.cols());\n    this-&gt;m_NumIndividuals = num_shapes / this-&gt;GetTimeptsPerIndividual();\n    int nr = X.rows();  // number of points*3\n\n    // set the sizes of random slope and intercept matrix\n    m_SlopeRand.set_size(m_NumIndividuals, nr);      // num_groups X num_points*3\n    m_InterceptRand.set_size(m_NumIndividuals, nr);  // num_groups X num_points*3\n\n    vnl_matrix&lt;double&gt; fixed;   // slopes + intercepts for all points\n    vnl_matrix&lt;double&gt; random;  // slopes + intercepts for all groups, for all points\n    fixed.set_size(2, nr);\n    random.set_size(2, nr * m_NumIndividuals);\n    vnl_matrix&lt;double&gt; Ds(2, 2);  // covariance matrix of random parameters (2x2)\n    Ds.set_identity();            // initialize to identity\n    double sigma2s = 1;           // variance of error\n    vnl_matrix&lt;double&gt; identity_n;\n    identity_n.set_size(m_TimeptsPerIndividual, m_TimeptsPerIndividual);\n    identity_n.set_identity();\n    vnl_matrix&lt;double&gt; identity_2;\n    identity_2.set_size(2, 2);\n    identity_2.set_identity();\n    vnl_matrix&lt;double&gt;*Ws = NULL, *Vs = NULL;\n    Ws = new vnl_matrix&lt;double&gt;[m_NumIndividuals];\n    Vs = new vnl_matrix&lt;double&gt;[m_NumIndividuals];\n    for (int i = 0; i &lt; m_NumIndividuals; i++) {\n      Vs[i].set_size(m_TimeptsPerIndividual, m_TimeptsPerIndividual);\n      Ws[i].set_size(m_TimeptsPerIndividual, m_TimeptsPerIndividual);\n    }\n\n    vnl_matrix&lt;double&gt; sum_mat1(2, 2, 0);\n    vnl_vector&lt;double&gt; sum_mat2(2);\n    sum_mat2.fill(0.0);\n    vnl_vector&lt;double&gt; residual;\n    residual.set_size(m_TimeptsPerIndividual);\n    residual.fill(0.0);\n    double ecorr = 0.0;\n    double tracevar = 0.0;\n    vnl_matrix&lt;double&gt; bscorr(2, 2, 0.0);\n    vnl_matrix&lt;double&gt; bsvar(2, 2, 0.0);\n    vnl_matrix&lt;double&gt; Xp;\n    Xp.set_size(m_TimeptsPerIndividual, 2);\n    vnl_vector&lt;double&gt; y;\n    y.set_size(m_TimeptsPerIndividual);\n    vnl_vector&lt;double&gt; tempvect;\n    tempvect.set_size(2);\n    for (int i = 0; i &lt; nr; i++)  // for all points (x,y,z coordinates)\n    {\n      sigma2s = 1.0;\n      Ds.set_identity();\n      for (int j = 0; j &lt; 50; j++)  // EM iterations\n      {\n        sum_mat1.fill(0.0);\n        sum_mat2.fill(0.0);\n        residual.fill(0.0);\n        ecorr = 0.0;\n        tracevar = 0.0;\n        bscorr.fill(0.0);\n        bsvar.fill(0.0);\n        for (int k = 0; k &lt; m_NumIndividuals; k++) {\n          for (int l = 0; l &lt; m_TimeptsPerIndividual; l++) {\n            Xp(l, 0) = m_Expl(k * m_TimeptsPerIndividual + l);\n            Xp(l, 1) = 1;\n            y(l) = X(i, k * m_TimeptsPerIndividual + l);\n          }\n          Vs[k] = (identity_n * sigma2s) + Xp * Ds * vnl_transpose(Xp);\n          // Ws = static_cast&lt;vnl_matrix&gt; (vnl_matrix_inverse&lt;double&gt;(Vs));\n          Ws[k] = vnl_inverse(Vs[k]);\n          sum_mat1 = sum_mat1 + vnl_transpose(Xp) * Ws[k] * Xp;\n          sum_mat2 = sum_mat2 + vnl_transpose(Xp) * Ws[k] * y;\n        }\n        tempvect = vnl_inverse(sum_mat1) * sum_mat2;\n        fixed.set_column(i, tempvect);\n        for (int k = 0; k &lt; m_NumIndividuals; k++) {\n          for (int l = 0; l &lt; m_TimeptsPerIndividual; l++) {\n            Xp(l, 0) = m_Expl(k * m_TimeptsPerIndividual + l);\n            Xp(l, 1) = 1;\n            y(l) = X(i, k * m_TimeptsPerIndividual + l);\n          }\n          tempvect = Ds * vnl_transpose(Xp) * Ws[k] * (y - (Xp * fixed.get_column(i)));\n          random.set_column(i * m_NumIndividuals + k, tempvect);\n          residual = y - (Xp * fixed.get_column(i)) - (Xp * random.get_column(i * m_NumIndividuals + k));\n          ecorr = ecorr + dot_product(residual, residual);\n          tracevar = tracevar + (m_TimeptsPerIndividual - sigma2s * vnl_trace(Ws[k]));\n          bscorr = bscorr + outer_product(random.get_column(i * m_NumIndividuals + k),\n                                          random.get_column(i * m_NumIndividuals + k));\n          bsvar = bsvar + (identity_2 - (vnl_transpose(Xp) * Ws[k] * Xp * Ds));\n        }\n        sigma2s = (ecorr + sigma2s * tracevar) / (num_shapes);\n        Ds = (bscorr + Ds * bsvar) / m_NumIndividuals;\n      }  // endfor EM iterations\n      // printf (\"point #%d\\n\", i);\n    }  // endfor all points on shape (x,y &amp; z)\n\n    m_Slope = fixed.get_row(0);\n    m_Intercept = fixed.get_row(1);\n    for (int i = 0; i &lt; m_NumIndividuals; i++) {\n      for (int j = 0; j &lt; nr; j++)  // for all points * 3\n      {\n        m_SlopeRand(i, j) = random(0, j * m_NumIndividuals + i);\n        m_InterceptRand(i, j) = random(1, j * m_NumIndividuals + i);\n      }\n    }\n    delete[] Vs;\n    delete[] Ws;\n    // printf (\"points:\\n\");\n    // for (int k = 0; k &lt; m_NumIndividuals; k++)\n    //  for (int l = 0; l &lt; m_TimeptsPerIndividual; l++)\n    //      printf (\"%g   %g\\n\", X(0,k*m_TimeptsPerIndividual + l), m_Expl(k*m_TimeptsPerIndividual + l));\n\n    // printf (\"fixed: slope %g, intercept %g\", m_Slope(0), m_Intercept(0));\n    // printf (\"random: slopes %g %g, intercepts %g %g\", m_SlopeRand(0,0), m_SlopeRand(1,0), m_InterceptRand(0,0),\n    // m_InterceptRand(1,0));\n  }\n\n  //\n  void Initialize() {\n    m_Intercept.fill(0.0);\n    m_Slope.fill(0.0);\n    m_MeanMatrix.fill(0.0);\n\n    m_SlopeRand.fill(0.0);\n    m_InterceptRand.fill(0.0);\n  }\n\n  virtual void BeforeIteration() {\n    m_UpdateCounter++;\n    if (m_UpdateCounter &gt;= m_RegressionInterval) {\n      m_UpdateCounter = 0;\n      this-&gt;EstimateParameters();\n      this-&gt;UpdateMeanMatrix();\n    }\n  }\n\n  void SetRegressionInterval(int i) { m_RegressionInterval = i; }\n  int GetRegressionInterval() const { return m_RegressionInterval; }\n\n protected:\n  MixedEffectsShapeMatrix() {\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n    m_UpdateCounter = 0;\n    m_RegressionInterval = 1;\n    m_NumIndividuals = 13;\n    m_TimeptsPerIndividual = 3;\n  }\n  virtual ~MixedEffectsShapeMatrix(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  MixedEffectsShapeMatrix(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);                            // purposely not implemented\n\n  int m_UpdateCounter;\n  int m_RegressionInterval;\n\n  // Parameters for the linear model\n  vnl_vector&lt;double&gt; m_Intercept;\n  vnl_vector&lt;double&gt; m_Slope;\n\n  // The explanatory variable value for each sample (matrix column)\n  vnl_vector&lt;double&gt; m_Expl;\n\n  // A matrix to store the mean estimated for each explanatory variable (each sample)\n  vnl_matrix&lt;double&gt; m_MeanMatrix;\n\n  vnl_matrix&lt;double&gt; m_InterceptRand;  // added: AK , random intercepts for each group\n  vnl_matrix&lt;double&gt; m_SlopeRand;      // added: AK , random slopes for each group\n  int m_NumIndividuals;\n  int m_TimeptsPerIndividual;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Module_8dox.html","title":"Module.dox","text":"<p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MonaiLabelJob_8h.html","title":"Studio/ShapeWorksMONAI/MonaiLabelJob.h","text":""},{"location":"api/Files/MonaiLabelJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) monailabel"},{"location":"api/Files/MonaiLabelJob_8h.html#classes","title":"Classes","text":"Name class monailabel::MonaiLabelJob"},{"location":"api/Files/MonaiLabelJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Session.h&gt;\n#include &lt;Job/Job.h&gt;\n#include &lt;Project/Project.h&gt;\n#include &lt;Shape.h&gt;\n#include &lt;ShapeWorksMONAI/MonaiLabelTool.h&gt;\n#include &lt;pybind11/embed.h&gt;\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;pybind11/stl.h&gt;\n\n#include &lt;QObject&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;string&gt;\n\nnamespace py = pybind11;\n\nnamespace shapeworks {\nclass ShapeWorksStudioApp;\nclass Session;\nclass Job;\n}  // namespace shapeworks\n\nnamespace monailabel {\n\nusing shapeworks::Job;\nusing shapeworks::ProjectHandle;\nusing shapeworks::Session;\nusing shapeworks::ShapeWorksStudioApp;\n\nclass MonaiLabelJob : public Job {\n  Q_OBJECT;\n\n public:\n  const static std::string MONAI_RESULT_EXTENSION;\n  const static std::string MONAI_RESULT_DTYPE;\n\n  MonaiLabelJob(QSharedPointer&lt;Session&gt; session, const std::string&amp; server_url, const std::string&amp; client_id,\n                const std::string&amp; strategy, const std::string&amp; model_type);\n  ~MonaiLabelJob();\n  void setServer(const std::string&amp; server_url);\n  void setModelType(const std::string&amp; model_type);\n  inline const std::string&amp; getServer() { return server_url_; }\n  void setClientId(const std::string&amp; client_id = \"\");\n  inline const std::string&amp; getClientId() { return client_id_; };\n  void initializeClient();\n  inline std::shared_ptr&lt;py::object&gt; getClient() const { return monai_client_; };\n\n  py::dict getInfo();\n  std::string getModelName(std::string modelType);\n  std::vector&lt;std::string&gt; getModelNames(const std::string&amp; model_type);\n  std::string getSessionId();\n  py::dict getParamsFromConfig(std::string section, std::string name);\n\n  // MONAI Client callers\n  py::dict nextSample(std::string strategy, py::dict params);\n  py::tuple infer(std::string model, std::string image_in, py::dict params, std::string label_in, std::string file,\n                  std::string session_id);\n  py::dict saveLabel(std::string image_in, std::string label_in, py::dict params);\n  py::dict uploadImage(std::string image_in, std::string image_id);\n\n  void updateShapes();\n\n  void runSegmentationModel();\n  void run() override;\n  QString name() override;\n  void python_message(std::string str);\n  void setCurrentSampleNumber(int n);\n\n public Q_SLOTS:\n  void onUploadSampleClicked();     // Triggered when  upload Sample button is clicked\n  void onRunSegmentationClicked();  // Triggered when Run Segmentation is clicked\n  void onSubmitLabelClicked();      // Triggered when Submit Label is clicked\n\n Q_SIGNALS:\n  void triggerUpdateView();\n  void triggerClientInitialized(bool success);\n  void triggerUploadSampleCompleted();\n  void triggerSegmentationCompleted();\n  void triggerSubmitLabelCompleted();\n\n private:\n  std::string tmp_dir_;\n  std::string server_url_;\n  std::string client_id_;\n  // TODO: implement remote server session\n  //   std::string username_;\n  //   std::string password_;\n  //   std::string auth_token_;\n  std::string strategy_;\n  std::string model_type_ = \"\";\n  std::string model_name_ = \"\";\n  std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;\n      models_available_;  // TODO: add functionality to interchange between models from UI\n  std::shared_ptr&lt;py::object&gt; monai_client_;\n\n  // QT states\n  bool waitingForUpload;\n  bool waitingForSegmentation;\n  bool waitingForLabelSubmission;\n\n  // Current subjects\n  int sample_number_;\n  std::string currentSampleId_;\n  std::string currentSegmentationPath_;\n  std::vector&lt;std::string&gt; currentSegmentationPaths_;\n  std::vector&lt;std::string&gt; organNames_;\n\n  QSharedPointer&lt;Session&gt; session_;\n  ProjectHandle project_;\n\n  bool error_occurred_ = false;\n};\n}  // namespace monailabel\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MonaiLabelTool_8h.html","title":"Studio/ShapeWorksMONAI/MonaiLabelTool.h","text":""},{"location":"api/Files/MonaiLabelTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) monailabel"},{"location":"api/Files/MonaiLabelTool_8h.html#classes","title":"Classes","text":"Name class monailabel::MonaiLabelTool"},{"location":"api/Files/MonaiLabelTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Data/Session.h&gt;\n#include &lt;Interface/ShapeWorksStudioApp.h&gt;\n#include &lt;Project.h&gt;\n#include &lt;Shape.h&gt;\n#include &lt;ShapeWorksMONAI/MonaiLabelJob.h&gt;\n\n#include &lt;QElapsedTimer&gt;\n#include &lt;QObject&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\nclass Ui_MonaiLabelTool;\nclass QLabel;\nclass QTableWidget;\nclass QLineEdit;\nclass Preferences;\n\nnamespace shapeworks {\nclass ShapeWorksStudioApp;\nclass Session;\n}  // namespace shapeworks\nnamespace monailabel {\n\nclass MonaiLabelJob;\nusing shapeworks::Session;\nusing shapeworks::ShapeWorksStudioApp;\nclass MonaiLabelTool : public QWidget {\n  Q_OBJECT;\n\n public:\n  const static std::string MONAI_MODE_SEGMENTATION;\n  const static std::string MONAI_MODE_DEEPGROW;\n  const static std::string MONAI_MODE_DEEPEDIT;\n  const static std::string MONAI_SAMPLE_STRATEGY_RANDOM;\n\n  MonaiLabelTool(Preferences&amp; prefs);\n  ~MonaiLabelTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n  void set_app(ShapeWorksStudioApp* app);\n  bool is_active();\n  void loadParamsFromUi();\n  void shutdown();\n  void runSegmentationTool();\n  void resizeEvent(QResizeEvent* event) override;\n  int getCurrentSampleNumber();\n  void enable_actions();\n  void activate();\n\n public Q_SLOTS:\n  void handle_error(QString msg);\n  void onConnectServer();\n  void onServerAddressChanged();\n  void onModelTypeChanged(int index);\n  void triggerUpdateView();\n  void handle_progress(int val, QString message);\n  void handleSampleNumberChanged();\n  void handleClientInitialized(bool success);\n  void handleUploadSampleCompleted();\n  void handleSegmentationCompleted();\n  void handleSubmitLabelCompleted();\n\n Q_SIGNALS:\n  void update_view();\n  void progress(int);\n  void sampleChanged();\n\n private:\n\n  void set_connect_button();\n\n  Preferences&amp; preferences_;\n  Ui_MonaiLabelTool* ui_;\n  QSharedPointer&lt;Session&gt; session_;\n  ShapeWorksStudioApp* app_;\n  bool tool_is_running_ = false;\n  QSharedPointer&lt;MonaiLabelJob&gt; monai_label_job_;\n  QElapsedTimer timer_;\n\n  std::string server_address_;\n  std::string model_type_;\n  std::string strategy_;\n  std::string client_id_;\n  int samples_processed_ = 0;\n};\n\n}  // namespace monailabel\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MonaiLabelUtils_8h.html","title":"Studio/ShapeWorksMONAI/MonaiLabelUtils.h","text":""},{"location":"api/Files/MonaiLabelUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) monailabel"},{"location":"api/Files/MonaiLabelUtils_8h.html#classes","title":"Classes","text":"Name class monailabel::UrlValidator class monailabel::MonaiLabelUtils"},{"location":"api/Files/MonaiLabelUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QLineEdit&gt;\n#include &lt;QString&gt;\n#include &lt;QUrl&gt;\n#include &lt;QWidget&gt;\n#include &lt;QValidator&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;Data/Session.h&gt;\n#include &lt;itkImage.h&gt;\n\nnamespace shapeworks {\n    class Session;\n}\nnamespace monailabel {\n\ntypedef float PixelType;\ntypedef itk::Image&lt; PixelType, 3 &gt; ImageType;\n\nclass UrlValidator : public QValidator {\n public:\n  UrlValidator(QObject* parent = nullptr) : QValidator(parent) {}\n\n  QValidator::State validate(QString&amp; input, int&amp; pos) const override {\n    Q_UNUSED(pos);\n    QUrl url(input);\n    if (!url.isValid() || (url.scheme() != \"http\" &amp;&amp; url.scheme() != \"https\")) {\n      return QValidator::Invalid;\n    }\n    // Allow '0.0.0.0'\n    if (url.host() == \"0.0.0.0\") {\n      if (url.port() == -1) {\n        return QValidator::Invalid;\n      }\n      return QValidator::Acceptable;\n    }\n    if (url.host().isEmpty()) {\n      return QValidator::Invalid;\n    }\n    if (url.port() == -1) {\n      return QValidator::Invalid;\n    }\n    return QValidator::Acceptable;\n  }\n};\nclass MonaiLabelUtils {\n public:\n  static bool createDir(const QString&amp; dirPath);\n  static bool copySegmentation(const QString&amp; sourcePath,\n                               const QString&amp; destinationPath);\n  static bool deleteTempFile(const QString&amp; filePath);\n  static std::string getFeatureName(\n      QSharedPointer&lt;shapeworks::Session&gt; session);\n  static ImageType::Pointer loadNRRD(const std::string&amp; filePath);\n  static ImageType::Pointer extractOrganSegmentation(ImageType::Pointer inputImage,\n                                              int label);\n  static void saveNRRD(ImageType::Pointer image, const std::string&amp; outputPath);\n  static bool isOrganPresent(ImageType::Pointer image);\n\n  static void processSegmentation(const std::string&amp; segmentationPath,\n                           const std::map&lt;int, std::string&gt;&amp; organLabels,\n                           const std::string&amp; outputDir,\n                           const std::string&amp; sampleId,\n                           std::vector&lt;std::string&gt;&amp; organSegmentationPaths);\n};\n\n}  // namespace monailabel\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/MorphologicalDeviationScore_8h.html","title":"Libs/Optimize/Function/EarlyStop/MorphologicalDeviationScore.h","text":""},{"location":"api/Files/MorphologicalDeviationScore_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/MorphologicalDeviationScore_8h.html#classes","title":"Classes","text":"Name class shapeworks::MorphologicalDeviationScore"},{"location":"api/Files/MorphologicalDeviationScore_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n// #include \"cnpy.h\"\n\nnamespace shapeworks {\nclass MorphologicalDeviationScore {\n public:\n  MorphologicalDeviationScore();\n  // Fit PPCA model on control shapes\n  bool SetControlShapes(const Eigen::MatrixXd&amp; X);  // (n_samples x n_features)\n  Eigen::VectorXd GetMorphoDevScore(const Eigen::MatrixXd&amp; X);  // (n,)\n\n private:\n  bool is_fitted_ = false;\n\n  // Fitted model parameters\n  Eigen::RowVectorXd mean_;                        // (1 x d)\n  Eigen::MatrixXd components_;                     // (d x q)\n  Eigen::VectorXd principal_components_variance_;  // (q,)\n  int n_components_ = 0;\n  double noise_variance_ = 0.0;\n  double retained_variance_ratio_ = 0.95;\n  // Derived matrices\n  Eigen::MatrixXd precision_matrix_;  // (d x d)\n  // Helper functions\n  bool FitPPCA(const Eigen::MatrixXd&amp; X);\n  Eigen::MatrixXd ComputeCovarianceMatrix();\n  Eigen::MatrixXd ComputePrecisionMatrix();\n//   inline static void save_vector(const Eigen::VectorXd&amp; v,\n//                                  const std::string&amp; fname) {\n//     cnpy::npy_save(fname, v.data(), {(size_t)v.size()}, \"w\");\n//   };\n//   inline static void save_matrix(const Eigen::MatrixXd m,\n//                                  const std::string&amp; fname) {\n//     Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;\n//         X_rm = m;\n//     cnpy::npy_save(fname, X_rm.data(), {(size_t)m.rows(), (size_t)m.cols()},\n//                    \"w\");\n//   };\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/NetworkAnalysisJob_8h.html","title":"Studio/Job/NetworkAnalysisJob.h","text":""},{"location":"api/Files/NetworkAnalysisJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/NetworkAnalysisJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::NetworkAnalysisJob"},{"location":"api/Files/NetworkAnalysisJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\nnamespace shapeworks {\n\nclass Project;\n\nclass NetworkAnalysisJob : public Job {\n  Q_OBJECT\n public:\n  NetworkAnalysisJob(std::shared_ptr&lt;Project&gt; project, std::string target_group, std::string target_feature);\n  void run() override;\n  QString name() override;\n\n  void set_pvalue_of_interest(double pvalue_of_interest);\n  void set_pvalue_threshold(double pvalue_threshold);\n  void set_num_iterations(int num_iterations);\n\n  Eigen::VectorXd get_tvalues();\n  Eigen::VectorXd get_spm_values();\n\n private:\n  std::shared_ptr&lt;Project&gt; project_;\n  ParticleShapeStatistics stats_;\n  Eigen::VectorXd tvalues_;\n  Eigen::VectorXd spm_values_;\n  std::string target_group_;\n  std::string target_feature_;\n\n  double pvalue_of_interest_ = 0;\n  double pvalue_threshold_ = 0;\n  int num_iterations_ = 0;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ObjectReader_8h.html","title":"Libs/Optimize/Utils/ObjectReader.h","text":""},{"location":"api/Files/ObjectReader_8h.html#classes","title":"Classes","text":"Name class ObjectReader"},{"location":"api/Files/ObjectReader_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nclass ObjectReader {\n public:\n  typedef ObjectReader Self;\n  typedef T ObjectType;\n\n  const std::vector&lt;ObjectType&gt; &amp;GetOutput() const { return m_Output; }\n  std::vector&lt;ObjectType&gt; &amp;GetOutput() { return m_Output; }\n\n  void SetFileName(const char *fn) { m_FileName = fn; }\n  void SetFileName(const std::string &amp;fn) { m_FileName = fn; }\n  const std::string &amp;GetFileName() const { return m_FileName; }\n\n  inline void Read() { this-&gt;Update(); }\n  void Update() {\n    // Open the output file.\n    std::ifstream in(m_FileName.c_str(), std::ios::binary);\n\n    if (!in) {\n      std::cerr &lt;&lt; \"Could not open filename \" &lt;&lt; m_FileName &lt;&lt; std::endl;\n      throw 1;\n    }\n    // Read the number of transforms\n    int N;\n    in.read(reinterpret_cast&lt;char *&gt;(&amp;N), sizeof(int));\n\n    int sz = sizeof(ObjectType);\n    // Read the transforms\n    for (unsigned int i = 0; i &lt; (unsigned int)N; i++) {\n      ObjectType q;  // maybe not the most efficient, but safe\n      in.read(reinterpret_cast&lt;char *&gt;(&amp;q), sz);\n      m_Output.push_back(q);\n    }\n\n    in.close();\n  }\n\n  ObjectReader() {}\n  virtual ~ObjectReader(){};\n\n private:\n  ObjectReader(const Self &amp;);   // purposely not implemented\n  void operator=(const Self &amp;);  // purposely not implemented\n\n  std::vector&lt;ObjectType&gt; m_Output;\n  std::string m_FileName;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ObjectWriter_8h.html","title":"Libs/Optimize/Utils/ObjectWriter.h","text":""},{"location":"api/Files/ObjectWriter_8h.html#classes","title":"Classes","text":"Name class ObjectWriter"},{"location":"api/Files/ObjectWriter_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nclass ObjectWriter {\n public:\n  typedef ObjectWriter Self;\n\n  typedef T ObjectType;\n\n  void SetInput(const std::vector&lt;ObjectType&gt; &amp;p) { m_Input = p; }\n\n  void SetFileName(const char *fn) { m_FileName = fn; }\n  void SetFileName(const std::string &amp;fn) { m_FileName = fn; }\n  const std::string &amp;GetFileName() const { return m_FileName; }\n\n  inline void Write() { this-&gt;Update(); }\n  void Update() {\n    // Open the output file.\n    //  std::ofstream out( m_FileName.c_str(), std::ios::binary );\n    std::ofstream out(m_FileName.c_str());\n\n    if (!out) {\n      std::cerr &lt;&lt; \"Could not open point file for output: \" &lt;&lt; m_FileName &lt;&lt; std::endl;\n      throw 1;\n    }\n\n    // Write the number of objects\n    int sz = m_Input.size();\n    out.write(reinterpret_cast&lt;char *&gt;(&amp;sz), sizeof(int));\n\n    sz = sizeof(ObjectType);\n    // Write the objects\n    for (typename std::vector&lt;ObjectType&gt;::const_iterator it = m_Input.begin(); it != m_Input.end(); it++) {\n      ObjectType q = *it;  // maybe not the most efficient, but safe\n      out.write(reinterpret_cast&lt;char *&gt;(&amp;q), sz);\n    }\n\n    out.close();\n  }\n\n  ObjectWriter() {}\n  virtual ~ObjectWriter(){};\n\n private:\n  ObjectWriter(const Self &amp;);   // purposely not implemented\n  void operator=(const Self &amp;);  // purposely not implemented\n\n  std::vector&lt;ObjectType&gt; m_Input;\n  std::string m_FileName;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Observer_8h.html","title":"Libs/Optimize/Observer.h","text":""},{"location":"api/Files/Observer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Observer_8h.html#classes","title":"Classes","text":"Name class shapeworks::Observer This class is an observer interface for classes to monitor for changes to the optimizer (observer pattern) struct shapeworks::Observer::DefinedCallbacksStruct"},{"location":"api/Files/Observer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"itkCommand.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n\nnamespace shapeworks {\n\nclass Observer : public itk::DataObject {\n public:\n  typedef Observer Self;\n  typedef DataObject Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(Observer, DataObject);\n\n  struct DefinedCallbacksStruct {\n    DefinedCallbacksStruct()\n        : DomainAddEvent(false),\n          TransformSetEvent(false),\n          PrefixTransformSetEvent(false),\n          PositionSetEvent(false),\n          PositionAddEvent(false),\n          PositionRemoveEvent(false) {}\n    bool DomainAddEvent;\n    bool TransformSetEvent;\n    bool PrefixTransformSetEvent;\n    bool PositionSetEvent;\n    bool PositionAddEvent;\n    bool PositionRemoveEvent;\n  };\n\n  DefinedCallbacksStruct m_DefinedCallbacks;\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp;) {}\n  virtual void TransformSetEventCallback(Object*, const itk::EventObject&amp;) {}\n  virtual void PrefixTransformSetEventCallback(Object*, const itk::EventObject&amp;) {}\n  virtual void PositionSetEventCallback(Object*, const itk::EventObject&amp;) {}\n  virtual void PositionAddEventCallback(Object*, const itk::EventObject&amp;) {}\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {}\n\n protected:\n  Observer() {}\n  virtual ~Observer(){};\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n private:\n  Observer(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);     // purposely not implemented\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/OptimizationVisualizer_8h.html","title":"Libs/Optimize/Utils/OptimizationVisualizer.h","text":""},{"location":"api/Files/OptimizationVisualizer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/OptimizationVisualizer_8h.html#classes","title":"Classes","text":"Name class shapeworks::OptimizationVisualizer"},{"location":"api/Files/OptimizationVisualizer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkActor.h&gt;\n#include &lt;vtkCellArray.h&gt;\n#include &lt;vtkPoints.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkPolyDataMapper.h&gt;\n#include &lt;vtkRenderWindow.h&gt;\n#include &lt;vtkRenderer.h&gt;\n#include &lt;vtkSphereSource.h&gt;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"TriMesh.h\"\n#include \"ParticleSystem.h\"\n\nnamespace shapeworks {\nclass OptimizationVisualizer {\n public:\n  void AddMesh(vtkPolyData* mesh, std::shared_ptr&lt;trimesh::TriMesh&gt; tmesh);\n  void IterationCallback(ParticleSystem* particleSystem);\n\n  void SetWireFrame(bool enabled);\n  void SetSaveScreenshots(bool enabled, std::string path);\n\n  OptimizationVisualizer() {}\n  ~OptimizationVisualizer() {}\n\n private:\n  void initialize();\n\n  std::string screenshotDirectory;\n  bool saveScreenshots = false;\n  bool wireFrame = false;\n  bool colorNormals = false;\n  bool initialized = false;\n\n  double* focalPoint;\n  int iteration = 0;\n  double radius;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyData&gt;&gt; meshes;\n  std::vector&lt;std::shared_ptr&lt;trimesh::TriMesh&gt;&gt; tmeshes;\n\n  vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();\n  vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New();\n  vtkSmartPointer&lt;vtkRenderer&gt; mainRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::New();\n  vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::New();\n  vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();\n  vtkSmartPointer&lt;vtkPolyData&gt; polydata = vtkSmartPointer&lt;vtkPolyData&gt;::New();\n  vtkSmartPointer&lt;vtkSphereSource&gt; cubeSource = vtkSmartPointer&lt;vtkSphereSource&gt;::New();\n\n  vtkSmartPointer&lt;vtkPolyDataMapper&gt; lineMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();\n  vtkSmartPointer&lt;vtkActor&gt; lineActor = vtkSmartPointer&lt;vtkActor&gt;::New();\n  vtkSmartPointer&lt;vtkCellArray&gt; lines = vtkSmartPointer&lt;vtkCellArray&gt;::New();\n\n  std::vector&lt;vtkSmartPointer&lt;vtkRenderer&gt;&gt; sampleRenderers;\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyDataMapper&gt;&gt; sampleMappers;\n  std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; samplePoints;\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyData&gt;&gt; samplePolyData;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/OptimizeParameterFile_8h.html","title":"Libs/Optimize/OptimizeParameterFile.h","text":""},{"location":"api/Files/OptimizeParameterFile_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/OptimizeParameterFile_8h.html#classes","title":"Classes","text":"Name class shapeworks::OptimizeParameterFile"},{"location":"api/Files/OptimizeParameterFile_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;exception&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nclass TiXmlHandle;\n\nnamespace shapeworks {\nclass Optimize;\n\nclass OptimizeParameterFile {\n public:\n  OptimizeParameterFile();\n\n  bool load_parameter_file(std::string filename, Optimize* optimize);\n\n private:\n  bool set_visualizer_parameters(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool set_io_parameters(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool set_optimization_parameters(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool set_debug_parameters(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_image_inputs(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_mesh_inputs(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_contour_inputs(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_mesh_attributes(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_point_files(TiXmlHandle* docHandle, Optimize* optimize);\n\n  bool read_constraints(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  bool read_distribution_cutting_plane(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  bool read_cutting_planes(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  bool read_explanatory_variables(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  bool read_flag_particles(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  bool read_flag_domains(TiXmlHandle* doc_handle, Optimize* optimize);\n\n  int get_num_inputs(TiXmlHandle* docHandle);\n\n private:\n  std::vector&lt;int&gt; read_int_list(TiXmlHandle* doc_handle, std::string name);\n\n  int verbosity_level_ = 0;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/OptimizeParameters_8h.html","title":"Libs/Optimize/OptimizeParameters.h","text":""},{"location":"api/Files/OptimizeParameters_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/OptimizeParameters_8h.html#classes","title":"Classes","text":"Name class shapeworks::OptimizeParameters"},{"location":"api/Files/OptimizeParameters_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Project/Project.h&gt;\n\n#include &lt;itkPoint.h&gt;\n\n#include &lt;functional&gt;\n#include \"EarlyStoppingConfig.h\"\nnamespace shapeworks {\n\nclass Optimize;\n\nclass OptimizeParameters {\n public:\n  explicit OptimizeParameters(ProjectHandle project);\n  void save_to_project();\n\n  std::string get_optimize_output_prefix();\n  void set_optimize_output_prefix(std::string prefix);\n\n  std::vector&lt;int&gt; get_number_of_particles();\n  void set_number_of_particles(std::vector&lt;int&gt; number_of_particles);\n\n  double get_initial_relative_weighting();\n  void set_initial_relative_weighting(double value);\n\n  double get_relative_weighting();\n  void set_relative_weighting(double value);\n\n  double get_starting_regularization();\n  void set_starting_regularization(double value);\n\n  double get_ending_regularization();\n  void set_ending_regularization(double value);\n\n  int get_iterations_per_split();\n  void set_iterations_per_split(int value);\n\n  int get_optimization_iterations();\n  void set_optimization_iterations(int value);\n\n  bool get_use_geodesic_distance();\n  void set_use_geodesic_distance(bool value);\n\n  int get_geodesic_cache_multiplier();\n  void set_geodesic_cache_multiplier(int value);\n\n  std::vector&lt;bool&gt; get_use_normals();\n  void set_use_normals(std::vector&lt;bool&gt; use_normals);\n\n  double get_normals_strength();\n  void set_normals_strength(double value);\n\n  bool get_use_disentangled_ssm();\n  void set_use_disentangled_ssm(bool value);\n\n  bool get_use_procrustes();\n  void set_use_procrustes(bool value);\n\n  bool get_use_procrustes_scaling();\n  void set_use_procrustes_scaling(bool value);\n\n  bool get_use_procrustes_rotation_translation();\n  void set_use_procrustes_rotation_translation(bool value);\n\n  int get_procrustes_interval();\n  void set_procrustes_interval(int value);\n\n  bool get_use_multiscale();\n  void set_use_multiscale(bool value);\n\n  int get_multiscale_particles();\n  void set_multiscale_particles(int value);\n\n  double get_narrow_band();\n  void set_narrow_band(double value);\n\n  int get_verbosity();\n  void set_verbosity(int value);\n\n  bool get_mesh_ffc_mode();\n  void set_mesh_ffc_mode(bool value);\n\n  bool get_use_landmarks();\n  void set_use_landmarks(bool value);\n\n  bool get_use_fixed_subjects();\n  void set_use_fixed_subjects(bool value);\n  std::string get_fixed_subjects_column();\n  void set_fixed_subject_column(std::string column);\n  std::string get_fixed_subjects_choice();\n  void set_fixed_subjects_choice(std::string choice);\n\n  void set_abort_load(bool value);\n\n  void set_load_callback(const std::function&lt;void(int)&gt;&amp; f);\n\n  bool set_up_optimize(Optimize* optimize);\n\n  bool is_subject_fixed(std::shared_ptr&lt;Subject&gt; subject);\n\n  int get_checkpoint_interval();\n  void set_checkpoint_interval(int iterations);\n\n  bool get_save_init_splits();\n  void set_save_init_splits(bool enabled);\n\n  bool get_keep_checkpoints();\n  void set_keep_checkpoints(bool enabled);\n\n  std::vector&lt;std::string&gt; get_field_attributes();\n  void set_field_attributes(std::vector&lt;std::string&gt; attributes);\n\n  std::vector&lt;double&gt; get_field_attribute_weights();\n  void set_field_attribute_weights(std::vector&lt;double&gt; weights);\n\n  bool get_use_geodesics_to_landmarks();\n  void set_use_geodesics_to_landmarks(bool value);\n\n  double get_geodesic_to_landmarks_weight();\n  void set_geodesic_to_landmarks_weight(double value);\n\n  std::string get_particle_format();\n  void set_particle_format(std::string format);\n\n  double get_geodesic_remesh_percent();\n  void set_geodesic_remesh_percent(double value);\n\n  bool get_shared_boundary();\n  void set_shared_boundary(bool value);\n\n  double get_shared_boundary_weight();\n  void set_shared_boundary_weight(double value);\n\n  EarlyStoppingConfig get_early_stopping_config();\n\n  Parameters get_parameters() const;\n\n private:\n  std::string get_output_prefix();\n\n  std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; get_initial_points();\n\n  Parameters params_;\n  ProjectHandle project_;\n\n  std::function&lt;void(int)&gt; load_callback_;\n\n  bool abort_load_ = false;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/OptimizeTool_8h.html","title":"Studio/Optimize/OptimizeTool.h","text":""},{"location":"api/Files/OptimizeTool_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/OptimizeTool_8h.html#classes","title":"Classes","text":"Name class shapeworks::OptimizeTool"},{"location":"api/Files/OptimizeTool_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n#include &lt;QProgressDialog&gt;\n#include &lt;QElapsedTimer&gt;\n\n#include &lt;itkPoint.h&gt;\n\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Data/Telemetry.h&gt;\n\nclass Ui_OptimizeTool;\n\nclass QLineEdit;\n\nnamespace shapeworks {\nclass QOptimize;\nclass OptimizeParameters;\nclass Session;\n\n\nclass OptimizeTool : public QWidget {\nQ_OBJECT;\n\npublic:\n\n  OptimizeTool(Preferences&amp; prefs, Telemetry&amp; telemetry);\n  ~OptimizeTool();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n\n  void activate();\n\n  void load_params();\n  void store_params();\n\n  void enable_actions();\n  void disable_actions();\n\n  void shutdown_threads();\n\npublic Q_SLOTS:\n\n  void on_run_optimize_button_clicked();\n  void on_restoreDefaults_clicked();\n  void handle_optimize_complete();\n  void handle_optimize_failed();\n  void handle_progress(int val, QString message);\n  void handle_error(QString);\n  void handle_warning(QString);\n  void handle_message(QString);\n\n  void update_ui_elements();\n\n  bool validate_inputs();\n\nQ_SIGNALS:\n  void optimize_start();\n  void optimize_complete();\n\n  void progress(int);\n  void status(std::string);\n\nprivate:\n\n  void setup_domain_boxes();\n\n  void update_run_button();\n\n  void handle_load_progress(int count);\n\n  std::vector&lt;QLineEdit*&gt; particle_boxes_;\n\n  Preferences&amp; preferences_;\n  Telemetry&amp; telemetry_;\n\n\n  std::vector&lt;QLineEdit*&gt; line_edits_;\n\n  QList&lt;QThread*&gt; threads_;\n  bool optimization_is_running_ = false;\n  QSharedPointer&lt;QOptimize&gt; optimize_;\n  QSharedPointer&lt;OptimizeParameters&gt; optimize_parameters_;\n  QSharedPointer&lt;Session&gt; session_;\n  QElapsedTimer elapsed_timer_;\n\n  Ui_OptimizeTool* ui_;\n};\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Optimize_8h.html","title":"Libs/Optimize/Optimize.h","text":""},{"location":"api/Files/Optimize_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Optimize_8h.html#classes","title":"Classes","text":"Name class shapeworks::MatrixContainer class shapeworks::Optimize"},{"location":"api/Files/Optimize_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#ifdef _WIN32\n#pragma warning(disable : 4996)\n#endif\n\n// std\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// itk\n#include &lt;itkCommand.h&gt;\n#include &lt;itkImage.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n\n// shapeworks\n#include &lt;Project/Project.h&gt;\n\n#include \"Libs/Optimize/Domain/DomainType.h\"\n#include \"Libs/Optimize/Function/VectorFunction.h\"\n#include \"Libs/Optimize/Utils/OptimizationVisualizer.h\"\n#include \"ProcrustesRegistration.h\"\n#include \"Sampler.h\"\n#include \"EarlyStoppingConfig.h\"\n\nnamespace shapeworks {\n\nclass Project;\nclass ParticleGoodBadAssessment;\n\nclass MatrixContainer {\n public:\n  Eigen::MatrixXd matrix_;\n};\n\nclass Optimize {\n public:\n  using ImageType = itk::Image&lt;float, 3&gt;;\n  using VectorType = VectorFunction::VectorType;\n  using MatrixType = Eigen::MatrixXd;\n\n  Optimize();\n\n  virtual ~Optimize();\n\n  bool Run();\n\n  bool LoadParameterFile(std::string filename);\n\n  bool SetUpOptimize(ProjectHandle project);\n\n  void SetProject(std::shared_ptr&lt;Project&gt; project);\n\n  void SetIterationCallbackFunction(const std::function&lt;void(void)&gt;&amp; f) { this-&gt;iteration_callback_ = f; }\n\n  void AbortOptimization();\n\n  bool GetAborted();\n\n  virtual std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; GetLocalPoints();\n\n  virtual std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; GetGlobalPoints();\n\n  void SetCutPlanes(std::vector&lt;std::array&lt;itk::Point&lt;double&gt;, 3&gt;&gt; cut_planes);\n\n  void SetVerbosity(int verbosity_level);\n\n  void SetDomainsPerShape(int domains_per_shape);\n  int GetDomainsPerShape();\n\n  void SetDomainType(shapeworks::DomainType type);\n  shapeworks::DomainType GetDomainType();\n\n  void SetNumberOfParticles(std::vector&lt;int&gt; number_of_particles);\n  std::vector&lt;int&gt; GetNumberOfParticles();\n\n  void SetTransformFile(std::string filename);\n  std::string GetTransformFile();\n\n  void SetPrefixTransformFile(std::string prefix_transform_file);\n  std::string GetPrefixTransformFile();\n\n  void SetOutputDir(std::string output_dir);\n\n  void SetOutputTransformFile(std::string output_transform_file);\n\n  void SetOutputIndividualTransformFiles(bool value);\n\n  void SetUseMeshBasedAttributes(bool use_mesh_based_attributes);\n\n  bool GetUseMeshBasedAttributes();\n\n  void SetUseXYZ(std::vector&lt;bool&gt; use_xyz);\n\n  void SetUseNormals(std::vector&lt;bool&gt; use_normals);\n\n  void SetAttributesPerDomain(std::vector&lt;int&gt; attributes_per_domain);\n  std::vector&lt;int&gt; GetAttributesPerDomain();\n\n  void SetDistributionDomainID(int distribution_domain_id);\n  int GetDistributionDomainID();\n\n  void SetOutputCuttingPlaneFile(std::string output_cutting_plane_file);\n  void SetUseCuttingPlanes(bool use_cutting_planes);\n  void SetCuttingPlane(unsigned int i, const vnl_vector_fixed&lt;double, 3&gt;&amp; va, const vnl_vector_fixed&lt;double, 3&gt;&amp; vb,\n                       const vnl_vector_fixed&lt;double, 3&gt;&amp; vc);\n\n  void SetMeshFFCMode(int mesh_ffc_mode) {\n    m_mesh_ffc_mode = mesh_ffc_mode;\n    m_sampler-&gt;SetMeshFFCMode(mesh_ffc_mode);\n  }\n  void SetTimePtsPerSubject(int time_pts_per_subject);\n  int GetTimePtsPerSubject();\n  void SetOptimizationIterations(int optimization_iterations);\n  void SetOptimizationIterationsCompleted(int optimization_iterations_completed);\n  void SetIterationsPerSplit(int iterations_per_split);\n  void SetUseShapeStatisticsInInit(bool use_shape_statistics_in_init);\n  void SetProcrustesInterval(int procrustes_interval);\n  void SetProcrustesScaling(bool procrustes_scaling);\n  void SetProcrustesRotationTranslation(bool procrustes_rotation_translation);\n  void SetRelativeWeighting(double relative_weighting);\n  void SetInitialRelativeWeighting(double initial_relative_weighting);\n  void SetStartingRegularization(double starting_regularization);\n  void SetEndingRegularization(double ending_regularization);\n  void SetRecomputeRegularizationInterval(int recompute_regularization_interval);\n  void SetSaveInitSplits(bool save_init_splits);\n  void SetCheckpointingInterval(int checkpointing_interval);\n  void SetKeepCheckpoints(int keep_checkpoints);\n\n  void SetUseRegression(bool use_regression);\n  void SetUseMixedEffects(bool use_mixed_effects);\n\n  void SetUseDisentangledSpatiotemporalSSM(bool use_disentangled_ssm_4d);\n  bool GetUseDisentangledSpatiotemporalSSM();\n\n  void SetNormalAngle(double normal_angle);\n  void SetPerformGoodBad(bool perform_good_bad);\n  void SetLogEnergy(bool log_energy);\n\n  void AddImage(ImageType::Pointer image, std::string name = \"\");\n  void AddMesh(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n  void AddContour(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n\n  void SetFilenames(const std::vector&lt;std::string&gt;&amp; filenames);\n  void SetPointFiles(const std::vector&lt;std::string&gt;&amp; point_files);\n\n  void SetInitialPoints(std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; initial_points);\n\n  int GetNumShapes();\n  void SetAttributeScales(const std::vector&lt;double&gt;&amp; scales);\n\n  void SetFieldAttributes(const std::vector&lt;std::string&gt;&amp; field_attributes);\n\n  void SetParticleFlags(std::vector&lt;int&gt; flags);\n  void SetFixedDomains(std::vector&lt;int&gt; flags);\n\n  void SetSharedBoundaryEnabled(bool enabled);\n  void SetSharedBoundaryWeight(double weight);\n\n  void SetEarlyStoppingConfig(EarlyStoppingConfig config);\n\n  const std::vector&lt;int&gt;&amp; GetDomainFlags();\n\n  void SetFileOutputEnabled(bool enabled);\n\n  std::vector&lt;bool&gt; GetUseXYZ();\n\n  std::vector&lt;bool&gt; GetUseNormals();\n\n  void SetNarrowBand(double v);\n\n  double GetNarrowBand();\n\n  void SetUseShapeStatisticsAfter(int num_particles);\n\n  int GetUseShapeStatisticsAfter();\n\n  void PrintParamInfo();\n\n  std::shared_ptr&lt;Sampler&gt; GetSampler() { return m_sampler; }\n\n  MatrixContainer GetParticleSystem();\n\n  void SetPythonFile(std::string filename);\n\n  void SetGeodesicsEnabled(bool is_enabled);\n  bool GetGeodesicsEnabled() const { return m_geodesics_enabled; }\n\n  void SetGeodesicsCacheSizeMultiplier(size_t n);\n\n  void SetGeodesicsRemeshPercent(double percent);\n\n  OptimizationVisualizer&amp; GetVisualizer();\n  void SetShowVisualizer(bool show);\n  bool GetShowVisualizer();\n\n  bool GetMeshFFCMode() { return m_mesh_ffc_mode; }\n\n  vnl_vector_fixed&lt;double, 3&gt; TransformPoint(int domain, vnl_vector_fixed&lt;double, 3&gt; input);\n\n  void UpdateProgress();\n\n  void set_particle_format(std::string format) { particle_format_ = format; }\n\n protected:\n  virtual void SetIterationCallback();\n\n  void ComputeTotalIterations();\n\n  void OptimizerStop();\n\n  void ReadTransformFile();\n  void ReadPrefixTransformFile(const std::string&amp; s);\n\n  void InitializeSampler();\n  double GetMinNeighborhoodRadius();\n  void AddSinglePoint();\n  void Initialize();\n  void RunOptimize();\n\n  void ComputeEnergyAfterIteration();\n\n  void SetCotanSigma();\n\n  void WriteTransformFile(int iter = -1) const;\n  void WriteTransformFile(std::string iter_prefix) const;\n  void WriteTransformFiles(int iter = -1) const;\n  void WriteTransformFiles(std::string iter_prefix) const;\n  void WritePointFiles(int iter = -1);\n  void WritePointFiles(std::string iter_prefix);\n  void WritePointFilesWithFeatures(int iter = -1);\n  void WritePointFilesWithFeatures(std::string iter_prefix);\n  void WriteEnergyFiles();\n  void WriteSplitFiles(std::string name);\n  void WriteCuttingPlanePoints(int iter = -1);\n  void WriteParameters(std::string output_dir = \"\");\n  void ReportBadParticles();\n\n  int SetParameters();\n  void WriteModes();\n\n  void PrintStartMessage(std::string str, unsigned int vlevel = 0) const;\n\n  void PrintDoneMessage(unsigned int vlevel = 0) const;\n\n  virtual void UpdateExportablePoints();\n\n  virtual std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt; GetProcrustesTransforms();\n\n  void UpdateProject();\n\n  // return a checkpoint dir for the current iteration\n  std::string GetCheckpointDir();\n\n  std::shared_ptr&lt;Sampler&gt; m_sampler;\n  ProcrustesRegistration::Pointer m_procrustes;\n  std::shared_ptr&lt;ParticleGoodBadAssessment&gt; m_good_bad;\n\n  unsigned int m_verbosity_level = 0;\n\n  std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; m_local_points, m_global_points;\n\n  int m_checkpoint_counter = 0;\n  int m_procrustes_counter = 0;\n  bool m_use_cutting_planes = false;\n  bool m_optimizing = false;\n  bool m_use_regression = false;\n  bool m_use_mixed_effects = false;\n  bool m_use_disentangled_ssm = false;\n\n  // IO Parameters\n  unsigned int m_domains_per_shape = 1;\n  shapeworks::DomainType m_domain_type = shapeworks::DomainType::Image;\n  std::vector&lt;int&gt; m_number_of_particles;\n  std::string m_transform_file;\n  std::string m_prefix_transform_file;\n  std::string m_output_dir;\n  std::string m_output_transform_file;\n  bool m_output_transform_files = false;\n  bool m_mesh_based_attributes = false;\n  std::vector&lt;bool&gt; m_use_xyz;\n  std::vector&lt;bool&gt; m_use_normals;\n  std::vector&lt;int&gt; m_attributes_per_domain;\n  int m_distribution_domain_id = -1;\n  std::string m_output_cutting_plane_file;\n\n  // Optimization Parameters\n  bool m_mesh_ffc_mode = 0;\n\n  unsigned int m_timepts_per_subject = 1;\n  int m_optimization_iterations = 2000;\n  int m_optimization_iterations_completed = 0;\n  int m_iterations_per_split = 1000;\n  bool m_use_shape_statistics_in_init = false;\n  unsigned int m_procrustes_interval = 3;\n  bool m_procrustes_scaling = true;\n  bool m_procrustes_rotation_translation = true;\n  double m_relative_weighting = 1.0;\n  double m_initial_relative_weighting = 0.05;\n  double m_starting_regularization = 1000;\n  double m_ending_regularization = 1.0;\n  int m_recompute_regularization_interval = 1;\n  bool m_save_init_splits = false;\n  unsigned int m_checkpointing_interval = 50;\n  int m_keep_checkpoints = 0;\n  double m_cotan_sigma_factor = 5.0;\n  std::vector&lt;int&gt; m_particle_flags;\n  std::vector&lt;int&gt; m_domain_flags;\n  double m_narrow_band = 0.0;\n  bool m_narrow_band_set = false;\n  bool m_fixed_domains_present = false;\n  int m_use_shape_statistics_after = -1;\n  std::string m_python_filename;\n  bool m_geodesics_enabled = false;             // geodesics disabled by default\n  size_t m_geodesic_cache_size_multiplier = 0;  // 0 =&gt; MeshWrapper will use a heuristic to determine cache size\n  double m_geodesic_remesh_percent = 100.0;     // 100% by default (e.g. no remeshing)\n\n  // m_spacing is used to scale the random update vector for particle splitting.\n  double m_spacing = 0;\n\n  std::vector&lt;std::string&gt; m_filenames;\n  int m_num_shapes = 0;\n\n  std::vector&lt;double&gt; m_energy_a;\n  std::vector&lt;double&gt; m_energy_b;\n  std::vector&lt;double&gt; m_total_energy;\n  bool m_log_energy = false;\n  std::string m_str_energy;\n\n  // GoodBadAssessment\n  std::vector&lt;std::vector&lt;int&gt;&gt; m_bad_ids;\n  double m_normal_angle = itk::Math::pi / 2.0;\n  bool m_perform_good_bad = false;\n\n  std::vector&lt;int&gt; m_cutting_planes_per_input;\n  std::vector&lt;int&gt; m_spheres_per_input;\n\n  bool m_file_output_enabled = true;\n  bool m_aborted = false;\n  std::vector&lt;std::array&lt;itk::Point&lt;double&gt;, 3&gt;&gt; m_cut_planes;\n\n  int m_total_iterations = 0;\n  int m_iteration_count = 0;\n  int m_split_number = 0;\n\n  int current_particle_iterations_ = 0;\n  int total_particle_iterations_ = 0;\n\n  std::function&lt;void(void)&gt; iteration_callback_;\n  bool show_visualizer_ = false;\n  shapeworks::OptimizationVisualizer visualizer_;\n\n  std::string particle_format_ = \"particles\";\n  std::shared_ptr&lt;Project&gt; project_;\n\n  std::chrono::system_clock::time_point m_start_time;\n  std::chrono::system_clock::time_point m_last_update_time;\n  std::chrono::system_clock::time_point m_last_remaining_update_time;\n  std::string m_remaining_time_message;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PaintWidget_8h.html","title":"Studio/Visualization/PaintWidget.h","text":""},{"location":"api/Files/PaintWidget_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PaintWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::PaintWidget"},{"location":"api/Files/PaintWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"vtkAbstractWidget.h\"\n\nclass vtkContourRepresentation;\nclass vtkPolyData;\nclass vtkPointPlacer;\nclass vtkRenderer;\n\nnamespace shapeworks {\n\nclass Viewer;\nclass StudioSphereRepresentation;\n\nclass PaintWidget : public vtkAbstractWidget {\n public:\n  // Description:\n  // Instantiate this class.\n  static PaintWidget* New();\n\n  // Description:\n  // Standard methods for a VTK class.\n  vtkTypeMacro(PaintWidget, vtkAbstractWidget);\n  void PrintSelf(ostream&amp; os, vtkIndent indent);\n\n  // Description:\n  // Set / get the Point Placer. The point placer is\n  // responsible for converting display coordinates into\n  // world coordinates according to some constraints, and\n  // for validating world positions.\n  // void SetPointPlacer( vtkPointPlacer * );\n  vtkSetMacro(PointPlacer, vtkPointPlacer*);\n  vtkGetMacro(PointPlacer, vtkPointPlacer*);\n\n  vtkSetMacro(Renderer, vtkRenderer*);\n  vtkGetMacro(Renderer, vtkRenderer*);\n\n  void set_viewer(Viewer* viewer);\n\n  void set_circle_mode(bool circle_mode);\n\n  // Description:\n  // The method for activiating and deactiviating this widget. This method\n  // must be overridden because it is a composite widget and does more than\n  // its superclasses' vtkAbstractWidget::SetEnabled() method.\n  virtual void SetEnabled(int);\n\n  // Description:\n  // Specify an instance of vtkWidgetRepresentation used to represent this\n  // widget in the scene. Note that the representation is a subclass of vtkProp\n  // so it can be added to the renderer independent of the widget.\n  void SetRepresentation(vtkContourRepresentation* r) {\n    this-&gt;Superclass::SetWidgetRepresentation(reinterpret_cast&lt;vtkWidgetRepresentation*&gt;(r));\n  }\n\n  // Description:\n  // Create the default widget representation if one is not set.\n  void CreateDefaultRepresentation();\n\n  void update_position();\n\n  // Description:\n  // Initialize the contour widget from a user supplied set of points. The\n  // state of the widget decides if you are still defining the widget, or\n  // if you've finished defining (added the last point) are manipulating\n  // it. Note that if the polydata supplied is closed, the state will be\n  // set to manipulate.\n  //  State: Define = 0, Manipulate = 1.\n  virtual void Initialize(vtkPolyData* poly, int state = 1);\n  virtual void Initialize() { this-&gt;Initialize(NULL); }\n\n  void set_brush_size(double size);\n  double get_brush_size();\n\n  void set_brush_color(float r, float g, float b);\n\n protected:\n  PaintWidget();\n  ~PaintWidget();\n\n  // The state of the widget\n  enum { Start, Paint, Erase };\n\n  int WidgetState;\n  vtkPointPlacer* PointPlacer;\n  vtkRenderer* Renderer;\n\n  // Callback interface to capture events when\n  // placing the widget.\n  static void StartPaintAction(vtkAbstractWidget* w);\n  static void EndPaintAction(vtkAbstractWidget* w);\n  static void StartEraseAction(vtkAbstractWidget* w);\n  static void EndEraseAction(vtkAbstractWidget* w);\n  static void MoveAction(vtkAbstractWidget* w);\n  static void LeaveAction(vtkAbstractWidget* w);\n  static void KeyPressAction(vtkAbstractWidget* w);\n\n  bool use_point_placer(double displayPos[2], int newState);\n  void set_cursor(int requestedShape);\n\n  StudioSphereRepresentation* sphere_cursor_;\n\n  bool mouse_in_window_;\n\n  Viewer* viewer_;\n  bool circle_mode_ = false;\n\n private:\n  PaintWidget(const PaintWidget&amp;);     // Not implemented\n  void operator=(const PaintWidget&amp;);  // Not implemented\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Parameters_8h.html","title":"Libs/Project/Parameters.h","text":""},{"location":"api/Files/Parameters_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Parameters_8h.html#classes","title":"Classes","text":"Name class shapeworks::Parameters Parameter settings."},{"location":"api/Files/Parameters_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ProjectUtils.h\"\n\n#include \"Variant.h\"\n\nnamespace shapeworks {\n\n\nclass Parameters {\n  using StringMap = project::types::StringMap;\n\n public:\n  static constexpr const char* ANALYSIS_PARAMS = \"analysis\";\n  static constexpr const char* GROOM_PARAMS = \"groom\";\n  static constexpr const char* OPTIMIZE_PARAMS = \"optimize\";\n  static constexpr const char* STUDIO_PARAMS = \"studio\";\n  static constexpr const char* PROJECT_PARAMS = \"project\";\n  static constexpr const char* DEEPSSM_PARAMS = \"deepssm\";\n  static constexpr const char* MONAI_PARAMS = \"monai\";\n\n  Parameters();\n\n  explicit Parameters(StringMap map);\n\n  Variant get(std::string key, Variant default_value);\n\n  bool key_exists(std::string key);\n\n  void set(std::string key, Variant value);\n\n  void remove_entry(std::string key);\n\n  void set_map(StringMap map);\n\n  StringMap get_map() const;\n\n  void reset_parameters();\n\n private:\n  StringMap map_;\n\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleAreaJob_8h.html","title":"Studio/Job/ParticleAreaJob.h","text":""},{"location":"api/Files/ParticleAreaJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleAreaJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleAreaJob"},{"location":"api/Files/ParticleAreaJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\n#include &lt;QSharedPointer&gt;\n\nclass vtkLookupTable;\n\nnamespace shapeworks {\n\nclass Session;\n\nclass ParticleAreaJob : public Job {\n  Q_OBJECT\n public:\n  ParticleAreaJob(QSharedPointer&lt;Session&gt; session);\n  void run() override;\n  QString name() override { return \"Particle Normal Evaluation\"; }\n\n  const Eigen::VectorXd&amp; get_mean_areas() const { return mean_areas_; }\n  const Eigen::VectorXd&amp; get_stddev_areas() const { return stddev_areas_; }\n\n Q_SIGNALS:\n\n private:\n  QSharedPointer&lt;Session&gt; session_;\n  Eigen::VectorXd mean_areas_;\n  Eigen::VectorXd stddev_areas_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleAreaPanel_8h.html","title":"Studio/Analysis/ParticleAreaPanel.h","text":""},{"location":"api/Files/ParticleAreaPanel_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleAreaPanel_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleAreaPanel"},{"location":"api/Files/ParticleAreaPanel_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n\n// Qt\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\n// ShapeWorks\n#include &lt;ParticleShapeStatistics.h&gt;\n\n// Studio\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Job/ParticleAreaJob.h&gt;\n#include &lt;Shape.h&gt;\n#include &lt;Visualization/Visualizer.h&gt;\n\nclass Ui_ParticleAreaPanel;\nclass JKQTPlotter;\n\nnamespace shapeworks {\n\nclass Session;\nclass Lightbox;\nclass ShapeWorksStudioApp;\n\nclass ParticleAreaPanel : public QWidget {\n  Q_OBJECT;\n\n public:\n  ParticleAreaPanel(QWidget* parent = 0);\n  ~ParticleAreaPanel();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n  void reset();\n\n  bool get_display_particle_area() const;\n\n  Eigen::VectorXd get_computed_values() const;\n  std::string get_computed_value_name() const;\n\n public Q_SLOTS:\n\n  void run_clicked();\n  void show_particle_area_clicked();\n\n  void display_option_changed();\n\n  void handle_job_progress(int progress);\n  void handle_job_complete();\n\n Q_SIGNALS:\n\n  void update_view();\n\n private:\n\n  void update_run_button();\n\n  void update_graphs();\n\n  QSharedPointer&lt;Session&gt; session_;\n  QSharedPointer&lt;ParticleAreaJob&gt; job_;\n\n  Ui_ParticleAreaPanel* ui_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleArea_8h.html","title":"Libs/Analyze/ParticleArea.h","text":""},{"location":"api/Files/ParticleArea_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleArea_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleArea"},{"location":"api/Files/ParticleArea_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkPoint.h&gt;\n\n#include &lt;Eigen/Core&gt;\n#include &lt;QColor&gt;\n\n#include \"vtkPolyData.h\"\n\nnamespace shapeworks {\n\nclass ParticleArea {\n public:\n  static void assign_vertex_particles(vtkSmartPointer&lt;vtkPolyData&gt; poly_data,\n                                      std::vector&lt;itk::Point&lt;double&gt;&gt; particles);\n\n  static void assign_vertex_colors(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, std::vector&lt;QColor&gt; colors);\n\n  static void assign_vertex_areas(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, Eigen::VectorXd areas);\n\n  static std::vector&lt;QColor&gt; colors_from_lut(vtkSmartPointer&lt;vtkLookupTable&gt; lut);\n\n  static Eigen::VectorXd compute_particle_triangle_areas(vtkSmartPointer&lt;vtkPolyData&gt; poly_data,\n                                                         std::vector&lt;itk::Point&lt;double&gt;&gt; particles);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ParticleColors_8h.html","title":"Studio/Visualization/ParticleColors.h","text":""},{"location":"api/Files/ParticleColors_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleColors_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleColors Supplies particle colors."},{"location":"api/Files/ParticleColors_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkLookupTable.h&gt;\n\n#include &lt;QObject&gt;\n\nnamespace shapeworks {\n\n\nclass ParticleColors : public QObject {\n  Q_OBJECT;\n\n public:\n  enum ParticleColorsType { Distinct = 0, Original = 1 };\n  Q_ENUM(ParticleColorsType);\n\n  static vtkSmartPointer&lt;vtkLookupTable&gt; construct_distinct();\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleDomain_8h.html","title":"Libs/Optimize/Domain/ParticleDomain.h","text":""},{"location":"api/Files/ParticleDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleDomain"},{"location":"api/Files/ParticleDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"DomainType.h\"\n#include \"Libs/Optimize/Constraints/Constraints.h\"\n#include \"itkDataObject.h\"\n#include \"itkPoint.h\"\n#include \"vnl/vnl_matrix_fixed.h\"\n#include \"vnl/vnl_vector_fixed.h\"\n\nnamespace shapeworks {\n\nclass ParticleDomain {\n public:\n  typedef std::shared_ptr&lt;ParticleDomain&gt; Pointer;\n\n  using PointType = itk::Point&lt;double, 3&gt;;\n  using GradNType = vnl_matrix_fixed&lt;float, 3, 3&gt;;\n  using VectorDoubleType = vnl_vector_fixed&lt;double, 3&gt;;\n  using VectorFloatType = vnl_vector_fixed&lt;float, 3&gt;;\n\n  virtual bool ApplyConstraints(PointType &amp;p, int idx, bool dbg = false) const = 0;\n\n  // todo update should be const?\n  virtual PointType UpdateParticlePosition(const PointType &amp;point, int idx, VectorDoubleType &amp;update) const = 0;\n\n  virtual void InvalidateParticlePosition(int idx) const {}\n\n  virtual VectorDoubleType ProjectVectorToSurfaceTangent(VectorDoubleType &amp;gradE, const PointType &amp;pos,\n                                                         int idx) const = 0;\n  virtual VectorFloatType SampleGradientAtPoint(const PointType &amp;point, int idx) const = 0;\n  virtual VectorFloatType SampleNormalAtPoint(const PointType &amp;point, int idx) const = 0;\n  virtual GradNType SampleGradNAtPoint(const PointType &amp;p, int idx) const = 0;\n\n  virtual double Distance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b,\n                          VectorDoubleType *out_grad = nullptr) const {\n    if (out_grad != nullptr) {\n      for (int i = 0; i &lt; DIMENSION; i++) {\n        (*out_grad)[i] = a[i] - b[i];\n      }\n    }\n    return a.EuclideanDistanceTo(b);\n  }\n  virtual double SquaredDistance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b) const {\n    return a.SquaredEuclideanDistanceTo(b);\n  }\n  virtual bool IsWithinDistance(const PointType &amp;a, int idx_a, const PointType &amp;b, int idx_b, double test_dist,\n                                double &amp;distance) const {\n    distance = this-&gt;Distance(a, idx_a, b, idx_b);\n    return distance &lt; test_dist;\n  }\n\n  virtual double GetCurvature(const PointType &amp;p, int idx) const = 0;\n  virtual double GetSurfaceMeanCurvature() const = 0;\n  virtual double GetSurfaceStdDevCurvature() const = 0;\n\n  virtual const PointType &amp;GetLowerBound() const = 0;\n  virtual const PointType &amp;GetUpperBound() const = 0;\n\n  virtual PointType GetZeroCrossingPoint() const = 0;\n  virtual double GetSurfaceArea() const = 0;\n\n  virtual PointType GetValidLocationNear(PointType p) const = 0;\n  virtual double GetMaxDiameter() const = 0;\n\n  virtual void DeleteImages() = 0;\n  virtual void DeletePartialDerivativeImages() = 0;\n  virtual void UpdateZeroCrossingPoint() = 0;\n\n  bool IsDomainFixed() const { return m_FixedDomain; }\n  virtual shapeworks::DomainType GetDomainType() const = 0;\n\n  std::shared_ptr&lt;shapeworks::Constraints&gt; GetConstraints() const { return constraints; }\n\n  // Use `random` to advance a particle and return a new position\n  virtual PointType GetPositionAfterSplit(const PointType &amp;pt, const VectorDoubleType &amp;local_direction,\n                                          const VectorDoubleType &amp;global_direction, double epsilon) const {\n    // todo this has been copied from itkParticleSystem::AdvancedAllParticleSplitting.\n    //  Ideally, we should compute a direction that is \"consistent\" depending on the domain type and use the\n    //  `UpdateParticlePosition` API to advance the particle. See ContourDomain for an example. Leaving this be for\n    //  now because we'd have to retest all MeshDomain and ImageDomain use cases if this behaviour changes.\n    PointType new_pt;\n    for (unsigned int k = 0; k &lt; 3; k++) {\n      new_pt[k] = pt[k] + epsilon * local_direction[k] / 5.;\n    }\n    return new_pt;\n  }\n\n  void SetDomainID(int id) { this-&gt;m_DomainID = id; }\n\n  void SetDomainName(std::string name) { this-&gt;m_DomainName = name; }\n\n protected:\n  // is this a fixed domain or not?  We start as fixed and if an image or mesh is set, we set this to false\n  bool m_FixedDomain{true};\n\n  int m_DomainID{-1};\n  std::string m_DomainName;\n\n  ParticleDomain() { this-&gt;constraints = std::make_shared&lt;shapeworks::Constraints&gt;(); }\n  virtual ~ParticleDomain() {}\n\n  std::shared_ptr&lt;shapeworks::Constraints&gt; constraints;\n\n private:\n  ParticleDomain(const ParticleDomain &amp;);  // purposely not implemented\n  void operator=(const ParticleDomain &amp;);  // purposely not implemented\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleEvents_8h.html","title":"Libs/Optimize/ParticleEvents.h","text":""},{"location":"api/Files/ParticleEvents_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleEvents_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleEvent"},{"location":"api/Files/ParticleEvents_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"itkEventObject.h\"\n\nnamespace shapeworks {\nclass ParticleEvent : public itk::EventObject {\n public:\n  typedef ParticleEvent Self;\n\n  ParticleEvent() {}\n  virtual ~ParticleEvent() {}\n\n\n  ParticleEvent(const ParticleEvent&amp; v) : itk::EventObject(v) {\n    m_PositionIndex = v.m_PositionIndex;\n    m_DomainIndex = v.m_DomainIndex;\n  }\n  const ParticleEvent&amp; operator=(const ParticleEvent&amp; v) {\n    m_PositionIndex = v.m_PositionIndex;\n    m_DomainIndex = v.m_DomainIndex;\n\n    return *this;\n  }\n\n  virtual const char* GetEventName() const { return \"ParticleEvent\"; }\n\n  virtual bool CheckEvent(const ::itk::EventObject* e) const { return dynamic_cast&lt;const Self*&gt;(e); }\n\n  virtual ::itk::EventObject* MakeObject() const { return new Self; }\n\n  inline void SetPositionIndex(int i) { m_PositionIndex = i; }\n  int GetPositionIndex() const { return m_PositionIndex; }\n\n  inline void SetDomainIndex(int i) { m_DomainIndex = i; }\n  int GetDomainIndex() const { return m_DomainIndex; }\n\n private:\n  int m_PositionIndex;\n  int m_DomainIndex;\n};\n\nitkEventMacro(ParticleDomainAddEvent, ParticleEvent);\nitkEventMacro(ParticleTransformSetEvent, ParticleEvent);\nitkEventMacro(ParticlePrefixTransformSetEvent, ParticleEvent);\nitkEventMacro(ParticlePositionSetEvent, ParticleEvent);\nitkEventMacro(ParticlePositionAddEvent, ParticleEvent);\nitkEventMacro(ParticlePositionRemoveEvent, ParticleEvent);\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleFile_8h.html","title":"Libs/Particles/ParticleFile.h","text":""},{"location":"api/Files/ParticleFile_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) shapeworks::particles"},{"location":"api/Files/ParticleFile_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkPoint.h&gt;\n\n#include &lt;Eigen/Core&gt;\n\nnamespace shapeworks {\n\nnamespace particles {\n\n//---------------------------------------------------------------------------\nEigen::VectorXd read_particles(std::string filename);\n\n//---------------------------------------------------------------------------\nstd::vector&lt;itk::Point&lt;double, 3&gt;&gt; read_particles_as_vector(std::string filename);\n\n//---------------------------------------------------------------------------\nvoid write_particles(std::string filename, const Eigen::VectorXd&amp; points);\n\n//---------------------------------------------------------------------------\nvoid write_particles_from_vector(std::string filename, std::vector&lt;itk::Point&lt;double, 3&gt;&gt; points);\n\n}  // namespace particles\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleGaussianModeWriter_8h.html","title":"Libs/Optimize/Utils/ParticleGaussianModeWriter.h","text":""},{"location":"api/Files/ParticleGaussianModeWriter_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleGaussianModeWriter_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleGaussianModeWriter"},{"location":"api/Files/ParticleGaussianModeWriter_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Libs/Optimize/Matrix/LegacyShapeMatrix.h\"\n#include \"itkDataObject.h\"\n\nnamespace shapeworks {\n\ntemplate &lt;unsigned int VDimension&gt;\nclass ParticleGaussianModeWriter : public itk::DataObject {\n public:\n  typedef ParticleGaussianModeWriter Self;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef DataObject Superclass;\n  itkTypeMacro(ParticleGaussianModeWriter, DataObject);\n\n  typedef ParticleSystem ParticleSystemType;\n  typedef LegacyShapeMatrix ShapeMatrixType;\n  typedef typename ShapeMatrixType::DataType DataType;\n\n  typedef typename ParticleSystemType::PointType PointType;\n  typedef vnl_vector&lt;DataType&gt; vnl_vector_type;\n  typedef vnl_matrix&lt;DataType&gt; vnl_matrix_type;\n\n  itkNewMacro(Self);\n\n  itkStaticConstMacro(Dimension, unsigned int, VDimension);\n\n  void Update() const;\n\n  int GetNumberOfModes() const { return m_NumberOfModes; }\n  void SetNumberOfModes(int b) { m_NumberOfModes = b; }\n\n  void SetShapeMatrix(ShapeMatrixType* s) { m_ShapeMatrix = s; }\n  ShapeMatrixType* GetShapeMatrix() { return m_ShapeMatrix.GetPointer(); }\n  const ShapeMatrixType* GetShapeMatrix() const { return m_ShapeMatrix.GetPointer(); }\n\n  void SetFileName(const std::string&amp; s) { m_FileName = s; }\n  void SetFileName(const char* s) { m_FileName = s; }\n  const std::string&amp; GetFileName() const { return m_FileName; }\n\n protected:\n  ParticleGaussianModeWriter() : m_NumberOfModes(3) {}\n  virtual ~ParticleGaussianModeWriter() {}\n  void operator=(const ParticleGaussianModeWriter&amp;);\n  ParticleGaussianModeWriter(const ParticleGaussianModeWriter&amp;);\n  typename ShapeMatrixType::Pointer m_ShapeMatrix;\n\n  int m_NumberOfModes;\n  std::string m_FileName;\n};\n\n}  // namespace shapeworks\n\n#include \"ParticleGaussianModeWriter.txx\"\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleGoodBadAssessment_8h.html","title":"Libs/Optimize/Utils/ParticleGoodBadAssessment.h","text":""},{"location":"api/Files/ParticleGoodBadAssessment_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleGoodBadAssessment_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleGoodBadAssessment Performs good/bad points assessment and reports the bad positions of the particle system."},{"location":"api/Files/ParticleGoodBadAssessment_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Libs/Optimize/Container/MeanCurvatureContainer.h\"\n#include \"ParticleSystem.h\"\n\nnamespace shapeworks {\n\nclass ParticleGoodBadAssessment {\n public:\n  using MeanCurvatureCacheType = MeanCurvatureContainer&lt;float, 3&gt;;\n\n  void set_domains_per_shape(int i) { domains_per_shape_ = i; }\n\n  void set_criterion_angle(double a) { criterion_angle_ = a; }\n\n  std::vector&lt;std::vector&lt;int&gt;&gt; run_assessment(const ParticleSystem* ps,\n                                               MeanCurvatureCacheType* mean_curvature_cache);\n\n private:\n  vnl_matrix&lt;double&gt; compute_particles_normals(int d, const ParticleSystem* ps);\n  int domains_per_shape_ = 1;\n  double criterion_angle_ = 90.0;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleNeighborhood_8h.html","title":"Libs/Optimize/Neighborhood/ParticleNeighborhood.h","text":""},{"location":"api/Files/ParticleNeighborhood_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleNeighborhood_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleNeighborhood"},{"location":"api/Files/ParticleNeighborhood_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"Libs/Optimize/Domain/ParticleDomain.h\"\n#include \"ParticlePointIndexPair.h\"\n\nnamespace shapeworks {\nclass ParticleSystem;\n\nclass ParticleNeighborhood {\n public:\n  explicit ParticleNeighborhood(ParticleSystem* ps, int domain_id = -1) : ps_(ps), domain_id_(domain_id) {}\n\n  std::vector&lt;ParticlePointIndexPair&gt; find_neighborhood_points(const itk::Point&lt;double, 3&gt;&amp; position, int id,\n                                                               std::vector&lt;double&gt;&amp; weights,\n                                                               std::vector&lt;double&gt;&amp; distances, double radius);\n\n  std::vector&lt;ParticlePointIndexPair&gt; find_neighborhood_points(const itk::Point&lt;double, 3&gt;&amp; position, int id,\n                                                               std::vector&lt;double&gt;&amp; weights, double radius);\n\n  std::vector&lt;ParticlePointIndexPair&gt; find_neighborhood_points(const itk::Point&lt;double, 3&gt;&amp; position, int id,\n                                                               double radius);\n\n  void set_weighting_enabled(bool is_enabled) { weighting_enabled_ = is_enabled; }\n\n  bool is_weighting_enabled() const { return weighting_enabled_; }\n\n  void set_force_euclidean(bool is_enabled) { force_euclidean_ = is_enabled; }\n\n  bool is_force_euclidean() const { return force_euclidean_; }\n\n  void set_domain(ParticleDomain::Pointer domain) { domain_ = domain; };\n  ParticleDomain::Pointer get_domain() const { return domain_; };\n\n  void set_domain_id(int id) { domain_id_ = id; }\n\n private:\n  std::pair&lt;std::vector&lt;ParticlePointIndexPair&gt;, std::vector&lt;double&gt;&gt; get_points_in_sphere(\n      const itk::Point&lt;double, 3&gt;&amp; position, int id, double radius);\n\n  ParticleSystem* ps_;\n  ParticleDomain::Pointer domain_;\n  int domain_id_{-1};\n  double flat_cutoff_{0.3};\n  bool weighting_enabled_{true};\n  bool force_euclidean_{false};\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleNormalEvaluationJob_8h.html","title":"Studio/Job/ParticleNormalEvaluationJob.h","text":""},{"location":"api/Files/ParticleNormalEvaluationJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleNormalEvaluationJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleNormalEvaluationJob"},{"location":"api/Files/ParticleNormalEvaluationJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n#include &lt;QSharedPointer&gt;\n\nnamespace shapeworks {\n\nclass Session;\n\nclass ParticleNormalEvaluationJob : public Job {\n  Q_OBJECT\n public:\n  ParticleNormalEvaluationJob(QSharedPointer&lt;Session&gt; session, double max_angle_degrees);\n  void run() override;\n  QString name() override;\n\n  std::vector&lt;bool&gt; get_good_bad();\n\nQ_SIGNALS:\n\n  void result_ready(std::vector&lt;bool&gt; good_bad);\n\n private:\n  QSharedPointer&lt;Session&gt; session_;\n  double max_angle_degrees_;\n\n  std::vector&lt;bool&gt; good_bad_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleNormalEvaluation_8h.html","title":"Libs/Particles/ParticleNormalEvaluation.h","text":""},{"location":"api/Files/ParticleNormalEvaluation_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleNormalEvaluation_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleNormalEvaluation"},{"location":"api/Files/ParticleNormalEvaluation_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Particles/ParticleSystemEvaluation.h&gt;\n\n#include &lt;memory&gt;\n\nnamespace shapeworks {\n\n\nclass Surface;\nclass ParticleNormalEvaluation {\n public:\n  static std::vector&lt;double&gt; evaluate_particle_normals(const Eigen::MatrixXd&amp; particles,\n                                                       const Eigen::MatrixXd&amp; normals);\n\n  static std::vector&lt;bool&gt; threshold_particle_normals(std::vector&lt;double&gt; angles, double max_angle_degrees);\n\n  static Eigen::MatrixXd compute_particle_normals(const Eigen::MatrixXd&amp; particles,\n                                                  std::vector&lt;std::shared_ptr&lt;Surface&gt;&gt; meshes);\n\n private:\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticlePointIndexPair_8h.html","title":"Libs/Optimize/Neighborhood/ParticlePointIndexPair.h","text":""},{"location":"api/Files/ParticlePointIndexPair_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticlePointIndexPair_8h.html#classes","title":"Classes","text":"Name struct shapeworks::ParticlePointIndexPair"},{"location":"api/Files/ParticlePointIndexPair_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"itkPoint.h\"\nnamespace shapeworks {\nstruct ParticlePointIndexPair {\n  typedef itk::Point&lt;double, 3&gt; PointType;\n  ParticlePointIndexPair() {}\n  ParticlePointIndexPair(const PointType&amp; p, unsigned int i = 0) {\n    Point = p;\n    Index = i;\n  }\n  ParticlePointIndexPair(const ParticlePointIndexPair&amp; o) { this-&gt;operator=(o); }\n  const ParticlePointIndexPair&amp; operator=(const ParticlePointIndexPair&amp; o) {\n    Point = o.Point;\n    Index = o.Index;\n    return *this;\n  }\n  PointType Point;\n  unsigned int Index;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleRegionDomain_8h.html","title":"Libs/Optimize/Domain/ParticleRegionDomain.h","text":""},{"location":"api/Files/ParticleRegionDomain_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleRegionDomain_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleRegionDomain"},{"location":"api/Files/ParticleRegionDomain_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ParticleDomain.h\"\n\nnamespace shapeworks {\n\nclass ParticleRegionDomain : public ParticleDomain {\n public:\n  using Pointer = std::shared_ptr&lt;ParticleRegionDomain&gt;;\n\n  typedef typename ParticleDomain::PointType PointType;\n\n  virtual bool ApplyConstraints(PointType &amp;p) const {\n    bool changed = false;\n    for (unsigned int i = 0; i &lt; DIMENSION; i++) {\n      if (p[i] &lt; GetLowerBound()[i]) {\n        changed = true;\n        p[i] = GetLowerBound()[i];\n      } else if (p[i] &gt; GetUpperBound()[i]) {\n        changed = true;\n        p[i] = GetUpperBound()[i];\n      }\n    }\n    return changed;\n  }\n\n  virtual const PointType &amp;GetUpperBound() const { return m_UpperBound; }\n  virtual const PointType &amp;GetLowerBound() const { return m_LowerBound; }\n  void SetUpperBound(const PointType _UpperBound) { m_UpperBound = _UpperBound; }\n  void SetLowerBound(const PointType _LowerBound) { m_LowerBound = _LowerBound; }\n  void SetRegion(const PointType &amp;lowerBound, const PointType &amp;upperBound) {\n    SetLowerBound(lowerBound);\n    SetUpperBound(upperBound);\n  }\n\n protected:\n  ParticleRegionDomain() {}\n  virtual ~ParticleRegionDomain(){};\n\n  void PrintSelf(std::ostream &amp;os, itk::Indent indent) const {\n    os &lt;&lt; \"LowerBound = \" &lt;&lt; GetLowerBound() &lt;&lt; std::endl;\n    os &lt;&lt; \"UpperBound = \" &lt;&lt; GetUpperBound() &lt;&lt; std::endl;\n  }\n\n  inline bool IsInsideBuffer(const PointType &amp;p) const {\n    for (int i = 0; i &lt; DIMENSION; i++) {\n      if (p[i] &lt; m_LowerBound[i] || p[i] &gt; m_UpperBound[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n private:\n  PointType m_LowerBound;\n  PointType m_UpperBound;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleShapeStatistics_8h.html","title":"Libs/Particles/ParticleShapeStatistics.h","text":""},{"location":"api/Files/ParticleShapeStatistics_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleShapeStatistics_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleShapeStatistics"},{"location":"api/Files/ParticleShapeStatistics_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"ParticleSystemEvaluation.h\"\n#include \"Shapeworks.h\"\n\nnamespace shapeworks {\n\nclass Project;\n\nclass ParticleShapeStatistics {\n public:\n  ParticleShapeStatistics(){};\n  explicit ParticleShapeStatistics(std::shared_ptr&lt;Project&gt; project);\n  ~ParticleShapeStatistics(){};\n\n  int do_pca(std::vector&lt;std::vector&lt;Point&gt;&gt; global_pts, int domainsPerShape = 1);\n\n  int do_pca(ParticleSystemEvaluation particleSystem, int domainsPerShape = 1);\n\n  int do_pca(std::shared_ptr&lt;Project&gt; project);\n\n  int import_points(std::vector&lt;Eigen::VectorXd&gt; points, std::vector&lt;int&gt; group_ids);\n\n  void compute_multi_level_analysis_statistics(std::vector&lt;Eigen::VectorXd&gt; points, unsigned int dps);\n\n  int compute_shape_dev_modes_for_mca();\n\n  int compute_relative_pose_modes_for_mca();\n\n  void set_num_particles_per_domain(const std::vector&lt;int&gt;&amp; num_particles_array);\n\n  int read_point_files(const std::string&amp; s);\n\n  int write_csv_file(const std::string&amp; s);\n\n  int compute_modes();\n\n  int get_num_modes() const;\n\n  int principal_component_projections();\n\n  Eigen::VectorXd project_new_sample(const Eigen::VectorXd&amp; new_sample);\n\n  int get_num_samples() const { return num_samples_; }\n  int get_group1_num_samples() const { return num_samples_group1_; }\n  int get_group2_num_samples() const { return num_samples_group2_; }\n\n  int get_num_dimensions() const { return num_dimensions_; }\n  int get_domains_per_shape() { return domains_per_shape_; }\n  std::vector&lt;int&gt; NumberOfPointsArray() { return num_particles_array_; }\n\n  int GroupID(unsigned int i) const { return group_ids_[i]; }\n  const std::vector&lt;int&gt;&amp; GroupID() const { return group_ids_; }\n\n  const Eigen::MatrixXd&amp; get_eigen_vectors() const { return eigenvectors_; }\n  const std::vector&lt;double&gt;&amp; get_eigen_values() const { return eigenvalues_; }\n\n  const Eigen::MatrixXd&amp; get_eigenvectors_rel_pos() { return eigenvectors_rel_pose_; }\n  const std::vector&lt;double&gt;&amp; get_eigenvalues_shape_dev() { return eigenvalues_shape_dev_; }\n  const Eigen::MatrixXd&amp; get_eigenvectors_shape_dev() { return eigenvectors_shape_dev_; }\n  const std::vector&lt;double&gt;&amp; get_eigenvalues_rel_pose() { return eigenvalues_rel_pose_; }\n  const Eigen::VectorXd&amp; get_mean_shape_dev() { return mean_shape_dev_; }\n  const Eigen::VectorXd&amp; get_mean_rel_pos() { return mean_rel_pose_; }\n\n  const Eigen::VectorXd&amp; get_mean() const { return mean_; }\n  const Eigen::VectorXd&amp; get_group1_mean() const { return mean1_; }\n  const Eigen::VectorXd&amp; get_group2_mean() const { return mean2_; }\n\n  const Eigen::VectorXd&amp; get_group_difference() const { return groupdiff_; }\n\n  int compute_median_shape(const int ID);\n\n  double l1_norm(unsigned int a, unsigned int b);\n\n  Eigen::MatrixXd&amp; get_pca_loadings() { return principals_; }\n\n  const std::vector&lt;double&gt;&amp; get_percent_variance_by_mode() const { return percent_variance_by_mode_; }\n\n  static int simple_linear_regression(const std::vector&lt;double&gt;&amp; y, const std::vector&lt;double&gt;&amp; x, double&amp; a, double&amp; b);\n\n  Eigen::VectorXd get_compactness(const std::function&lt;void(float)&gt;&amp; progress_callback = nullptr) const;\n  Eigen::VectorXd get_specificity(const std::function&lt;void(float)&gt;&amp; progress_callback = nullptr,\n                                  const std::function&lt;bool()&gt;&amp; check_abort = nullptr) const;\n  Eigen::VectorXd get_generalization(const std::function&lt;void(float)&gt;&amp; progress_callback = nullptr,\n                                     const std::function&lt;bool(void)&gt;&amp; check_abort = nullptr) const;\n\n  Eigen::MatrixXd get_group1_matrix() const;\n  Eigen::MatrixXd get_group2_matrix() const;\n\n  Eigen::MatrixXd&amp; matrix() { return matrix_; };\n\n  void set_num_values_per_particle(int value_per_particle) { values_per_particle_ = value_per_particle; }\n\n  void set_particle_to_surface_mode(bool value) { particle_to_surface_mode_ = value; }\n  bool get_particle_to_surface_mode() const { return particle_to_surface_mode_; }\n  void set_meshes(const std::vector&lt;Mesh&gt;&amp; meshes) { meshes_ = meshes; }\n\n  void load_from_project(std::shared_ptr&lt;Project&gt; project);\n\n private:\n  unsigned int num_samples_group1_;\n  unsigned int num_samples_group2_;\n  unsigned int num_samples_;\n  unsigned int domains_per_shape_ = 0;\n  unsigned int num_dimensions_;\n  std::vector&lt;int&gt; group_ids_;\n\n  Eigen::MatrixXd eigenvectors_;\n  std::vector&lt;double&gt; eigenvalues_;\n  Eigen::VectorXd mean_;\n  Eigen::VectorXd mean1_;\n  Eigen::VectorXd mean2_;\n  Eigen::MatrixXd points_minus_mean_;\n  Eigen::MatrixXd shapes_;\n\n  std::vector&lt;double&gt; percent_variance_by_mode_;\n  Eigen::MatrixXd principals_;\n\n  Eigen::VectorXd groupdiff_;\n\n  // Variables for MLCA\n  std::vector&lt;int&gt; num_particles_array_;      // Number of Particles for each object in the multi-object shape structure\n  Eigen::MatrixXd eigenvectors_rel_pose_;     // Eigenvectors defined for relative pose subspace\n  Eigen::MatrixXd eigenvectors_shape_dev_;    // Eigenvectors defined for morphological subspace\n  std::vector&lt;double&gt; eigenvalues_rel_pose_;  // Eigenvalues defined in relative pose subspace\n  std::vector&lt;double&gt; eigenvalues_shape_dev_;  // Eigenvectors defined in morphological subspace\n  Eigen::MatrixXd points_minus_mean_rel_pose_;\n  Eigen::MatrixXd points_minus_mean_shape_dev_;\n  Eigen::VectorXd mean_shape_dev_;\n  Eigen::VectorXd mean_rel_pose_;\n  Eigen::MatrixXd super_matrix_;  // Shape Matrix reshaped, used to compute MLCA statistics\n\n  Eigen::MatrixXd matrix_;\n\n  Eigen::MatrixXd group1_matrix_;\n  Eigen::MatrixXd group2_matrix_;\n\n  std::vector&lt;Eigen::VectorXd&gt; points_;\n\n  int values_per_particle_ = 3;  // e.g. 3 for x/y/z, 4 for x/y/z/scalar\n  bool particle_to_surface_mode_ = false;\n  std::vector&lt;Mesh&gt; meshes_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleSystemEvaluation_8h.html","title":"Libs/Particles/ParticleSystemEvaluation.h","text":""},{"location":"api/Files/ParticleSystemEvaluation_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleSystemEvaluation_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleSystemEvaluation"},{"location":"api/Files/ParticleSystemEvaluation_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Libs/Mesh/Mesh.h&gt;\n\n#include &lt;Eigen/Core&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\nclass ParticleSystemEvaluation {\n public:\n  explicit ParticleSystemEvaluation(const std::vector&lt;std::string&gt;&amp; paths);\n\n  explicit ParticleSystemEvaluation(const Eigen::MatrixXd&amp; matrix, int num_values_per_particle = 3);\n\n  const Eigen::MatrixXd&amp; get_matrix() const { return matrix_; };\n\n  int get_num_values_per_particle() const { return num_values_per_particle_; }\n\n  const std::vector&lt;std::string&gt;&amp; get_paths() const { return paths_; }\n\n  int num_samples() const { return matrix_.cols(); }\n\n  int num_dims() const { return matrix_.rows(); }\n\n  bool exact_compare(const ParticleSystemEvaluation&amp; other) const;\n\n  bool evaluation_compare(const ParticleSystemEvaluation&amp; other) const;\n\n  static bool read_particle_file(std::string filename, Eigen::VectorXd&amp; points);\n\n  void set_meshes(const std::vector&lt;Mesh&gt;&amp; meshes);\n\n  const std::vector&lt;Mesh&gt;&amp; get_meshes() const { return meshes_; }\n\n private:\n  friend struct SharedCommandData;\n\n  ParticleSystemEvaluation() {}\n\n  Eigen::MatrixXd matrix_;\n  std::vector&lt;std::string&gt; paths_;\n  int num_values_per_particle_ = 3;  // e.g. 3 for x/y/z, 4 for x/y/z/scalar, 1 for scalar-only\n  std::vector&lt;Mesh&gt; meshes_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ParticleSystem_8h.html","title":"Libs/Optimize/ParticleSystem.h","text":""},{"location":"api/Files/ParticleSystem_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ParticleSystem_8h.html#classes","title":"Classes","text":"Name class shapeworks::ParticleSystem A facade class managing interactions with a particle system."},{"location":"api/Files/ParticleSystem_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;random&gt;\n#include &lt;vector&gt;\n\n#include \"Libs/Optimize/Container/GenericContainer.h\"\n#include \"Libs/Optimize/Domain/ParticleDomain.h\"\n#include \"Libs/Optimize/Neighborhood/ParticleNeighborhood.h\"\n#include \"Observer.h\"\n#include \"ParticleEvents.h\"\n#include \"itkCommand.h\"\n#include \"itkDataObject.h\"\n#include \"itkEventObject.h\"\n#include \"itkObjectFactory.h\"\n#include \"itkPoint.h\"\n#include \"itkWeakPointer.h\"\n#include \"vnl/vnl_inverse.h\"\n#include \"vnl/vnl_matrix_fixed.h\"\n#include \"vnl/vnl_vector_fixed.h\"\n\nnamespace shapeworks {\nclass ParticleSystem : public itk::DataObject {\n public:\n  static constexpr int VDimension = 3;\n\n  typedef ParticleSystem Self;\n  typedef DataObject Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(ParticleSystem, itk::DataObject);\n\n  itkStaticConstMacro(Dimension, unsigned int, VDimension);\n\n  using DomainType = shapeworks::ParticleDomain;\n\n  typedef itk::Point&lt;double, VDimension&gt; PointType;\n\n  typedef GenericContainer&lt;PointType&gt; PointContainerType;\n\n  //  typedef Transform&lt;double, VDimension, VDimension&gt; TransformType;\n  typedef vnl_matrix_fixed&lt;double, VDimension + 1, VDimension + 1&gt; TransformType;\n  typedef vnl_vector_fixed&lt;double, VDimension&gt; VectorType;\n  typedef vnl_matrix&lt;double&gt; VnlMatrixType;\n\n  void RegisterObserver(Observer *attr);\n\n  void SynchronizePositions() {\n    for (unsigned int d = 0; d &lt; this-&gt;GetNumberOfDomains(); d++) {\n      for (unsigned int p = 0; p &lt; this-&gt;GetNumberOfParticles(d); p++) {\n        this-&gt;SetPosition(this-&gt;GetPosition(p, d), p, d);\n      }\n    }\n  }\n\n  unsigned long int GetNumberOfParticles(unsigned int d = 0) const { return m_Positions[d]-&gt;GetSize(); }\n\n  const PointType &amp;AddPosition(const PointType &amp;, unsigned int d = 0);\n  const PointType &amp;SetPosition(const PointType &amp;, unsigned long int k, unsigned int d = 0);\n\n  void RemovePosition(unsigned long int k, unsigned int d = 0);\n\n  PointType &amp;GetPosition(unsigned long int k, unsigned int d = 0) { return m_Positions[d]-&gt;operator[](k); }\n  const PointType &amp;GetPosition(unsigned long int k, unsigned int d = 0) const { return m_Positions[d]-&gt;operator[](k); }\n  PointType GetTransformedPosition(unsigned long int k, unsigned int d = 0) const {\n    return this-&gt;TransformPoint(m_Positions[d]-&gt;operator[](k), m_Transforms[d] * m_PrefixTransforms[d]);\n  }\n  PointType GetPrefixTransformedPosition(unsigned long int k, unsigned int d = 0) const {\n    return this-&gt;TransformPoint(m_Positions[d]-&gt;operator[](k), m_PrefixTransforms[d]);\n  }\n\n  void SplitAllParticles(double epsilon);\n  void SplitParticle(double epsilon, unsigned int idx, unsigned int d = 0);\n  void AdvancedAllParticleSplitting(double epsilon, unsigned int domains_per_shape, unsigned int dom_to_process);\n  // Debug function\n  void PrintParticleSystem();\n\n  std::shared_ptr&lt;ParticleNeighborhood&gt; GetNeighborhood(unsigned int k) const { return m_Neighborhoods[k]; }\n\n  using PointVectorType = std::vector&lt;ParticlePointIndexPair&gt;;\n\n  PointVectorType FindNeighborhoodPoints(const PointType &amp;p, int idx, double r, unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(p, idx, r);\n  }\n  inline PointVectorType FindNeighborhoodPoints(const PointType &amp;p, int idx, std::vector&lt;double&gt; &amp;w,\n                                                std::vector&lt;double&gt; &amp;distances, double r, unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(p, idx, w, distances, r);\n  }\n  inline PointVectorType FindNeighborhoodPoints(const PointType &amp;p, int idx, std::vector&lt;double&gt; &amp;w, double r,\n                                                unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(p, idx, w, r);\n  }\n  inline PointVectorType FindNeighborhoodPoints(unsigned int idx, double r, unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(GetPosition(idx, d), idx, r);\n  }\n  inline PointVectorType FindNeighborhoodPoints(unsigned int idx, std::vector&lt;double&gt; &amp;w,\n                                                std::vector&lt;double&gt; &amp;distances, double r, unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(GetPosition(idx, d), idx, w, distances, r);\n  }\n  inline PointVectorType FindNeighborhoodPoints(unsigned int idx, std::vector&lt;double&gt; &amp;w, double r,\n                                                unsigned int d = 0) const {\n    return m_Neighborhoods[d]-&gt;find_neighborhood_points(GetPosition(idx, d), idx, w, r);\n  }\n\n  //  inline int FindNeighborhoodPoints(const PointType &amp;p,  double r, PointVectorType &amp;vec, unsigned int d = 0) const\n  //  {  return m_Neighborhoods[d]-&gt;FindNeighborhoodPoints(p, r, vec); }\n\n  //   PointVectorType FindTransformedNeighborhoodPoints(const PointType &amp;p, double r, unsigned int d = 0) const\n  //   {\n  //     PointVectorType ans = m_Neighborhoods[d]\n  //       -&gt;FindNeighborhoodPoints(this-&gt;TransformPoint(p, InverseTransform[d]), r);\n  //     for (unsigned int i = 0; i &lt; ans.size(); i++)\n  //       {\n  //       ans.Point[i] = this-&gt;TransformPoint(ans.Point[i], m_Transform[d]);\n  //       }\n  //     return ans;\n  //   }\n\n  void AddDomain(DomainType::Pointer input);\n\n  std::vector&lt;DomainType::Pointer&gt;::const_iterator GetDomainsBegin() const { return m_Domains.begin(); }\n\n  std::vector&lt;DomainType::Pointer&gt;::const_iterator GetDomainsEnd() const { return m_Domains.end(); }\n\n  DomainType *GetDomain(unsigned int i) { return m_Domains[i].get(); }\n\n  DomainType *GetDomain() { return m_Domains[0].get(); }\n\n  const DomainType *GetDomain(unsigned int i) const { return m_Domains[i].get(); }\n\n  const DomainType *GetDomain() const { return m_Domains[0].get(); }\n\n  unsigned int GetNumberOfDomains() const { return m_Domains.size(); }\n\n  void SetTransform(unsigned int i, const TransformType &amp;);\n  void SetTransform(const TransformType &amp;p) { this-&gt;SetTransform(0, p); }\n  void SetPrefixTransform(unsigned int i, const TransformType &amp;);\n  void SetPrefixTransform(const TransformType &amp;p) { this-&gt;SetPrefixTransform(0, p); }\n\n  std::vector&lt;TransformType&gt;::const_iterator GetTransformsBegin() const { return m_Transforms.begin(); }\n\n  std::vector&lt;TransformType&gt;::const_iterator GetTransformsEnd() const { return m_Transforms.end(); }\n\n  const TransformType &amp;GetTransform(unsigned int i) const { return m_Transforms[i]; }\n\n  const TransformType &amp;GetTransform() const { return m_Transforms[0]; }\n\n  TransformType GetTransform(unsigned int i) { return m_Transforms[i]; }\n\n  TransformType GetTransform() { return m_Transforms[0]; }\n\n  const TransformType &amp;GetPrefixTransform(unsigned int i) const { return m_PrefixTransforms[i]; }\n\n  const TransformType &amp;GetPrefixTransform() const { return m_PrefixTransforms[0]; }\n\n  TransformType GetPrefixTransform(unsigned int i) { return m_PrefixTransforms[i]; }\n\n  TransformType GetPrefixTransform() { return m_PrefixTransforms[0]; }\n\n  std::vector&lt;TransformType&gt;::const_iterator GetInverseTransformsBegin() const { return m_InverseTransforms.begin(); }\n\n  std::vector&lt;TransformType&gt;::const_iterator GetInverseTransformsEnd() const { return m_InverseTransforms.end(); }\n\n  const TransformType &amp;GetInverseTransform(unsigned int i) const { return m_InverseTransforms[i]; }\n\n  const TransformType &amp;GetInverseTransform() const { return m_InverseTransforms[0]; }\n\n  const TransformType &amp;GetInversePrefixTransform(unsigned int i) const { return m_InversePrefixTransforms[i]; }\n\n  const TransformType &amp;GetInversePrefixTransform() const { return m_InversePrefixTransforms[0]; }\n\n  const std::vector&lt;PointContainerType::Pointer&gt; &amp;GetPositions() const { return m_Positions; }\n  const PointContainerType::Pointer &amp;GetPositions(unsigned int d) const { return m_Positions[d]; }\n\n  void AddPositionList(const std::vector&lt;PointType&gt; &amp;, unsigned int d = 0);\n\n  PointType TransformPoint(const PointType &amp;, const TransformType &amp;) const;\n\n  VectorType TransformVector(const VectorType &amp;, const TransformType &amp;) const;\n\n  VnlMatrixType TransformNormalDerivative(const VnlMatrixType &amp;, const TransformType &amp;) const;\n\n  inline TransformType InvertTransform(const TransformType &amp;T) const {\n    // Note, vnl_inverse is optimized for small matrices 1x1 - 4x4\n    return vnl_inverse(T);\n  }\n\n  void FlagDomain(unsigned int i) {\n    // ensure large enough\n    while (i &gt;= this-&gt;m_DomainFlags.size()) {\n      m_DomainFlags.push_back(false);\n    }\n\n    // set the flag\n    m_DomainFlags[i] = true;\n  }\n  void UnflagDomain(unsigned int i) { m_DomainFlags[i] = false; }\n  bool GetDomainFlag(unsigned int i) const {\n    if (i &gt;= m_DomainFlags.size()) {\n      // not set\n      return false;\n    }\n    return m_DomainFlags[i];\n  }\n  const std::vector&lt;bool&gt; &amp;GetDomainFlags() const { return m_DomainFlags; }\n  void SetDomainFlags() {\n    for (unsigned int i = 0; i &lt; m_DomainFlags.size(); i++) {\n      m_DomainFlags[i] = true;\n    }\n  }\n  void ResetDomainFlags() {\n    for (unsigned int i = 0; i &lt; m_DomainFlags.size(); i++) {\n      m_DomainFlags[i] = false;\n    }\n  }\n\n  void SetFixedParticleFlag(unsigned int d, unsigned int i) { m_FixedParticleFlags[d][i] = true; }\n  void ResetFixedParticleFlag(unsigned int d, unsigned int i) { m_FixedParticleFlags[d][i] = false; }\n  bool GetFixedParticleFlag(unsigned int d, unsigned int i) const { return m_FixedParticleFlags[d][i]; }\n  void ResetFixedParticleFlags() {\n    for (unsigned d = 0; d &lt; m_FixedParticleFlags.size(); d++) {\n      for (unsigned int i = 0; i &lt; m_FixedParticleFlags[d].size(); i++) m_FixedParticleFlags[d][i] = false;\n    }\n  }\n\n  void SetDomainsPerShape(unsigned int num) {\n    m_DomainsPerShape = num;\n    m_FixedParticleFlags.resize(m_DomainsPerShape);\n  }\n  unsigned int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  void SetNumberOfDomains(unsigned int);\n\n  // Returns the maximum distance between nearest neighbors in domain dom\n  double ComputeMaxDistNearestNeighbors(size_t dom);\n\n  void SetFieldAttributes(const std::vector&lt;std::string&gt; &amp;field_attributes) { m_FieldAttributes = field_attributes; }\n\n  const std::vector&lt;std::string&gt; &amp;GetFieldAttributes() const { return m_FieldAttributes; }\n\n protected:\n  ParticleSystem();\n  void PrintSelf(std::ostream &amp;os, itk::Indent indent) const;\n  virtual ~ParticleSystem(){};\n\n  TransformType &amp;GetInverseTransform(unsigned int i) { return m_InverseTransforms[i]; }\n\n  TransformType &amp;GetInverseTransform() { return m_InverseTransforms[0]; }\n\n  TransformType &amp;GetInversePrefixTransform(unsigned int i) { return m_InversePrefixTransforms[i]; }\n\n  TransformType &amp;GetInversePrefixTransform() { return m_InversePrefixTransforms[0]; }\n\n private:\n  ParticleSystem(const Self &amp;);  // purposely not implemented\n  void operator=(const Self &amp;);  // purposely not implemented\n\n  std::vector&lt;PointContainerType::Pointer&gt; m_Positions;\n\n  std::vector&lt;DomainType::Pointer&gt; m_Domains;\n\n  unsigned int m_DomainsPerShape;\n\n  std::vector&lt;std::shared_ptr&lt;ParticleNeighborhood&gt;&gt; m_Neighborhoods;\n\n  std::vector&lt;TransformType&gt; m_Transforms;\n\n  std::vector&lt;TransformType&gt; m_InverseTransforms;\n\n  std::vector&lt;TransformType&gt; m_PrefixTransforms;\n\n  std::vector&lt;TransformType&gt; m_InversePrefixTransforms;\n\n  std::vector&lt;unsigned long int&gt; m_IndexCounters;\n\n  std::vector&lt;bool&gt; m_DomainFlags;\n\n  std::vector&lt;std::vector&lt;bool&gt;&gt; m_FixedParticleFlags;\n\n  std::vector&lt;std::string&gt; m_FieldAttributes;\n\n  std::mt19937 m_rand{42};\n};\n\n}  // end namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Particles_8h.html","title":"Libs/Analyze/Particles.h","text":""},{"location":"api/Files/Particles_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Particles_8h.html#classes","title":"Classes","text":"Name class shapeworks::Particles Representation of correspondence points for a shape including multiple domains."},{"location":"api/Files/Particles_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkPoint.h&gt;\n#include &lt;vnl/vnl_vector.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\n#include \"Shapeworks.h\"\n\nclass vtkTransform;\n\nnamespace shapeworks {\n\n\nclass Particles {\n public:\n  Particles() = default;\n\n  void set_local_particles(int domain, const std::vector&lt;itk::Point&lt;double&gt;&gt;&amp; particles);\n  void set_world_particles(int domain, const std::vector&lt;itk::Point&lt;double&gt;&gt;&amp; particles);\n\n  void set_local_particles(int domain, Eigen::VectorXd particles);\n  void set_world_particles(int domain, Eigen::VectorXd particles);\n\n  std::vector&lt;Eigen::VectorXd&gt; get_local_particles() const; // one Eigen::VectorXd per domain\n  std::vector&lt;Eigen::VectorXd&gt; get_world_particles() const; // one Eigen::VectorXd per domain\n\n  Eigen::VectorXd get_local_particles(int domain);\n  Eigen::VectorXd get_world_particles(int domain);\n  Eigen::VectorXd get_raw_world_particles(int domain);\n\n  Eigen::VectorXd get_combined_local_particles() const;\n  Eigen::VectorXd get_combined_global_particles() const;\n  void set_combined_global_particles(const Eigen::VectorXd &amp;particles);\n\n  std::vector&lt;itk::Point&lt;double&gt;&gt; get_local_points(int domain);\n  std::vector&lt;itk::Point&lt;double&gt;&gt; get_world_points(int domain);\n\n  int get_domain_for_combined_id(int id);\n\n  void set_transform(vtkSmartPointer&lt;vtkTransform&gt; transform);\n  void set_procrustes_transforms(const std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt;&amp; transforms);\n  void set_alignment_type(int alignment);\n\n  Eigen::VectorXd get_difference_vectors(const Particles&amp; other) const;\n\n  static void save_particles_file(std::string filename, const Eigen::VectorXd&amp; points);\n\n  int get_number_of_domains();\n\n  int get_total_number_of_particles();\n\n private:\n  void transform_global_particles();\n\n  std::vector&lt;itk::Point&lt;double&gt;&gt; eigen_to_point_vector(const Eigen::VectorXd&amp; particles) const;\n\n  Eigen::VectorXd combine(const std::vector&lt;Eigen::VectorXd&gt;&amp; particles) const;\n\n  void set_particles(int domain, std::vector&lt;itk::Point&lt;double&gt;&gt; particles, bool local);\n  std::vector&lt;Eigen::VectorXd&gt; local_particles_;               // one for each domain\n  std::vector&lt;Eigen::VectorXd&gt; global_particles_;              // one for each domain\n  std::vector&lt;Eigen::VectorXd&gt; transformed_global_particles_;  // one for each domain\n\n  vtkSmartPointer&lt;vtkTransform&gt; transform_;\n  std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt; procrustes_transforms_;\n  int alignment_type_ = -3;  // not a valid value\n\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/PlaneConstraint_8h.html","title":"Libs/Optimize/Constraints/PlaneConstraint.h","text":""},{"location":"api/Files/PlaneConstraint_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PlaneConstraint_8h.html#classes","title":"Classes","text":"Name class shapeworks::PlaneConstraint"},{"location":"api/Files/PlaneConstraint_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;vector&gt;\n\n#include \"Libs/Optimize/Constraints/Constraint.h\"\n\nclass vtkPlane;\n\nnamespace shapeworks {\n\nclass PlaneConstraint : public Constraint {\n public:\n  bool isViolated(const Eigen::Vector3d &amp;pt) const override;\n\n  void print() const override;\n\n  Eigen::Vector3d getPlaneNormal() { return planeNormal_; }\n\n  void setPlaneNormal(const Eigen::Vector3d &amp;inPlane) { planeNormal_ = inPlane; }\n\n  Eigen::Vector3d getPlanePoint() { return planePoint_; }\n  void setPlanePoint(const vnl_vector&lt;double&gt; &amp;point) { planePoint_ = Eigen::Vector3d(point[0], point[1], point[2]); }\n  void setPlanePoint(const Eigen::Vector3d &amp;p) { planePoint_ = p; }\n\n  Eigen::Vector3d constraintGradient(const Eigen::Vector3d &amp;pt) const override { return -planeNormal_; }\n\n  std::vector&lt;Eigen::Vector3d&gt; &amp;points() { return points_; };\n  double getOffset();\n  void setOffset(double offset);\n\n  double constraintEval(const Eigen::Vector3d &amp;pt) const override;\n\n  void updatePlaneFromPoints();\n\n  vtkSmartPointer&lt;vtkPlane&gt; getVTKPlane();\n\n private:\n  Eigen::Vector3d planeNormal_;\n  Eigen::Vector3d planePoint_;\n\n  std::vector&lt;Eigen::Vector3d&gt; points_;\n  double offset_ = 0;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PlaneWidget_8h.html","title":"Studio/Visualization/PlaneWidget.h","text":""},{"location":"api/Files/PlaneWidget_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PlaneWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::PlaneWidget PlaneWidget."},{"location":"api/Files/PlaneWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#include &lt;Libs/Optimize/Constraints/PlaneConstraint.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;vector&gt;\n\nclass vtkHandleWidget;\nclass vtkSphereSource;\nclass vtkPlaneSource;\nclass vtkPolyDataMapper;\nclass vtkActor;\n\nnamespace shapeworks {\n\nclass Viewer;\nclass PlaneCallback;\nclass StudioHandleWidget;\n\n\nclass PlaneWidget {\n public:\n  PlaneWidget(Viewer* viewer);\n  ~PlaneWidget();\n\n  void update();\n\n  void store_positions();\n\n  void update_glyph_properties();\n\n  void clear_planes();\n\n  void handle_right_click(int domain, int plane, int point);\n\n  void delete_plane(int domain, int plane_id);\n\n  void flip_plane(int domain, int plane_id);\n\n  void apply_plane(int domain, int plane_id);\n\n  void set_plane_offset(int domain, int plane_id, int offset);\n\n  void finalize_plane_offset(int domain, int plane_id);\n\n private:\n  void update_plane_points();\n  void update_planes();\n\n  vtkSmartPointer&lt;StudioHandleWidget&gt; create_handle();\n\n  void assign_handle_to_domain(vtkSmartPointer&lt;StudioHandleWidget&gt; handle, int domain_id);\n\n  int count_plane_points();\n  int count_complete_planes();\n\n  PlaneConstraint&amp; get_plane_reference(int domain, int plane);\n\n  double get_offset_scale(int domain_id);\n\n  bool block_update_ = false;\n\n  Viewer* viewer_ = nullptr;\n\n  // control points\n  vtkSmartPointer&lt;vtkSphereSource&gt; sphere_;\n  std::vector&lt;vtkSmartPointer&lt;StudioHandleWidget&gt;&gt; handles_;\n\n  // planes\n  std::vector&lt;vtkSmartPointer&lt;vtkPlaneSource&gt;&gt; plane_sources_;\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyDataMapper&gt;&gt; plane_mappers_;\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; plane_actors_;\n\n  vtkSmartPointer&lt;PlaneCallback&gt; callback_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PlatformUtils_8h.html","title":"Libs/Utils/PlatformUtils.h","text":""},{"location":"api/Files/PlatformUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PlatformUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::PlatformUtils Platform utility functions."},{"location":"api/Files/PlatformUtils_8h.html#source-code","title":"Source code","text":"<pre><code>namespace shapeworks {\n\nclass PlatformUtils {\n public:\n  static bool is_windows() {\n#ifdef _WIN32\n    return true;\n#endif\n    return false;\n  }\n\n  static bool is_linux() {\n#ifdef __linux__\n    return true;\n#endif\n    return false;\n  }\n\n  static bool is_macos() {\n#ifdef __APPLE__\n    return true;\n#endif\n    return false;\n  }\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PreferencesWindow_8h.html","title":"Studio/Data/PreferencesWindow.h","text":""},{"location":"api/Files/PreferencesWindow_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PreferencesWindow_8h.html#classes","title":"Classes","text":"Name class shapeworks::PreferencesWindow Qt UI dialog to control preferences."},{"location":"api/Files/PreferencesWindow_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QDialog&gt;\n\n#include \"Data/Preferences.h\"\n\nclass Ui_PreferencesWindow;\nclass QAbstractButton;\n\nnamespace shapeworks {\n\n\n\n\nclass PreferencesWindow : public QDialog {\n  Q_OBJECT\n\n public:\n  PreferencesWindow(QWidget* parent, Preferences&amp; prefs);\n\n  void set_values_from_preferences();\n\n  void closeEvent(QCloseEvent* event) override;\n\n public Q_SLOTS:\n  void on_mesh_cache_enabled_stateChanged(int state);\n  void on_mesh_cache_memory_valueChanged(int value);\n  void on_color_scheme_currentIndexChanged(int index);\n  void on_pca_range_valueChanged(double value);\n  void on_pca_steps_valueChanged(int value);\n  void on_parallel_enabled_toggled(bool b);\n  void on_num_threads_valueChanged(int i);\n\n  void accept() override;\n\n  void restore_defaults();\n\n  void save_to_preferences();\n\n Q_SIGNALS:\n  void clear_cache();\n  void update_view();\n  void slider_update();\n\n private:\n  void update_labels();\n  Preferences&amp; preferences_;\n  Ui_PreferencesWindow* ui_;\n};\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Preferences_8h.html","title":"Studio/Data/Preferences.h","text":""},{"location":"api/Files/Preferences_8h.html#classes","title":"Classes","text":"Name class Preferences Application preferences."},{"location":"api/Files/Preferences_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QSettings&gt;\n#include &lt;QString&gt;\n\n\nclass Preferences : public QObject {\n  Q_OBJECT;\n\n public:\n  enum OrientationMarkerType { medical = 0, triad = 1, none = 2 };\n\n  enum OrientationMarkerCorner { upper_right = 0, lower_right = 1, lower_left = 2, upper_left = 3 };\n\n  Preferences();\n\n  enum { MAX_RECENT_FILES = 64 };\n\n  void restore_defaults();\n\n  void add_recent_file(QString file, QString path);\n  QStringList get_recent_files();\n  QStringList get_recent_paths();\n\n  QByteArray get_window_geometry();\n  void set_window_geometry(QByteArray geometry);\n\n  QByteArray get_window_state();\n  void set_window_state(QByteArray state);\n\n  QString get_last_directory();\n  void set_last_directory(QString value);\n\n  bool get_cache_enabled();\n  void set_cache_enabled(bool value);\n\n  bool get_parallel_enabled();\n  void set_parallel_enabled(bool value);\n\n  int get_memory_cache_percent();\n  void set_memory_cache_percent(int value);\n\n  int get_num_threads();\n  void set_num_threads(int num_threads);\n\n  int get_dataloader_num_workers();\n  void set_dataloader_num_workers(int num_workers);\n\n  float get_glyph_size();\n  void set_glyph_size(float value);\n\n  float get_glyph_quality();\n  void set_glyph_quality(float value);\n\n  bool get_glyph_auto_size();\n  void set_glyph_auto_size(bool value);\n\n  bool get_glyph_scale_arrows();\n  void set_glyph_scale_arrows(bool value);\n\n  float get_pca_range();\n  void set_pca_range(float value);\n\n  int get_pca_steps();\n  void set_pca_steps(int value);\n\n  void set_color_scheme(int value);\n  int get_color_scheme();\n\n  void set_particle_colors(int value);\n  int get_particle_colors();\n\n  void set_color_map(int value);\n  int get_color_map();\n\n  void set_discrete_color_mode(bool value);\n  bool get_discrete_color_mode();\n\n  void set_reverse_color_map(bool value);\n  bool get_reverse_color_map();\n\n  bool get_center_checked();\n  void set_center_checked(bool value);\n\n  int get_geodesic_cache_multiplier();\n  void set_geodesic_cache_multiplier(int value);\n\n  OrientationMarkerType get_orientation_marker_type();\n  void set_orientation_marker_type(OrientationMarkerType type);\n\n  OrientationMarkerCorner get_orientation_marker_corner();\n  void set_orientation_marker_corner(OrientationMarkerCorner corner);\n\n  QString get_groom_file_template();\n  void set_groom_file_template(QString groom_file_template);\n\n  QString get_optimize_file_template();\n  void set_optimize_file_template(QString optimize_file_template);\n\n  QSize get_export_override_size();\n  void set_export_override_size(QSize size);\n  bool get_export_override_size_enabled();\n  void set_export_override_size_enabled(bool enabled);\n  bool get_export_show_orientation_marker();\n  void set_export_show_orientation_marker(bool value);\n  bool get_export_show_color_scale();\n  void set_export_show_color_scale(bool value);\n  int get_export_num_pca_images();\n  void set_export_num_pca_images(int number);\n  double get_export_pca_range();\n  void set_export_pca_range(double range);\n  void set_export_pca_modes(QString string);\n  QString get_export_pca_modes();\n\n  bool get_auto_update_check();\n  void set_auto_update_check(bool enabled);\n\n  QDateTime get_update_snooze_until();\n  void set_update_snooze_until(QDateTime date);\n\n  QString get_device_id();\n\n  bool get_telemetry_enabled();\n  void set_telemetry_enabled(bool enabled);\n\n  bool get_telemetry_asked();\n  void set_telemetry_asked(bool asked);\n\n  QStringList get_pending_telemetry_events();\n  void set_pending_telemetry_events(QStringList events);\n\n Q_SIGNALS:\n\n  void color_scheme_changed(int newIndex);\n  void glyph_properties_changed();\n  void threading_changed_signal();\n  void sliders_changed_signal();\n\n private:\n  void update_recent_files();\n  void update_threads();\n  QStringList recent_files_;\n  QStringList recent_paths_;\n\n  QSettings settings_;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Procrustes3D_8h.html","title":"Libs/Alignment/Procrustes3D.h","text":""},{"location":"api/Files/Procrustes3D_8h.html#classes","title":"Classes","text":"Name struct SimilarityTransform3D class Procrustes3D"},{"location":"api/Files/Procrustes3D_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vnl/vnl_matrix.h&gt;\n#include &lt;vnl/vnl_matrix_fixed.h&gt;\n#include &lt;vnl/vnl_vector_fixed.h&gt;\n\n#include &lt;vector&gt;\n\nstruct SimilarityTransform3D {\n  vnl_matrix_fixed&lt;double, 3, 3&gt; rotation;\n  double scale;\n  vnl_vector_fixed&lt;double, 3&gt; translation;\n};\n\nclass Procrustes3D {\n public:\n  typedef double RealType;\n  typedef vnl_vector_fixed&lt;double, 3&gt; PointType;\n  typedef std::vector&lt;PointType&gt; ShapeType;\n  typedef ShapeType::iterator ShapeIteratorType;\n\n  typedef std::vector&lt;ShapeType&gt; ShapeListType;\n  typedef ShapeListType::iterator ShapeListIteratorType;\n\n  typedef std::vector&lt;SimilarityTransform3D&gt; SimilarityTransformListType;\n  typedef SimilarityTransformListType::iterator SimilarityTransformListIteratorType;\n\n  typedef vnl_matrix_fixed&lt;double, 3 + 1, 3 + 1&gt; TransformMatrixType;\n  typedef std::vector&lt;TransformMatrixType&gt; TransformMatrixListType;\n  typedef TransformMatrixListType::iterator TransformMatrixIteratorType;\n\n public:\n  Procrustes3D() : m_Scaling(true), m_RotationTranslation(true) {}\n  Procrustes3D(bool do_scaling, bool do_rotation_translation)\n      : m_Scaling(do_scaling), m_RotationTranslation(do_rotation_translation) {}\n\n  bool GetScaling() const { return m_Scaling; }\n  void ScalingOn() { m_Scaling = true; }\n  void ScalingOff() { m_Scaling = false; }\n\n  bool GetRotationTranslation() const { return m_RotationTranslation; }\n  void RotationTranslationOn() { m_RotationTranslation = true; }\n  void RotationTranslationOff() { m_RotationTranslation = false; }\n\n  // Align a list of shapes using Generalized Procrustes Analysis\n  void AlignShapes(SimilarityTransformListType&amp; transforms, ShapeListType&amp; shapes);\n\n  void RemoveTranslation(SimilarityTransformListType&amp; transforms, ShapeListType&amp; shapes);\n\n  // Helper function to transform a shape by a similarity transform\n  static void TransformShape(ShapeType&amp; shape, SimilarityTransform3D&amp; transform);\n\n  // Helper function to transform a list of shapes by a list of transforms\n  static void TransformShapes(ShapeListType&amp; shapes, SimilarityTransformListType&amp; transforms);\n\n  static RealType ComputeSumOfSquares(ShapeListType&amp; shapes);\n\n  // Transform from Configuration space to Procrustes space.  Translation\n  // followed by rotation and scaling.\n  void ConstructTransformMatrices(SimilarityTransformListType&amp; transforms, TransformMatrixListType&amp; transformMatrices);\n  void ConstructTransformMatrix(SimilarityTransform3D&amp; transform, TransformMatrixType&amp; transformMatrix);\n\n  void ComputeMeanShape(ShapeType&amp; mean, ShapeListType&amp; shapeList);\n  void ComputeCenterOfMass(ShapeType&amp; shape, PointType&amp; center);\n  void CenterShape(ShapeType&amp; shape);\n\n  // this is the center which needed for translation of the shapes to coincide on the image origin\n  // so that the whole object is in the image and won't go outside\n  void ComputeCommonCenter(SimilarityTransformListType&amp; transforms, PointType&amp; center);\n\n  // Align source shape to target using Ordinary Procrustes Analysis (translation, scaling and rotation)\n  // the target shape is assumed to be centered at the origin\n  void AlignSourceToTarget(SimilarityTransform3D&amp; transform, ShapeType&amp; target, ShapeType&amp; source);\n\n  /* The median shape is\n       defined as the shape with the minimum sum of Euclidean L1 norms to all\n       other shapes in that group.  */\n  int ComputeMedianShape(ShapeListType&amp; shapeList);\n\n private:\n  // Align two shapes (rotation &amp; scale) using Ordinary Procrustes Analysis\n  void AlignTwoShapes(SimilarityTransform3D&amp; transform, ShapeType&amp; shape1, ShapeType&amp; shape2);\n\n  bool m_Scaling;              // a flag to factor out scaling\n  bool m_RotationTranslation;  // a flag for rotation + translation + (scale depending on m_Scaling), if false, the\n                               // transformation will only be scaling\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ProcrustesRegistration_8h.html","title":"Libs/Optimize/ProcrustesRegistration.h","text":""},{"location":"api/Files/ProcrustesRegistration_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ProcrustesRegistration_8h.html#classes","title":"Classes","text":"Name class shapeworks::ProcrustesRegistration"},{"location":"api/Files/ProcrustesRegistration_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"ParticleSystem.h\"\n#include \"vnl/vnl_matrix.h\"\n\nnamespace shapeworks {\nclass ProcrustesRegistration {\n public:\n  using Pointer = std::shared_ptr&lt;ProcrustesRegistration&gt;;\n\n  // Particle system typedefs\n  using ParticleSystemType = ParticleSystem;\n  using PointType = ParticleSystemType::PointType;\n\n  void SetParticleSystem(ParticleSystemType* p) { m_ParticleSystem = p; }\n  ParticleSystemType* GetParticleSystem() const { return m_ParticleSystem; }\n  ParticleSystemType* GetParticleSystem() { return m_ParticleSystem; }\n\n  void RunRegistration(int i);\n  void RunRegistration();\n\n  void SetDomainsPerShape(int i) { m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  bool GetScaling() const { return m_Scaling; }\n  void SetScaling(bool scaling) { m_Scaling = scaling; }\n\n  bool GetRotationTranslation() const { return m_RotationTranslation; }\n  void SetRotationTranslation(bool rotationTranslation) { m_RotationTranslation = rotationTranslation; }\n\n private:\n  int m_DomainsPerShape = 1;\n  bool m_Scaling = true;\n  bool m_RotationTranslation = true;\n  ParticleSystemType* m_ParticleSystem = nullptr;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Profiling_8h.html","title":"Libs/Common/Profiling.h","text":""},{"location":"api/Files/Profiling_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Profiling_8h.html#classes","title":"Classes","text":"Name struct shapeworks::ProfileEntry struct shapeworks::TraceEvent class shapeworks::TimerStackEntry class shapeworks::Profiler class shapeworks::ScopedTimer"},{"location":"api/Files/Profiling_8h.html#defines","title":"Defines","text":"Name TIME_START(name) TIME_STOP(name) TIME_SCOPE(name) TIME_FINALIZE()"},{"location":"api/Files/Profiling_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/Profiling_8h.html#define-time_start","title":"define TIME_START","text":"<pre><code>#define TIME_START(\n    name\n)\nshapeworks::Profiler::instance().start_timer(name);\n</code></pre>"},{"location":"api/Files/Profiling_8h.html#define-time_stop","title":"define TIME_STOP","text":"<pre><code>#define TIME_STOP(\n    name\n)\nshapeworks::Profiler::instance().stop_timer(name);\n</code></pre>"},{"location":"api/Files/Profiling_8h.html#define-time_scope","title":"define TIME_SCOPE","text":"<pre><code>#define TIME_SCOPE(\n    name\n)\nshapeworks::ScopedTimer _scoped_timer_##__LINE__(name)\n</code></pre>"},{"location":"api/Files/Profiling_8h.html#define-time_finalize","title":"define TIME_FINALIZE","text":"<pre><code>#define TIME_FINALIZE(\n\n)\nshapeworks::Profiler::instance().finalize()\n</code></pre>"},{"location":"api/Files/Profiling_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QElapsedTimer&gt;\n#include &lt;QMutex&gt;\n#include &lt;QString&gt;\n#include &lt;QThread&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\n//---------------------------------------------------------------------------\nstruct ProfileEntry {\n  QString name;\n  double exclusive_time_ms;\n  double inclusive_time_ms;\n  int call_count;\n  int subcall_count;\n  Qt::HANDLE thread_id;\n};\n\n//---------------------------------------------------------------------------\nstruct TraceEvent {\n  QString name;\n  QString phase;  // \"B\" for begin, \"E\" for end\n  qint64 timestamp_us;\n  Qt::HANDLE thread_id;\n  int process_id;\n};\n\n//---------------------------------------------------------------------------\nclass TimerStackEntry {\n public:\n  TimerStackEntry(const QString&amp; name, qint64 start_time_us);\n\n  QString name;\n  qint64 start_time_us;\n  double accumulated_child_time_ms;\n};\n\n//---------------------------------------------------------------------------\nclass Profiler {\n public:\n  static Profiler&amp; instance();\n\n  void start_timer(const QString&amp; name);\n  void stop_timer(const QString&amp; name);\n  void finalize();\n\n  bool is_profiling_enabled() const { return profiling_enabled_; }\n  bool is_tracing_enabled() const { return tracing_enabled_; }\n\n private:\n  Profiler();\n  ~Profiler();\n\n  void write_profile_report();\n  void write_trace_file();\n  QString format_time(double ms);\n\n  bool profiling_enabled_;\n  bool tracing_enabled_;\n  qint64 start_time_us_;\n\n  QMutex mutex_;\n  std::unordered_map&lt;Qt::HANDLE, std::vector&lt;std::unique_ptr&lt;TimerStackEntry&gt;&gt;&gt; timer_stacks_;\n  std::unordered_map&lt;QString, ProfileEntry&gt; profile_entries_;\n  std::vector&lt;TraceEvent&gt; trace_events_;\n\n  QElapsedTimer elapsed_timer_;\n};\n\n//---------------------------------------------------------------------------\nclass ScopedTimer {\n public:\n  ScopedTimer(const QString&amp; name);\n  ~ScopedTimer();\n\n private:\n  QString name_;\n  bool enabled_;\n};\n\n}  // namespace shapeworks\n\n// Profiling macros\n#define TIME_START(name) shapeworks::Profiler::instance().start_timer(name);\n#define TIME_STOP(name) shapeworks::Profiler::instance().stop_timer(name);\n#define TIME_SCOPE(name) shapeworks::ScopedTimer _scoped_timer_##__LINE__(name)\n#define TIME_FINALIZE() shapeworks::Profiler::instance().finalize()\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ProjectReader_8h.html","title":"Libs/Project/ProjectReader.h","text":""},{"location":"api/Files/ProjectReader_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ProjectReader_8h.html#classes","title":"Classes","text":"Name class shapeworks::ProjectReader Base class for Project readers."},{"location":"api/Files/ProjectReader_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Project.h\"\n#include \"ProjectUtils.h\"\n\nnamespace shapeworks {\n\n\nclass ProjectReader {\n public:\n  using StringMapList = project::types::StringMapList;\n  using StringMap = project::types::StringMap;\n  using StringList = project::types::StringList;\n  using StringMultiMap = project::types::StringMultiMap;\n\n  ProjectReader(Project &amp;project);\n\n  virtual ~ProjectReader() = default;\n\n  virtual bool read_project(std::string filename) = 0;\n\n  virtual StringMap get_parameters(std::string name) = 0;\n\n  virtual StringMultiMap get_multi_parameters(std::string name) = 0;\n\n protected:\n  void load_subjects(StringMapList list);\n\n  void load_parameters();\n\n  void load_parameter(std::string name, StringMap map);\n\n  void load_landmark_definitions(StringMapList list);\n\n  static StringList get_keys(StringMap map);\n\n  bool contains(StringMap map, std::string key);\n\n  Project &amp;project_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ProjectUtils_8h.html","title":"Libs/Project/ProjectUtils.h","text":""},{"location":"api/Files/ProjectUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry) shapeworks::project shapeworks::project::prefixes shapeworks::project::types"},{"location":"api/Files/ProjectUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::ProjectUtils"},{"location":"api/Files/ProjectUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// std\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// tsl\n#include &lt;ordered_map.h&gt;\n\n// vtk\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;vtkTransform.h&gt;\n\n// shapeworks\n#include &lt;Libs/Optimize/Domain/DomainType.h&gt;\n\nnamespace shapeworks {\n\nclass Project;\nclass Subject;\n\nnamespace project::prefixes {\nstatic constexpr const char* SEGMENTATION_PREFIX = \"segmentation_\";\nstatic constexpr const char* LANDMARKS_FILE_PREFIX = \"landmarks_file_\";\n\nstatic constexpr const char* SHAPE_PREFIX = \"shape_\";\nstatic constexpr const char* MESH_PREFIX = \"mesh_\";\nstatic constexpr const char* CONTOUR_PREFIX = \"contour_\";\n\nstatic constexpr const char* GROOMED_PREFIX = \"groomed_\";\nstatic constexpr const char* GROOMED_CONTOUR_PREFIX = \"groomed_contour_\";\n\nstatic constexpr const char* CONSTRAINTS_PREFIX = \"constraints_\";\n\nstatic constexpr const char* GROOMED_TRANSFORMS_PREFIX = \"alignment_\";\nstatic constexpr const char* PROCRUSTES_TRANSFORMS_PREFIX = \"procrustes_\";\nstatic constexpr const char* IMAGE_PREFIX = \"image_\";\nstatic constexpr const char* FEATURE_PREFIX = \"feature_\";\nstatic constexpr const char* GROUP_PREFIX = \"group_\";\n\nstatic constexpr const char* LOCAL_PARTICLES = \"local_particles\";\nstatic constexpr const char* WORLD_PARTICLES = \"world_particles\";\n\nstatic constexpr const char* LOCAL_PARTICLES_PREFIX = \"local_particles_\";\nstatic constexpr const char* WORLD_PARTICLES_PREFIX = \"world_particles_\";\n\n}  // namespace project::prefixes\n\nnamespace project::types {\nusing StringMap = tsl::ordered_map&lt;std::string, std::string&gt;;\nusing StringList = std::vector&lt;std::string&gt;;\nusing StringMapList = std::vector&lt;StringMap&gt;;\nusing StringMultiMap = std::map&lt;std::string, StringMap&gt;;\n}  // namespace project::types\n\nclass ProjectUtils {\n public:\n  using StringList = project::types::StringList;\n  using StringMap = project::types::StringMap;\n\n  static vtkSmartPointer&lt;vtkTransform&gt; convert_transform(std::vector&lt;double&gt; list);\n\n  static vtkSmartPointer&lt;vtkTransform&gt; convert_transform(std::string string);\n\n  static std::vector&lt;double&gt; convert_transform(vtkSmartPointer&lt;vtkTransform&gt; transform);\n\n  static StringList determine_domain_names(StringList keys);\n\n  static void determine_domain_types(Project* project, StringMap key_map);\n\n  static StringList get_input_prefixes();\n\n  static StringList get_groomed_prefixes();\n\n  static StringList get_original_keys(StringList domain_names, StringMap key_map);\n\n  static StringList get_values(StringList prefixes, StringList domain_names, StringMap key_map);\n\n  static std::vector&lt;std::vector&lt;double&gt;&gt; get_transforms(std::string prefix, StringList domain_names,\n                                                         StringMap key_map);\n\n  static StringMap get_value_map(std::vector&lt;std::string&gt; prefix, StringMap key_map);\n\n  static StringMap get_extra_columns(StringMap key_map);\n\n  static DomainType determine_domain_type(std::string filename);\n\n  static bool starts_with(std::string str, std::string prefix);\n\n  static std::string transform_to_string(std::vector&lt;double&gt; transform);\n\n  static std::vector&lt;std::string&gt; convert_domain_types(std::vector&lt;DomainType&gt; domain_types);\n  static std::vector&lt;std::string&gt; convert_groomed_domain_types(std::vector&lt;DomainType&gt; domain_types);\n\n  static StringMap convert_subject_to_map(Project* project, Subject* subject);\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Project_8h.html","title":"Libs/Project/Project.h","text":""},{"location":"api/Files/Project_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Project_8h.html#classes","title":"Classes","text":"Name class shapeworks::LandmarkDefinition Landmark class containing properties of each landmark. class shapeworks::Project Representation of a project."},{"location":"api/Files/Project_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Parameters.h\"\n#include \"Subject.h\"\n\nnamespace shapeworks {\n\nclass Project;\nusing ProjectHandle = std::shared_ptr&lt;Project&gt;;\n\nclass LandmarkDefinition {\n public:\n  std::string domain_;\n  int domain_id_ = -1;\n  int landmark_id = -1;\n  std::string name_;\n  bool visible_ = true;\n  std::string color_;\n  std::string comment_;\n};\n\n\nclass Project {\n public:\n  Project();\n  ~Project();\n\n  bool load(const std::string&amp; filename);\n\n  bool save(const std::string&amp; filename = \"\");\n\n  void set_project_path(const std::string&amp; path);\n\n  std::string get_project_path();\n\n  std::string get_filename();\n\n  void set_filename(std::string filename);\n\n  std::vector&lt;std::string&gt; get_headers();\n\n  std::vector&lt;std::string&gt; get_string_column(const std::string&amp; name) const;\n\n  int get_number_of_subjects();\n\n  int get_number_of_domains_per_subject();\n\n  std::vector&lt;std::string&gt; get_domain_names();\n\n  void set_domain_names(std::vector&lt;std::string&gt; domain_names);\n\n  std::vector&lt;std::shared_ptr&lt;Subject&gt;&gt;&amp; get_subjects();\n\n  std::vector&lt;std::shared_ptr&lt;Subject&gt;&gt; get_non_excluded_subjects();\n\n  void set_subjects(const std::vector&lt;std::shared_ptr&lt;Subject&gt;&gt;&amp; subjects);\n\n  void update_subjects();\n\n  bool get_originals_present() const;\n\n  bool get_groomed_present() const;\n\n  bool get_particles_present() const;\n\n  bool get_images_present();\n\n  bool get_fixed_subjects_present();\n\n  bool get_excluded_subjects_present();\n\n  std::vector&lt;std::string&gt; get_feature_names();\n\n  std::vector&lt;std::string&gt; get_image_names();\n\n  std::vector&lt;std::string&gt; get_group_names();\n\n  std::vector&lt;std::string&gt; get_group_values(const std::string&amp; group_name) const;\n\n  Parameters get_parameters(const std::string&amp; name, std::string domain_name = \"\");\n\n  std::map&lt;std::string, Parameters&gt; get_parameter_map(const std::string&amp; name);\n\n  void set_parameter_map(const std::string&amp; name, std::map&lt;std::string, Parameters&gt; map);\n\n  void set_parameters(const std::string&amp; name, Parameters params, std::string domain_name = \"\");\n\n  void clear_parameters(const std::string&amp; name);\n\n  int get_supported_version() const;\n\n  int get_version() const;\n\n  std::vector&lt;LandmarkDefinition&gt; get_landmarks(int domain_id);\n\n  std::vector&lt;std::vector&lt;LandmarkDefinition&gt;&gt; get_all_landmark_definitions();\n\n  void set_landmark_definitions(std::vector&lt;std::vector&lt;LandmarkDefinition&gt;&gt; defs);\n\n  bool get_landmarks_present();\n\n  void set_landmarks(int domain_id, std::vector&lt;LandmarkDefinition&gt; landmarks);\n\n  void new_landmark(int domain_id);\n\n  std::vector&lt;DomainType&gt; get_original_domain_types();\n\n  std::vector&lt;DomainType&gt; get_groomed_domain_types();\n\n  void set_original_domain_types(std::vector&lt;DomainType&gt; domain_types);\n\n  void set_groomed_domain_types(std::vector&lt;DomainType&gt; domain_types);\n\n private:\n  void set_default_landmark_colors();\n\n  void determine_feature_names();\n\n  std::string get_next_landmark_name(int domain_id);\n  std::string get_next_landmark_color(int domain_id);\n\n  std::vector&lt;std::shared_ptr&lt;Subject&gt;&gt; subjects_;\n\n  std::string filename_;\n  std::string project_path_;\n\n  std::vector&lt;std::string&gt; default_landmark_colors_;\n\n  bool originals_present_{false};\n  bool groomed_present_{false};\n  bool particles_present_{false};\n  bool images_present_{false};\n\n  std::vector&lt;std::string&gt; feature_names_;\n  std::vector&lt;std::string&gt; image_names_;\n\n  std::vector&lt;std::vector&lt;LandmarkDefinition&gt;&gt; landmark_definitions_;\n\n  std::vector&lt;std::string&gt; domain_names_;\n  std::vector&lt;DomainType&gt; original_domain_types_;\n  std::vector&lt;DomainType&gt; groomed_domain_types_;\n\n  // map of type (e.g. groom, optimize) to map (domain-&gt;Parameters)\n  std::map&lt;std::string, std::map&lt;std::string, Parameters&gt;&gt; parameters_;\n\n  static constexpr int supported_version_{2};\n  int version_{2};\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PythonAnalyze_8h.html","title":"Libs/Python/PythonAnalyze.h","text":""},{"location":"api/Files/PythonAnalyze_8h.html#functions","title":"Functions","text":"Name void define_python_analyze(pybind11::module_ m)"},{"location":"api/Files/PythonAnalyze_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/PythonAnalyze_8h.html#function-define_python_analyze","title":"function define_python_analyze","text":"<pre><code>void define_python_analyze(\n    pybind11::module_ m\n)\n</code></pre>"},{"location":"api/Files/PythonAnalyze_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;pybind11/pybind11.h&gt;\n\nvoid define_python_analyze(pybind11::module_ m);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PythonGroom_8h.html","title":"Libs/Python/PythonGroom.h","text":""},{"location":"api/Files/PythonGroom_8h.html#functions","title":"Functions","text":"Name void define_python_groom(pybind11::module_ m)"},{"location":"api/Files/PythonGroom_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/PythonGroom_8h.html#function-define_python_groom","title":"function define_python_groom","text":"<pre><code>void define_python_groom(\n    pybind11::module_ m\n)\n</code></pre>"},{"location":"api/Files/PythonGroom_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;pybind11/pybind11.h&gt;\n\nvoid define_python_groom(pybind11::module_ m);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/PythonWorker_8h.html","title":"Libs/Application/Job/PythonWorker.h","text":""},{"location":"api/Files/PythonWorker_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/PythonWorker_8h.html#classes","title":"Classes","text":"Name class shapeworks::PythonWorker"},{"location":"api/Files/PythonWorker_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// qt\n#include &lt;QObject&gt;\n#include &lt;QSharedPointer&gt;\n\n// vtk\n#include &lt;vtkSmartPointer.h&gt;\n\n// studio\n#include &lt;Job/Job.h&gt;\n#include &lt;Libs/Application/ShapeWorksVtkOutputWindow.h&gt;\n\nnamespace shapeworks {\nclass PythonLogger;\n\nclass PythonWorker : public QObject {\n  Q_OBJECT\n\n public:\n  constexpr static const char* python_api_version = \"6.7\";\n\n  PythonWorker();\n  ~PythonWorker();\n\n  void set_vtk_output_window(vtkSmartPointer&lt;ShapeWorksVtkOutputWindow&gt; output_window);\n  void set_cli_mode(bool cli_mode);\n\n  void run_job(QSharedPointer&lt;Job&gt; job);\n  void set_current_job(QSharedPointer&lt;Job&gt; job);\n\n  void incoming_python_message(std::string message_string);\n  void incoming_python_progress(double value, std::string message);\n\n  void end_python();\n\n  void abort_job();\n\n public Q_SLOTS:\n\n  bool init();\n\n  void start_job(QSharedPointer&lt;Job&gt; job);\n\n  void finalize_python();\n\n Q_SIGNALS:\n\n  void result_ready();\n  void finished();\n\n private:\n  bool initialized_ = false;\n  bool initialized_success_ = false;\n\n  vtkSmartPointer&lt;ShapeWorksVtkOutputWindow&gt; studio_vtk_output_window_;\n\n  QSharedPointer&lt;PythonLogger&gt; python_logger_;\n\n  QSharedPointer&lt;Job&gt; current_job_;\n\n  QThread* thread_{nullptr};\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/QMeshWarper_8h.html","title":"Libs/Analyze/QMeshWarper.h","text":""},{"location":"api/Files/QMeshWarper_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/QMeshWarper_8h.html#classes","title":"Classes","text":"Name class shapeworks::QMeshWarper Wraps MeshWarper as a QObject."},{"location":"api/Files/QMeshWarper_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Mesh/MeshWarper.h&gt;\n#include &lt;QObject&gt;\n#include &lt;QMutex&gt;\n#include &lt;QElapsedTimer&gt;\n\nnamespace shapeworks {\n\nclass QMeshWarper : public QObject, public MeshWarper {\nQ_OBJECT;\n\npublic:\n  QMeshWarper(QObject* parent = nullptr);\n\n  float get_progress();\n\nprotected:\n\n  void update_progress(float p) override;\n\nQ_SIGNALS:\n  void progress();\n\nprivate:\n  float current_progress_ = 0;\n};\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/QOptimize_8h.html","title":"Studio/Optimize/QOptimize.h","text":""},{"location":"api/Files/QOptimize_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/QOptimize_8h.html#classes","title":"Classes","text":"Name class shapeworks::QOptimize Wraps Optimize as a QObject."},{"location":"api/Files/QOptimize_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#ifndef Q_MOC_RUN\n#include &lt;Analyze/Particles.h&gt;\n#include &lt;Optimize/Optimize.h&gt;\n#endif\n#include &lt;QElapsedTimer&gt;\n#include &lt;QMutex&gt;\n#include &lt;QObject&gt;\n\nnamespace shapeworks {\n\nclass QOptimize : public QObject, public Optimize {\n  Q_OBJECT;\n\n public:\n  QOptimize(QObject* parent = nullptr);\n  virtual ~QOptimize();\n\n  std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; GetLocalPoints() override;\n  std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; GetGlobalPoints() override;\n\n  std::vector&lt;Particles&gt; GetParticles();\n\n  std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt; GetProcrustesTransforms() override;\n\n  void UpdateExportablePoints() override;\n\n protected:\n  virtual void SetIterationCallback() override;\n  void IterateCallbackInternal();\n\n Q_SIGNALS:\n  void progress(int, QString);\n\n private:\n  // for concurrent access\n  QMutex qmutex_;\n\n  QElapsedTimer time_since_last_update_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ReconstructSurface_8h.html","title":"Libs/Particles/ReconstructSurface.h","text":""},{"location":"api/Files/ReconstructSurface_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ReconstructSurface_8h.html#classes","title":"Classes","text":"Name class shapeworks::ReconstructSurface"},{"location":"api/Files/ReconstructSurface_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Libs/Alignment/Transforms/itkThinPlateSplineKernelTransform2.h\"\n#include \"Libs/Alignment/Transforms/itkCompactlySupportedRBFSparseKernelTransform.h\"\n#include \"Mesh.h\"\n\n#include &lt;itkPointSet.h&gt;\n\nnamespace shapeworks {\n\nusing ThinPlateSplineTransform = itk::ThinPlateSplineKernelTransform2&lt;double, 3&gt;;\nusing RBFSSparseTransform      = itk::CompactlySupportedRBFSparseKernelTransform&lt;double, 3&gt;;\n\ntemplate&lt;class TransformType&gt;\nclass ReconstructSurface\n{\npublic:\n  using TransformTypePtr = typename TransformType::Pointer;\n  using PointSetType = typename TransformType::PointSetType;\n  using PointIdType = typename PointSetType::PointIdentifier;\n\n  ReconstructSurface() = default;\n  ReconstructSurface(const std::string &amp;denseFile, const std::string &amp;sparseFile, const std::string &amp;goodPointsFile);\n\n  double computeAverageDistanceToNeighbors(vtkSmartPointer&lt;vtkPoints&gt; points, std::vector&lt;int&gt; particlesIndices);\n\n  void checkMapping(TransformTypePtr transform, vtkSmartPointer&lt;vtkPoints&gt; sourcePoints, vtkSmartPointer&lt;vtkPoints&gt; targetPoints);\n\n  void generateWarpedMeshes(TransformTypePtr transform, vtkSmartPointer&lt;vtkPolyData&gt;&amp; outputMesh);\n\n  Mesh getMesh(PointArray localPoints);\n\n  vtkSmartPointer&lt;vtkPoints&gt; convertToImageCoordinates(vtkSmartPointer&lt;vtkPoints&gt; particles, const Vector&amp; spacing, const Point3&amp; origin);\n\n  int computeMedianShape(std::vector&lt;Eigen::MatrixXd&gt;&amp; shapeList);\n\n  void performKMeansClustering(std::vector&lt;PointArray&gt; worldPoints, int numberOfParticles, std::vector&lt;int&gt;&amp; centroidIndices);\n\n  Eigen::MatrixXd computeParticlesNormals(vtkSmartPointer&lt;vtkPoints&gt; particles, Image dt);\n\n  vtkSmartPointer&lt;vtkPolyData&gt; getDenseMean(std::vector&lt;PointArray&gt; localPoints,\n                                            std::vector&lt;PointArray&gt; worldPoints,\n                                            std::vector&lt;std::string&gt; distance_transform);\n\n  void computeDenseMean(std::vector&lt;PointArray&gt; localPoints,\n                        std::vector&lt;PointArray&gt; worldPoints,\n                        std::vector&lt;std::string&gt; distanceTransform);\n\n  std::vector&lt;PointArray&gt; computeSparseMean(std::vector&lt;PointArray&gt; localPoints, Point3 commonCenter);\n\n  void writeMeanInfo();\n\n  void surface(const std::vector&lt;std::string&gt; localPointsFiles);\n\n  void samplesAlongPCAModes(const std::vector&lt;std::string&gt; worldPointsFiles);\n\n  void meanSurface(const std::vector&lt;std::string&gt; distanceTransformFiles,\n                   const std::vector&lt;std::string&gt; localPointsFiles,\n                   const std::vector&lt;std::string&gt; worldPointsFiles);\n\n  // set operations //\n\n  void setOutPrefix(std::string prefix) { this-&gt;outPrefix = prefix; }\n\n  void setOutPath(std::string path) { this-&gt;outPath = path; }\n\n  void setDoProcrustes(bool doProcrusts) { this-&gt;doProcrustes = doProcrustes; }\n\n  void setDoProcrustesScaling(bool doProcrustsScaling) { this-&gt;doProcrustesScaling = doProcrustesScaling; }\n\n  void setPairwiseNormalsDiffForGoodBad(bool pairwiseNormalsDiffForGoodBad) { this-&gt;pairwiseNormalsDiffForGoodBad = pairwiseNormalsDiffForGoodBad; }\n\n  void setMeanBeforeWarp(bool meanBeforeWarp) { this-&gt;meanBeforeWarp = meanBeforeWarp; }\n\n  void setEnableOutput(bool enableOutput) { this-&gt;enableOutput = enableOutput; }\n\n  void setModeIndex(int modeIndex) { this-&gt;modeIndex = modeIndex; }\n\n  void setNumOfModes(int numOfModes) { this-&gt;numOfModes = numOfModes; }\n\n  void setNumOfSamplesPerMode(int numOfSamplesPerMode) { this-&gt;numOfSamplesPerMode = numOfSamplesPerMode; }\n\n  void setNumOfParticles(int numOfParticles) { this-&gt;numOfParticles = numOfParticles; }\n\n  void setNumOfClusters(int numOfClusters) { this-&gt;numOfClusters = numOfClusters; }\n\n  void setMaxStdDev(float maxStdDev) { this-&gt;maxStdDev = maxStdDev; }\n\n  void setMaxVarianceCaptured(float maxVarianceCaptured) { this-&gt;maxVarianceCaptured = maxVarianceCaptured; }\n\n  void setMaxAngleDegrees(float maxAngleDegrees) { this-&gt;maxAngleDegrees = maxAngleDegrees; }\n\nprivate:\n  float normalAngle = Pi/2.0;\n  std::vector&lt;std::string&gt; localPointsFiles;\n  std::vector&lt;std::string&gt; worldPointsFiles;\n  std::vector&lt;std::string&gt; distanceTransformFiles;\n  vtkSmartPointer&lt;vtkPolyData&gt; denseMean;\n  vtkSmartPointer&lt;vtkPoints&gt; sparseMean;\n  std::vector&lt;bool&gt; goodPoints;\n  std::string outPrefix;\n  std::string outPath;\n  bool denseDone = true;\n  bool doProcrustes;\n  bool doProcrustesScaling;\n  bool pairwiseNormalsDiffForGoodBad = false;\n  bool meanBeforeWarp = true;\n  bool enableOutput = true;\n  int modeIndex = -1;\n  int numOfModes = -1;\n  int numOfSamplesPerMode = -1;\n  int numOfParticles = -1;\n  int numOfClusters = -1;\n  float maxStdDev = 0;\n  float maxVarianceCaptured = 0;\n  float maxAngleDegrees = 0;\n\n  vtkSmartPointer&lt;vtkPoints&gt; setSparseMean(const std::string&amp; sparsePath);\n  std::vector&lt;bool&gt; setGoodPoints(const std::string&amp; pointsPath);\n  std::vector&lt;PointArray&gt; setLocalPointsFiles(const std::vector&lt;std::string&gt; localPointsFiles);\n  std::vector&lt;PointArray&gt; setWorldPointsFiles(const std::vector&lt;std::string&gt; worldPointsFiles);\n\n};\n\n} // shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Reconstruction_8h.html","title":"Libs/Analyze/Reconstruction.h","text":""},{"location":"api/Files/Reconstruction_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/Reconstruction_8h.html#classes","title":"Classes","text":"Name class itk::BSplineInterpolateImageFunctionWithDoubleCoefficents class Reconstruction"},{"location":"api/Files/Reconstruction_8h.html#source-code","title":"Source code","text":"<pre><code>#ifndef __RECONSTRUCTION_H__\n#define __RECONSTRUCTION_H__\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n\n#include \"itkThinPlateSplineKernelTransform2.h\"\n#include \"itkCompactlySupportedRBFSparseKernelTransform.h\"\n\n#include &lt;itkImageToVTKImageFilter.h&gt;\n#include &lt;itkVTKImageToImageFilter.h&gt;\n\n#include &lt;vtkPolyData.h&gt;\n#include &lt;itkAddImageFilter.h&gt;\n#include &lt;itkGradientImageFilter.h&gt;\n#include &lt;itkGradientMagnitudeImageFilter.h&gt;\n#include &lt;itkResampleImageFilter.h&gt;\n\n#include &lt;itkLinearInterpolateImageFunction.h&gt;\n#include &lt;itkBSplineInterpolateImageFunction.h&gt;\n\n#include &lt;itkMultiplyImageFilter.h&gt;\n#include \"itkImageRegionConstIterator.h\"\n#include &lt;itkImageDuplicator.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;itkImageFileWriter.h&gt;\n#include \"Procrustes3D.h\"\n\n#ifdef assert\n#undef assert\n#define assert(a) { if (!static_cast&lt;bool&gt;(a)) { throw std::runtime_error(\"a\"); } }\n#endif\n\nnamespace itk\n{\ntemplate&lt;typename TImageType, typename TCoordRep = double&gt;\nclass ITK_TEMPLATE_EXPORT BSplineInterpolateImageFunctionWithDoubleCoefficents\n        : public BSplineInterpolateImageFunction &lt;TImageType, TCoordRep, double&gt;\n{};\n}\n\ntemplate &lt; template &lt; typename TCoordRep, unsigned &gt; class TTransformType = itk::CompactlySupportedRBFSparseKernelTransform,\n           template &lt; typename ImageType, typename TCoordRep &gt; class TInterpolatorType = itk::LinearInterpolateImageFunction,\n           typename TCoordRep = double, typename PixelType = float, typename ImageType = itk::Image&lt;PixelType, 3&gt;&gt;\nclass Reconstruction {\npublic:\n    typedef itk::GradientImageFilter&lt;ImageType, PixelType&gt;               GradientFilterType;\n    typedef itk::GradientMagnitudeImageFilter&lt;ImageType, ImageType &gt; GradientMagnitudeFilterType;\n    typedef itk::Image&lt; itk::CovariantVector&lt; PixelType, 3 &gt;, 3 &gt;        GradientImageType;\n    typedef itk::ImageRegionIterator&lt; GradientImageType &gt;            GradientImageIteratorType;\n    typedef itk::ImageRegionIterator&lt; ImageType &gt;                    ImageIteratorType;\n\n    typedef itk::ImageFileWriter&lt; ImageType &gt;  WriterType;\n\n    typedef itk::ImageToVTKImageFilter&lt;ImageType&gt;                    ITK2VTKConnectorType;\n    typedef itk::AddImageFilter &lt;ImageType, ImageType &gt;              AddImageFilterType;\n    typedef itk::ResampleImageFilter&lt;ImageType, ImageType &gt;          ResampleFilterType;\n\n    typedef TInterpolatorType &lt; ImageType, TCoordRep &gt;                  InterpolatorType;\n    typedef itk::MultiplyImageFilter &lt;ImageType, ImageType, ImageType&gt;  MultiplyByConstantImageFilterType;\n\n    typedef itk::ImageDuplicator&lt; ImageType &gt;                           DuplicatorType;\n    typedef TTransformType &lt; TCoordRep, 3 &gt;                             TransformType;\n\n    typedef itk::Point&lt; TCoordRep, 3 &gt;                  PointType;\n    typedef std::vector&lt; PointType &gt;                    PointArrayType;\n    typedef typename TransformType::PointSetType        PointSetType;\n    typedef typename PointSetType::PointIdentifier      PointIdType;\n\n    Reconstruction(std::string out_prefix = \"\",\n                   float decimationPercent = 0.3f,\n                   double angleThresh = 45.0f,\n                   size_t numClusters = 5,\n                   bool fixWinding = true,\n                   bool doLaplacianSmoothingBeforeDecimation = true,\n                   bool doLaplacianSmoothingAfterDecimation = true,\n                   float smoothingLambda = 0.5f,\n                   int smoothingIterations = 1,\n                   bool usePairwiseNormalsDifferencesForGoodBad = false);\n    ~Reconstruction();\n    vtkSmartPointer&lt;vtkPolyData&gt; getDenseMean(\n            std::vector&lt; PointArrayType &gt; local_pts =\n            std::vector&lt; PointArrayType &gt;(),\n            std::vector&lt; PointArrayType &gt; global_pts =\n            std::vector&lt; PointArrayType &gt;(),\n            std::vector&lt;std::string&gt; distance_transform =\n            std::vector&lt;std::string&gt;() );\n    void reset();\n\n    void setDecimation(float dec);\n    void setNumClusters(int num);\n    void setMaxAngle(double angleDegrees);\n    void setFixWinding(bool fixWinding);\n    void setLaplacianSmoothingBeforeDecimation(bool doLaplacianSmoothingBeforeDecimation);\n    void setLaplacianSmoothingAfterDecimation(bool doLaplacianSmoothingAfterDecimation);\n    void setSmoothingLambda(float smoothingLambda);\n    void setSmoothingIterations(int smoothingIterations);\n    void setOutputEnabled(bool enabled);\n\n    void setMeanBeforeWarpEnabled(bool enabled);\n\n    vtkSmartPointer&lt;vtkPolyData&gt; getMesh(PointArrayType local_pts);\n    void readMeanInfo(std::string dense,\n                      std::string sparse, std::string goodPoints);\n    bool sparseDone();\n    bool denseDone();\n    void writeMeanInfo(std::string nameBase);\n\n    vtkSmartPointer&lt;vtkPoints&gt;   SparseMean(){return sparseMean_;}\n    vtkSmartPointer&lt;vtkPolyData&gt; DenseMean() {return denseMean_;}\n\n    std::vector&lt;bool&gt; GoodPoints(){return goodPoints_;}\n\n    std::string OutPrefix(){return out_prefix_;}\n    void setOutPrefix(std::string out_prefix){out_prefix_ = out_prefix;}\n\n    std::vector&lt; PointArrayType &gt;  computeSparseMean(std::vector&lt; PointArrayType &gt; local_pts,\n                                                     itk::Point&lt;TCoordRep&gt;&amp; common_center,\n                                                     bool do_procrustes = true,\n                                                     bool do_procrustes_scaling = false);\n\n    void setOrigin(typename ImageType::PointType origin)\n    {\n        use_origin = true;\n        origin_[0] = origin[0];\n        origin_[1] = origin[1];\n        origin_[2] = origin[2];\n    }\n\n    void EnablePairwiseNormalsDifferencesForGoodBad(){usePairwiseNormalsDifferencesForGoodBad_ = true;}\n    void DisablePairwiseNormalsDifferencesForGoodBad(){usePairwiseNormalsDifferencesForGoodBad_ = false;}\n\nprivate:\n    int ComputeMedianShape(std::vector&lt;vnl_matrix&lt;double&gt;&gt; &amp; shapeList);\n    void computeDenseMean(\n            std::vector&lt; PointArrayType &gt; local_pts,\n            std::vector&lt; PointArrayType &gt; global_pts,\n            std::vector&lt;std::string&gt; distance_transform);\n    vnl_matrix&lt;double&gt; computeParticlesNormals(\n            vtkSmartPointer&lt; vtkPoints &gt; particles,\n            typename ImageType::Pointer distance_transform);\n    void generateWarpedMeshes(typename TransformType::Pointer transform,\n                              vtkSmartPointer&lt;vtkPolyData&gt;&amp; outputMesh);\n    double computeAverageDistanceToNeighbors(vtkSmartPointer&lt;vtkPoints&gt; points,\n                                             std::vector&lt;int&gt; particles_indices);\n    void CheckMapping(vtkSmartPointer&lt;vtkPoints&gt; sourcePts,\n                      vtkSmartPointer&lt;vtkPoints&gt; targetPts,\n                      typename TransformType::Pointer transform,\n                      vtkSmartPointer&lt;vtkPoints&gt; &amp; mappedCorrespondences,\n                      double &amp; rms, double &amp; rms_wo_mapping, double &amp; maxmDist);\n    vtkSmartPointer&lt;vtkPoints&gt; convertToImageCoordinates(\n            vtkSmartPointer&lt;vtkPoints&gt; particles, int number_of_particles,\n            const itk::Image&lt; float, 3 &gt;::SpacingType&amp; spacing,\n            const itk::Image&lt; float, 3 &gt;::PointType&amp; origin);\n    vtkSmartPointer&lt;vtkPoints&gt; convertToPhysicalCoordinates(\n            vtkSmartPointer&lt;vtkPoints&gt; particles, int number_of_particles,\n            const itk::Image&lt; float, 3 &gt;::SpacingType&amp; spacing,\n            const itk::Image&lt; float, 3 &gt;::PointType&amp; origin);\n    vtkSmartPointer&lt;vtkPolyData&gt; extractIsosurface(\n            vtkSmartPointer&lt;vtkImageData&gt; volData,\n            float levelsetValue        = 0.0f,\n            float targetReduction      = 0.1f,\n            float featureAngle         = 30,\n            int lsSmootherIterations   = 1,\n            int meshSmootherIterations = 1,\n            bool preserveTopology      = true);\n    vtkSmartPointer&lt;vtkPolyData&gt; MeshQC(\n            vtkSmartPointer&lt;vtkPolyData&gt; meshIn);\n\n    typename ImageType::Pointer loadImage(std::string filename);\n\n    void performKMeansClustering(\n            std::vector&lt; PointArrayType &gt; global_pts,\n            unsigned int number_of_particles,\n            std::vector&lt;int&gt; &amp; centroidIndices);\n\n    void writePLY(char* filename, vtkSmartPointer&lt;vtkPolyData&gt; meshIn);\n    void writeVTK(char* filename, vtkSmartPointer&lt;vtkPolyData&gt; meshIn);\n\n    //members.\n    vtkSmartPointer&lt;vtkPoints&gt; sparseMean_;\n    vtkSmartPointer&lt;vtkPolyData&gt; denseMean_;\n    std::vector&lt;bool&gt; goodPoints_;\n    bool sparseDone_;\n    bool denseDone_;\n    float decimationPercent_;\n    double maxAngleDegrees_;\n    size_t numClusters_;\n    int medianShapeIndex_;\n\n    bool fixWinding_;\n    bool doLaplacianSmoothingBeforeDecimation_;\n    bool doLaplacianSmoothingAfterDecimation_;\n    float smoothingLambda_;\n    int smoothingIterations_;\n\n    typename ImageType::PointType origin_;\n    bool use_origin;\n\n    std::string out_prefix_; // to save intermediate files in case needed\n    bool output_enabled_ = true;\n    bool usePairwiseNormalsDifferencesForGoodBad_ = false;\n\n    bool mean_before_warp_enabled_ = true;\n};\n\n#include \"Reconstruction.cpp\"  //need to include template definition in order for it to be instantiated\n\n#endif // !__RECONSTRUCTION_H__\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Region_8h.html","title":"Libs/Common/Region.h","text":""},{"location":"api/Files/Region_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Region_8h.html#classes","title":"Classes","text":"Name class shapeworks::IndexRegion Indices into a 3d region of memory (can be negative, e.g., for the purpose of padding an image) class shapeworks::PhysicalRegion physical bounds of a 3d region of space"},{"location":"api/Files/Region_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Shapeworks.h\"\n\nnamespace shapeworks\n{\n\n// A logical region of an Image or a Mesh\nclass IndexRegion;\n\n// A physical region of an Image or a Mesh\nclass PhysicalRegion;\n\nclass IndexRegion\n{\npublic:\n  Coord min{1000000000, 1000000000, 1000000000};\n  Coord max{-1000000000, -1000000000, -1000000000};\n\n  IndexRegion() = default;\n  IndexRegion(const IndexRegion&amp;) = default;\n\n  IndexRegion(const Dims &amp;dims) : min{0, 0, 0} {\n    if (0 != (dims[0] + dims[1] + dims[2])) {\n      max = {static_cast&lt;Coord::value_type&gt;(dims[0]) - 1,\n             static_cast&lt;Coord::value_type&gt;(dims[1]) - 1,\n             static_cast&lt;Coord::value_type&gt;(dims[2]) - 1};\n    }\n  }\n\n  IndexRegion(const Coord &amp;_min, const Coord &amp;_max) :\n    min{_min[0], _min[1], _min[2]}, max{_max[0], _max[1], _max[2]} {}\n\n  bool operator==(const IndexRegion &amp;other) const { return min == other.min &amp;&amp; max == other.max; }\n\n  bool valid() const { return max[0] &gt; min[0] &amp;&amp; max[1] &gt; min[1] &amp;&amp; max[2] &gt; min[2]; }\n\n  Coord origin() const { return Coord({min[0], min[1], min[2]}); }\n\n  Dims size() const {\n    return Dims({static_cast&lt;Dims::value_type&gt;(max[0] - min[0] + 1),\n                 static_cast&lt;Dims::value_type&gt;(max[1] - min[1] + 1),\n                 static_cast&lt;Dims::value_type&gt;(max[2] - min[2] + 1)});\n  }\n\n  IndexRegion&amp; pad(int padding);\n\n};\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const IndexRegion &amp;region);\n\n\nclass PhysicalRegion\n{\npublic:\n  Point min;\n  Point max;\n\n  PhysicalRegion(const PhysicalRegion&amp;) = default;\n\n  PhysicalRegion(const Point &amp;_min, const Point &amp;_max) {\n    min[0] = _min[0];\n    min[1] = _min[1];\n    min[2] = _min[2];\n    max[0] = _max[0];\n    max[1] = _max[1];\n    max[2] = _max[2];\n  }\n\n  PhysicalRegion() {\n    min = Point({1000000000, 1000000000, 1000000000});\n    max = Point({-1000000000, -1000000000, -1000000000});\n  }\n\n  PhysicalRegion(std::string str);\n\n  bool operator==(const PhysicalRegion &amp;other) const {\n    return min == other.min &amp;&amp; max == other.max;\n  }\n\n  bool valid() const {\n    bool minLessThanMax = max[0] &gt; min[0] &amp;&amp; max[1] &gt; min[1] &amp;&amp; max[2] &gt; min[2];\n    return minLessThanMax;\n  }\n\n  Point origin() const { return min; }\n\n  Point size() const { return max - min; }\n\n  PhysicalRegion&amp; shrink(const PhysicalRegion &amp;other);\n\n  PhysicalRegion&amp; expand(const PhysicalRegion &amp;other);\n\n  PhysicalRegion&amp; expand(const Point &amp;pt);\n\n  PhysicalRegion&amp; pad(double padding);\n\n  std::string to_string() const;\n\n};\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const PhysicalRegion &amp;region);\n\n} // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Sampler_8h.html","title":"Libs/Optimize/Sampler.h","text":""},{"location":"api/Files/Sampler_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Sampler_8h.html#classes","title":"Classes","text":"Name class shapeworks::Sampler struct shapeworks::Sampler::CuttingPlaneType struct shapeworks::Sampler::SphereType"},{"location":"api/Files/Sampler_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Logging.h&gt;\n#include &lt;Mesh/Mesh.h&gt;\n\n#include \"CorrespondenceMode.h\"\n#include \"GradientDescentOptimizer.h\"\n#include \"Libs/Optimize/Container/GenericContainerArray.h\"\n#include \"Libs/Optimize/Container/MeanCurvatureContainer.h\"\n#include \"Libs/Optimize/Domain/Surface.h\"\n#include \"Libs/Optimize/Function/CorrespondenceFunction.h\"\n#include \"Libs/Optimize/Function/SamplingFunction.h\"\n#include \"Libs/Optimize/Function/DisentangledCorrespondenceFunction.h\"\n#include \"Libs/Optimize/Function/DualVectorFunction.h\"\n#include \"Libs/Optimize/Function/LegacyCorrespondenceFunction.h\"\n#include \"Libs/Optimize/Matrix/LinearRegressionShapeMatrix.h\"\n#include \"Libs/Optimize/Matrix/MixedEffectsShapeMatrix.h\"\n#include \"Libs/Optimize/Neighborhood/ParticleNeighborhood.h\"\n#include \"ParticleSystem.h\"\n#include \"vnl/vnl_matrix_fixed.h\"\n#include \"EarlyStoppingConfig.h\"\n\n// Uncomment to visualize FFCs with scalar and vector fields\n// #define VIZFFC\n\n#if defined(VIZFFC)\n#include \"MeshUtils.h\"\n#endif\n\nnamespace shapeworks {\n\nclass Sampler {\n public:\n  using PixelType = float;\n  static constexpr unsigned int Dimension = 3;\n\n  using ImageType = itk::Image&lt;PixelType, Dimension&gt;;\n  using PointType = ImageType::PointType;\n\n  using MeanCurvatureCacheType = MeanCurvatureContainer&lt;PixelType, Dimension&gt;;\n  using TransformType = vnl_matrix_fixed&lt;double, Dimension + 1, Dimension + 1&gt;;\n  using OptimizerType = GradientDescentOptimizer;\n\n  struct CuttingPlaneType {\n    vnl_vector_fixed&lt;double, 3&gt; a;\n    vnl_vector_fixed&lt;double, 3&gt; b;\n    vnl_vector_fixed&lt;double, 3&gt; c;\n  };\n\n  struct SphereType {\n    vnl_vector_fixed&lt;double, Dimension&gt; center;\n    double radius;\n  };\n\n  Sampler();\n\n  virtual ~Sampler(){};\n\n  ParticleSystem* GetParticleSystem() { return m_ParticleSystem; }\n  const ParticleSystem* GetParticleSystem() const { return m_ParticleSystem.GetPointer(); }\n\n  std::shared_ptr&lt;SamplingFunction&gt; GetCurvatureGradientFunction() { return m_SamplingFunction; }\n\n  std::shared_ptr&lt;OptimizerType&gt; GetOptimizer() { return m_Optimizer; }\n  std::shared_ptr&lt;const OptimizerType&gt; GetOptimizer() const { return m_Optimizer; }\n\n  void SetPointsFile(unsigned int i, const std::string&amp; s) {\n    if (m_PointsFiles.size() &lt; i + 1) {\n      m_PointsFiles.resize(i + 1);\n    }\n    m_PointsFiles[i] = s;\n  }\n\n  void SetPointsFile(const std::string&amp; s) { this-&gt;SetPointsFile(0, s); }\n\n  void SetInitialPoints(std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; initial_points) {\n    initial_points_ = initial_points;\n  }\n\n  void AddImage(ImageType::Pointer image, double narrow_band, std::string name = \"\");\n\n  void ApplyConstraintsToZeroCrossing() {\n    for (size_t i = 0; i &lt; m_DomainList.size(); i++) {\n      this-&gt;m_DomainList[i]-&gt;UpdateZeroCrossingPoint();\n    }\n  }\n\n  void AddMesh(std::shared_ptr&lt;shapeworks::Surface&gt; mesh, double geodesic_remesh_percent = 100);\n\n  void AddContour(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n\n  void SetFieldAttributes(const std::vector&lt;std::string&gt;&amp; s);\n\n  void SetDomainsPerShape(int n) {\n    m_DomainsPerShape = n;\n    m_LinearRegressionShapeMatrix-&gt;SetDomainsPerShape(n);\n    m_MixedEffectsShapeMatrix-&gt;SetDomainsPerShape(n);\n    m_LegacyShapeMatrix-&gt;SetDomainsPerShape(n);\n    m_CorrespondenceFunction-&gt;SetDomainsPerShape(n);\n    m_GeneralShapeMatrix-&gt;SetDomainsPerShape(n);\n    m_GeneralShapeGradMatrix-&gt;SetDomainsPerShape(n);\n  }\n\n  void SetCuttingPlane(unsigned int i, const vnl_vector_fixed&lt;double, Dimension&gt;&amp; va,\n                       const vnl_vector_fixed&lt;double, Dimension&gt;&amp; vb, const vnl_vector_fixed&lt;double, Dimension&gt;&amp; vc);\n  void AddFreeFormConstraint(int domain, const FreeFormConstraint&amp; ffc);\n\n  void TransformCuttingPlanes(unsigned int i);\n\n  void AddSphere(unsigned int i, vnl_vector_fixed&lt;double, Dimension&gt;&amp; c, double r);\n\n  void SetAdaptivityMode() { m_LinkingFunction-&gt;set_function_a(GetCurvatureGradientFunction()); }\n\n  void SetCorrespondenceOn() { m_LinkingFunction-&gt;set_b_on(); }\n\n  void SetCorrespondenceOff() { m_LinkingFunction-&gt;set_b_off(); }\n\n  void SetSamplingOn() { m_LinkingFunction-&gt;set_a_on(); }\n\n  void SetSamplingOff() { m_LinkingFunction-&gt;set_a_off(); }\n\n  bool GetCorrespondenceOn() const { return m_LinkingFunction-&gt;get_b_on(); }\n\n  bool GetSamplingOn() const { return m_LinkingFunction-&gt;get_a_on(); }\n\n  void SetCorrespondenceMode(shapeworks::CorrespondenceMode mode);\n\n  void RegisterGeneralShapeMatrices() {\n    this-&gt;m_ParticleSystem-&gt;RegisterObserver(m_GeneralShapeMatrix);\n    this-&gt;m_ParticleSystem-&gt;RegisterObserver(m_GeneralShapeGradMatrix);\n  }\n\n  void SetAttributeScales(const std::vector&lt;double&gt;&amp; s) {\n    m_CorrespondenceFunction-&gt;SetAttributeScales(s);\n    m_GeneralShapeMatrix-&gt;SetAttributeScales(s);\n    m_GeneralShapeGradMatrix-&gt;SetAttributeScales(s);\n  }\n\n  void SetXYZ(unsigned int i, bool flag) {\n    m_CorrespondenceFunction-&gt;SetXYZ(i, flag);\n    m_GeneralShapeMatrix-&gt;SetXYZ(i, flag);\n    m_GeneralShapeGradMatrix-&gt;SetXYZ(i, flag);\n  }\n\n  void SetNormals(int i, bool flag) {\n    m_CorrespondenceFunction-&gt;SetNormals(i, flag);\n    m_GeneralShapeMatrix-&gt;SetNormals(i, flag);\n    m_GeneralShapeGradMatrix-&gt;SetNormals(i, flag);\n  }\n\n  void SetAttributesPerDomain(const std::vector&lt;int&gt; s);\n\n  LegacyShapeMatrix* GetShapeMatrix() { return m_LegacyShapeMatrix.GetPointer(); }\n\n  ShapeMatrix* GetGeneralShapeMatrix() { return m_GeneralShapeMatrix.GetPointer(); }\n  ShapeGradientMatrix* GetGeneralShapeGradientMatrix() { return m_GeneralShapeGradMatrix.GetPointer(); }\n\n  DualVectorFunction* GetLinkingFunction() { return m_LinkingFunction.get(); }\n\n  LegacyCorrespondenceFunction* GetEnsembleEntropyFunction() { return m_EnsembleEntropyFunction.get(); }\n\n  DisentangledCorrespondenceFunction* GetDisentangledEnsembleEntropyFunction() {\n    return m_DisentangledEnsembleEntropyFunction.get();\n  }\n\n  LegacyCorrespondenceFunction* GetEnsembleRegressionEntropyFunction() {\n    return m_EnsembleRegressionEntropyFunction.get();\n  }\n\n  LegacyCorrespondenceFunction* GetEnsembleMixedEffectsEntropyFunction() {\n    return m_EnsembleMixedEffectsEntropyFunction.get();\n  }\n\n  CorrespondenceFunction* GetMeshBasedGeneralEntropyGradientFunction() { return m_CorrespondenceFunction.get(); }\n\n  const DualVectorFunction* GetLinkingFunction() const { return m_LinkingFunction.get(); }\n\n  const LegacyCorrespondenceFunction* GetEnsembleEntropyFunction() const {\n    return m_EnsembleEntropyFunction.get();\n  }\n\n  const DisentangledCorrespondenceFunction* GetDisentangledEnsembleEntropyFunction() const {\n    return m_DisentangledEnsembleEntropyFunction.get();\n  }\n\n  const LegacyCorrespondenceFunction* GetEnsembleRegressionEntropyFunction() const {\n    return m_EnsembleRegressionEntropyFunction.get();\n  }\n\n  const LegacyCorrespondenceFunction* GetEnsembleMixedEffectsEntropyFunction() const {\n    return m_EnsembleMixedEffectsEntropyFunction.get();\n  }\n\n  const CorrespondenceFunction* GetMeshBasedGeneralEntropyGradientFunction() const {\n    return m_CorrespondenceFunction.get();\n  }\n\n  void SetTimeptsPerIndividual(int n) { m_MixedEffectsShapeMatrix-&gt;SetTimeptsPerIndividual(n); }\n\n  shapeworks::CorrespondenceMode GetCorrespondenceMode() const { return m_CorrespondenceMode; }\n\n  void SetTransformFile(const std::string&amp; s) { m_TransformFile = s; }\n\n  void SetTransformFile(const char* s) { m_TransformFile = std::string(s); }\n\n  void SetPrefixTransformFile(const std::string&amp; s) { m_PrefixTransformFile = s; }\n\n  void SetPrefixTransformFile(const char* s) { m_PrefixTransformFile = std::string(s); }\n\n  void SetPairwisePotentialType(int pairwise_potential_type) { m_pairwise_potential_type = pairwise_potential_type; }\n\n  int GetPairwisePotentialType() { return m_pairwise_potential_type; }\n\n  void SetVerbosity(unsigned int val) {\n    m_verbosity = val;\n    m_Optimizer-&gt;set_verbosity(val);\n  }\n\n  unsigned int GetVerbosity() { return m_verbosity; }\n\n  void SetSharedBoundaryEnabled(bool enabled) { m_IsSharedBoundaryEnabled = enabled; }\n  void SetSharedBoundaryWeight(double weight) { m_SharedBoundaryWeight = weight; }\n\n  void SetEarlyStoppingConfig(EarlyStoppingConfig config) { early_stopping_config_ = config; }\n\n  void ReadTransforms();\n  void ReadPointsFiles();\n  void AllocateDataCaches();\n  void AllocateDomainsAndNeighborhoods();\n  void InitializeOptimizationFunctions();\n\n  void initialize_initial_positions();\n\n  void Initialize() {\n    this-&gt;m_Initializing = true;\n    this-&gt;Execute();\n    this-&gt;m_Initializing = false;\n  }\n\n  void ReInitialize();\n\n  void Execute();\n\n  using CuttingPlaneList = std::vector&lt;std::vector&lt;std::pair&lt;Eigen::Vector3d, Eigen::Vector3d&gt;&gt;&gt;;\n\n  CuttingPlaneList ComputeCuttingPlanes();\n\n  Eigen::Vector3d ComputePlaneNormal(const vnl_vector&lt;double&gt;&amp; a, const vnl_vector&lt;double&gt;&amp; b,\n                                     const vnl_vector&lt;double&gt;&amp; c);\n\n  std::vector&lt;FreeFormConstraint&gt; GetFFCs() { return m_FFCs; }\n\n  void SetMeshFFCMode(bool mesh_ffc_mode) { m_meshFFCMode = mesh_ffc_mode; }\n\n private:\n  bool GetInitialized() { return this-&gt;m_Initialized; }\n\n  void SetInitialized(bool value) { this-&gt;m_Initialized = value; }\n\n  bool GetInitializing() { return this-&gt;m_Initializing; }\n\n  void SetInitializing(bool value) { this-&gt;m_Initializing = value; }\n\n  bool m_Initialized{false};\n  bool m_Initializing{false};\n\n  std::shared_ptr&lt;OptimizerType&gt; m_Optimizer;\n\n  std::shared_ptr&lt;SamplingFunction&gt; m_SamplingFunction;\n\n  GenericContainerArray&lt;double&gt;::Pointer m_Sigma1Cache;\n\n  ParticleSystem::Pointer m_ParticleSystem;\n\n  std::vector&lt;ParticleDomain::Pointer&gt; m_DomainList;\n\n  int m_pairwise_potential_type;\n\n  shapeworks::CorrespondenceMode m_CorrespondenceMode;\n\n  std::shared_ptr&lt;DualVectorFunction&gt; m_LinkingFunction;\n\n  std::shared_ptr&lt;LegacyCorrespondenceFunction&gt; m_EnsembleEntropyFunction;\n  std::shared_ptr&lt;LegacyCorrespondenceFunction&gt; m_EnsembleRegressionEntropyFunction;\n  std::shared_ptr&lt;LegacyCorrespondenceFunction&gt; m_EnsembleMixedEffectsEntropyFunction;\n  std::shared_ptr&lt;DisentangledCorrespondenceFunction&gt; m_DisentangledEnsembleEntropyFunction;\n  std::shared_ptr&lt;CorrespondenceFunction&gt; m_CorrespondenceFunction;\n\n  LegacyShapeMatrix::Pointer m_LegacyShapeMatrix;\n\n  LinearRegressionShapeMatrix::Pointer m_LinearRegressionShapeMatrix;\n  MixedEffectsShapeMatrix::Pointer m_MixedEffectsShapeMatrix;\n\n  shapeworks::ShapeMatrix::Pointer m_GeneralShapeMatrix;\n  shapeworks::ShapeGradientMatrix::Pointer m_GeneralShapeGradMatrix;\n\n  bool initialize_ffcs(size_t dom);\n\n private:\n  Sampler(const Sampler&amp;);         // purposely not implemented\n  void operator=(const Sampler&amp;);  // purposely not implemented\n\n  std::vector&lt;std::string&gt; m_PointsFiles;\n  std::vector&lt;int&gt; m_AttributesPerDomain;\n  int m_DomainsPerShape;\n  double m_Spacing{0};\n  bool m_IsSharedBoundaryEnabled;\n  double m_SharedBoundaryWeight{0.5};\n\n  std::string m_TransformFile;\n  std::string m_PrefixTransformFile;\n  std::vector&lt;std::vector&lt;CuttingPlaneType&gt;&gt; m_CuttingPlanes;\n  std::vector&lt;std::vector&lt;SphereType&gt;&gt; m_Spheres;\n  std::vector&lt;FreeFormConstraint&gt; m_FFCs;\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyData&gt;&gt; m_meshes;\n  bool m_meshFFCMode = false;\n\n  std::vector&lt;std::string&gt; fieldAttributes_;\n\n  std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; initial_points_;\n\n  EarlyStoppingConfig early_stopping_config_; // config for early stopping\n\n  unsigned int m_verbosity;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/SamplingFunction_8h.html","title":"Libs/Optimize/Function/SamplingFunction.h","text":""},{"location":"api/Files/SamplingFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/SamplingFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::SamplingFunction"},{"location":"api/Files/SamplingFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Libs/Optimize/Container/GenericContainerArray.h&gt;\n\n#include \"VectorFunction.h\"\n\nnamespace shapeworks {\n\nclass SamplingFunction : public VectorFunction {\n public:\n  constexpr static int VDimension = 3;\n\n  static std::shared_ptr&lt;SamplingFunction&gt; New() {\n    return std::make_shared&lt;SamplingFunction&gt;();\n  }\n\n  using VectorType = vnl_vector_fixed&lt;double, 3&gt;;\n  using PointType = ParticleSystem::PointType;\n  using GradientVectorType = vnl_vector_fixed&lt;float, 3&gt;;\n  using SigmaCacheType = GenericContainerArray&lt;double&gt;;\n\n  VectorType evaluate(unsigned int a, unsigned int b, const ParticleSystem* c, double&amp; d) const override {\n    double e;\n    return evaluate(a, b, c, d, e);\n  }\n\n  VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp;, double&amp;) const override;\n\n  void before_evaluate(unsigned int, unsigned int, const ParticleSystem*) override;\n\n  double energy(unsigned int a, unsigned int b, const ParticleSystem* c) const override {\n    double d, e;\n    evaluate(a, b, c, d, e);\n    return e;\n  }\n\n  double EstimateSigma(unsigned int idx, unsigned int dom, const shapeworks::ParticleDomain* domain,\n                       const PointType&amp; pos, double initial_sigma, double precision, int&amp; err, double&amp; avg_kappa) const;\n\n  void SetSharedBoundaryWeight(double w) { m_SharedBoundaryWeight = w; }\n  double GetSharedBoundaryWeight() const { return m_SharedBoundaryWeight; }\n\n  void SetSharedBoundaryEnabled(bool enabled) { m_IsSharedBoundaryEnabled = enabled; }\n  bool GetSharedBoundaryEnabled() const { return m_IsSharedBoundaryEnabled; }\n\n  void SetSpatialSigmaCache(SigmaCacheType* s) { m_SpatialSigmaCache = s; }\n  SigmaCacheType* GetSpatialSigmaCache() { return m_SpatialSigmaCache.GetPointer(); }\n  const SigmaCacheType* GetSpatialSigmaCache() const { return m_SpatialSigmaCache.GetPointer(); }\n\n  void SetMinimumNeighborhoodRadius(double s) { m_MinimumNeighborhoodRadius = s; }\n  double GetMinimumNeighborhoodRadius() const { return m_MinimumNeighborhoodRadius; }\n\n  void SetMaximumNeighborhoodRadius(double s) { m_MaximumNeighborhoodRadius = s; }\n  double GetMaximumNeighborhoodRadius() const { return m_MaximumNeighborhoodRadius; }\n\n  void SetFlatCutoff(double s) { m_FlatCutoff = s; }\n  double GetFlatCutoff() const { return m_FlatCutoff; }\n  void SetNeighborhoodToSigmaRatio(double s) { m_NeighborhoodToSigmaRatio = s; }\n  double GetNeighborhoodToSigmaRatio() const { return m_NeighborhoodToSigmaRatio; }\n\n  void reset_buffers() override { m_SpatialSigmaCache-&gt;ZeroAllValues(); }\n\n  std::shared_ptr&lt;VectorFunction&gt; clone() override;\n\n  SamplingFunction() {}\n  ~SamplingFunction() override = default;\n\n private:\n  SamplingFunction(const SamplingFunction&amp;) = delete;\n  SamplingFunction&amp; operator=(const SamplingFunction&amp;) = delete;\n\n  struct CrossDomainNeighborhood {\n    ParticlePointIndexPair pi_pair;\n    double weight;\n    double distance;\n    int dom;\n\n    CrossDomainNeighborhood(const ParticlePointIndexPair&amp; pi_pair_, double weight_, double distance_, int dom_)\n        : pi_pair(pi_pair_), weight(weight_), distance(distance_), dom(dom_) {}\n  };\n  std::vector&lt;CrossDomainNeighborhood&gt; m_CurrentNeighborhood;\n  void UpdateNeighborhood(const PointType&amp; pos, int idx, int d, double radius, const ParticleSystem* system);\n\n  unsigned int m_Counter{0};\n  double m_avgKappa{0};\n  bool m_IsSharedBoundaryEnabled{false};\n  double m_SharedBoundaryWeight{1.0};\n  double m_CurrentSigma{0.0};\n  float m_MaxMoveFactor{0};\n  double m_MinimumNeighborhoodRadius{0};\n  double m_MaximumNeighborhoodRadius{0};\n  double m_FlatCutoff{0.05};\n  double m_NeighborhoodToSigmaRatio{3.0};\n\n  SigmaCacheType::Pointer m_SpatialSigmaCache;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/SegmentationToolPanel_8h.html","title":"Studio/Data/SegmentationToolPanel.h","text":""},{"location":"api/Files/SegmentationToolPanel_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/SegmentationToolPanel_8h.html#classes","title":"Classes","text":"Name class shapeworks::SegmentationToolPanel"},{"location":"api/Files/SegmentationToolPanel_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Shape.h&gt;\n\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\nclass Ui_SegmentationToolPanel;\n\nnamespace shapeworks {\n\nclass Session;\nclass Lightbox;\nclass ShapeWorksStudioApp;\n\nclass SegmentationToolPanel : public QWidget {\n  Q_OBJECT;\n\n public:\n  SegmentationToolPanel(QWidget* parent = 0);\n  ~SegmentationToolPanel();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n  void reset();\n\n public Q_SLOTS:\n\n Q_SIGNALS:\n\n  void update_view();\n\n private:\n  QSharedPointer&lt;Session&gt; session_;\n\n  void update_paint_value();\n  void recompute_surface();\n\n  Ui_SegmentationToolPanel* ui_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Session_8h.html","title":"Studio/Data/Session.h","text":""},{"location":"api/Files/Session_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Session_8h.html#classes","title":"Classes","text":"Name class shapeworks::CompareSettings class shapeworks::Session Representation of a session."},{"location":"api/Files/Session_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Analyze/Analyze.h&gt;\n#include &lt;Analyze/Particles.h&gt;\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Logging.h&gt;\n#include &lt;MeshManager.h&gt;\n#include &lt;Particles/ParticleSystemEvaluation.h&gt;\n#include &lt;Project/Project.h&gt;\n#include &lt;Shapeworks.h&gt;\n#include &lt;StudioEnums.h&gt;\n#include &lt;Visualization/Viewer.h&gt;\n#include &lt;itkMatrixOffsetTransformBase.h&gt;\n#include &lt;vtkLookupTable.h&gt;\n\n#include &lt;QSharedPointer&gt;\n#include &lt;QVector&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\nclass PythonWorker;\n\nclass CompareSettings {\n public:\n  bool compare_enabled_ = false;\n  bool surface_distance_mode_ = false;\n  bool original_checked_ = false;\n  bool groomed_checked_ = false;\n  bool reconstructed_checked_ = false;\n  bool mean_shape_checked_ = false;\n  float opacity_ = 1.0;\n  DisplayMode get_display_mode() {\n    if (original_checked_) {\n      return DisplayMode::Original;\n    } else if (groomed_checked_) {\n      return DisplayMode::Groomed;\n    } else {\n      return DisplayMode::Reconstructed;\n    }\n  }\n  bool get_mean_shape_checked() { return mean_shape_checked_; }\n};\n\nclass Shape;\n\nclass Session;\ntypedef QSharedPointer&lt;Session&gt; SessionHandle;\n\nusing TransformType = vtkSmartPointer&lt;vtkTransform&gt;;\n\n\nclass Session : public QObject, public QEnableSharedFromThis&lt;Session&gt; {\n  Q_OBJECT;\n\n public:\n  using AlignmentType = Analyze::AlignmentType;\n\n  Session(QWidget* parent, Preferences&amp; prefs);\n\n  ~Session();\n\n  void set_parent(QWidget* parent);\n\n  bool save_project(QString filename);\n\n  bool load_project(QString filename);\n\n  bool load_light_project(QString filename);\n\n  bool load_xl_project(QString filename);\n\n  void set_project_path(QString relative_path);\n\n  std::shared_ptr&lt;shapeworks::Project&gt; get_project();\n\n  void load_original_files(std::vector&lt;std::string&gt; filenames);\n\n  void load_groomed_files(std::vector&lt;std::string&gt; file_names, double iso, int domains_per_shape);\n\n  bool load_point_files(std::vector&lt;std::string&gt; local, std::vector&lt;std::string&gt; world, int domains_per_shape);\n\n  bool update_particles(std::vector&lt;Particles&gt; particles);\n\n  int get_num_particles();\n\n  ParticleSystemEvaluation get_local_particle_system(int domain);\n\n  void update_procrustes_transforms(std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt; transforms);\n\n  bool is_light_project();\n\n  bool get_groomed_present();\n\n  void remove_shapes(QList&lt;int&gt; list);\n\n  ShapeList get_shapes();\n\n  ShapeList get_non_excluded_shapes();\n\n  void calculate_reconstructed_samples();\n\n  QString get_filename();\n\n  QString get_display_name();\n\n  bool original_present();\n  bool groomed_present();\n  bool particles_present();\n  bool groups_available();\n  int get_num_shapes();\n\n  int get_domains_per_shape();\n\n  std::string get_default_feature_map();\n\n  static bool is_supported_file_format(std::string filename);\n\n  std::shared_ptr&lt;MeshManager&gt; get_mesh_manager() { return this-&gt;mesh_manager_; }\n\n  shapeworks::Parameters&amp; parameters();\n\n  std::vector&lt;DomainType&gt; get_groomed_domain_types();\n\n  double update_auto_glyph_size();\n\n  double get_auto_glyph_size();\n\n  static Point3 get_point(const Eigen::VectorXd&amp; points, int i);\n\n  void clear_particles();\n\n  bool get_feature_auto_scale();\n\n  double get_feature_range_max();\n  double get_feature_range_min();\n  void set_feature_range(double min, double max);\n  void set_feature_range_min(double value);\n  void set_feature_range_max(double value);\n\n  void set_feature_uniform_scale(bool value);\n  bool get_feature_uniform_scale();\n\n  void handle_ctrl_click(PickResult result);\n\n  void trigger_landmarks_changed();\n  void trigger_planes_changed();\n  void trigger_ffc_changed();\n  void trigger_annotations_changed();\n  void trigger_save();\n  void trigger_data_changed();\n  void reload_particles();\n  void trigger_fill_all_ffc();\n\n  void set_active_landmark_domain(int id);\n  int get_active_landmark_domain();\n  void set_placing_landmark(int id);\n  int get_placing_landmark();\n  void set_landmarks_active(bool active);\n  bool get_landmarks_active();\n  void set_planes_active(bool active);\n  bool get_planes_active();\n  void set_show_landmark_labels(bool show);\n  bool get_show_landmark_labels();\n\n  void set_show_planes(bool show);\n  bool get_show_planes();\n  bool should_show_planes();\n\n  void set_show_landmarks(bool show);\n  bool get_show_landmarks();\n\n  // image volume\n  bool set_image_name(std::string image_name);\n  std::string get_image_name();\n\n  // image axis\n  void set_image_axis(QString axis);\n  Axis get_image_axis();\n\n  // image view 3d mode\n  void set_image_3d_mode(bool mode);\n  bool get_image_3d_mode();\n\n  // image sync/share window width and level\n  void set_image_share_window_and_level(bool enabled);\n  bool get_image_share_brightness_contrast();\n\n  // image sync slice\n  void set_image_sync_slice(bool enabled);\n  bool get_image_sync_slice();\n\n  // 3D image, thickness feature\n  void set_image_thickness_feature(bool enabled);\n  bool get_image_thickness_feature();\n\n  void set_feature_map(std::string feature_map);\n  std::string get_feature_map();\n\n  bool has_constraints();\n\n  void set_loading(bool loading);\n  bool is_loading();\n\n  void set_tool_state(std::string state);\n  std::string get_tool_state();\n  bool is_analysis_mode();\n\n  void set_ffc_paint_active(bool enabled);\n  bool get_ffc_paint_active();\n\n  void set_seg_paint_active(bool enabled);\n  bool get_seg_paint_active();\n\n  void set_seg_paint_value(int value);\n  int get_seg_paint_value();\n\n  void set_ffc_paint_mode_inclusive(bool inclusive);\n  bool get_ffc_paint_mode_inclusive();\n\n  void set_ffc_paint_size(double size);\n  double get_ffc_paint_size();\n\n  void set_seg_paint_size(double size);\n  double get_seg_paint_size();\n\n  bool get_show_good_bad_particles();\n  void set_show_good_bad_particles(bool enabled);\n\n  bool get_show_difference_vectors();\n  void set_show_difference_vectors(bool enabled);\n  bool should_difference_vectors_show();\n\n  std::vector&lt;bool&gt; get_good_bad_particles();\n  void set_good_bad_particles(const std::vector&lt;bool&gt;&amp; good_bad);\n\n  // for setting difference to mean, etc\n  void set_difference_particles(Particles particles) { difference_particles_ = particles; }\n  Particles get_difference_particles() { return difference_particles_; }\n\n  void set_compare_settings(CompareSettings settings);\n  CompareSettings get_compare_settings();\n\n  void trigger_repaint();\n\n  void trigger_reinsert_shapes();\n\n  void set_display_mode(DisplayMode mode);\n\n  DisplayMode get_display_mode();\n\n  void set_glyph_lut(vtkSmartPointer&lt;vtkLookupTable&gt; lut) { glyph_lut_ = lut; }\n  vtkSmartPointer&lt;vtkLookupTable&gt; get_glyph_lut() { return glyph_lut_; }\n\n  void set_py_worker(QSharedPointer&lt;PythonWorker&gt; worker) { py_worker_ = worker; }\n  QSharedPointer&lt;PythonWorker&gt; get_py_worker() { return py_worker_; }\n\n  Eigen::MatrixXd get_all_particles();\n  Eigen::MatrixXd get_all_scalars(std::string target_feature);\n\n  void set_current_alignment(AlignmentType alignment) { current_alignment_ = alignment; }\n  AlignmentType get_current_alignment() { return current_alignment_; }\n\n  bool is_modified() { return modified_; }\n  void set_modified(bool modified);\n\n  void recompute_surfaces();\n\n public Q_SLOTS:\n  void set_feature_auto_scale(bool value);\n\n  void set_landmark_drag_mode(bool mode);\n  bool get_landmark_drag_mode();\n\n  void handle_clear_cache();\n  void handle_new_mesh();\n  void handle_thread_complete();\n\n Q_SIGNALS:\n  void data_changed();\n  void tool_state_changed();\n  void points_changed();\n  void landmarks_changed();\n  void planes_changed();\n  void ffc_changed();\n  void update_display();\n  void feature_map_changed();\n  void reset_stats();\n  void new_mesh();\n  void feature_range_changed();\n  void update_view_mode();\n  void image_slice_settings_changed();\n  void paint_mode_changed();\n  void repaint();\n  void reinsert_shapes();\n  void annotations_changed();\n  void save();\n  void session_title_changed();\n  void image_name_changed();\n  void fill_all_ffc_requested();\n\n public:\n  // constants\n  const static std::string DATA_C;\n  const static std::string GROOM_C;\n  const static std::string OPTIMIZE_C;\n  const static std::string ANALYSIS_C;\n  const static std::string DEEPSSM_C;\n  const static std::string MONAI_C;\n\n private:\n  void renumber_shapes();\n\n  void new_landmark(PickResult result);\n\n  void new_plane_point(PickResult result);\n\n  QWidget* parent_{nullptr};\n\n  Preferences&amp; preferences_;\n\n  QString filename_;\n\n  ShapeList shapes_;\n\n  Particles difference_particles_;\n\n  std::shared_ptr&lt;MeshManager&gt; mesh_manager_;\n\n  bool groups_available_{false};\n  bool is_light_project_{false};\n\n  bool unsaved_particle_files_{false};\n\n  Parameters params_;\n\n  std::shared_ptr&lt;Project&gt; project_{new Project()};\n\n  double auto_glyph_size_ = -1;\n\n  int active_landmark_domain_ = -1;\n  int placing_landmark_ = -1;\n  bool landmark_drag_mode_ = false;\n  bool landmarks_active_ = false;\n  bool planes_active_ = false;\n  bool show_landmark_labels_ = false;\n  bool show_difference_vectors_ = false;\n\n  bool ffc_painting_active_ = false;\n  bool ffc_painting_inclusive_mode_ = false;\n  double ffc_paint_size_ = 50;\n  double seg_paint_size_ = 50;\n  bool seg_painting_active_ = false;\n  int seg_painting_value_ = 1;\n\n  bool is_loading_ = false;\n  CompareSettings compare_settings_;\n\n  vtkSmartPointer&lt;vtkLookupTable&gt; glyph_lut_;\n\n  QSharedPointer&lt;PythonWorker&gt; py_worker_;\n\n  AlignmentType current_alignment_{AlignmentType::Local};\n\n  bool modified_{false};\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeEvaluationJob_8h.html","title":"Studio/Analysis/ShapeEvaluationJob.h","text":""},{"location":"api/Files/ShapeEvaluationJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeEvaluationJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeEvaluationJob The ShapeEvaluationJob class is a worker class that computes shape evaluation metrics of compactness, specificity, and generalization. It runs asynchronously using the Job and Worker interfaces."},{"location":"api/Files/ShapeEvaluationJob_8h.html#functions","title":"Functions","text":"Name Q_DECLARE_METATYPE(Eigen::VectorXd ) Q_DECLARE_METATYPE(shapeworks::ShapeEvaluationJob::JobType )"},{"location":"api/Files/ShapeEvaluationJob_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/ShapeEvaluationJob_8h.html#function-q_declare_metatype","title":"function Q_DECLARE_METATYPE","text":"<pre><code>Q_DECLARE_METATYPE(\n    Eigen::VectorXd \n)\n</code></pre>"},{"location":"api/Files/ShapeEvaluationJob_8h.html#function-q_declare_metatype_1","title":"function Q_DECLARE_METATYPE","text":"<pre><code>Q_DECLARE_METATYPE(\n    shapeworks::ShapeEvaluationJob::JobType \n)\n</code></pre>"},{"location":"api/Files/ShapeEvaluationJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Worker.h&gt;\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\n#include &lt;QSharedPointer&gt;\n\nnamespace shapeworks {\n\nclass Session;\n\nclass ShapeEvaluationJob : public Job {\n  Q_OBJECT\n public:\n  enum class JobType { CompactnessType, SpecificityType, GeneralizationType };\n\n  ShapeEvaluationJob(JobType job_type, ParticleShapeStatistics stats, QSharedPointer&lt;Session&gt; session);\n\n  void run() override;\n\n  QString name() override;\n\n Q_SIGNALS:\n\n  void report_progress(shapeworks::ShapeEvaluationJob::JobType job_type, float progress);\n  void result_ready(shapeworks::ShapeEvaluationJob::JobType job_type, Eigen::VectorXd data);\n\n private:\n  void receive_progress(float progress);\n  void prep_meshes();\n\n  JobType job_type_;\n  ParticleShapeStatistics stats_;\n  QSharedPointer&lt;Session&gt; session_;\n};\n}  // namespace shapeworks\n\nQ_DECLARE_METATYPE(Eigen::VectorXd);\nQ_DECLARE_METATYPE(shapeworks::ShapeEvaluationJob::JobType);\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeEvaluation_8h.html","title":"Libs/Particles/ShapeEvaluation.h","text":""},{"location":"api/Files/ShapeEvaluation_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeEvaluation_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeEvaluation"},{"location":"api/Files/ShapeEvaluation_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Core&gt;\n#include &lt;string&gt;\n\n#include \"ParticleSystemEvaluation.h\"\n\nnamespace shapeworks {\n\nclass ShapeEvaluation {\n public:\n  ShapeEvaluation();\n\n  static double compute_compactness(const ParticleSystemEvaluation&amp; particle_system, int num_modes,\n                                    const std::string&amp; save_to = \"\");\n\n  static Eigen::VectorXd compute_full_compactness(const ParticleSystemEvaluation&amp; particle_system,\n                                                  std::function&lt;void(float)&gt; progress_callback = nullptr);\n\n  static double compute_generalization(const ParticleSystemEvaluation&amp; particle_system, int num_modes,\n                                       const std::string&amp; save_to = \"\", bool surface_distance_mode = false);\n\n  static Eigen::VectorXd compute_full_generalization(const ParticleSystemEvaluation&amp; particle_system,\n                                                     std::function&lt;void(float)&gt; progress_callback = nullptr,\n                                                     std::function&lt;bool()&gt; check_abort = nullptr,\n                                                     bool surface_distance_mode = false);\n\n  static double compute_specificity(const ParticleSystemEvaluation&amp; particle_system, int num_mode,\n                                    const std::string&amp; save_to = \"\", bool surface_distance_mode = false);\n\n  static Eigen::VectorXd compute_full_specificity(const ParticleSystemEvaluation&amp; particle_system,\n                                                  std::function&lt;void(float)&gt; progress_callback = nullptr,\n                                                  std::function&lt;bool()&gt; check_abort = nullptr,\n                                                  bool surface_distance_mode = false);\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeGradientMatrix_8h.html","title":"Libs/Optimize/Matrix/ShapeGradientMatrix.h","text":""},{"location":"api/Files/ShapeGradientMatrix_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeGradientMatrix_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeGradientMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES!"},{"location":"api/Files/ShapeGradientMatrix_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"Libs/Optimize/Container/GenericContainer.h\"\n#include \"Libs/Optimize/Domain/ImageDomainWithGradN.h\"\n#include \"Libs/Optimize/Domain/ImageDomainWithGradients.h\"\n#include \"Libs/Optimize/Domain/ImplicitSurfaceDomain.h\"\n#include \"Observer.h\"\n#include \"ParticleSystem.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n#include \"vnl/vnl_matrix.h\"\n\nnamespace shapeworks {\nclass ShapeGradientMatrix : public vnl_matrix&lt;double&gt;, public Observer {\n public:\n  typedef double DataType;\n  typedef ShapeGradientMatrix Self;\n  typedef Observer Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  typedef ParticleSystem ParticleSystemType;\n\n  itkNewMacro(Self);\n  itkTypeMacro(ShapeGradientMatrix, Observer);\n\n  virtual void BeforeIteration() {}\n  virtual void AfterIteration() {}\n\n  void SetDomainsPerShape(int i) { m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  void SetAttributesPerDomain(const std::vector&lt;int&gt;&amp; i) { m_AttributesPerDomain = i; }\n\n  void SetAttributeScales(const std::vector&lt;double&gt;&amp; s) { m_AttributeScales = s; }\n\n  void SetXYZ(int i, bool val) {\n    if (m_use_xyz.size() != m_DomainsPerShape) {\n      m_use_xyz.resize(m_DomainsPerShape);\n    }\n    m_use_xyz[i] = val;\n  }\n  void SetNormals(int i, bool val) {\n    if (m_use_normals.size() != m_DomainsPerShape) {\n      m_use_normals.resize(m_DomainsPerShape);\n    }\n    m_use_normals[i] = val;\n  }\n\n  virtual void SetMatrix(const vnl_matrix&lt;double&gt;&amp; m) { vnl_matrix&lt;double&gt;::operator=(m); }\n\n  virtual void ResizeMatrix(int rs, int cs) {\n    vnl_matrix&lt;double&gt; tmp(*this);  // copy existing  matrix\n\n    // Create new column (shape)\n    this-&gt;set_size(rs, cs);\n\n    // Copy old data into new matrix.\n    for (unsigned int c = 0; c &lt; tmp.cols(); c++) {\n      for (unsigned int r = 0; r &lt; tmp.rows(); r++) {\n        this-&gt;operator()(r, c) = tmp(r, c);\n      }\n    }\n  }\n\n  void SetValues(const ParticleSystemType* ps, int idx, int d);\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp; e) {\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    unsigned int d = event.GetDomainIndex();\n\n    if (d % m_DomainsPerShape == 0) {\n      this-&gt;ResizeMatrix(this-&gt;rows(), this-&gt;cols() + 3);  // 3 columns for every shape\n    }\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    // update the size of matrix based on xyz, normals and number of attributes being used\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n\n    int numRows = 0;\n    for (int i = 0; i &lt; m_DomainsPerShape; i++) {\n      if (m_use_xyz[i]) {\n        numRows += 3 * ps-&gt;GetNumberOfParticles(i);\n      }\n      if (m_use_normals[i]) {\n        numRows += 3 * ps-&gt;GetNumberOfParticles(i);\n      }\n      numRows += m_AttributesPerDomain[i] * ps-&gt;GetNumberOfParticles(i);\n    }\n\n    if (numRows &gt; this-&gt;rows()) {\n      this-&gt;ResizeMatrix(numRows, this-&gt;cols());\n    }\n\n    this-&gt;SetValues(ps, idx, d);\n  }\n\n  virtual void PositionSetEventCallback(Object* o, const itk::EventObject&amp; e) {\n    // update xyz, normals and number of attributes being used\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n\n    this-&gt;SetValues(ps, idx, d);\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n protected:\n  ShapeGradientMatrix() {\n    m_DomainsPerShape = 1;\n\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n  }\n  virtual ~ShapeGradientMatrix() {}\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n  int m_DomainsPerShape;\n\n private:\n  ShapeGradientMatrix(const Self&amp;);  // purposely not implemented\n  void operator=(const Self&amp;);       // purposely not implemented\n\n  std::vector&lt;bool&gt; m_use_xyz;  // one per anatomy/domain?\n  std::vector&lt;bool&gt; m_use_normals;  // one per anatomy/domain?\n  std::vector&lt;int&gt; m_AttributesPerDomain;\n  std::vector&lt;double&gt; m_AttributeScales;\n\n};  // end class\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeMatrix_8h.html","title":"Libs/Optimize/Matrix/ShapeMatrix.h","text":""},{"location":"api/Files/ShapeMatrix_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeMatrix_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES!"},{"location":"api/Files/ShapeMatrix_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#include \"Domain/MeshDomain.h\"\n#include \"Libs/Optimize/Container/GenericContainer.h\"\n#include \"Libs/Optimize/Domain/ImageDomainWithGradients.h\"\n#include \"Libs/Optimize/Domain/ImplicitSurfaceDomain.h\"\n#include \"Observer.h\"\n#include \"ParticleSystem.h\"\n#include \"itkDataObject.h\"\n#include \"itkWeakPointer.h\"\n#include \"vnl/vnl_matrix.h\"\nnamespace shapeworks {\n\nclass ShapeMatrix : public vnl_matrix&lt;double&gt;, public Observer {\n public:\n  typedef double DataType;\n  typedef ShapeMatrix Self;\n  typedef Observer Superclass;\n  typedef itk::SmartPointer&lt;Self&gt; Pointer;\n  typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;\n  typedef itk::WeakPointer&lt;const Self&gt; ConstWeakPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(ShapeMatrix, Observer);\n\n  virtual void before_iteration() {}\n  virtual void after_iteration() {}\n\n  void SetDomainsPerShape(int i) { m_DomainsPerShape = i; }\n  int GetDomainsPerShape() const { return m_DomainsPerShape; }\n\n  void SetAttributesPerDomain(const std::vector&lt;int&gt;&amp; i) { m_AttributesPerDomain = i; }\n\n  void SetAttributeScales(const std::vector&lt;double&gt;&amp; s) { m_AttributeScales = s; }\n\n  void SetXYZ(int i, bool val) {\n    if (m_use_xyz.size() != m_DomainsPerShape) m_use_xyz.resize(m_DomainsPerShape);\n    m_use_xyz[i] = val;\n  }\n  void SetNormals(int i, bool val) {\n    if (m_use_normals.size() != m_DomainsPerShape) m_use_normals.resize(m_DomainsPerShape);\n    m_use_normals[i] = val;\n  }\n\n  virtual void SetMatrix(const vnl_matrix&lt;double&gt;&amp; m) { vnl_matrix&lt;double&gt;::operator=(m); }\n\n  virtual void ResizeMatrix(int rs, int cs) {\n    vnl_matrix&lt;double&gt; tmp(*this);  // copy existing  matrix\n\n    // Create new column (shape)\n    this-&gt;set_size(rs, cs);\n\n    // Copy old data into new matrix.\n    for (unsigned int c = 0; c &lt; tmp.cols(); c++) {\n      for (unsigned int r = 0; r &lt; tmp.rows(); r++) this-&gt;operator()(r, c) = tmp(r, c);\n    }\n  }\n\n  virtual void DomainAddEventCallback(Object*, const itk::EventObject&amp; e) {\n    const ParticleDomainAddEvent&amp; event = dynamic_cast&lt;const ParticleDomainAddEvent&amp;&gt;(e);\n    unsigned int d = event.GetDomainIndex();\n\n    if (d % m_DomainsPerShape == 0) this-&gt;ResizeMatrix(this-&gt;rows(), this-&gt;cols() + 1);\n  }\n\n  void SetValues(const ParticleSystem* ps, int idx, int d) {\n    const int VDimension = 3;\n\n    const typename ParticleSystem::PointType pos = ps-&gt;GetTransformedPosition(idx, d);\n    const typename ParticleSystem::PointType posLocal = ps-&gt;GetPosition(idx, d);\n    unsigned int k = 0;\n    int dom = d % m_DomainsPerShape;\n    int num = 0;\n    for (int i = 0; i &lt; dom; i++) {\n      if (m_use_xyz[i]) {\n        k += VDimension * ps-&gt;GetNumberOfParticles(i);\n        num += VDimension;\n      }\n      if (m_use_normals[i]) {\n        k += VDimension * ps-&gt;GetNumberOfParticles(i);\n        num += VDimension;\n      }\n      k += m_AttributesPerDomain[i] * ps-&gt;GetNumberOfParticles(i);\n      num += m_AttributesPerDomain[i];\n    }\n    if (m_use_xyz[dom]) k += idx * VDimension;\n    if (m_use_normals[dom]) k += idx * VDimension;\n    k += idx * m_AttributesPerDomain[dom];\n\n    int s = 0;\n    if (m_use_xyz[dom]) {\n      for (unsigned int i = 0; i &lt; VDimension; i++) {\n        this-&gt;operator()(i + k, d / m_DomainsPerShape) = pos[i] * m_AttributeScales[num + i + s];\n      }\n      k += VDimension;\n      s += VDimension;\n    }\n    if (m_use_normals[dom]) {\n      vnl_vector_fixed&lt;float, DIMENSION&gt; pN = ps-&gt;GetDomain(d)-&gt;SampleNormalAtPoint(posLocal, idx);\n      ParticleSystem::VectorType tmp;\n      tmp[0] = pN[0];\n      tmp[1] = pN[1];\n      tmp[2] = pN[2];\n      tmp = ps-&gt;TransformVector(tmp, ps-&gt;GetTransform(d) * ps-&gt;GetPrefixTransform(d));\n      pN[0] = tmp[0];\n      pN[1] = tmp[1];\n      pN[2] = tmp[2];\n      pN = pN.normalize();  // contains scaling\n      for (unsigned int i = 0; i &lt; VDimension; i++) {\n        this-&gt;operator()(i + k, d / m_DomainsPerShape) = pN[i] * m_AttributeScales[num + i + s];\n      }\n      k += VDimension;\n      s += VDimension;\n    }\n\n    std::vector&lt;float&gt; feature_values;\n    if (m_AttributesPerDomain[dom] &gt; 0) {\n      Point3 pt;\n      pt[0] = posLocal[0];\n      pt[1] = posLocal[1];\n      pt[2] = posLocal[2];\n      feature_values.clear();\n      const MeshDomain* domain = static_cast&lt;const MeshDomain*&gt;(ps-&gt;GetDomain(d));\n\n      auto mesh = domain-&gt;GetSWMesh();\n\n      auto field_attributes = ps-&gt;GetFieldAttributes();\n\n      for (int i = 0; i &lt; field_attributes.size(); i++) {\n        feature_values.push_back(mesh-&gt;interpolateFieldAtPoint(field_attributes[i], pt));\n      }\n\n      for (int aa = 0; aa &lt; m_AttributesPerDomain[dom]; aa++) {\n        this-&gt;operator()(aa + k, d / m_DomainsPerShape) = feature_values[aa] * m_AttributeScales[aa + num + s];\n      }\n    }\n  }\n\n  virtual void PositionAddEventCallback(Object* o, const itk::EventObject&amp; e) {\n    const int VDimension = 3;\n\n    // update the size of matrix based on xyz, normals and number of attributes being used\n    const ParticlePositionAddEvent&amp; event = dynamic_cast&lt;const ParticlePositionAddEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n\n    int numRows = 0;\n    for (int i = 0; i &lt; m_DomainsPerShape; i++) {\n      if (m_use_xyz[i]) numRows += VDimension * ps-&gt;GetNumberOfParticles(i);\n      if (m_use_normals[i]) numRows += VDimension * ps-&gt;GetNumberOfParticles(i);\n      numRows += m_AttributesPerDomain[i] * ps-&gt;GetNumberOfParticles(i);\n    }\n\n    if (numRows &gt; this-&gt;rows()) this-&gt;ResizeMatrix(numRows, this-&gt;cols());\n\n    this-&gt;SetValues(ps, idx, d);\n  }\n\n  virtual void PositionSetEventCallback(Object* o, const itk::EventObject&amp; e) {\n    // update xyz, normals and number of attributes being used\n    const ParticlePositionSetEvent&amp; event = dynamic_cast&lt;const ParticlePositionSetEvent&amp;&gt;(e);\n    const ParticleSystem* ps = dynamic_cast&lt;const ParticleSystem*&gt;(o);\n    const int d = event.GetDomainIndex();\n    const unsigned int idx = event.GetPositionIndex();\n\n    this-&gt;SetValues(ps, idx, d);\n  }\n\n  virtual void PositionRemoveEventCallback(Object*, const itk::EventObject&amp;) {\n    // NEED TO IMPLEMENT THIS\n  }\n\n  void PrintMatrix() {\n    std::cout &lt;&lt; std::endl;\n    for (unsigned int r = 0; r &lt; this-&gt;rows(); r++) {\n      for (unsigned int c = 0; c &lt; this-&gt;cols(); c++) {\n        std::cout &lt;&lt; this-&gt;operator()(r, c) &lt;&lt; \"  \";\n      }\n      std::cout &lt;&lt; std::endl;\n    }\n  }\n\n  bool CheckForNans() {\n    bool flag = false;\n    for (unsigned int r = 0; r &lt; this-&gt;rows(); r++) {\n      for (unsigned int c = 0; c &lt; this-&gt;cols(); c++) {\n        if (std::isnan(this-&gt;operator()(r, c))) {\n          flag = true;\n          break;\n        }\n      }\n    }\n    return flag;\n  }\n\n protected:\n  ShapeMatrix() {\n    m_DomainsPerShape = 1;\n\n    this-&gt;m_DefinedCallbacks.DomainAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionAddEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionSetEvent = true;\n    this-&gt;m_DefinedCallbacks.PositionRemoveEvent = true;\n  }\n  virtual ~ShapeMatrix() {}\n\n  void PrintSelf(std::ostream&amp; os, itk::Indent indent) const { Superclass::PrintSelf(os, indent); }\n\n  int m_DomainsPerShape;\n\n private:\n  ShapeMatrix(const Self&amp;);     // purposely not implemented\n  void operator=(const Self&amp;);  // purposely not implemented\n\n  std::vector&lt;bool&gt; m_use_xyz;\n  std::vector&lt;bool&gt; m_use_normals;\n  std::vector&lt;int&gt; m_AttributesPerDomain;\n  std::vector&lt;double&gt; m_AttributeScales;\n\n};  // end class\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeScalarJob_8h.html","title":"Studio/Job/ShapeScalarJob.h","text":""},{"location":"api/Files/ShapeScalarJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeScalarJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeScalarJob"},{"location":"api/Files/ShapeScalarJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Data/Session.h&gt;\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\n#include &lt;QPixmap&gt;\n\nnamespace shapeworks {\n\nclass Project;\n\nclass ShapeScalarJob : public Job {\n  Q_OBJECT\n public:\n  enum class JobType { Find_Components, MSE_Plot, Predict };\n  enum class Direction { To_Shape, To_Scalar };\n\n  ShapeScalarJob(QSharedPointer&lt;Session&gt; session, QString target_feature, Eigen::MatrixXd target_particles,\n                 JobType job_type);\n  void run() override;\n  QString name() override;\n\n  QPixmap get_plot();\n\n  void set_number_of_components(int num_components) { num_components_ = num_components; }\n  void set_number_of_folds(int num_folds) { num_folds_ = num_folds; }\n  void set_max_number_of_components(int num) { max_components_ = num; }\n\n  Eigen::VectorXd get_prediction() { return prediction_; };\n\n  static Eigen::VectorXd predict_scalars(QSharedPointer&lt;Session&gt; session, QString target_feature,\n                                         Eigen::MatrixXd target_particles);\n\n  static Eigen::VectorXd predict_shape(QSharedPointer&lt;Session&gt; session, QString target_feature,\n                                       Eigen::MatrixXd target_particles);\n\n  static void clear_model() { needs_clear_ = true; };\n\n  void set_direction(Direction direction) { direction_ = direction; }\n\n private:\n  void prep_data();\n\n  bool run_fit();\n  void run_prediction();\n\n  static Eigen::VectorXd predict(QSharedPointer&lt;Session&gt; session, QString target_feature,\n                                 Eigen::MatrixXd target_particles, Direction direction);\n\n  QSharedPointer&lt;Session&gt; session_;\n\n  ParticleShapeStatistics stats_;\n\n  QString target_feature_;\n\n  QPixmap plot_;\n\n  Eigen::MatrixXd all_particles_;\n  Eigen::MatrixXd all_scalars_;\n\n  Eigen::MatrixXd target_values_;\n  Eigen::VectorXd prediction_;\n\n  bool num_components_ = 3;\n  int num_folds_ = 5;\n  int max_components_ = 20;\n\n  Direction direction_{Direction::To_Scalar};\n  JobType job_type_;\n\n  static std::atomic&lt;bool&gt; needs_clear_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeScalarPanel_8h.html","title":"Studio/Analysis/ShapeScalarPanel.h","text":""},{"location":"api/Files/ShapeScalarPanel_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeScalarPanel_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeScalarPanel"},{"location":"api/Files/ShapeScalarPanel_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n\n// Qt\n#include &lt;QSharedPointer&gt;\n#include &lt;QWidget&gt;\n\n// ShapeWorks\n#include &lt;ParticleShapeStatistics.h&gt;\n\n// Studio\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Job/ShapeScalarJob.h&gt;\n#include &lt;Shape.h&gt;\n#include &lt;Visualization/Visualizer.h&gt;\n\nclass Ui_ShapeScalarPanel;\nclass JKQTPlotter;\n\nnamespace shapeworks {\n\nclass Session;\nclass Lightbox;\nclass ShapeWorksStudioApp;\n\nclass ShapeScalarPanel : public QWidget {\n  Q_OBJECT;\n\n public:\n  ShapeScalarPanel(QWidget* parent = 0);\n  ~ShapeScalarPanel();\n\n  void set_session(QSharedPointer&lt;Session&gt; session);\n  void reset();\n\n public Q_SLOTS:\n\n  void run_clicked();\n\n  void handle_job_progress(int progress);\n  void handle_job_complete();\n\n Q_SIGNALS:\n\n  void update_view();\n\n private:\n  void update_run_button();\n\n  void update_graphs();\n\n  QSharedPointer&lt;Session&gt; session_;\n  QSharedPointer&lt;ShapeScalarJob&gt; job_;\n\n  Ui_ShapeScalarPanel* ui_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeWorksStudioApp_8h.html","title":"Studio/Interface/ShapeWorksStudioApp.h","text":""},{"location":"api/Files/ShapeWorksStudioApp_8h.html#namespaces","title":"Namespaces","text":"Name monailabel shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeWorksStudioApp_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeWorksStudioApp Main ShapeWorksStudio window."},{"location":"api/Files/ShapeWorksStudioApp_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/PreferencesWindow.h&gt;\n#include &lt;Data/Telemetry.h&gt;\n#include &lt;Interface/CustomSlider.h&gt;\n#include &lt;Interface/LogWindow.h&gt;\n#include &lt;Interface/StudioLogger.h&gt;\n#include &lt;Interface/UpdateChecker.h&gt;\n#include &lt;Libs/Application/ShapeWorksVtkOutputWindow.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;QActionGroup&gt;\n#include &lt;QCheckBox&gt;\n#include &lt;QDoubleSpinBox&gt;\n#include &lt;QElapsedTimer&gt;\n#include &lt;QErrorMessage&gt;\n#include &lt;QLabel&gt;\n#include &lt;QMainWindow&gt;\n#include &lt;QPointer&gt;\n#include &lt;QProgressBar&gt;\n#include &lt;QSpinBox&gt;\n#include &lt;QTimer&gt;\n\n// Forward Qt class declarations\nclass Ui_ShapeWorksStudioApp;\n\nnamespace monailabel {\nclass MonaiLabelTool;\n}\n\nnamespace shapeworks {\nclass Lightbox;\nclass DataTool;\nclass GroomTool;\nclass OptimizeTool;\nclass AnalysisTool;\nclass DeepSSMTool;\nclass Session;\nclass Visualizer;\nclass SplashScreen;\nclass WheelEventForwarder;\nclass StatusBarWidget;\nclass PythonWorker;\nclass CompareWidget;\n\n\nclass ShapeWorksStudioApp : public QMainWindow {\n  Q_OBJECT\n public:\n  ShapeWorksStudioApp();\n  ~ShapeWorksStudioApp();\n\n  void closeEvent(QCloseEvent* event) override;\n\n  void initialize_vtk();\n  void import_files(QStringList file_names);\n\n public Q_SLOTS:\n\n  void open_project(QString filename);\n\n  void on_action_new_project_triggered();\n  void on_action_open_project_triggered();\n  void on_action_show_project_folder_triggered();\n  bool on_action_save_project_triggered();\n  bool save_project_as(QString type);\n  void save_as_swproj_clicked();\n  void save_as_xlsx_clicked();\n  void on_action_quit_triggered();\n  void on_action_import_triggered();\n  void splash_screen_closed();\n\n  void on_vertical_scroll_bar_valueChanged();\n\n  void on_action_import_mode_triggered();\n  void on_action_groom_mode_triggered();\n  void on_action_optimize_mode_triggered();\n  void on_action_analysis_mode_triggered();\n  void on_action_deepssm_mode_triggered();\n  void on_action_monai_mode_triggered();\n  void on_actionShow_Tool_Window_triggered();\n  void on_actionExport_PCA_Mesh_triggered();\n  void on_actionExport_Eigenvalues_triggered();\n  void on_actionExport_Eigenvectors_triggered();\n  void on_actionExport_PCA_Mode_Points_triggered();\n  void on_action_preferences_triggered();\n  void action_export_current_mesh_triggered(int index = 0, bool clip_constraints = false);\n  void on_action_export_current_particles_triggered();\n  void on_action_export_mesh_scalars_triggered();\n  void on_action_export_pca_scores_triggered();\n  void action_export_pca_montage_triggered();\n  void action_export_screenshot_triggered();\n  void action_export_particle_scalars_triggered();\n  void action_export_all_subjects_particle_scalars_triggered();\n\n  void on_center_checkbox_stateChanged();\n  void on_zoom_slider_valueChanged();\n  void on_view_mode_combobox_currentIndexChanged(QString disp_mode);\n  void on_auto_view_button_clicked();\n\n  void handle_pca_changed();\n  void handle_slider_update();\n\n  void handle_mca_changed();\n\n  void handle_project_changed();\n  void handle_points_changed();\n  void handle_groom_start();\n  void handle_groom_complete();\n  void handle_optimize_start();\n  void handle_optimize_complete();\n  void handle_reconstruction_complete();\n  void handle_reset_stats();\n\n  void handle_display_setting_changed();\n  void handle_glyph_changed();\n  void handle_opacity_changed();\n\n  void handle_alignment_changed();\n  void handle_open_recent();\n\n  void handle_color_scheme();\n  void handle_pca_update();\n  void clear_message();\n\n  // callbacks from logger\n  void handle_message(std::string str);\n  void handle_error(std::string str);\n  void handle_warning(std::string str);\n  void handle_debug(std::string str);\n  void handle_status(std::string str);\n  void handle_progress_with_message(int amt, std::string str);\n  void handle_progress(int amt);\n\n  void message_callback(std::string str);\n  void handle_new_mesh();\n  void handle_clear_cache();\n  void handle_compare_settings_changed();\n\n  void handle_lightbox_right_click(int index);\n\n  void update_feature_map_selection(int index);\n  void update_feature_map_scale();\n\n  void image_combo_changed(int index);\n  void handle_image_name_changed();\n\n  void show_splash_screen();\n  void hide_splash_screen();\n  void about();\n  void keyboard_shortcuts();\n\n  void toggle_log_window();\n\n  QSharedPointer&lt;PythonWorker&gt; get_py_worker();\n\n  Preferences&amp; prefs() { return preferences_; }\n  QSharedPointer&lt;Session&gt; session() { return session_; }\n\n  QSharedPointer&lt;Visualizer&gt; get_visualizer() { return visualizer_; }\n\n protected:\n  void dragEnterEvent(QDragEnterEvent* event) override;\n  void dragLeaveEvent(QDragLeaveEvent* event) override;\n  void dropEvent(QDropEvent* event) override;\n\n private:\n  void new_session();\n  void update_tool_mode();\n  void update_view_mode();\n  void reset_num_viewers();\n\n  void update_view_combo();\n  void update_compare_menu();\n\n  bool should_reconstruct_view_show();\n\n  static bool write_particle_file(std::string filename, Eigen::VectorXd particles);\n\n  static const std::string SETTING_ZOOM_C;\n\n  void set_view_combo_item_enabled(int item, bool value);\n  bool is_view_combo_item_enabled(int item);\n\n  void disable_all_actions();\n\n  void enable_possible_actions();\n\n  void update_from_preferences();\n\n  void update_scrollbar();\n\n  void update_table();\n\n  void update_display(bool force = false);\n\n  void display_mode_shape();\n\n  bool get_feature_uniform_scale();\n  void set_feature_uniform_scale(bool value);\n\n  void update_recent_files();\n  void update_alignment_options();\n\n  void save_project(QString filename);\n\n  bool write_scalars(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, QString filename);\n\n  void set_message(MessageType message_type, QString message);\n\n  void create_glyph_submenu();\n  void create_iso_submenu();\n  void create_compare_submenu();\n\n  void update_window_title();\n\n  Ui_ShapeWorksStudioApp* ui_;\n\n  QActionGroup* action_group_ = nullptr;\n\n  QSharedPointer&lt;Lightbox&gt; lightbox_;\n  QSharedPointer&lt;DataTool&gt; data_tool_;\n  QSharedPointer&lt;GroomTool&gt; groom_tool_;\n  QSharedPointer&lt;OptimizeTool&gt; optimize_tool_;\n  QSharedPointer&lt;AnalysisTool&gt; analysis_tool_;\n  QSharedPointer&lt;DeepSSMTool&gt; deepssm_tool_;\n  QSharedPointer&lt;monailabel::MonaiLabelTool&gt; monai_tool_;\n  QSharedPointer&lt;Visualizer&gt; visualizer_;\n  QSharedPointer&lt;PreferencesWindow&gt; preferences_window_;\n  CompareWidget* compare_widget_ = nullptr;\n  vtkSmartPointer&lt;ShapeWorksVtkOutputWindow&gt; studio_vtk_output_window_;\n\n  // all the preferences\n  Preferences preferences_;\n\n  QSharedPointer&lt;Session&gt; session_;\n  QSharedPointer&lt;WheelEventForwarder&gt; wheel_event_forwarder_;\n\n  // programmatic UI elements\n  CustomSlider* glyph_size_slider_;\n  CustomSlider* glyph_quality_slider_;\n  QLabel* glyph_size_label_;\n  QLabel* glyph_quality_label_;\n  QCheckBox* glyph_auto_size_;\n  QCheckBox* glyph_arrow_scale_{nullptr};\n  QList&lt;QAction*&gt; recent_file_actions_;\n  LogWindow log_window_;\n  QPointer&lt;StatusBarWidget&gt; status_bar_;\n  QSharedPointer&lt;shapeworks::SplashScreen&gt; splash_screen_;\n  QErrorMessage error_message_dialog_;\n  std::vector&lt;CustomSlider*&gt; iso_opacity_sliders_;\n  std::vector&lt;QCheckBox*&gt; domain_particle_checkboxes_;\n\n  QString current_message_;\n\n  std::string current_display_mode_;\n\n  bool block_update_{false};\n\n  QElapsedTimer time_since_last_update_;\n  qint64 last_render_ = -1;\n\n  QStringList current_features_;\n  QStringList current_image_list_;\n\n  QSharedPointer&lt;PythonWorker&gt; py_worker_;\n\n  StudioLogger logger_;\n  UpdateChecker update_checker_{preferences_};\n  Telemetry telemetry_{preferences_};\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/ShapeWorksVtkOutputWindow_8h.html","title":"Libs/Application/ShapeWorksVtkOutputWindow.h","text":""},{"location":"api/Files/ShapeWorksVtkOutputWindow_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeWorksVtkOutputWindow_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeWorksVtkOutputWindow Implementation of vtkOutputWindow to capture and display VTK error messages."},{"location":"api/Files/ShapeWorksVtkOutputWindow_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkOutputWindow.h&gt;\n\n#include &lt;QObject&gt;\n\nnamespace shapeworks {\n\nclass ShapeWorksVtkOutputWindow : public QObject, public vtkOutputWindow {\n  Q_OBJECT;\n\n public:\n  static ShapeWorksVtkOutputWindow* New();\n\n  vtkTypeMacro(ShapeWorksVtkOutputWindow, vtkOutputWindow);\n\n  ShapeWorksVtkOutputWindow();\n\n  void DisplayErrorText(const char* text) override;\n  void DisplayWarningText(const char* text) override;\n  void DisplayGenericWarningText(const char* text) override;\n  void DisplayDebugText(const char* text) override;\n private:\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ShapeWorksWorker_8h.html","title":"Studio/Data/ShapeWorksWorker.h","text":""},{"location":"api/Files/ShapeWorksWorker_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeWorksWorker_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeworksWorker"},{"location":"api/Files/ShapeWorksWorker_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QObject&gt;\n\n#include &lt;Data/Session.h&gt;\n\nnamespace shapeworks {\nclass Optimize;\nclass Groom;\nclass OptimizeParameters;\n\nclass ShapeworksWorker : public QObject {\nQ_OBJECT\n\npublic:\n  enum ThreadType {\n    GroomType, OptimizeType, ReconstructType\n  };\n\n  ShapeworksWorker(ThreadType type,\n                   QSharedPointer&lt;Groom&gt; groom,\n                   QSharedPointer&lt;Optimize&gt; optimize,\n                   QSharedPointer&lt;OptimizeParameters&gt; optimize_parameters,\n                   QSharedPointer&lt;Session&gt; session,\n                   double maxAngle = 45.,\n                   float decimationPercent = 0.3f,\n                   int numClusters = 5);\n  ~ShapeworksWorker();\n\npublic Q_SLOTS:\n  void process();\n\nQ_SIGNALS:\n  void result_ready();\n  void failure();\n  void finished();\n\nprivate:\n\n  QSharedPointer&lt;Groom&gt; groom_;\n  QSharedPointer&lt;Optimize&gt; optimize_;\n  QSharedPointer&lt;OptimizeParameters&gt; optimize_parameters_;\n  QSharedPointer&lt;Session&gt; session_;\n  ThreadType type_;\n  float decimation_percent_;\n  double max_angle_;\n  int num_clusters_;\n};\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Shape_8h.html","title":"Libs/Analyze/Shape.h","text":""},{"location":"api/Files/Shape_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Shape_8h.html#classes","title":"Classes","text":"Name class shapeworks::Shape Representation of a single shape/patient/subject. class shapeworks::Shape::Point TODO: replace this wherever it is used."},{"location":"api/Files/Shape_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkMatrixOffsetTransformBase.h&gt;\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n#include &lt;string&gt;\n\n// studio\n#include \"MeshGroup.h\"\n#include \"MeshManager.h\"\n#include \"StudioEnums.h\"\n#include \"StudioMesh.h\"\n\n// shapeworks\n#include &lt;Analyze/Particles.h&gt;\n#include &lt;Libs/Optimize/Constraints/Constraints.h&gt;\n#include &lt;Project/Subject.h&gt;\n\nnamespace shapeworks {\n\nclass Shape;\nusing ShapeHandle = std::shared_ptr&lt;Shape&gt;;\nusing ShapeList = std::vector&lt;ShapeHandle&gt;;\nclass Surface;\n\nclass Shape {\n public:\n  class Point {\n   public:\n    Point(){};\n    Point(double _x, double _y, double _z) : x(_x), y(_y), z(_z){};\n    double x = 0, y = 0, z = 0;\n  };\n\n  Shape();\n\n  ~Shape();\n\n  std::string get_display_name();\n\n  MeshGroup get_meshes(DisplayMode display_mode, bool wait = false);\n\n  void set_annotations(std::vector&lt;std::string&gt; annotations, bool only_overwrite_blank = true);\n  std::vector&lt;std::string&gt; get_annotations();\n\n  void set_mesh_manager(std::shared_ptr&lt;MeshManager&gt; mesh_manager);\n\n  void set_subject(std::shared_ptr&lt;shapeworks::Subject&gt; subject);\n\n  bool is_subject();\n\n  std::shared_ptr&lt;shapeworks::Subject&gt; get_subject();\n\n  bool is_fixed();\n\n  bool is_excluded();\n\n  void import_original_file(const std::string&amp; filename);\n\n  MeshGroup get_original_meshes(bool wait = false);\n\n  MeshGroup get_groomed_meshes(bool wait = false);\n\n  MeshGroup get_reconstructed_meshes(bool wait = false);\n\n  void set_reconstructed_meshes(MeshGroup meshes);\n\n  void reset_groomed_mesh();\n\n  bool import_global_point_files(std::vector&lt;std::string&gt; filenames);\n\n  bool import_local_point_files(std::vector&lt;std::string&gt; filenames);\n\n  bool import_landmarks_files(std::vector&lt;std::string&gt; filenames);\n\n  bool store_landmarks();\n\n  bool import_constraints(std::vector&lt;std::string&gt; filenames);\n\n  bool store_constraints();\n\n  void set_particles(Particles particles);\n\n  Particles get_particles();\n\n  void set_particle_transform(vtkSmartPointer&lt;vtkTransform&gt; transform);\n\n  void set_alignment_type(int alignment);\n\n  Eigen::VectorXd get_global_correspondence_points();\n\n  std::vector&lt;Eigen::VectorXd&gt; get_particles_for_display();\n\n  Eigen::VectorXd get_local_correspondence_points();\n\n  void clear_reconstructed_mesh();\n\n  int get_id();\n\n  void set_id(int id);\n\n  void update_annotations();\n\n  std::vector&lt;std::string&gt; get_original_filenames();\n  std::vector&lt;std::string&gt; get_original_filenames_with_path();\n\n  std::string get_original_filename();\n  std::string get_original_filename_with_path();\n\n  std::string get_groomed_filename();\n  std::string get_groomed_filename_with_path(int domain);\n\n  std::string get_global_point_filename();\n  std::string get_global_point_filename_with_path();\n\n  std::string get_local_point_filename();\n  std::string get_local_point_filename_with_path();\n\n  void set_transform(vtkSmartPointer&lt;vtkTransform&gt; transform);\n  vtkSmartPointer&lt;vtkTransform&gt; get_transform(int domain = 0);\n  vtkSmartPointer&lt;vtkTransform&gt; get_inverse_transform(int domain = 0);\n\n  bool has_alignment();\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_original_transform(int domain = 0);\n\n  void set_reconstruction_transforms(std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt; transforms);\n  vtkSmartPointer&lt;vtkTransform&gt; get_reconstruction_transform(int domain);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_groomed_transform(int domain = 0);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_procrustes_transform(int domain = 0);\n  std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt; get_procrustes_transforms();\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_alignment(int domain = 0);\n\n  void load_feature(DisplayMode display_mode, std::string feature);\n\n  std::shared_ptr&lt;Image&gt; get_image_volume(std::string image_volume_name);\n\n  std::shared_ptr&lt;Image&gt; get_segmentation();\n  std::string get_segmentation_filename() { return segmentation_filename_; }\n\n  Eigen::VectorXd get_point_features(std::string feature);\n\n  void set_point_features(std::string feature, Eigen::VectorXd values);\n\n  void load_feature_from_scalar_file(std::string filename, std::string feature_name);\n\n  void set_override_feature(std::string feature);\n  std::string get_override_feature();\n\n  Eigen::MatrixXd&amp; landmarks();\n\n  std::vector&lt;Constraints&gt;&amp; constraints();\n\n  Constraints&amp; get_constraints(int domain_id);\n\n  bool has_constraints();\n\n  bool has_planes();\n\n  std::vector&lt;std::shared_ptr&lt;Surface&gt;&gt; get_groomed_mesh_wrappers();\n\n  void recompute_original_surface();\n\n  void ensure_segmentation();\n\n private:\n  void generate_meshes(std::vector&lt;std::string&gt; filenames, MeshGroup&amp; mesh_list, bool save_transform,\n                       bool wait = false);\n\n  static bool import_point_file(std::string filename, Eigen::VectorXd&amp; points);\n\n  void apply_feature_to_points(std::string feature, ImageType::Pointer image);\n  void load_feature_from_mesh(std::string feature, MeshHandle mesh);\n\n  int id_;\n\n  MeshGroup original_meshes_;\n  MeshGroup groomed_meshes_;\n  MeshGroup reconstructed_meshes_;\n  std::vector&lt;std::shared_ptr&lt;Surface&gt;&gt; groomed_mesh_wrappers_;\n\n  std::string override_feature_;\n\n  std::vector&lt;std::string&gt; global_point_filenames_;\n  std::vector&lt;std::string&gt; local_point_filenames_;\n\n  std::map&lt;std::string, Eigen::VectorXd&gt; point_features_;\n  Particles particles_;\n\n  std::shared_ptr&lt;Subject&gt; subject_;\n\n  vtkSmartPointer&lt;vtkTransform&gt; transform_ = vtkSmartPointer&lt;vtkTransform&gt;::New();\n\n  std::vector&lt;vtkSmartPointer&lt;vtkTransform&gt;&gt; reconstruction_transforms_;\n\n  std::vector&lt;std::string&gt; corner_annotations_;\n\n  std::shared_ptr&lt;MeshManager&gt; mesh_manager_;\n\n  Eigen::MatrixXd landmarks_;\n\n  std::shared_ptr&lt;Image&gt; image_volume_;\n  std::string image_volume_filename_;\n\n  std::shared_ptr&lt;Image&gt; segmentation_;\n  std::string segmentation_filename_;\n\n  std::vector&lt;Constraints&gt; constraints_;  // one set for each domain\n  int alignment_type_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/ShapeworksUtils_8h.html","title":"Libs/Common/ShapeworksUtils.h","text":""},{"location":"api/Files/ShapeworksUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/ShapeworksUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::ShapeWorksUtils"},{"location":"api/Files/ShapeworksUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;oneapi/tbb/global_control.h&gt;\n#include &lt;vtkMatrix4x4.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n\n#include \"Shapeworks.h\"\n\nnamespace shapeworks {\n\nclass ShapeWorksUtils {\n  using time_point = std::chrono::time_point&lt;std::chrono::steady_clock&gt;;\n\n public:\n  static time_point now() { return std::chrono::steady_clock::now(); }\n\n  static double elapsed(time_point start, time_point end, bool print_elapsed = true);\n\n  static unsigned get_rng_seed() { return rng_seed_; }\n\n  static void set_rng_seed(const unsigned seed);\n\n  static unsigned get_random_number() { return mt_(); }\n\n  // TODO: in C++17 this is a standard function\n  static bool is_directory(const std::string&amp; pathname);\n\n  // TODO: in C++17 this is a standard function\n  static bool file_exists(const std::string&amp; filename);\n\n  static void setup_console_logging(bool show_progress, bool xml_status);\n\n  static void set_progress_callback(void* ptr);\n\n  static void setup_threads();\n\n  static Matrix33 convert_matrix(const vtkSmartPointer&lt;vtkMatrix4x4&gt;&amp; mat);\n  static Vector3 get_offset(const vtkSmartPointer&lt;vtkMatrix4x4&gt;&amp; mat);\n\n private:\n  static unsigned rng_seed_;\n  static std::mt19937 mt_;\n  static std::unique_ptr&lt;tbb::global_control&gt; tbb_global_control_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Shapeworks_8h.html","title":"Libs/Common/Shapeworks.h","text":""},{"location":"api/Files/Shapeworks_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Shapeworks_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkPoint.h&gt;\n#include &lt;itkVector.h&gt;\n#include &lt;itkCovariantVector.h&gt;\n#include &lt;itkMatrix.h&gt;\n#include &lt;itkSize.h&gt;\n#include &lt;itkIndex.h&gt;\n#include &lt;itkAffineTransform.h&gt;\n#include &lt;itkIdentityTransform.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;vtkTransform.h&gt;\n#include &lt;vtkPlane.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkDoubleArray.h&gt;\n\nnamespace shapeworks {\n\nconst auto Pi = std::atan(1.0) * 4.0;\n\nusing Coord         = itk::Index&lt;3&gt;;\nusing Dims          = itk::Size&lt;3&gt;;\nusing Point3        = itk::Point&lt;double, 3&gt;;\nusing Vector3       = itk::Vector&lt;double, 3&gt;;\nusing Matrix44      = itk::Matrix&lt;double, 4, 4&gt;;\nusing Matrix33      = itk::Matrix&lt;double, 3, 3&gt;;\nusing IPoint3       = itk::Point&lt;int, 3&gt;;\nusing FPoint3       = itk::Point&lt;float, 3&gt;;\nusing Covariant     = itk::CovariantVector&lt;float, 3&gt;;\nusing Vector        = Vector3;\nusing Point         = Point3;\nusing Matrix        = Matrix33;\nusing Plane         = vtkSmartPointer&lt;vtkPlane&gt;;\n\n// While doubles are the most commonly stored items, vtkDataArray can store any\n// type, yet has a default interface that conveniently stores and retrieves\n// doubles. When required, one can convert a vtkDataArray to a vtkDoubleArray\n// explicitly using `dynamic_cast&lt;vtkDoubleArray*&gt;(vtk_data_array)`.\nusing Array         = vtkSmartPointer&lt;vtkDataArray&gt;;\nusing Field         = Array;\nusing PointArray    = std::vector&lt;Point3&gt;;\n\nVector3 makeVector(std::array&lt;double, 3&gt;&amp;&amp; arr);\n\nPointArray makePointArray(int size, Point3 value);\n\nusing GenericTransform   = itk::Transform&lt;double, 3&gt;;\nusing IdentityTransform  = itk::IdentityTransform&lt;double, 3&gt;;\nusing TransformPtr       = GenericTransform::Pointer;\nTransformPtr createTransform(const Matrix33 &amp;mat, const Vector3 &amp;translate = makeVector({0,0,0}));\n\nTransformPtr convert_to_image_transform(vtkSmartPointer&lt;vtkTransform&gt; vtk_transform);\n\nPlane makePlane(const Point &amp;p, const Vector3 &amp;n);\nPlane makePlane(const Point &amp;p0, const Point &amp;p1, const Point &amp;p2);\n\nPoint getOrigin(const Plane plane);\nVector3 getNormal(const Plane plane);\n\nusing AffineTransform    = itk::AffineTransform&lt;double, 3&gt;;\nusing AffineTransformPtr = AffineTransform::Pointer;\n\nusing MeshTransform = vtkSmartPointer&lt;vtkTransform&gt;;\nMeshTransform createMeshTransform(const vtkSmartPointer&lt;vtkMatrix4x4&gt; &amp;mat);\n\nPoint toPoint(const Dims &amp;d);\nPoint toPoint(const Coord &amp;c);\nVector toVector(const Dims &amp;d);\nVector toVector(const Point &amp;p);\nVector toVector(const itk::CovariantVector&lt;double, 3&gt; &amp;v);\nPoint toPoint(const Vector &amp;v);\nCoord toCoord(const Dims &amp;d);\nDims toDims(const Coord &amp;c);\nDims toDims(const Point &amp;p);\nCoord toCoord(const Point &amp;p);\n\ntemplate&lt;typename P&gt;\nP negate(const P &amp;p) { return P({-p[0], -p[1], -p[2]}); }\n\ntemplate&lt;&gt;\nVector3 negate(const Vector3 &amp;v);\n\ntemplate&lt;typename P&gt;\nP invertValue(const P &amp;p) { return P({1.0/p[0], 1.0/p[1], 1.0/p[2]}); }\n\ntemplate&lt;&gt;\nVector3 invertValue(const Vector3 &amp;v);\n\nVector3 dotProduct(const Vector3 &amp;a, const Vector3 &amp;b);\nVector3 crossProduct(const Vector3 &amp;a, const Vector3 &amp;b);\ndouble length(const Vector3 &amp;v);\n\nenum Axis { invalid = -1, X, Y, Z };\nAxis toAxis(const std::string &amp;str);\nstd::string axisToString(Axis axis);\n\nbool axis_is_valid(const Vector3 &amp;axis);\nbool axis_is_valid(const Axis &amp;axis);\n\ndouble degToRad(const double deg);\n\ndouble mean(const Field field);\n\ndouble stddev(const Field field);\n\nstd::vector&lt;double&gt; range(const Field field);\n\nclass Image;\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator+(const P &amp;p, const P &amp;q)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] + q[i];\n  return ret;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator-(const P &amp;p, const P &amp;q)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] - q[i];\n  return ret;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Vector, P&gt;::value || // use operator*(v0, v1); (or call dotProduct)\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator*(const P &amp;p, const P &amp;q)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] * q[i];\n  return ret;\n}\n\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Vector, P&gt;::value || // use operator/(v0, v1); \n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator/(const P &amp;p, const P &amp;q)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] / q[i];\n  return ret;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP&amp; operator+=(P &amp;p, const P &amp;q)\n{\n  for (unsigned i = 0; i &lt; 3; i++)\n    p[i] += q[i];\n  return p;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP&amp; operator-=(P &amp;p, const P &amp;q)\n{\n  for (unsigned i = 0; i &lt; 3; i++)\n    p[i] -= q[i];\n  return p;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator*(const P &amp;p, const double x)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] * x;\n  return std::move(ret);\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP operator/(const P &amp;p, const double x)\n{\n  P ret;\n  for (unsigned i = 0; i &lt; 3; i++)\n    ret[i] = p[i] / x;\n  return std::move(ret);\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP&amp; operator*=(P &amp;p, const double x)\n{\n  for (unsigned i = 0; i &lt; 3; i++)\n    p[i] *= x;\n  return p;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nP&amp; operator/=(P &amp;p, const double x)\n{\n  for (unsigned i = 0; i &lt; 3; i++)\n    p[i] /= x;\n  return p;\n}\n\ntemplate&lt;typename T&gt;\nbool epsEqual(T a, T b, T epsilon)\n{\n  return std::abs(a-b) &lt; epsilon;\n}\n\ntemplate&lt;typename P, typename = std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||\n                                                 std::is_same&lt;Coord, P&gt;::value ||\n                                                 std::is_same&lt;Dims, P&gt;::value ||\n                                                 std::is_same&lt;Vector, P&gt;::value ||\n                                                 std::is_same&lt;Point, P&gt;::value ||\n                                                 std::is_same&lt;IPoint3, P&gt;::value ||\n                                                 std::is_same&lt;FPoint3, P&gt;::value&gt; &gt;\nbool epsEqual(const P &amp;a, const P &amp;b, const typename P::ValueType &amp;eps)\n{\n  return std::abs(a[0]-b[0]) &lt; eps &amp;&amp; std::abs(a[1]-b[1]) &lt; eps &amp;&amp; std::abs(a[2]-b[2]) &lt; eps;\n}\n\nbool epsEqual(double a, double b, double eps);\n\ntemplate&lt;typename T&gt;\nT clamp(T value, T min, T max) {\n  value = std::min&lt;T&gt;(value, max);\n  value = std::max&lt;T&gt;(value, min);\n  return value;\n}\n\n} // shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/SharedCommandData_8h.html","title":"Applications/shapeworks/SharedCommandData.h","text":""},{"location":"api/Files/SharedCommandData_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/SharedCommandData_8h.html#classes","title":"Classes","text":"Name struct shapeworks::SharedCommandData"},{"location":"api/Files/SharedCommandData_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n\n#include \"Image.h\"\n#include \"Mesh.h\"\n#include \"ParticleSystemEvaluation.h\"\n#include \"Shapeworks.h\"\n\nnamespace shapeworks {\n\nstruct SharedCommandData\n{\n  Image image;\n  std::unique_ptr&lt;Mesh&gt; mesh;\n  PhysicalRegion region;\n  ParticleSystemEvaluation particleSystem;\n  Field field;\n\n  bool validImage() const { return image.itk_image_ != nullptr; }\n  bool validMesh() const { return mesh != nullptr; }\n  bool validParticleSystem() const {return particleSystem.num_samples() &gt;= 1 &amp;&amp; particleSystem.num_dims() &gt;= 1; }\n};\n\n\n} // shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/SliceView_8h.html","title":"Studio/Visualization/SliceView.h","text":""},{"location":"api/Files/SliceView_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/SliceView_8h.html#classes","title":"Classes","text":"Name class shapeworks::SliceView SliceView."},{"location":"api/Files/SliceView_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Shapeworks.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include \"qcolor.h\"\n\nclass vtkImageActor;\nclass vtkImageSliceMapper;\nclass vtkImageData;\n\nclass vtkPolyData;\nclass vtkPolyDataMapper;\nclass vtkActor;\nclass vtkTransformPolyDataFilter;\nclass vtkCutter;\nclass vtkStripper;\nclass vtkImageActorPointPlacer;\n\nnamespace shapeworks {\n\nclass Viewer;\n\nclass SliceView {\n public:\n  enum SliceChange { Down, Up };\n\n  SliceView(Viewer* viewer);\n\n  void set_volume(std::shared_ptr&lt;Image&gt; volume);\n\n  void add_mesh(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n  void set_mask(std::shared_ptr&lt;Image&gt; mask);\n  void clear_meshes();\n\n  void set_orientation(int orientation);\n\n  bool is_image_loaded();\n\n  void update_colormap();\n  void update_renderer();\n\n  void update_camera();\n\n  Point handle_key(std::string key);\n\n  void change_slice(SliceChange change);\n\n  Point get_slice_position();\n\n  void set_slice_position(Point point);\n\n  void set_brightness_and_contrast(double brightness, double contrast);\n\n  double get_spacing();\n\n  int get_orientation_index();\n\n  void update_particles();\n\n  Viewer* get_viewer();\n\n  bool should_point_show(double x, double y, double z);\n\n  int get_slice_number();\n\n  vtkSmartPointer&lt;vtkImageActor&gt; get_image_actor();\n\n  vtkPlane* get_slice_plane();\n\n  void update();\n\n private:\n  void set_slice_number(int slice);\n\n  void update_extent();\n\n  vtkSmartPointer&lt;vtkActor&gt; create_shape_actor(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, QColor color);\n\n  Viewer* viewer_{nullptr};\n\n  vtkSmartPointer&lt;vtkImageActor&gt; image_slice_;\n  vtkSmartPointer&lt;vtkImageActor&gt; mask_slice_;\n  vtkSmartPointer&lt;vtkImageSliceMapper&gt; slice_mapper_;\n  vtkSmartPointer&lt;vtkImageSliceMapper&gt; mask_mapper_;\n  std::shared_ptr&lt;Image&gt; volume_;\n  std::shared_ptr&lt;Image&gt; mask_volume_;\n\n  vtkSmartPointer&lt;vtkImageData&gt; vtk_volume_;\n  vtkSmartPointer&lt;vtkImageData&gt; vtk_mask_volume_;\n  vtkSmartPointer&lt;vtkImageActorPointPlacer&gt; placer_;\n\n  int current_slice_number_ = 0;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; cut_actors_;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyData&gt;&gt; poly_datas_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/SplashScreen_8h.html","title":"Studio/Interface/SplashScreen.h","text":""},{"location":"api/Files/SplashScreen_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/SplashScreen_8h.html#classes","title":"Classes","text":"Name class shapeworks::SplashScreen"},{"location":"api/Files/SplashScreen_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// qt\n#include &lt;QDialog&gt;\n\n// studio\n#include &lt;Data/Preferences.h&gt;\n\nclass Ui_SplashScreen;\nclass QListWidgetItem;\n\nnamespace shapeworks {\n\nclass SplashScreen : public QDialog {\nQ_OBJECT\n\npublic:\n\n  SplashScreen(QWidget* parent, Preferences&amp; preferences);\n\n  virtual ~SplashScreen();\n\nprivate Q_SLOTS:\n\n  void new_project();\n\n  void open_existing();\n\n  void open_recent();\n\n  void quit();\n\n  void enable_load_recent_button(QListWidgetItem* item);\n\nQ_SIGNALS:\n\n  void open_project(QString file_path);\n\nprivate:\n\n  void resizeEvent(QResizeEvent* event) override;\n\n  void populate_recent_projects();\n\n  Ui_SplashScreen* ui_;\n\n  Preferences&amp; preferences_;\n};\n\n} // end namespace\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StackWalker_8h.html","title":"Studio/Utils/StackWalker.h","text":""},{"location":"api/Files/StackWalker_8h.html#source-code","title":"Source code","text":"<pre><code>#ifdef _WIN32\n\n/**********************************************************************\n * \n * StackWalker.h\n *\n *\n *\n * LICENSE (http://www.opensource.org/licenses/bsd-license.php)\n *\n *   Copyright (c) 2005-2009, Jochen Kalmbach\n *   All rights reserved.\n *\n *   Redistribution and use in source and binary forms, with or without modification, \n *   are permitted provided that the following conditions are met:\n *\n *   Redistributions of source code must retain the above copyright notice, \n *   this list of conditions and the following disclaimer. \n *   Redistributions in binary form must reproduce the above copyright notice, \n *   this list of conditions and the following disclaimer in the documentation \n *   and/or other materials provided with the distribution. \n *   Neither the name of Jochen Kalmbach nor the names of its contributors may be \n *   used to endorse or promote products derived from this software without \n *   specific prior written permission. \n *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n *   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n *   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n *   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE \n *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n *   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; \n *   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND \n *   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS \n *   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * **********************************************************************/\n// #pragma once is supported starting with _MCS_VER 1000, \n// so we need not to check the version (because we only support _MSC_VER &gt;= 1100)!\n#pragma once\n\n#include &lt;windows.h&gt;\n\n// special defines for VC5/6 (if no actual PSDK is installed):\n#if _MSC_VER &lt; 1300\ntypedef unsigned __int64 DWORD64, *PDWORD64;\n#if defined(_WIN64)\ntypedef unsigned __int64 SIZE_T, *PSIZE_T;\n#else\ntypedef unsigned long SIZE_T, *PSIZE_T;\n#endif\n#endif  // _MSC_VER &lt; 1300\n\nclass StackWalkerInternal;  // forward\nclass StackWalker\n{\npublic:\n  typedef enum StackWalkOptions\n  {\n    // No addition info will be retrived \n    // (only the address is available)\n    RetrieveNone = 0,\n\n    // Try to get the symbol-name\n    RetrieveSymbol = 1,\n\n    // Try to get the line for this symbol\n    RetrieveLine = 2,\n\n    // Try to retrieve the module-infos\n    RetrieveModuleInfo = 4,\n\n    // Also retrieve the version for the DLL/EXE\n    RetrieveFileVersion = 8,\n\n    // Contains all the abouve\n    RetrieveVerbose = 0xF,\n\n    // Generate a \"good\" symbol-search-path\n    SymBuildPath = 0x10,\n\n    // Also use the public Microsoft-Symbol-Server\n    SymUseSymSrv = 0x20,\n\n    // Contains all the abouve \"Sym\"-options\n    SymAll = 0x30,\n\n    // Contains all options (default)\n    OptionsAll = 0x3F\n  } StackWalkOptions;\n\n  StackWalker(\n    int options = OptionsAll, // 'int' is by design, to combine the enum-flags\n    LPCSTR szSymPath = NULL, \n    DWORD dwProcessId = GetCurrentProcessId(), \n    HANDLE hProcess = GetCurrentProcess()\n    );\n  StackWalker(DWORD dwProcessId, HANDLE hProcess);\n  virtual ~StackWalker();\n\n  typedef BOOL (__stdcall *PReadProcessMemoryRoutine)(\n    HANDLE      hProcess,\n    DWORD64     qwBaseAddress,\n    PVOID       lpBuffer,\n    DWORD       nSize,\n    LPDWORD     lpNumberOfBytesRead,\n    LPVOID      pUserData  // optional data, which was passed in \"ShowCallstack\"\n    );\n\n  BOOL LoadModules();\n\n  BOOL ShowCallstack(\n    HANDLE hThread = GetCurrentThread(), \n    const CONTEXT *context = NULL, \n    PReadProcessMemoryRoutine readMemoryFunction = NULL,\n    LPVOID pUserData = NULL  // optional to identify some data in the 'readMemoryFunction'-callback\n    );\n\n#if _MSC_VER &gt;= 1300\n// due to some reasons, the \"STACKWALK_MAX_NAMELEN\" must be declared as \"public\" \n// in older compilers in order to use it... starting with VC7 we can declare it as \"protected\"\nprotected:\n#endif\n    enum { STACKWALK_MAX_NAMELEN = 1024 }; // max name length for found symbols\n\nprotected:\n  // Entry for each Callstack-Entry\n  typedef struct CallstackEntry\n  {\n    DWORD64 offset;  // if 0, we have no valid entry\n    CHAR name[STACKWALK_MAX_NAMELEN];\n    CHAR undName[STACKWALK_MAX_NAMELEN];\n    CHAR undFullName[STACKWALK_MAX_NAMELEN];\n    DWORD64 offsetFromSmybol;\n    DWORD offsetFromLine;\n    DWORD lineNumber;\n    CHAR lineFileName[STACKWALK_MAX_NAMELEN];\n    DWORD symType;\n    LPCSTR symTypeString;\n    CHAR moduleName[STACKWALK_MAX_NAMELEN];\n    DWORD64 baseOfImage;\n    CHAR loadedImageName[STACKWALK_MAX_NAMELEN];\n  } CallstackEntry;\n\n  typedef enum CallstackEntryType {firstEntry, nextEntry, lastEntry};\n\n  virtual void OnSymInit(LPCSTR szSearchPath, DWORD symOptions, LPCSTR szUserName);\n  virtual void OnLoadModule(LPCSTR img, LPCSTR mod, DWORD64 baseAddr, DWORD size, DWORD result, LPCSTR symType, LPCSTR pdbName, ULONGLONG fileVersion);\n  virtual void OnCallstackEntry(CallstackEntryType eType, CallstackEntry &amp;entry);\n  virtual void OnDbgHelpErr(LPCSTR szFuncName, DWORD gle, DWORD64 addr);\n  virtual void OnOutput(LPCSTR szText);\n\n  StackWalkerInternal *m_sw;\n  HANDLE m_hProcess;\n  DWORD m_dwProcessId;\n  BOOL m_modulesLoaded;\n  LPSTR m_szSymPath;\n\n  int m_options;\n  int m_MaxRecursionCount;\n\n  static BOOL __stdcall myReadProcMem(HANDLE hProcess, DWORD64 qwBaseAddress, PVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead);\n\n  friend StackWalkerInternal;\n};  // class StackWalker\n\n\n// The \"ugly\" assembler-implementation is needed for systems before XP\n// If you have a new PSDK and you only compile for XP and later, then you can use \n// the \"RtlCaptureContext\"\n// Currently there is no define which determines the PSDK-Version... \n// So we just use the compiler-version (and assumes that the PSDK is \n// the one which was installed by the VS-IDE)\n\n// INFO: If you want, you can use the RtlCaptureContext if you only target XP and later...\n//       But I currently use it in x64/IA64 environments...\n//#if defined(_M_IX86) &amp;&amp; (_WIN32_WINNT &lt;= 0x0500) &amp;&amp; (_MSC_VER &lt; 1400)\n\n#if defined(_M_IX86)\n#ifdef CURRENT_THREAD_VIA_EXCEPTION\n// TODO: The following is not a \"good\" implementation, \n// because the callstack is only valid in the \"__except\" block...\n#define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \\\n  do { \\\n    memset(&amp;c, 0, sizeof(CONTEXT)); \\\n    EXCEPTION_POINTERS *pExp = NULL; \\\n    __try { \\\n      throw 0; \\\n    } __except( ( (pExp = GetExceptionInformation()) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_EXECUTE_HANDLER)) {} \\\n    if (pExp != NULL) \\\n      memcpy(&amp;c, pExp-&gt;ContextRecord, sizeof(CONTEXT)); \\\n      c.ContextFlags = contextFlags; \\\n  } while(0);\n#else\n// The following should be enough for walking the callstack...\n#define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \\\n  do { \\\n    memset(&amp;c, 0, sizeof(CONTEXT)); \\\n    c.ContextFlags = contextFlags; \\\n    __asm    call x \\\n    __asm x: pop eax \\\n    __asm    mov c.Eip, eax \\\n    __asm    mov c.Ebp, ebp \\\n    __asm    mov c.Esp, esp \\\n  } while(0);\n#endif\n\n#else\n\n// The following is defined for x86 (XP and higher), x64 and IA64:\n#define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \\\n  do { \\\n    memset(&amp;c, 0, sizeof(CONTEXT)); \\\n    c.ContextFlags = contextFlags; \\\n    RtlCaptureContext(&amp;c); \\\n} while(0);\n#endif\n\n#endif // win32\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StatsGroupLDAJob_8h.html","title":"Studio/Job/StatsGroupLDAJob.h","text":""},{"location":"api/Files/StatsGroupLDAJob_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StatsGroupLDAJob_8h.html#classes","title":"Classes","text":"Name class shapeworks::StatsGroupLDAJob"},{"location":"api/Files/StatsGroupLDAJob_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;Job/Job.h&gt;\n#include &lt;ParticleShapeStatistics.h&gt;\n\nclass JKQTPlotter;\n\nnamespace shapeworks {\n\nclass StatsGroupLDAJob : public Job {\n  Q_OBJECT\n public:\n  StatsGroupLDAJob();\n\n  void set_stats(ParticleShapeStatistics stats);\n\n  void run() override;\n\n  QString name() override;\n\n  Eigen::VectorXf get_group_pvalues();\n\n  void plot(JKQTPlotter* plot, QString group_1_name, QString group_2_name);\n\n private:\n  ParticleShapeStatistics stats_;\n  Eigen::MatrixXd group1_x_, group2_x_, group1_pdf_, group2_pdf_, group1_map_, group2_map_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StatusBarWidget_8h.html","title":"Studio/Interface/StatusBarWidget.h","text":""},{"location":"api/Files/StatusBarWidget_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StatusBarWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::StatusBarWidget StatusBarWidget."},{"location":"api/Files/StatusBarWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QMainWindow&gt;\n\n// Forward Qt class declarations\nclass Ui_StatusBarWidget;\n\nnamespace shapeworks {\n\nenum class MessageType { normal, warning, error, debug };\n\n\nclass StatusBarWidget : public QWidget {\n  Q_OBJECT\n\n public:\n  StatusBarWidget(QMainWindow* parent = 0);\n\n  void set_message(MessageType message_type, QString message);\n  void set_progress(int value);\n\n  void resizeEvent(QResizeEvent* event) override;\n\n Q_SIGNALS:\n  void toggle_log_window();\n\n private:\n  void update_layout();\n\n  Ui_StatusBarWidget* ui_;\n\n  QStatusBar* q_status_bar_;\n\n  QIcon normal_message_icon_;\n  QIcon warning_message_icon_;\n  QIcon error_message_icon_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StringUtils_8h.html","title":"Libs/Utils/StringUtils.h","text":""},{"location":"api/Files/StringUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StringUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::StringUtils String utility functions."},{"location":"api/Files/StringUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace shapeworks {\n\nclass StringUtils {\n public:\n  static std::string removeExtension(std::string const&amp; filename);\n  static std::string getPath(std::string const&amp; filename);\n  static std::string getFilename(std::string const&amp; pathname);\n  static std::string getBaseFilenameWithoutExtension(std::string const&amp; pathname);\n  static std::string toLower(std::string s);\n  static bool hasSuffix(std::string const&amp; filename, std::string const&amp; suffix);\n  static std::vector&lt;std::string&gt; getFileNamesFromPaths(const std::vector&lt;std::string&gt;&amp; paths);\n\n  static std::string getLowerExtension(std::string const&amp; filename);\n\n  // safely convert a const char* to string, allowing for nullptr\n  static std::string safeString(const char* s) { return s == nullptr ? std::string() : s; }\n\n  static std::string replace_string(std::string str, const std::string&amp; search, const std::string&amp; replace);\n\n  static std::string join(const std::vector&lt;std::string&gt;&amp; strings, const std::string&amp; delimiter);\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioEnums_8h.html","title":"Libs/Analyze/StudioEnums.h","text":""},{"location":"api/Files/StudioEnums_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioEnums_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n\nnamespace shapeworks {\n\n//-----------------------------------------------------------------------------\nenum DisplayMode { Original = 0, Groomed = 1, Reconstructed = 2 };\n\n//-----------------------------------------------------------------------------\nstd::string display_mode_to_string(DisplayMode display_mode);\n\n//-----------------------------------------------------------------------------\nDisplayMode string_to_display_mode(std::string str);\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/StudioHandleWidget_8h.html","title":"Studio/Visualization/StudioHandleWidget.h","text":""},{"location":"api/Files/StudioHandleWidget_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioHandleWidget_8h.html#classes","title":"Classes","text":"Name class shapeworks::StudioHandleWidget"},{"location":"api/Files/StudioHandleWidget_8h.html#source-code","title":"Source code","text":"<pre><code>#include &lt;vtkHandleWidget.h&gt;\n\nnamespace shapeworks {\nclass PlaneWidget;\n\nclass StudioHandleWidget : public vtkHandleWidget {\n public:\n  static StudioHandleWidget *New();\n\n  StudioHandleWidget();\n\n  void set_domain(int domain) { domain_ = domain; };\n  void set_plane(int plane) { plane_ = plane; };\n  void set_point(int point) { point_ = point; };\n\n  void set_plane_widget(PlaneWidget *plane_widget) { plane_widget_ = plane_widget; }\n\n protected:\n  static void RightClickSelectAction(vtkAbstractWidget *w);\n\n  static void CustomMoveAction(vtkAbstractWidget *w);\n  static void CustomSelectAction(vtkAbstractWidget *w);\n  static void CustomEndSelectAction(vtkAbstractWidget *w);\n\n  int domain_ = -1;\n  int plane_ = -1;\n  int point_ = -1;\n  PlaneWidget *plane_widget_;\n\n  bool shift_active_ = false;\n  int start_y_ = 0;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioImageActorPointPlacer_8h.html","title":"Studio/Visualization/StudioImageActorPointPlacer.h","text":""},{"location":"api/Files/StudioImageActorPointPlacer_8h.html#classes","title":"Classes","text":"Name class StudioImageActorPointPlacer"},{"location":"api/Files/StudioImageActorPointPlacer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"vtkImageActorPointPlacer.h\"\n\nclass StudioImageActorPointPlacer : public vtkImageActorPointPlacer {\n public:\n  static StudioImageActorPointPlacer* New();\n  vtkTypeMacro(StudioImageActorPointPlacer, vtkImageActorPointPlacer);\n  void PrintSelf(ostream&amp; os, vtkIndent indent) override;\n\n  // Override ComputeWorldPosition to take transform into account\n  int ComputeWorldPosition(vtkRenderer* renderer, double displayPos[2], double worldPos[3],\n                           double worldOrient[9]) override;\n\n  // Override ValidateWorldPosition\n  int ValidateWorldPosition(double worldPos[3]) override;\n\n  // Override UpdateWorldPosition\n  int UpdateWorldPosition(vtkRenderer* renderer, double worldPos[3], double worldOrient[9]) override;\n\n protected:\n  StudioImageActorPointPlacer();\n  ~StudioImageActorPointPlacer() override;\n\n private:\n  StudioImageActorPointPlacer(const StudioImageActorPointPlacer&amp;) = delete;\n  void operator=(const StudioImageActorPointPlacer&amp;) = delete;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioInteractorStyle_8h.html","title":"Studio/Visualization/StudioInteractorStyle.h","text":""},{"location":"api/Files/StudioInteractorStyle_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioInteractorStyle_8h.html#classes","title":"Classes","text":"Name class shapeworks::StudioInteractorStyle"},{"location":"api/Files/StudioInteractorStyle_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkInteractorStyleTrackballCamera.h&gt;\n#include &lt;vtkPropPicker.h&gt;\n#include &lt;vtkRenderWindowInteractor.h&gt;\n\nnamespace shapeworks {\n\nclass Lightbox;\n\n// Handle mouse events\nclass StudioInteractorStyle : public vtkInteractorStyleTrackballCamera {\n public:\n  static StudioInteractorStyle* New();\n  vtkTypeMacro(StudioInteractorStyle, vtkInteractorStyleTrackballCamera);\n\n  void set_lightbox(Lightbox* lightbox);\n\n  StudioInteractorStyle();\n\n  virtual ~StudioInteractorStyle();\n\n  void OnLeftButtonDown() override;\n  void OnRightButtonDown() override;\n  void OnRightButtonUp() override;\n\n  void OnMouseWheelForward() override;\n  void OnMouseWheelBackward() override;\n\n  void OnKeyDown() override;\n  void Dolly() override;\n\n  void Rotate() override;\n\n  void OnMouseMove() override;\n\n protected:\n  void Dolly(double factor) override;\n\n private:\n  Lightbox* lightbox_;\n  bool right_click_dragged_{false};\n  bool right_button_down_{false};\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioLogger_8h.html","title":"Studio/Interface/StudioLogger.h","text":""},{"location":"api/Files/StudioLogger_8h.html#classes","title":"Classes","text":"Name class StudioLogger Handle logger callbacks via Qt for thread correctness."},{"location":"api/Files/StudioLogger_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QObject&gt;\n\nclass StudioLogger : public QObject {\n  Q_OBJECT\n\n public:\n  StudioLogger() {}\n  virtual ~StudioLogger();\n\n  void register_callbacks();\n\n  // callbacks from logger\n  void handle_message(std::string str);\n  void handle_error(std::string str);\n  void handle_warning(std::string str);\n  void handle_debug(std::string str);\n  void handle_status(std::string str);\n  void handle_progress(double value, std::string str);\n\n Q_SIGNALS:\n  void message(std::string str);\n  void error(std::string str);\n  void warning(std::string str);\n  void debug(std::string str);\n  void status(std::string str);\n  void progress(int value, std::string str);\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioMesh_8h.html","title":"Libs/Analyze/StudioMesh.h","text":""},{"location":"api/Files/StudioMesh_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioMesh_8h.html#classes","title":"Classes","text":"Name class shapeworks::StudioMesh Representation of a single mesh."},{"location":"api/Files/StudioMesh_8h.html#types","title":"Types","text":"Name using float PixelType using itk::Image&lt; PixelType, 3 &gt; ImageType"},{"location":"api/Files/StudioMesh_8h.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/StudioMesh_8h.html#using-pixeltype","title":"using PixelType","text":"<pre><code>using PixelType =  float;\n</code></pre>"},{"location":"api/Files/StudioMesh_8h.html#using-imagetype","title":"using ImageType","text":"<pre><code>using ImageType =  itk::Image&lt;PixelType, 3&gt;;\n</code></pre>"},{"location":"api/Files/StudioMesh_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Libs/Mesh/Mesh.h&gt;\n#include &lt;itkImage.h&gt;\n#include &lt;vnl/vnl_vector.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;vtkTransform.h&gt;\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n\nusing PixelType = float;\nusing ImageType = itk::Image&lt;PixelType, 3&gt;;\nclass vtkFloatArray;\nclass vtkStaticPointLocator;\n\nnamespace shapeworks {\n\nclass StudioMesh;\nusing MeshHandle = std::shared_ptr&lt;StudioMesh&gt;;\nusing MeshList = std::vector&lt;MeshHandle&gt;;\n\n\nclass StudioMesh {\n public:\n  StudioMesh();\n\n  ~StudioMesh();\n\n  vtkSmartPointer&lt;vtkPolyData&gt; get_poly_data();\n\n  void set_poly_data(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n\n  void set_error_message(std::string error_message);\n\n  std::string get_error_message();\n\n  void apply_feature_map(std::string name, ImageType::Pointer image);\n\n  void apply_scalars(MeshHandle mesh);\n\n  void interpolate_scalars_to_mesh(std::string name, Eigen::VectorXd positions, Eigen::VectorXd scalar_values);\n\n  double get_largest_dimension_size();\n\n  vtkFloatArray* get_or_create_array(std::string name, float default_value);\n\n  void paint_ffc(double world_pos[], double radius, bool inclusive);\n\n  void fill_ffc(bool inclusive);\n\n  bool has_ffc_paint();\n\n  Mesh get_sw_mesh();\n\n  static constexpr const char* const FFC_PAINT = \"ffc_paint\";\n\n private:\n  vtkSmartPointer&lt;vtkPolyData&gt; poly_data_;\n\n  vtkSmartPointer&lt;vtkStaticPointLocator&gt; locator_;\n\n  // error message if the polydata didn't load\n  std::string error_message_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/StudioSliceInteractorStyle_8h.html","title":"Studio/Visualization/StudioSliceInteractorStyle.h","text":""},{"location":"api/Files/StudioSliceInteractorStyle_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioSliceInteractorStyle_8h.html#classes","title":"Classes","text":"Name class shapeworks::StudioSliceInteractorStyle"},{"location":"api/Files/StudioSliceInteractorStyle_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vtkInteractorStyleImage.h&gt;\n#include &lt;vtkPropPicker.h&gt;\n#include &lt;vtkRenderWindowInteractor.h&gt;\n\nclass vtkImageActor;\nclass vtkImageSlice;\n\nnamespace shapeworks {\n\nclass Lightbox;\n\n// Handle mouse events\nclass StudioSliceInteractorStyle : public vtkInteractorStyleImage {\n public:\n  static StudioSliceInteractorStyle* New();\n  vtkTypeMacro(StudioSliceInteractorStyle, vtkInteractorStyleImage);\n\n  void set_lightbox(Lightbox* lightbox);\n\n  StudioSliceInteractorStyle();\n\n  virtual ~StudioSliceInteractorStyle();\n\n  void OnLeftButtonDown() override;\n  void OnRightButtonDown() override;\n  void OnMouseWheelForward() override;\n  void OnMouseWheelBackward() override;\n  void OnKeyDown() override;\n  void WindowLevel() override;\n  void StartWindowLevel() override;\n\n protected:\n private:\n  Lightbox* lightbox_;\n  vtkImageSlice* current_image_slice_{nullptr};\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/StudioUtils_8h.html","title":"Studio/Utils/StudioUtils.h","text":""},{"location":"api/Files/StudioUtils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/StudioUtils_8h.html#classes","title":"Classes","text":"Name class shapeworks::StudioUtils Utilities for Studio."},{"location":"api/Files/StudioUtils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Project/Project.h&gt;\nclass QWidget;\n\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;QImage&gt;\n#include &lt;QStringList&gt;\n\nclass vtkImageData;\nclass vtkRenderer;\nclass QComboBox;\n\nnamespace shapeworks {\n\nclass Session;\n\nclass StudioUtils {\n public:\n  static bool ask_multiple_domains_as_single(QWidget* parent, std::shared_ptr&lt;Project&gt; project);\n\n  static QStringList to_string_list(std::vector&lt;std::string&gt; vector);\n\n  static QImage vtk_image_to_qimage(vtkSmartPointer&lt;vtkImageData&gt; image_data);\n\n  static vtkSmartPointer&lt;vtkPolyData&gt; reverse_poly_data(vtkSmartPointer&lt;vtkPolyData&gt; poly_data);\n\n  static QString get_platform_string();\n\n  static void add_viewport_border(vtkRenderer* renderer, double* color, double line_width = 6.0);\n\n  static bool write_mesh(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, QString filename);\n\n  static void brightness_contrast_to_window_width_level(double brightness, double contrast, double min_intensity,\n                                                        double max_intensity, double&amp; window_width,\n                                                        double&amp; window_level);\n\n  static void window_width_level_to_brightness_contrast(double window_width, double window_level, double min_intensity,\n                                                        double max_intensity, double&amp; brightness, double&amp; contrast);\n\n  static void update_domain_combobox(QComboBox* combobox, QSharedPointer&lt;Session&gt; session,\n                                     const std::vector&lt;QString&gt;&amp; filters = {});\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Style_8h.html","title":"Studio/Interface/Style.h","text":""},{"location":"api/Files/Style_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Style_8h.html#classes","title":"Classes","text":"Name class shapeworks::Style"},{"location":"api/Files/Style_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nclass QPushButton;\n\nnamespace shapeworks {\n\nclass Style\n{\npublic:\n  Style();\n\n  static void apply_normal_button_style(QPushButton *button);\n  static void apply_abort_button_style(QPushButton *button);\n};\n\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Subject_8h.html","title":"Libs/Project/Subject.h","text":""},{"location":"api/Files/Subject_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Subject_8h.html#classes","title":"Classes","text":"Name class shapeworks::Subject Representation of a single subject."},{"location":"api/Files/Subject_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Libs/Optimize/Domain/DomainType.h&gt;\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"ProjectUtils.h\"\n\nnamespace shapeworks {\n\n\nclass Subject {\n public:\n  using StringMap = project::types::StringMap;\n  using StringList = project::types::StringList;\n\n  Subject();\n  ~Subject();\n\n  void set_original_filenames(StringList filenames);\n  StringList get_original_filenames();\n\n  void set_groomed_filenames(StringList filenames);\n  StringList get_groomed_filenames();\n\n  void set_local_particle_filenames(StringList filenames);\n  StringList get_local_particle_filenames();\n\n  void set_world_particle_filenames(StringList filenames);\n  StringList get_world_particle_filenames();\n\n  void set_landmarks_filenames(StringList filenames);\n  StringList get_landmarks_filenames();\n\n  void set_constraints_filenames(StringList filenames);\n  StringList get_constraints_filenames();\n\n  void set_number_of_domains(int number_of_domains);\n  int get_number_of_domains();\n\n  StringMap get_feature_filenames() const;\n  void set_feature_filenames(const StringMap&amp; feature_filenames);\n\n  std::vector&lt;std::vector&lt;double&gt;&gt; get_groomed_transforms() const;\n  void set_groomed_transforms(std::vector&lt;std::vector&lt;double&gt;&gt; transforms);\n  void set_groomed_transform(int i, std::vector&lt;double&gt; transform);\n\n  std::vector&lt;std::vector&lt;double&gt;&gt; get_procrustes_transforms() const;\n  void set_procrustes_transforms(std::vector&lt;std::vector&lt;double&gt;&gt; transforms);\n\n  StringMap get_group_values() const;\n  std::string get_group_value(std::string group_name);\n\n  void set_group_values(const StringMap&amp; group_values);\n\n  StringMap get_extra_values() const;\n  void set_extra_values(StringMap extra_values);\n\n  StringMap get_table_values() const;\n  void set_table_values(StringMap table_values);\n\n  std::string get_display_name();\n  void set_display_name(std::string display_name);\n\n  bool is_fixed();\n  void set_fixed(bool fixed);\n\n  bool is_excluded();\n  void set_excluded(bool excluded);\n\n  std::string get_notes();\n  void set_notes(std::string notes);\n\n private:\n  int number_of_domains_ = 0;\n\n  std::string display_name_;\n  bool fixed_ = false;\n  bool excluded_ = false;\n  StringList original_filenames_;\n  StringList groomed_filenames_;\n  StringList local_particle_filenames_;\n  StringList world_particle_filenames_;\n  StringList landmarks_filenames_;\n  StringList constraints_filenames_;\n  std::vector&lt;std::vector&lt;double&gt;&gt; groomed_transforms_;\n  std::vector&lt;std::vector&lt;double&gt;&gt; procrustes_transforms_;\n\n  StringMap feature_filenames_;\n  StringMap group_values_;\n  StringMap extra_values_;\n  StringMap table_values_;\n  std::string notes_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/SurfaceReconstructor_8h.html","title":"Libs/Analyze/SurfaceReconstructor.h","text":"<p>Surface Reconstruction Layer.  More...</p>"},{"location":"api/Files/SurfaceReconstructor_8h.html#classes","title":"Classes","text":"Name class SurfaceReconstructor"},{"location":"api/Files/SurfaceReconstructor_8h.html#detailed-description","title":"Detailed Description","text":"<p>Surface Reconstruction Layer. </p> <p>The SurfaceReconstructor wraps the surface reconstruction method </p>"},{"location":"api/Files/SurfaceReconstructor_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n#include &lt;itkPoint.h&gt;\n#include &lt;vtkPoints.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;Eigen/Core&gt;\n\nclass SurfaceReconstructorPrivate;\n\nclass SurfaceReconstructor {\n\n public:\n\n  SurfaceReconstructor();\n  ~SurfaceReconstructor();\n\n  //**********************************************//\n  //************Imported From Studio *************//\n\n  void initializeReconstruction(std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; local_pts,\n                                std::vector&lt;std::vector&lt;itk::Point&lt;double&gt;&gt;&gt; global_pts,\n                                std::vector&lt;std::string&gt; distance_transforms,\n                                double maxAngle,\n                                float decimationPercent,\n                                int numClusters);\n  bool hasDenseMean();\n  void setMean(vtkSmartPointer&lt;vtkPoints&gt; sparseMean,\n               vtkSmartPointer&lt;vtkPolyData&gt; denseMean,\n               std::vector&lt;bool&gt; goodPoints);\n\n  void writeMeanInfo(std::string baseName);\n  void readMeanInfo(std::string dense,\n                    std::string sparse, std::string goodPoints);\n  void resetReconstruct();\n  //**********************************************//\n\n  void set_number_of_clusters(int num_clusters);\n  void set_normal_angle(double angle);\n  void set_decimation_percent(double decimation);\n\n  bool get_surface_reconstruction_available();\n\n  vtkSmartPointer&lt;vtkPolyData&gt; build_mesh(const Eigen::VectorXd&amp; shape);\n\n private:\n\n  std::unique_ptr&lt;SurfaceReconstructorPrivate&gt; private_;\n\n  bool surface_reconstruction_available_ = false;\n\n  int num_clusters_ = -1;\n  double decimation_percent_ = 0.3f;\n  double normal_angle_ = 45.0f;\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/Surface_8h.html","title":"Libs/Optimize/Domain/Surface.h","text":""},{"location":"api/Files/Surface_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Surface_8h.html#classes","title":"Classes","text":"Name class shapeworks::Surface"},{"location":"api/Files/Surface_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;geometrycentral/surface/heat_method_distance.h&gt;\n#include &lt;geometrycentral/surface/meshio.h&gt;\n#include &lt;geometrycentral/surface/surface_mesh.h&gt;\n#include &lt;vtkPolyData.h&gt;\n#include &lt;vtkSmartPointer.h&gt;\n\n#include &lt;unordered_set&gt;\n\n#include \"Libs/Optimize/Domain/ParticleDomain.h\"\n#include \"MeshGeoEntry.h\"\n\nclass vtkCellLocator;\n\nnamespace shapeworks {\nclass Surface {\n  public:\n    using PointType = ParticleDomain::PointType;\n    using GradNType = ParticleDomain::GradNType;\n\n    using NormalType = vnl_vector_fixed&lt;float, 3&gt;;\n    using VectorType = vnl_vector_fixed&lt;double, 3&gt;;\n\n    explicit Surface(vtkSmartPointer&lt;vtkPolyData&gt; mesh,\n                     bool geodesics_enabled = false,\n                     size_t geodesics_cache_multiplier_size = 0); // 0 =&gt; MeshWrapper will choose a heuristic\n\n    ~Surface() = default;\n\n    double compute_distance(const PointType&amp; pointa,\n                            int idxa,\n                            const PointType&amp; pointb,\n                            int idxb,\n                            VectorType* out_grad = nullptr) const;\n\n    bool is_within_distance(const PointType&amp; pointa,\n                            int idxa,\n                            const PointType&amp; pointb,\n                            int idxb,\n                            double test_dist,\n                            double&amp; dist) const;\n\n    PointType geodesic_walk(PointType p, int idx, VectorType vector) const;\n\n    VectorType project_vector_to_surface_tangent(const PointType&amp; pointa, int idx, VectorType&amp; vector) const;\n\n    NormalType sample_normal_at_point(PointType p, int idx = -1) const;\n    GradNType sample_gradient_normal_at_point(PointType p, int idx) const;\n\n    PointType snap_to_mesh(PointType pointa, int idx) const;\n\n    PointType get_point_on_mesh() const;\n\n    inline const PointType&amp; get_mesh_lower_bound() const { return mesh_lower_bound_; }\n\n    inline const PointType&amp; get_mesh_upper_bound() const { return mesh_upper_bound_; }\n\n    virtual void invalidate_particle(int idx);\n\n    inline vtkSmartPointer&lt;vtkPolyData&gt; get_polydata() const { return original_mesh_; }\n\n    bool is_geodesics_enabled() const { return this-&gt;is_geodesics_enabled_; }\n\n  private:\n    int get_num_faces();\n    void compute_mesh_bounds();\n    void compute_grad_normals(const Eigen::MatrixXd&amp; V, const Eigen::MatrixXi&amp; F) const;\n\n    int get_triangle_for_point(const double pt[3], int idx, double closest_point[3]) const;\n\n    Eigen::Vector3d project_vector_to_face(const Eigen::Vector3d&amp; normal, const Eigen::Vector3d&amp; vector) const;\n\n    const Eigen::Vector3d get_face_normal(int face_index) const;\n\n    bool is_in_triangle(const double pt[3], int face_index) const;\n\n    Eigen::Vector3d compute_barycentric_coordinates(const Eigen::Vector3d&amp; pt, int face) const;\n\n    int compute_barycentric_coordinates(const Eigen::Vector3d&amp; pt,\n                                        int face,\n                                        double&amp; dist2,\n                                        Eigen::Vector3d&amp; bary) const;\n\n    int compute_face_and_weights(const PointType&amp; p, int idx, Eigen::Vector3d&amp; weights) const;\n\n    Eigen::Vector3d geodesic_walk_on_face(Eigen::Vector3d point_a,\n                                          Eigen::Vector3d projected_vector,\n                                          int face_index,\n                                          int&amp; ending_face) const;\n\n    Eigen::Vector3d get_barycentric_intersection(Eigen::Vector3d start,\n                                                 Eigen::Vector3d end,\n                                                 int currentFace,\n                                                 int edge) const;\n\n    int get_across_edge(int face, int edge) const;\n\n    int get_face_point_id(int face, int point_id) const;\n\n    int slide_along_edge(Eigen::Vector3d&amp; point, Eigen::Vector3d&amp; remainingVector_, int face_, int edge_) const;\n\n    Eigen::Vector3d get_vertex_coords(int vertex_id) const;\n\n    Eigen::Vector3d rotate_vector_to_face(const Eigen::Vector3d&amp; prev_normal,\n                                          const Eigen::Vector3d&amp; next_normal,\n                                          const Eigen::Vector3d&amp; vector) const;\n\n    vtkSmartPointer&lt;vtkPolyData&gt; poly_data_;\n    vtkSmartPointer&lt;vtkPolyData&gt; original_mesh_;\n\n    NormalType calculate_normal_at_point(Surface::PointType p, int idx) const;\n\n    // Caches of triangle, normal and position\n    // Has to be mutable because all of the accessor APIs are const\n    mutable std::vector&lt;int&gt; particle_triangles_;\n    mutable std::vector&lt;NormalType&gt; particle_normals_;\n    mutable std::vector&lt;PointType&gt; particle_positions_;\n    mutable std::vector&lt;double&gt; particle_neighboorhood_;\n\n    mutable std::vector&lt;GradNType&gt; grad_normals_;\n\n    // bounds of the mesh plus some buffer\n    PointType mesh_lower_bound_;\n    PointType mesh_upper_bound_;\n\n    // cell locator to find closest point on mesh\n    vtkSmartPointer&lt;vtkCellLocator&gt; cell_locator_;\n\n    // Geodesic distances\n\n    bool is_geodesics_enabled_{false};\n\n    // Geometry Central data structures\n    std::unique_ptr&lt;geometrycentral::surface::SurfaceMesh&gt; gc_mesh_;\n    std::unique_ptr&lt;geometrycentral::surface::VertexPositionGeometry&gt; gc_geometry_;\n    std::unique_ptr&lt;geometrycentral::surface::HeatMethodDistanceSolver&gt; gc_heatsolver_;\n\n    size_t geo_max_cache_entries_{0};\n    mutable size_t geo_cache_size_{0};\n\n    // Flattened version of libigl's gradient operator\n    std::vector&lt;Eigen::Matrix3d&gt; face_grad_;\n\n    std::vector&lt;std::unordered_set&lt;int&gt; &gt; face_kring_;\n\n    // Cache for geodesic distances from a triangle\n    mutable std::vector&lt;MeshGeoEntry&gt; geo_dist_cache_;\n\n    // Returns true if face f_a is in the K-ring of face f_b\n    bool are_faces_in_k_ring(int f_a, int f_b) const;\n    const size_t kring_{1};\n\n    // Convert the mesh to libigl data structures\n    void get_igl_mesh(Eigen::MatrixXd&amp; V, Eigen::MatrixXi&amp; F) const;\n\n    // Precompute heat data structures for faster geodesic lookups\n    void precompute_geodesics(const Eigen::MatrixXd&amp; V, const Eigen::MatrixXi&amp; F);\n\n    void compute_k_ring(int f, int k, std::unordered_set&lt;int&gt;&amp; ring) const;\n\n    const MeshGeoEntry&amp; geodesics_from_triangle(int f,\n                                                double max_dist = std::numeric_limits&lt;double&gt;::max(),\n                                                int req_target_f = -1) const;\n    const Eigen::Matrix3d geodesics_from_triangle_to_triangle(int f_a, int f_b) const;\n    void clear_geodesic_cache() const;\n\n    // Store some info about the last query. This accelerates the computation\n    // because the optimizer generally asks for the distances _from_ the same\n    // point as the previous query.\n    mutable bool geo_lq_cached_{false};\n    mutable PointType geo_lq_pt_a_{-1};\n    mutable int geo_lq_face_{-1};\n    mutable Eigen::Vector3d geo_lq_bary_;\n    void fetch_and_cache_first_point(const PointType pt_a, int idx_a, int&amp; face_a, Eigen::Vector3d&amp; bary_a) const;\n\n    Eigen::MatrixXd vertices_;\n    Eigen::MatrixXi faces_;\n};\n} // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Telemetry_8h.html","title":"Studio/Data/Telemetry.h","text":""},{"location":"api/Files/Telemetry_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Telemetry_8h.html#classes","title":"Classes","text":"Name class shapeworks::Telemetry"},{"location":"api/Files/Telemetry_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n\n#include &lt;QNetworkAccessManager&gt;\n\n\nnamespace shapeworks {\n\nclass Telemetry : public QObject {\n  Q_OBJECT\n\n public:\n  Telemetry(Preferences&amp; prefs);\n\n  void record_event(const QString&amp; name, const QVariantMap&amp; params);\n\n public Q_SLOTS:\n  void handle_network_reply(QNetworkReply* reply);\n\n private:\n  QString create_event(const QString&amp; name, const QVariantMap&amp; params);\n\n  void send_event(const QString&amp; event);\n\n  void store_event(const QString&amp; event);\n\n  bool enabled_ = true;\n\n  QNetworkAccessManager network_;\n\n  QString active_event_;\n\n  Preferences&amp; prefs_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/UpdateChecker_8h.html","title":"Studio/Interface/UpdateChecker.h","text":""},{"location":"api/Files/UpdateChecker_8h.html#namespaces","title":"Namespaces","text":"Name Ui shapeworks User usage reporting (telemetry)"},{"location":"api/Files/UpdateChecker_8h.html#classes","title":"Classes","text":"Name class shapeworks::UpdateChecker Update Checker."},{"location":"api/Files/UpdateChecker_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n\n#include &lt;QDialog&gt;\n#include &lt;QNetworkAccessManager&gt;\n\nnamespace Ui {\nclass UpdateChecker;\n}\n\nnamespace shapeworks {\n\n\nclass UpdateChecker : public QDialog {\n  Q_OBJECT\n\n public:\n  explicit UpdateChecker(Preferences&amp; prefs, QWidget* parent = nullptr);\n  ~UpdateChecker();\n\n  void run_auto_update_check();\n  void run_manual_update_check();\n\n public Q_SLOTS:\n  void handleNetworkReply(QNetworkReply* reply);\n\n private:\n  void run_update_check();\n\n  bool manual_trigger_{false};\n  QNetworkAccessManager network_;\n\n  Ui::UpdateChecker* ui_;\n\n  Preferences&amp; prefs_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Utils_8h.html","title":"Libs/Utils/Utils.h","text":""},{"location":"api/Files/Utils_8h.html#namespaces","title":"Namespaces","text":"Name utils"},{"location":"api/Files/Utils_8h.html#classes","title":"Classes","text":"Name class Utils"},{"location":"api/Files/Utils_8h.html#defines","title":"Defines","text":"Name twopi_inv twopi RANDU RANDN2(mu, sigma) RANDN"},{"location":"api/Files/Utils_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/Utils_8h.html#define-twopi_inv","title":"define twopi_inv","text":"<pre><code>#define twopi_inv 0.5/M_PI\n</code></pre>"},{"location":"api/Files/Utils_8h.html#define-twopi","title":"define twopi","text":"<pre><code>#define twopi 2.0*M_PI\n</code></pre>"},{"location":"api/Files/Utils_8h.html#define-randu","title":"define RANDU","text":"<pre><code>#define RANDU ((double) rand()/RAND_MAX)\n</code></pre>"},{"location":"api/Files/Utils_8h.html#define-randn2","title":"define RANDN2","text":"<pre><code>#define RANDN2(\n    mu,\n    sigma\n)\n(mu + (rand()%2 ? -1.0 : 1.0)*sigma*pow(-log(0.99999*RANDU), 0.5))\n</code></pre>"},{"location":"api/Files/Utils_8h.html#define-randn","title":"define RANDN","text":"<pre><code>#define RANDN RANDN2(0, 1.0)\n</code></pre>"},{"location":"api/Files/Utils_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n  Program:   ShapeWorks: Particle-based Shape Correspondence &amp; Visualization\n  Date:      $Date: 2014/03/24 01:17:40 $\n  Version:   $Revision: 1.2 $\n  Author:    $Author: elhabian $\n\n  Copyright (c) 2009 Scientific Computing and Imaging Institute.\n  See ShapeWorksLicense.txt for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notices for more information.\n=========================================================================*/\n\n#ifndef UTILS_H\n#define UTILS_H\n\n#ifdef _WIN32\n#ifndef _USE_MATH_DEFINES\n#define _USE_MATH_DEFINES\n#endif\n#endif\n\n#include &lt;Eigen/Core&gt;\n\n#include &lt;math.h&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;sstream&gt;      // std::istringstream\n\n#include &lt;itkMath.h&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;    // std::sort\n\n#include &lt;vtkSmartPointer.h&gt;\n#include &lt;vtkPoints.h&gt;\n#include &lt;itkImage.h&gt;\n#include &lt;itkPoint.h&gt;\n#include &lt;vnl/vnl_matrix.h&gt;\n\nnamespace utils //TODO: -&gt; namespace shapeworks (need to change everywhere it's used\n{\n#define twopi_inv 0.5/M_PI\n#define twopi  2.0*M_PI\n\n#define RANDU ((double) rand()/RAND_MAX)\n#define RANDN2(mu, sigma) (mu + (rand()%2 ? -1.0 : 1.0)*sigma*pow(-log(0.99999*RANDU), 0.5))\n#define RANDN RANDN2(0, 1.0)\n\n}\n\nclass Utils{\n\npublic:\n    static std::vector&lt;int&gt; randperm(int n);\n\n    //--------------------------- IO-----------------------------------\n    static void readSparseShape(vtkSmartPointer&lt;vtkPoints&gt;&amp; points, char* filename, int number_of_particles = -1);\n    static void writeSparseShape(char* filename, vtkSmartPointer&lt;vtkPoints&gt; particles);\n\n    static void readSparseShape(std::vector&lt;itk::Point&lt;double&gt; &gt; &amp; points, char* filename, int number_of_particles = -1);\n    static void writeSparseShape(char* filename, std::vector&lt;itk::Point&lt;double, 3&gt; &gt; points);\n\n    static std::vector&lt;int&gt; readParticleIds(char* filename);\n    static void writeParticleIds(char* filename, std::vector&lt;int&gt; ids);\n\n\n    static void quiet_delete_file(const std::string&amp; filename);\n\n    //--------------- point cloud queries --------------------------------\n    static void computeCenterOfMassForShapeEnsemble (std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list, itk::Point&lt; double, 3 &gt; &amp; center);\n    static void computeCenterOfMassForShape (std::vector&lt; itk::Point&lt; double, 3 &gt; &gt;  points, itk::Point&lt; double, 3 &gt; &amp; center);\n\n    static void updateMin(double curVal, double&amp; minVal);\n    static void updateMax(double curVal, double&amp; maxVal);\n\n    static void getBoundingBoxForShapeEnsemble (std::vector&lt; std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; &gt; points_list,\n                                                double&amp; min_x, double&amp; min_y, double&amp; min_z,\n                                                double&amp; max_x, double&amp; max_y, double&amp; max_z);\n    static void getBoundingBoxForShape (std::vector&lt; itk::Point&lt; double, 3 &gt; &gt;  points,\n                                        double&amp; min_x, double&amp; min_y, double&amp; min_z,\n                                        double&amp; max_x, double&amp; max_y, double&amp; max_z);\n\n\n\n    //--------------- coordinates transformations --------------------------------\n    static void spherical2cartesian(const double inPoint[3], double outPoint[3]);\n    static void cartesian2spherical(const double inPoint[3], double outPoint[3]);\n\n    static vtkSmartPointer&lt;vtkPoints&gt; convertToPhysicalCoordinates(vtkSmartPointer&lt;vtkPoints&gt; particles, int number_of_particles,\n                                                                   const itk::Image&lt; float,  3 &gt;::SpacingType&amp; spacing ,\n                                                                   const itk::Image&lt; float,  3 &gt;::PointType&amp; origin);\n\n    static vtkSmartPointer&lt;vtkPoints&gt; convertToImageCoordinates(vtkSmartPointer&lt;vtkPoints&gt; particles, int number_of_particles,\n                                                                const itk::Image&lt; float,  3 &gt;::SpacingType&amp; spacing ,\n                                                                const itk::Image&lt; float,  3 &gt;::PointType&amp; origin);\n\n    static std::string num2str(float num);\n    static std::string num2str(int num);\n    static std::vector&lt;double&gt; linspace(double a, double b, size_t N);\n    static std::string int2str(int n, int number_of_zeros);\n\n    //--------------- linear algebra -------------------------------------------\n\n    // matrix multiplication without an allocation for the output\n    template&lt;typename T&gt;\n    static void multiply_into(Eigen::MatrixXd &amp;out, const vnl_matrix&lt;T&gt; &amp;lhs, const vnl_matrix&lt;T&gt; &amp;rhs);\n\n  //--------------- average normal directions --------------------------------\n    /* Trying every theta (with a step size of dtheta), find the theta that results in the smallest MSE.\n         */\n    static double averageThetaBruteForce(std::vector&lt;double&gt; thetas, double dtheta);\n\n    // the chord method\n    static double averageThetaChord(std::vector&lt;double&gt; thetas);\n\n    // the exact method\n    static double averageThetaArc(std::vector&lt;double&gt; thetas);\n\nprivate:\n    // only good for positive numbers.\n    static double mod2pi_pos(double vin);\n\n    // Ensure that v is [-PI, PI]\n    static double mod2pi(double vin);\n\n    /* Returns a value of v wrapped such that ref and v differ by no\n         * more +/-PI\n         */\n    static double mod2pi(double ref, double v);\n\n    /* For a given theta, compute the MSE. A simple O(N) method used for testing. */\n    static double computeMSE(std::vector&lt;double&gt; thetas, double theta);\n\n};\n\n#endif // UTILS_H\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Variant_8h.html","title":"Libs/Project/Variant.h","text":""},{"location":"api/Files/Variant_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Variant_8h.html#classes","title":"Classes","text":"Name class shapeworks::Variant Variant class to represent multiple types."},{"location":"api/Files/Variant_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;Utils/StringUtils.h&gt;\n\nnamespace shapeworks {\n\ntemplate &lt;typename T&gt;\nstd::string variant_to_string(T begin, T end) {\n  std::stringstream ss;\n  bool first = true;\n  for (; begin != end; begin++) {\n    if (!first) {\n      ss &lt;&lt; \" \";\n    }\n    if constexpr (std::is_same&lt;T, std::string&gt;::value) {\n      // cast to string and replace spaces\n      std::string s(*begin);\n      ss &lt;&lt; StringUtils::replace_string(s,\" \", \"%20\");\n    } else {\n      ss &lt;&lt; *begin;\n    }\n    first = false;\n  }\n  return ss.str();\n}\n\n\nclass Variant {\n public:\n  Variant() : str_(), valid_(false) {}\n  Variant(const std::string&amp; v) : str_(v), valid_(true) {}\n  Variant(int v) : str_(std::to_string(v)), valid_(true) {}\n  Variant(double v) : str_(std::to_string(v)), valid_(true) {}\n  Variant(const char* v) : str_(v), valid_(true) {}\n  Variant(bool v) : str_(v ? \"true\" : \"false\"), valid_(true) {}\n  Variant(std::vector&lt;double&gt; v) : str_(variant_to_string(v.begin(), v.end())), valid_(true) {}\n  Variant(std::vector&lt;int&gt; v) : str_(variant_to_string(v.begin(), v.end())), valid_(true) {}\n  Variant(std::vector&lt;bool&gt; v) : str_(variant_to_string(v.begin(), v.end())), valid_(true) {}\n  Variant(std::vector&lt;std::string&gt; v) : str_(variant_to_string(v.begin(), v.end())), valid_(true) {}\n\n  operator std::string() const;\n  operator bool() const;\n  operator int() const;\n  operator unsigned int() const;\n  operator long() const;\n  operator unsigned long() const;\n  operator float() const;\n  operator double() const;\n  operator std::vector&lt;double&gt;() const;\n  operator std::vector&lt;int&gt;() const;\n  operator std::vector&lt;bool&gt;() const;\n  operator std::vector&lt;std::string&gt;() const;\n\n private:\n  std::string str_;\n  bool valid_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/VectorFunction_8h.html","title":"Libs/Optimize/Function/VectorFunction.h","text":""},{"location":"api/Files/VectorFunction_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/VectorFunction_8h.html#classes","title":"Classes","text":"Name class shapeworks::VectorFunction"},{"location":"api/Files/VectorFunction_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;memory&gt;\n#include \"Libs/Optimize/ParticleSystem.h\"\n#include \"vnl/vnl_vector_fixed.h\"\n\nnamespace shapeworks {\n\nclass VectorFunction {\n public:\n  constexpr static unsigned int Dimension = 3;\n\n  using VectorType = vnl_vector_fixed&lt;double, Dimension&gt;;\n\n  virtual VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp; maxtimestep) const = 0;\n  virtual VectorType evaluate(unsigned int, unsigned int, const ParticleSystem*, double&amp; maxtimestep,\n                              double&amp; energy) const = 0;\n  virtual double energy(unsigned int, unsigned int, const ParticleSystem*) const = 0;\n\n  virtual void reset_buffers() {}\n\n  virtual void after_iteration() {}\n\n  virtual void before_iteration() {}\n\n  virtual void before_evaluate(unsigned int, unsigned int, const ParticleSystem*) {}\n\n  virtual void set_particle_system(ParticleSystem* p) { particle_system_ = p; }\n  virtual ParticleSystem* get_particle_system() const { return particle_system_; }\n  virtual void set_domain_number(unsigned int i) { domain_number_ = i; }\n  virtual int get_domain_number() const { return domain_number_; }\n\n  virtual std::shared_ptr&lt;VectorFunction&gt; clone() {\n    std::cerr &lt;&lt; \"Error: base class VectorFunction clone method called!\\n\";\n    std::cerr &lt;&lt; \"Threaded run of current parameters not supported!\\n\";\n    return nullptr;\n  }\n\n  virtual double get_relative_energy_scaling() const { return 1.0; }\n  virtual void set_relative_energy_scaling(double r) { return; }\n\n  virtual ~VectorFunction() = default;\n\n protected:\n  VectorFunction() : particle_system_(nullptr), domain_number_(0) {}\n  VectorFunction(const VectorFunction&amp;) = delete;\n  VectorFunction&amp; operator=(const VectorFunction&amp;) = delete;\n\n  ParticleSystem* particle_system_;\n  unsigned int domain_number_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/VectorImage_8h.html","title":"Libs/Image/VectorImage.h","text":""},{"location":"api/Files/VectorImage_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/VectorImage_8h.html#classes","title":"Classes","text":"Name class shapeworks::VectorImage Gradient (vector) image."},{"location":"api/Files/VectorImage_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;itkGradientImageFilter.h&gt;\n#include &lt;itkVectorLinearInterpolateImageFunction.h&gt;\n\n#include \"Image.h\"\n\nnamespace shapeworks {\n\nclass VectorImage {\n public:\n  using GradientImageFilter = itk::GradientImageFilter&lt;Image::ImageType&gt;;\n  using ImageType = itk::Image&lt;Covariant, 3&gt;;\n  using GradientInterpolatorType = itk::VectorLinearInterpolateImageFunction&lt;ImageType, Image::PixelType&gt;;\n  using ImageIterator = itk::ImageRegionIterator&lt;ImageType&gt;;\n\n  VectorImage(const Image&amp; dt_img);\n  VectorImage() = delete;\n  ~VectorImage() = default;\n\n  Vector evaluate(Point p);\n  ImageIterator iterator();\n\n private:\n  itk::SmartPointer&lt;ImageType&gt; itk_image_;\n  itk::SmartPointer&lt;GradientInterpolatorType&gt; interpolator_;\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Viewer_8h.html","title":"Studio/Visualization/Viewer.h","text":""},{"location":"api/Files/Viewer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Viewer_8h.html#classes","title":"Classes","text":"Name class shapeworks::PickResult class shapeworks::Viewer 3D Viewer"},{"location":"api/Files/Viewer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Shape.h&gt;\n#include &lt;Visualization/ColorMap.h&gt;\n#include &lt;Visualization/ColorSchemes.h&gt;\n#include &lt;Visualization/SliceView.h&gt;\n\n#include &lt;QPointF&gt;\n#include &lt;QSharedPointer&gt;\n\nclass vtkRenderer;\nclass vtkLookupTable;\nclass vtkRenderWindowInteractor;\nclass vtkImageData;\nclass vtkCamera;\nclass vtkGlyph3D;\nclass vtkSphereSource;\nclass vtkArrowSource;\nclass vtkTransformPolyDataFilter;\nclass vtkScalarBarActor;\nclass vtkCornerAnnotation;\nclass vtkPolyDataMapper;\nclass vtkActor;\nclass vtkTransform;\nclass vtkReverseSense;\nclass vtkHandleWidget;\nclass vtkPolygonalSurfacePointPlacer;\nclass vtkImageSlice;\nclass vtkImageSliceMapper;\nclass vtkImageData;\nclass vtkCellPicker;\nclass vtkPropPicker;\nclass vtkColorSeries;\n\nnamespace shapeworks {\n\nclass Shape;\nclass Viewer;\nclass Visualizer;\nclass StudioInteractorStyle;\nclass LandmarkWidget;\nclass PlaneWidget;\nclass PaintWidget;\nclass Session;\n\ntypedef QSharedPointer&lt;Viewer&gt; ViewerHandle;\ntypedef QVector&lt;ViewerHandle&gt; ViewerList;\n\nclass PickResult {\n public:\n  Shape::Point pos_;\n  int domain_ = -1;\n  int subject_ = -1;\n};\n\n\nclass Viewer {\n public:\n  Viewer();\n  ~Viewer() = default;\n\n  void set_renderer(vtkSmartPointer&lt;vtkRenderer&gt; renderer);\n  vtkSmartPointer&lt;vtkRenderer&gt; get_renderer();\n\n  void display_shape(std::shared_ptr&lt;Shape&gt; shape);\n  void update_annotations();\n\n  void clear_viewer();\n  void reset_camera(std::array&lt;double, 3&gt; c);\n  void reset_camera();\n\n  void set_color_series(ColorMap color_series);\n  void set_glyph_size_and_quality(double size, double quality);\n  double get_glyph_size();\n  double get_glyph_quality();\n  void set_session(QSharedPointer&lt;Session&gt; session);\n  QSharedPointer&lt;Session&gt; get_session();\n\n  void set_show_glyphs(bool show);\n  void set_show_surface(bool show);\n  void set_scale_arrows(bool scale);\n\n  void update_points();\n  void update_glyph_properties();\n\n  int handle_pick(int* click_pos);\n\n  PickResult handle_ctrl_click(int* click_pos);\n\n  void set_selected_point(int id);\n\n  void set_glyph_lut(vtkSmartPointer&lt;vtkLookupTable&gt; lut);\n\n  void set_loading_screen(vtkSmartPointer&lt;vtkImageData&gt; loading_screen);\n\n  void set_color_scheme(int i);\n\n  void handle_new_mesh();\n\n  bool is_viewer_ready();\n\n  void set_visualizer(Visualizer* visualizer);\n\n  void update_feature_range(double* range);\n  void reset_feature_range();\n\n  void update_opacities();\n\n  std::shared_ptr&lt;Shape&gt; get_shape();\n\n  void update_landmarks();\n  void update_planes();\n  void update_paint_mode();\n\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; get_surface_actors();\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; get_unclipped_surface_actors();\n\n  MeshGroup get_meshes();\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_transform(int alignment_domain, int domain);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_landmark_transform(int domain);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_inverse_landmark_transform(int domain);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_image_transform();\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_inverse_image_transform();\n\n  SliceView&amp; slice_view();\n\n  void update_image_volume(bool force = false);\n\n  vtkSmartPointer&lt;vtkPoints&gt; get_glyph_points();\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_alignment_transform();\n\n  void update_clipping_planes();\n\n  vtkSmartPointer&lt;vtkPolygonalSurfacePointPlacer&gt; get_point_placer();\n\n  void handle_paint(double display_pos[2], double world_pos[3]);\n\n  void fill_all_ffc();\n\n  static bool is_reverse(vtkSmartPointer&lt;vtkTransform&gt; transform);\n\n  void update_actors();\n\n  void remove_scalar_bar();\n\n  bool is_ready() { return mesh_ready_; }\n\n  vtkFloatArray* get_particle_scalars();\n\n  vtkSmartPointer&lt;vtkPolyData&gt; get_particle_poly_data();\n\n  void insert_compare_meshes();\n\n  void set_scalar_visibility(vtkSmartPointer&lt;vtkPolyData&gt; poly_data, vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper,\n                             std::string scalar);\n\n  vtkSmartPointer&lt;vtkLookupTable&gt; get_surface_lut() { return surface_lut_; }\n\n  bool showing_feature_map();\n\n private:\n  void initialize_surfaces();\n\n  void display_vector_field();\n\n  void compute_point_differences(const Eigen::VectorXd&amp; points, vtkSmartPointer&lt;vtkFloatArray&gt; magnitudes,\n                                 vtkSmartPointer&lt;vtkFloatArray&gt; vectors);\n\n  void compute_surface_differences(vtkSmartPointer&lt;vtkFloatArray&gt; magnitudes, vtkSmartPointer&lt;vtkFloatArray&gt; vectors);\n\n  void update_difference_lut(float r0, float r1);\n\n  std::string get_displayed_feature_map();\n\n  vtkSmartPointer&lt;vtkPlane&gt; transform_plane(vtkSmartPointer&lt;vtkPlane&gt; plane, vtkSmartPointer&lt;vtkTransform&gt; transform);\n\n  bool visible_ = false;\n\n  std::shared_ptr&lt;Shape&gt; shape_;\n\n  bool show_glyphs_ = true;\n  bool show_surface_ = true;\n\n  double glyph_size_ = 1.0f;\n  double glyph_quality_ = 5.0f;\n  bool scale_arrows_{true};\n  ColorMap color_series_;\n\n  vtkSmartPointer&lt;vtkRenderer&gt; renderer_;\n\n  vtkSmartPointer&lt;vtkSphereSource&gt; sphere_source_;\n  vtkSmartPointer&lt;vtkReverseSense&gt; reverse_sphere_;\n\n  vtkSmartPointer&lt;vtkPoints&gt; glyph_points_;\n  vtkSmartPointer&lt;vtkPolyData&gt; glyph_point_set_;\n  vtkSmartPointer&lt;vtkGlyph3D&gt; glyphs_;\n  vtkSmartPointer&lt;vtkPolyDataMapper&gt; glyph_mapper_;\n  vtkSmartPointer&lt;vtkActor&gt; glyph_actor_;\n\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyDataMapper&gt;&gt; surface_mappers_;\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; surface_actors_;\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyDataMapper&gt;&gt; unclipped_surface_mappers_;\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; unclipped_surface_actors_;\n  std::vector&lt;vtkSmartPointer&lt;vtkLookupTable&gt;&gt; ffc_luts_;\n\n  // for comparing to other shapes (e.g. original vs groomed)\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyDataMapper&gt;&gt; compare_mappers_;\n  std::vector&lt;vtkSmartPointer&lt;vtkActor&gt;&gt; compare_actors_;\n\n  vtkSmartPointer&lt;vtkLookupTable&gt; glyph_lut_;\n  vtkSmartPointer&lt;vtkLookupTable&gt; surface_lut_;\n\n  vtkSmartPointer&lt;vtkArrowSource&gt; arrow_source_;\n  vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; arrow_flip_filter_;\n  vtkSmartPointer&lt;vtkGlyph3D&gt; arrow_glyphs_;\n  vtkSmartPointer&lt;vtkPolyDataMapper&gt; arrow_glyph_mapper_;\n  vtkSmartPointer&lt;vtkActor&gt; arrow_glyph_actor_;\n  vtkSmartPointer&lt;vtkTransform&gt; transform_180_;\n  vtkSmartPointer&lt;vtkScalarBarActor&gt; scalar_bar_actor_;\n\n  vtkSmartPointer&lt;vtkCornerAnnotation&gt; corner_annotation_;\n\n  bool arrows_visible_ = false;\n\n  ColorSchemes color_schemes_;\n  int scheme_ = 0;\n\n  bool mesh_ready_ = false;\n  bool viewer_ready_ = false;\n  bool loading_displayed_ = false;\n\n  MeshGroup meshes_;\n  MeshGroup compare_meshes_;\n\n  Visualizer* visualizer_{nullptr};\n\n  int number_of_domains_ = 0;\n  double lut_min_ = 0;\n  double lut_max_ = 0;\n\n  std::shared_ptr&lt;LandmarkWidget&gt; landmark_widget_;\n  std::shared_ptr&lt;PlaneWidget&gt; plane_widget_;\n  vtkSmartPointer&lt;PaintWidget&gt; paint_widget_;\n\n  QSharedPointer&lt;Session&gt; session_;\n\n  std::string current_image_name_ = \"-none-\";\n\n  vtkSmartPointer&lt;vtkCellPicker&gt; cell_picker_;\n  vtkSmartPointer&lt;vtkPropPicker&gt; prop_picker_;\n  vtkSmartPointer&lt;vtkPolygonalSurfacePointPlacer&gt; point_placer_;\n  vtkSmartPointer&lt;vtkImageActorPointPlacer&gt; slice_point_placer_;\n\n  // slice viewer\n  SliceView slice_view_{this};\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Visualizer_8h.html","title":"Studio/Visualization/Visualizer.h","text":""},{"location":"api/Files/Visualizer_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Visualizer_8h.html#classes","title":"Classes","text":"Name class shapeworks::Visualizer Controls display of objects in viewers."},{"location":"api/Files/Visualizer_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Data/Preferences.h&gt;\n#include &lt;Data/Session.h&gt;\n#include &lt;Visualization/Lightbox.h&gt;\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nnamespace shapeworks {\n\nclass Visualizer;\n\ntypedef QSharedPointer&lt;Visualizer&gt; VisualizerHandle;\n\n\nclass Visualizer : public QObject {\n  Q_OBJECT;\n\n public:\n  Visualizer(Preferences&amp; prefs);\n  ~Visualizer();\n\n  void set_lightbox(LightboxHandle lightbox);\n\n  void set_session(SessionHandle session);\n\n  void set_center(bool center);\n\n  bool get_center();\n\n  void set_alignment_domain(int domain);\n  int get_alignment_domain();\n\n  void set_show_glyphs(bool show);\n\n  void set_show_surface(bool show);\n\n  void display_samples();\n\n  void update_samples();\n\n  void update_landmarks();\n  void update_planes();\n  void update_paint_mode();\n  void handle_fill_all_ffc();\n\n  void display_sample(int i);\n\n  void display_shape(ShapeHandle shape);\n  void display_shapes(ShapeList shapes);\n\n  void set_selected_point_one(int id);\n  void set_selected_point_two(int id);\n\n  void set_mean(const Eigen::VectorXd&amp; mean);\n  void set_mean_shape(ShapeHandle mean_shape);\n  ShapeHandle get_mean_shape();\n\n  void reset_camera();\n\n  void update_lut();\n  void update_annotations();\n\n  Particles get_current_shape();\n\n  vtkFloatArray* get_current_particle_scalars();\n  vtkSmartPointer&lt;vtkPolyData&gt; get_current_particle_poly_data();\n\n  void handle_new_mesh();\n  vtkSmartPointer&lt;vtkPolyData&gt; get_current_mesh(int index, bool clip_constraints);\n  std::vector&lt;vtkSmartPointer&lt;vtkPolyData&gt;&gt; get_current_meshes_transformed(int index, bool clip_constraints = false);\n\n  const std::string&amp; get_feature_map() const;\n\n  void set_uniform_feature_range(bool value);\n\n  bool get_uniform_feature_range(void);\n\n  void set_feature_map(const std::string&amp; feature_map);\n\n  void clear_viewers();\n\n  void reset_feature_range();\n\n  double* get_feature_range();\n\n  double* get_feature_raw_range();\n\n  bool get_feature_range_valid();\n\n  void update_feature_range(double* range);\n\n  void update_feature_range(double min, double max);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_transform(std::shared_ptr&lt;Shape&gt; shape, int alignment_domain, int domain);\n\n  vtkSmartPointer&lt;vtkTransform&gt; get_transform(std::shared_ptr&lt;Shape&gt; shape, DisplayMode display_mode,\n                                              int alignment_domain, int domain);\n\n  void set_opacities(std::vector&lt;float&gt; opacities);\n\n  std::vector&lt;float&gt; get_opacities();\n\n  void set_domain_particle_visibilities(std::vector&lt;bool&gt; visibilities);\n\n  std::vector&lt;bool&gt; get_domain_particle_visibilities();\n\n  double get_current_glyph_size();\n\n  void handle_ctrl_click(PickResult result);\n\n  void redraw();\n\n  QPixmap export_to_pixmap(QSize size, bool transparent_background, bool show_orientation_marker, bool show_color_scale,\n                           bool&amp; ready);\n\n  QSize get_render_size();\n\n  LightboxHandle get_lightbox() { return this-&gt;lightbox_; }\n\n public Q_SLOTS:\n\n  void update_viewer_properties();\n\n  void handle_feature_range_changed();\n\n  void handle_image_slice_settings_changed();\n\n private:\n  Preferences&amp; preferences_;\n\n  void compute_measurements();\n\n  void setup_single_selected_point_lut();\n\n  std::string feature_map_;\n  int alignment_domain_;\n\n  bool center_;\n  bool needs_camera_reset_ = true;\n\n  bool show_glyphs_ = true;\n  bool show_surface_ = true;\n\n  LightboxHandle lightbox_;\n  SessionHandle session_;\n\n  vtkSmartPointer&lt;vtkLookupTable&gt; glyph_lut_;\n  int selected_point_one_;\n  int selected_point_two_;\n\n  Eigen::VectorXd cached_mean_;\n  ShapeHandle mean_shape_;\n  Particles current_shape_;\n\n  double feature_range_[2] = {0, 0};\n  double feature_manual_range_[2] = {0, 0};\n  bool feature_range_valid_ = false;\n  bool feature_range_uniform_ = true;\n\n  std::vector&lt;bool&gt; domain_particle_visibilities_;\n  std::vector&lt;float&gt; opacities_;\n\n  double current_glyph_size_{0};\n};\n\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/WheelEventForwarder_8h.html","title":"Studio/Interface/WheelEventForwarder.h","text":""},{"location":"api/Files/WheelEventForwarder_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/WheelEventForwarder_8h.html#classes","title":"Classes","text":"Name class shapeworks::WheelEventForwarder"},{"location":"api/Files/WheelEventForwarder_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\nclass QScrollBar;\n\nnamespace shapeworks {\n\nclass WheelEventForwarder : public QObject {\nQ_OBJECT\npublic:\n  explicit WheelEventForwarder(QScrollBar* target);\n  ~WheelEventForwarder();\n\n  bool eventFilter(QObject* obj, QEvent* event);\n\nprivate:\n  QScrollBar* target_;\n};\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/WindowsCrashHandler_8h.html","title":"Studio/Utils/WindowsCrashHandler.h","text":""},{"location":"api/Files/WindowsCrashHandler_8h.html#functions","title":"Functions","text":"Name int init_crash_handler()"},{"location":"api/Files/WindowsCrashHandler_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/WindowsCrashHandler_8h.html#function-init_crash_handler","title":"function init_crash_handler","text":"<pre><code>int init_crash_handler()\n</code></pre>"},{"location":"api/Files/WindowsCrashHandler_8h.html#source-code","title":"Source code","text":"<pre><code>int init_crash_handler();\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/Worker_8h.html","title":"Studio/Data/Worker.h","text":""},{"location":"api/Files/Worker_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/Worker_8h.html#classes","title":"Classes","text":"Name class shapeworks::Worker"},{"location":"api/Files/Worker_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Job/Job.h&gt;\n\n#include &lt;QObject&gt;\n#include &lt;QPointer&gt;\n#include &lt;QSharedPointer&gt;\n\nnamespace shapeworks {\n\nclass Worker : public QObject {\n  Q_OBJECT\n\n public:\n  Worker();\n  ~Worker();\n\n  static Worker *create_worker();\n\n  void run_job(QSharedPointer&lt;Job&gt; job);\n\n  QPointer&lt;QThread&gt; get_thread() { return thread_; }\n\n  void stop();\n\n public Q_SLOTS:\n  void process();\n\n Q_SIGNALS:\n  void error_message(QString);\n  void warning_message(QString);\n  void status_message(QString);\n  void progress(int);\n  void finished();\n\n private:\n  QSharedPointer&lt;Job&gt; job_;\n  QPointer&lt;QThread&gt; thread_;\n};\n}  // namespace shapeworks\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_0e4564af99249380ef1f30404400c0a3.html","title":"Libs/Optimize/Function","text":""},{"location":"api/Files/dir_0e4564af99249380ef1f30404400c0a3.html#directories","title":"Directories","text":"Name Libs/Optimize/Function/EarlyStop"},{"location":"api/Files/dir_0e4564af99249380ef1f30404400c0a3.html#files","title":"Files","text":"Name Libs/Optimize/Function/CorrespondenceFunction.h Libs/Optimize/Function/DisentangledCorrespondenceFunction.h Libs/Optimize/Function/DualVectorFunction.h Libs/Optimize/Function/LegacyCorrespondenceFunction.h Libs/Optimize/Function/SamplingFunction.h Libs/Optimize/Function/VectorFunction.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_18c9fb63c9ecb061d3bfcf14463b37a6.html","title":"Libs/Optimize/Matrix","text":""},{"location":"api/Files/dir_18c9fb63c9ecb061d3bfcf14463b37a6.html#files","title":"Files","text":"Name Libs/Optimize/Matrix/LegacyShapeMatrix.h Libs/Optimize/Matrix/LinearRegressionShapeMatrix.h Libs/Optimize/Matrix/MixedEffectsShapeMatrix.h Libs/Optimize/Matrix/ShapeGradientMatrix.h Libs/Optimize/Matrix/ShapeMatrix.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_2efd803177123288b92908ec296fe578.html","title":"Studio/Analysis","text":""},{"location":"api/Files/dir_2efd803177123288b92908ec296fe578.html#files","title":"Files","text":"Name Studio/Analysis/AnalysisTool.h Studio/Analysis/ParticleAreaPanel.h Studio/Analysis/ShapeEvaluationJob.h Studio/Analysis/ShapeScalarPanel.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_36d0ece48b2c599ca7cdf3fcf70a4111.html","title":"Libs/Mesh","text":""},{"location":"api/Files/dir_36d0ece48b2c599ca7cdf3fcf70a4111.html#directories","title":"Directories","text":"Name Libs/Mesh/PreviewMeshQC"},{"location":"api/Files/dir_36d0ece48b2c599ca7cdf3fcf70a4111.html#files","title":"Files","text":"Name Libs/Mesh/itkMultiplyByConstantImageFilter.h Libs/Mesh/Mesh.h Libs/Mesh/MeshComputeThickness.h Libs/Mesh/meshFIM.h Libs/Mesh/MeshUtils.h Libs/Mesh/MeshWarper.h Mesh warping capability. <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_37dfc33913c47c48c20c22cdbf1559c0.html","title":"Libs/Optimize/Neighborhood","text":""},{"location":"api/Files/dir_37dfc33913c47c48c20c22cdbf1559c0.html#files","title":"Files","text":"Name Libs/Optimize/Neighborhood/ParticleNeighborhood.h Libs/Optimize/Neighborhood/ParticlePointIndexPair.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_3ac71cfeb9e8c31aa5ca4ffc7168c68d.html","title":"Studio/ShapeWorksMONAI","text":""},{"location":"api/Files/dir_3ac71cfeb9e8c31aa5ca4ffc7168c68d.html#files","title":"Files","text":"Name Studio/ShapeWorksMONAI/MonaiLabelJob.h Studio/ShapeWorksMONAI/MonaiLabelTool.h Studio/ShapeWorksMONAI/MonaiLabelUtils.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_3c387d8f52af5a1c9b80596228515621.html","title":"Libs/Alignment/Transforms","text":""},{"location":"api/Files/dir_3c387d8f52af5a1c9b80596228515621.html#files","title":"Files","text":"Name Libs/Alignment/Transforms/itkAdvancedTransform.h Libs/Alignment/Transforms/itkCompactlySupportedRBFSparseKernelTransform.h Libs/Alignment/Transforms/itkKernelTransform2.h Libs/Alignment/Transforms/itkSparseKernelTransform.h Libs/Alignment/Transforms/itkThinPlateSplineKernelTransform2.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_409787ee32d93aa6a212981d92e6dc9a.html","title":"Libs/Mesh/PreviewMeshQC","text":""},{"location":"api/Files/dir_409787ee32d93aa6a212981d92e6dc9a.html#files","title":"Files","text":"Name Libs/Mesh/PreviewMeshQC/FEAreaCoverage.h Libs/Mesh/PreviewMeshQC/FEAutoMesher.h Libs/Mesh/PreviewMeshQC/FECoreMesh.h Libs/Mesh/PreviewMeshQC/FECVDDecimationModifier.h Libs/Mesh/PreviewMeshQC/FEElement.h Libs/Mesh/PreviewMeshQC/FEFillHole.h Libs/Mesh/PreviewMeshQC/FEFixMesh.h Libs/Mesh/PreviewMeshQC/FEMesh.h Libs/Mesh/PreviewMeshQC/FEMeshSmoothingModifier.h Libs/Mesh/PreviewMeshQC/FENodeElementList.h Libs/Mesh/PreviewMeshQC/FENodeFaceList.h Libs/Mesh/PreviewMeshQC/FENodeNodeList.h Libs/Mesh/PreviewMeshQC/FEVTKExport.h Libs/Mesh/PreviewMeshQC/FEVTKImport.h Libs/Mesh/PreviewMeshQC/Intersect.h Libs/Mesh/PreviewMeshQC/math3d.h Libs/Mesh/PreviewMeshQC/stdafx.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_4481568adb70067b4bb4b5ce096891b2.html","title":"Studio/Groom","text":""},{"location":"api/Files/dir_4481568adb70067b4bb4b5ce096891b2.html#files","title":"Files","text":"Name Studio/Groom/GroomTool.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_486a45e6ebc11931a27093b877e14af3.html","title":"Applications/shapeworks","text":""},{"location":"api/Files/dir_486a45e6ebc11931a27093b877e14af3.html#files","title":"Files","text":"Name Applications/shapeworks/Command.h Applications/shapeworks/Commands.h Applications/shapeworks/Executable.h Applications/shapeworks/SharedCommandData.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_4ea27a77bf632cd63100af8008b8abf4.html","title":"Libs/Project","text":""},{"location":"api/Files/dir_4ea27a77bf632cd63100af8008b8abf4.html#files","title":"Files","text":"Name Libs/Project/DeepSSMParameters.h Libs/Project/ExcelProjectReader.h Libs/Project/ExcelProjectWriter.h Libs/Project/JsonProjectReader.h Libs/Project/JsonProjectWriter.h Libs/Project/Parameters.h Libs/Project/Project.h Libs/Project/ProjectReader.h Libs/Project/ProjectUtils.h Libs/Project/Subject.h Libs/Project/Variant.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_645c19d7da098e01621cdebb663b8767.html","title":"Studio/Utils","text":""},{"location":"api/Files/dir_645c19d7da098e01621cdebb663b8767.html#files","title":"Files","text":"Name Studio/Utils/AnalysisUtils.h Studio/Utils/ImageLabel.h Studio/Utils/StackWalker.h Studio/Utils/StudioUtils.h Studio/Utils/WindowsCrashHandler.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_6a983b09072555944f6e4668cf5f99a9.html","title":"Libs/Application/DeepSSM","text":""},{"location":"api/Files/dir_6a983b09072555944f6e4668cf5f99a9.html#files","title":"Files","text":"Name Libs/Application/DeepSSM/DeepSSMJob.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_6cd87311705ab44b460cce19838a0cf5.html","title":"Libs/Python","text":""},{"location":"api/Files/dir_6cd87311705ab44b460cce19838a0cf5.html#files","title":"Files","text":"Name Libs/Python/pybind_utils.h Libs/Python/PythonAnalyze.h Libs/Python/PythonGroom.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_6e6cb9563333489fde7459b1f95e59a5.html","title":"Libs","text":""},{"location":"api/Files/dir_6e6cb9563333489fde7459b1f95e59a5.html#directories","title":"Directories","text":"Name Libs/Alignment Libs/Analyze Libs/Application Libs/Common Libs/Groom Libs/Image Libs/Mesh Libs/Optimize Libs/Particles Libs/Project Libs/Python Libs/Utils <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_714a13efdf7ee1e2759ceed0978ff76a.html","title":"Libs/Optimize/Function/EarlyStop","text":""},{"location":"api/Files/dir_714a13efdf7ee1e2759ceed0978ff76a.html#files","title":"Files","text":"Name Libs/Optimize/Function/EarlyStop/EarlyStopping.h Libs/Optimize/Function/EarlyStop/MorphologicalDeviationScore.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_73a09fceee206218e6d903b3c5deb969.html","title":"Libs/Utils","text":""},{"location":"api/Files/dir_73a09fceee206218e6d903b3c5deb969.html#files","title":"Files","text":"Name Libs/Utils/EigenUtils.h Libs/Utils/PlatformUtils.h Libs/Utils/StringUtils.h Libs/Utils/Utils.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_7d4dd3d8a2b1d1a0e92682acfb57f0f0.html","title":"Studio/Job","text":""},{"location":"api/Files/dir_7d4dd3d8a2b1d1a0e92682acfb57f0f0.html#files","title":"Files","text":"Name Studio/Job/GroupPvalueJob.h Studio/Job/NetworkAnalysisJob.h Studio/Job/ParticleAreaJob.h Studio/Job/ParticleNormalEvaluationJob.h Studio/Job/ShapeScalarJob.h Studio/Job/StatsGroupLDAJob.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_85653c7ab6d0c0e003ea454a8b2baba9.html","title":"Libs/Optimize/Utils","text":""},{"location":"api/Files/dir_85653c7ab6d0c0e003ea454a8b2baba9.html#files","title":"Files","text":"Name Libs/Optimize/Utils/MemoryUsage.h Libs/Optimize/Utils/ObjectReader.h Libs/Optimize/Utils/ObjectWriter.h Libs/Optimize/Utils/OptimizationVisualizer.h Libs/Optimize/Utils/ParticleGaussianModeWriter.h Libs/Optimize/Utils/ParticleGoodBadAssessment.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_8703d550aef9c899d5cf3c4cd311a554.html","title":"Libs/Optimize/Container","text":""},{"location":"api/Files/dir_8703d550aef9c899d5cf3c4cd311a554.html#files","title":"Files","text":"Name Libs/Optimize/Container/GenericContainer.h Libs/Optimize/Container/GenericContainerArray.h Libs/Optimize/Container/MeanCurvatureContainer.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_8c1195e4829fa17630c4278c41da729a.html","title":"Applications","text":""},{"location":"api/Files/dir_8c1195e4829fa17630c4278c41da729a.html#directories","title":"Directories","text":"Name Applications/shapeworks <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_9ab7bf277be286941ed03c100233212b.html","title":"Libs/Application","text":""},{"location":"api/Files/dir_9ab7bf277be286941ed03c100233212b.html#directories","title":"Directories","text":"Name Libs/Application/DeepSSM Libs/Application/Job"},{"location":"api/Files/dir_9ab7bf277be286941ed03c100233212b.html#files","title":"Files","text":"Name Libs/Application/ShapeWorksVtkOutputWindow.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_9e4ba78685e6608cfdea07960abd189c.html","title":"Libs/Image","text":""},{"location":"api/Files/dir_9e4ba78685e6608cfdea07960abd189c.html#files","title":"Files","text":"Name Libs/Image/Image.h Libs/Image/ImageUtils.h Libs/Image/itkTPGACLevelSetImageFilter.h Libs/Image/VectorImage.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_9e99c41d3802fada2a0119d079df0956.html","title":"Studio/Optimize","text":""},{"location":"api/Files/dir_9e99c41d3802fada2a0119d079df0956.html#files","title":"Files","text":"Name Studio/Optimize/OptimizeTool.h Studio/Optimize/QOptimize.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_a4bc8cdb2751c8604311dac5c98fb558.html","title":"Studio/Resources","text":""},{"location":"api/Files/dir_a4bc8cdb2751c8604311dac5c98fb558.html#files","title":"Files","text":"Name Studio/Resources/resource.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_aee3ea6bcd7d0f0da850c3e9fd33d5af.html","title":"Libs/Optimize/Constraints","text":""},{"location":"api/Files/dir_aee3ea6bcd7d0f0da850c3e9fd33d5af.html#files","title":"Files","text":"Name Libs/Optimize/Constraints/Constraint.h Libs/Optimize/Constraints/Constraints.h Libs/Optimize/Constraints/ConstraintType.h Libs/Optimize/Constraints/FreeFormConstraint.h Libs/Optimize/Constraints/PlaneConstraint.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_b0b944fd4368961b4965dd28c72a00a2.html","title":"Studio/Data","text":""},{"location":"api/Files/dir_b0b944fd4368961b4965dd28c72a00a2.html#files","title":"Files","text":"Name Studio/Data/DataTool.h Studio/Data/ExportUtils.h Studio/Data/LandmarkItemDelegate.h Studio/Data/LandmarkTableModel.h Studio/Data/MeshSettings.h Studio/Data/Preferences.h Studio/Data/PreferencesWindow.h Studio/Data/SegmentationToolPanel.h Studio/Data/Session.h Studio/Data/ShapeWorksWorker.h Studio/Data/Telemetry.h Studio/Data/Worker.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_b61e4180fa497c41c4b364a945b36efe.html","title":"Documentation/Doxygen","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_b6c1f9d4f6080dc79a7a9d2c69150815.html","title":"Studio/Visualization","text":""},{"location":"api/Files/dir_b6c1f9d4f6080dc79a7a9d2c69150815.html#files","title":"Files","text":"Name Studio/Visualization/ColorMap.h Studio/Visualization/ColorSchemes.h Studio/Visualization/LandmarkWidget.h Studio/Visualization/Lightbox.h Studio/Visualization/MeshSlice.h Studio/Visualization/PaintWidget.h Studio/Visualization/ParticleColors.h Studio/Visualization/PlaneWidget.h Studio/Visualization/SliceView.h Studio/Visualization/StudioHandleWidget.h Studio/Visualization/StudioImageActorPointPlacer.h Studio/Visualization/StudioInteractorStyle.h Studio/Visualization/StudioSliceInteractorStyle.h Studio/Visualization/Viewer.h Studio/Visualization/Visualizer.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_b92c77c85671879e4c48e03051777b7e.html","title":"Libs/Optimize/Domain","text":""},{"location":"api/Files/dir_b92c77c85671879e4c48e03051777b7e.html#files","title":"Files","text":"Name Libs/Optimize/Domain/ContourDomain.h Libs/Optimize/Domain/DomainType.h Libs/Optimize/Domain/ImageDomain.h Libs/Optimize/Domain/ImageDomainWithCurvature.h Libs/Optimize/Domain/ImageDomainWithGradients.h Libs/Optimize/Domain/ImageDomainWithGradN.h Libs/Optimize/Domain/ImplicitSurfaceDomain.h Libs/Optimize/Domain/MeshDomain.h Libs/Optimize/Domain/MeshGeoEntry.h Libs/Optimize/Domain/ParticleDomain.h Libs/Optimize/Domain/ParticleRegionDomain.h Libs/Optimize/Domain/Surface.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_baf8d66207f3fc39faf866e67ca98ce2.html","title":"Studio","text":""},{"location":"api/Files/dir_baf8d66207f3fc39faf866e67ca98ce2.html#directories","title":"Directories","text":"Name Studio/Analysis Studio/Data Studio/DeepSSM Studio/Groom Studio/Interface Studio/Job Studio/Optimize Studio/Resources Studio/ShapeWorksMONAI Studio/Utils Studio/Visualization <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_c13ed27a749775eeb2d59234813cae48.html","title":"Libs/Common","text":""},{"location":"api/Files/dir_c13ed27a749775eeb2d59234813cae48.html#files","title":"Files","text":"Name Libs/Common/Logging.h Libs/Common/Profiling.h Libs/Common/Region.h Libs/Common/Shapeworks.h Libs/Common/ShapeworksUtils.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_c8a30dba58b805ee2d567ab327483fca.html","title":"Libs/Alignment","text":""},{"location":"api/Files/dir_c8a30dba58b805ee2d567ab327483fca.html#directories","title":"Directories","text":"Name Libs/Alignment/Transforms"},{"location":"api/Files/dir_c8a30dba58b805ee2d567ab327483fca.html#files","title":"Files","text":"Name Libs/Alignment/Procrustes3D.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_c8ce71b7fc76205395f44c2291e69b75.html","title":"Libs/Groom","text":""},{"location":"api/Files/dir_c8ce71b7fc76205395f44c2291e69b75.html#files","title":"Files","text":"Name Libs/Groom/Groom.h Libs/Groom/GroomParameters.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_cb8980ab440f994989990a6313097edf.html","title":"Documentation","text":""},{"location":"api/Files/dir_cb8980ab440f994989990a6313097edf.html#directories","title":"Directories","text":"Name Documentation/Doxygen <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_d0685ddcbfeb436aff8439708f351fe6.html","title":"Libs/Application/Job","text":""},{"location":"api/Files/dir_d0685ddcbfeb436aff8439708f351fe6.html#files","title":"Files","text":"Name Libs/Application/Job/Job.h Libs/Application/Job/PythonWorker.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_d77cc112773b74d11448b7fad9142c8e.html","title":"Libs/Analyze","text":""},{"location":"api/Files/dir_d77cc112773b74d11448b7fad9142c8e.html#files","title":"Files","text":"Name Libs/Analyze/Analyze.h Libs/Analyze/CustomSurfaceReconstructionFilter.h Libs/Analyze/ItkToVtk.h Libs/Analyze/LegacyMeshGenerator.h Mesh generation. Libs/Analyze/MeshCache.h Libs/Analyze/MeshGenerator.h Mesh generation. Libs/Analyze/MeshGroup.h Libs/Analyze/MeshManager.h Libs/Analyze/MeshWorker.h Worker class for parallel mesh reconstruction. Libs/Analyze/MeshWorkQueue.h Libs/Analyze/ParticleArea.h Libs/Analyze/Particles.h Libs/Analyze/QMeshWarper.h Libs/Analyze/Reconstruction.h Libs/Analyze/Shape.h Libs/Analyze/StudioEnums.h Libs/Analyze/StudioMesh.h Libs/Analyze/SurfaceReconstructor.h Surface Reconstruction Layer. Libs/Analyze/vtkPolyDataToImageData.h <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/dir_e938d55d0d25a8e3889ca0b02966a6b3.html","title":"Studio/DeepSSM","text":""},{"location":"api/Files/dir_e938d55d0d25a8e3889ca0b02966a6b3.html#files","title":"Files","text":"Name Studio/DeepSSM/DeepSSMTool.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_f02d5d8e81e1edd3722111e50e18938d.html","title":"Libs/Optimize","text":""},{"location":"api/Files/dir_f02d5d8e81e1edd3722111e50e18938d.html#directories","title":"Directories","text":"Name Libs/Optimize/Constraints Libs/Optimize/Container Libs/Optimize/Domain Libs/Optimize/Function Libs/Optimize/Matrix Libs/Optimize/Neighborhood Libs/Optimize/Utils"},{"location":"api/Files/dir_f02d5d8e81e1edd3722111e50e18938d.html#files","title":"Files","text":"Name Libs/Optimize/CorrespondenceMode.h Libs/Optimize/EarlyStoppingConfig.h Libs/Optimize/GradientDescentOptimizer.h Libs/Optimize/Observer.h Libs/Optimize/Optimize.h Libs/Optimize/OptimizeParameterFile.h Libs/Optimize/OptimizeParameters.h Libs/Optimize/ParticleEvents.h Libs/Optimize/ParticleSystem.h Libs/Optimize/ProcrustesRegistration.h Libs/Optimize/Sampler.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_f27aadd9c7f02e71212dbf7893d91496.html","title":"Studio/Interface","text":""},{"location":"api/Files/dir_f27aadd9c7f02e71212dbf7893d91496.html#files","title":"Files","text":"Name Studio/Interface/CompareWidget.h Studio/Interface/CustomSlider.h Studio/Interface/ExportImageDialog.h Studio/Interface/KeyboardShortcuts.h Studio/Interface/LogWindow.h Studio/Interface/ShapeWorksStudioApp.h Studio/Interface/SplashScreen.h Studio/Interface/StatusBarWidget.h Studio/Interface/StudioLogger.h Studio/Interface/Style.h Studio/Interface/UpdateChecker.h Studio/Interface/WheelEventForwarder.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/dir_f6c26397dfcef1d1f5f1786f8168e7dd.html","title":"Libs/Particles","text":""},{"location":"api/Files/dir_f6c26397dfcef1d1f5f1786f8168e7dd.html#files","title":"Files","text":"Name Libs/Particles/EvaluationUtil.h Libs/Particles/ParticleFile.h Libs/Particles/ParticleNormalEvaluation.h Libs/Particles/ParticleShapeStatistics.h Libs/Particles/ParticleSystemEvaluation.h Libs/Particles/ReconstructSurface.h Libs/Particles/ShapeEvaluation.h <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/index_files.html","title":"Files","text":"<ul> <li>dir Applications <ul> <li>dir Applications/shapeworks <ul> <li>file Applications/shapeworks/Command.h </li> <li>file Applications/shapeworks/Commands.h </li> <li>file Applications/shapeworks/Executable.h </li> <li>file Applications/shapeworks/SharedCommandData.h </li> </ul> </li> </ul> </li> <li>dir Documentation <ul> <li>dir Documentation/Doxygen </li> </ul> </li> <li>dir Libs <ul> <li>dir Libs/Alignment <ul> <li>dir Libs/Alignment/Transforms <ul> <li>file Libs/Alignment/Transforms/itkAdvancedTransform.h </li> <li>file Libs/Alignment/Transforms/itkCompactlySupportedRBFSparseKernelTransform.h </li> <li>file Libs/Alignment/Transforms/itkKernelTransform2.h </li> <li>file Libs/Alignment/Transforms/itkSparseKernelTransform.h </li> <li>file Libs/Alignment/Transforms/itkThinPlateSplineKernelTransform2.h </li> </ul> </li> <li>file Libs/Alignment/Procrustes3D.h </li> </ul> </li> <li>dir Libs/Analyze <ul> <li>file Libs/Analyze/Analyze.h </li> <li>file Libs/Analyze/CustomSurfaceReconstructionFilter.h </li> <li>file Libs/Analyze/ItkToVtk.h </li> <li>file Libs/Analyze/LegacyMeshGenerator.h Mesh generation. </li> <li>file Libs/Analyze/MeshCache.h </li> <li>file Libs/Analyze/MeshGenerator.h Mesh generation. </li> <li>file Libs/Analyze/MeshGroup.h </li> <li>file Libs/Analyze/MeshManager.h </li> <li>file Libs/Analyze/MeshWorkQueue.h </li> <li>file Libs/Analyze/MeshWorker.h Worker class for parallel mesh reconstruction. </li> <li>file Libs/Analyze/ParticleArea.h </li> <li>file Libs/Analyze/Particles.h </li> <li>file Libs/Analyze/QMeshWarper.h </li> <li>file Libs/Analyze/Reconstruction.h </li> <li>file Libs/Analyze/Shape.h </li> <li>file Libs/Analyze/StudioEnums.h </li> <li>file Libs/Analyze/StudioMesh.h </li> <li>file Libs/Analyze/SurfaceReconstructor.h Surface Reconstruction Layer. </li> <li>file Libs/Analyze/vtkPolyDataToImageData.h </li> </ul> </li> <li>dir Libs/Application <ul> <li>dir Libs/Application/DeepSSM <ul> <li>file Libs/Application/DeepSSM/DeepSSMJob.h </li> </ul> </li> <li>dir Libs/Application/Job <ul> <li>file Libs/Application/Job/Job.h </li> <li>file Libs/Application/Job/PythonWorker.h </li> </ul> </li> <li>file Libs/Application/ShapeWorksVtkOutputWindow.h </li> </ul> </li> <li>dir Libs/Common <ul> <li>file Libs/Common/Logging.h </li> <li>file Libs/Common/Profiling.h </li> <li>file Libs/Common/Region.h </li> <li>file Libs/Common/Shapeworks.h </li> <li>file Libs/Common/ShapeworksUtils.h </li> </ul> </li> <li>dir Libs/Groom <ul> <li>file Libs/Groom/Groom.h </li> <li>file Libs/Groom/GroomParameters.h </li> </ul> </li> <li>dir Libs/Image <ul> <li>file Libs/Image/Image.h </li> <li>file Libs/Image/ImageUtils.h </li> <li>file Libs/Image/VectorImage.h </li> <li>file Libs/Image/itkTPGACLevelSetImageFilter.h </li> </ul> </li> <li>dir Libs/Mesh <ul> <li>dir Libs/Mesh/PreviewMeshQC <ul> <li>file Libs/Mesh/PreviewMeshQC/FEAreaCoverage.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEAutoMesher.h </li> <li>file Libs/Mesh/PreviewMeshQC/FECVDDecimationModifier.h </li> <li>file Libs/Mesh/PreviewMeshQC/FECoreMesh.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEElement.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEFillHole.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEFixMesh.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEMesh.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEMeshSmoothingModifier.h </li> <li>file Libs/Mesh/PreviewMeshQC/FENodeElementList.h </li> <li>file Libs/Mesh/PreviewMeshQC/FENodeFaceList.h </li> <li>file Libs/Mesh/PreviewMeshQC/FENodeNodeList.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEVTKExport.h </li> <li>file Libs/Mesh/PreviewMeshQC/FEVTKImport.h </li> <li>file Libs/Mesh/PreviewMeshQC/Intersect.h </li> <li>file Libs/Mesh/PreviewMeshQC/math3d.h </li> <li>file Libs/Mesh/PreviewMeshQC/stdafx.h </li> </ul> </li> <li>file Libs/Mesh/Mesh.h </li> <li>file Libs/Mesh/MeshComputeThickness.h </li> <li>file Libs/Mesh/MeshUtils.h </li> <li>file Libs/Mesh/MeshWarper.h Mesh warping capability. </li> <li>file Libs/Mesh/itkMultiplyByConstantImageFilter.h </li> <li>file Libs/Mesh/meshFIM.h </li> </ul> </li> <li>dir Libs/Optimize <ul> <li>file Libs/Optimize/CorrespondenceMode.h </li> <li>file Libs/Optimize/EarlyStoppingConfig.h </li> <li>file Libs/Optimize/GradientDescentOptimizer.h </li> <li>dir Libs/Optimize/Constraints <ul> <li>file Libs/Optimize/Constraints/Constraint.h </li> <li>file Libs/Optimize/Constraints/ConstraintType.h </li> <li>file Libs/Optimize/Constraints/Constraints.h </li> <li>file Libs/Optimize/Constraints/FreeFormConstraint.h </li> <li>file Libs/Optimize/Constraints/PlaneConstraint.h </li> </ul> </li> <li>dir Libs/Optimize/Container <ul> <li>file Libs/Optimize/Container/GenericContainer.h </li> <li>file Libs/Optimize/Container/GenericContainerArray.h </li> <li>file Libs/Optimize/Container/MeanCurvatureContainer.h </li> </ul> </li> <li>dir Libs/Optimize/Domain <ul> <li>file Libs/Optimize/Domain/ContourDomain.h </li> <li>file Libs/Optimize/Domain/DomainType.h </li> <li>file Libs/Optimize/Domain/ImageDomain.h </li> <li>file Libs/Optimize/Domain/ImageDomainWithCurvature.h </li> <li>file Libs/Optimize/Domain/ImageDomainWithGradN.h </li> <li>file Libs/Optimize/Domain/ImageDomainWithGradients.h </li> <li>file Libs/Optimize/Domain/ImplicitSurfaceDomain.h </li> <li>file Libs/Optimize/Domain/MeshDomain.h </li> <li>file Libs/Optimize/Domain/MeshGeoEntry.h </li> <li>file Libs/Optimize/Domain/ParticleDomain.h </li> <li>file Libs/Optimize/Domain/ParticleRegionDomain.h </li> <li>file Libs/Optimize/Domain/Surface.h </li> </ul> </li> <li>dir Libs/Optimize/Function <ul> <li>file Libs/Optimize/Function/CorrespondenceFunction.h </li> <li>file Libs/Optimize/Function/DisentangledCorrespondenceFunction.h </li> <li>file Libs/Optimize/Function/DualVectorFunction.h </li> <li>file Libs/Optimize/Function/LegacyCorrespondenceFunction.h </li> <li>dir Libs/Optimize/Function/EarlyStop <ul> <li>file Libs/Optimize/Function/EarlyStop/EarlyStopping.h </li> <li>file Libs/Optimize/Function/EarlyStop/MorphologicalDeviationScore.h </li> </ul> </li> <li>file Libs/Optimize/Function/SamplingFunction.h </li> <li>file Libs/Optimize/Function/VectorFunction.h </li> </ul> </li> <li>dir Libs/Optimize/Matrix <ul> <li>file Libs/Optimize/Matrix/LegacyShapeMatrix.h </li> <li>file Libs/Optimize/Matrix/LinearRegressionShapeMatrix.h </li> <li>file Libs/Optimize/Matrix/MixedEffectsShapeMatrix.h </li> <li>file Libs/Optimize/Matrix/ShapeGradientMatrix.h </li> <li>file Libs/Optimize/Matrix/ShapeMatrix.h </li> </ul> </li> <li>dir Libs/Optimize/Neighborhood <ul> <li>file Libs/Optimize/Neighborhood/ParticleNeighborhood.h </li> <li>file Libs/Optimize/Neighborhood/ParticlePointIndexPair.h </li> </ul> </li> <li>dir Libs/Optimize/Utils <ul> <li>file Libs/Optimize/Utils/MemoryUsage.h </li> <li>file Libs/Optimize/Utils/ObjectReader.h </li> <li>file Libs/Optimize/Utils/ObjectWriter.h </li> <li>file Libs/Optimize/Utils/OptimizationVisualizer.h </li> <li>file Libs/Optimize/Utils/ParticleGaussianModeWriter.h </li> <li>file Libs/Optimize/Utils/ParticleGoodBadAssessment.h </li> </ul> </li> <li>file Libs/Optimize/Observer.h </li> <li>file Libs/Optimize/Optimize.h </li> <li>file Libs/Optimize/OptimizeParameterFile.h </li> <li>file Libs/Optimize/OptimizeParameters.h </li> <li>file Libs/Optimize/ParticleEvents.h </li> <li>file Libs/Optimize/ParticleSystem.h </li> <li>file Libs/Optimize/ProcrustesRegistration.h </li> <li>file Libs/Optimize/Sampler.h </li> </ul> </li> <li>dir Libs/Particles <ul> <li>file Libs/Particles/EvaluationUtil.h </li> <li>file Libs/Particles/ParticleFile.h </li> <li>file Libs/Particles/ParticleNormalEvaluation.h </li> <li>file Libs/Particles/ParticleShapeStatistics.h </li> <li>file Libs/Particles/ParticleSystemEvaluation.h </li> <li>file Libs/Particles/ReconstructSurface.h </li> <li>file Libs/Particles/ShapeEvaluation.h </li> </ul> </li> <li>dir Libs/Project <ul> <li>file Libs/Project/DeepSSMParameters.h </li> <li>file Libs/Project/ExcelProjectReader.h </li> <li>file Libs/Project/ExcelProjectWriter.h </li> <li>file Libs/Project/JsonProjectReader.h </li> <li>file Libs/Project/JsonProjectWriter.h </li> <li>file Libs/Project/Parameters.h </li> <li>file Libs/Project/Project.h </li> <li>file Libs/Project/ProjectReader.h </li> <li>file Libs/Project/ProjectUtils.h </li> <li>file Libs/Project/Subject.h </li> <li>file Libs/Project/Variant.h </li> </ul> </li> <li>dir Libs/Python <ul> <li>file Libs/Python/PythonAnalyze.h </li> <li>file Libs/Python/PythonGroom.h </li> <li>file Libs/Python/pybind_utils.h </li> </ul> </li> <li>dir Libs/Utils <ul> <li>file Libs/Utils/EigenUtils.h </li> <li>file Libs/Utils/PlatformUtils.h </li> <li>file Libs/Utils/StringUtils.h </li> <li>file Libs/Utils/Utils.h </li> </ul> </li> </ul> </li> <li>file Module.dox </li> <li>dir Studio <ul> <li>dir Studio/Analysis <ul> <li>file Studio/Analysis/AnalysisTool.h </li> <li>file Studio/Analysis/ParticleAreaPanel.h </li> <li>file Studio/Analysis/ShapeEvaluationJob.h </li> <li>file Studio/Analysis/ShapeScalarPanel.h </li> </ul> </li> <li>dir Studio/Data <ul> <li>file Studio/Data/DataTool.h </li> <li>file Studio/Data/ExportUtils.h </li> <li>file Studio/Data/LandmarkItemDelegate.h </li> <li>file Studio/Data/LandmarkTableModel.h </li> <li>file Studio/Data/MeshSettings.h </li> <li>file Studio/Data/Preferences.h </li> <li>file Studio/Data/PreferencesWindow.h </li> <li>file Studio/Data/SegmentationToolPanel.h </li> <li>file Studio/Data/Session.h </li> <li>file Studio/Data/ShapeWorksWorker.h </li> <li>file Studio/Data/Telemetry.h </li> <li>file Studio/Data/Worker.h </li> </ul> </li> <li>dir Studio/DeepSSM <ul> <li>file Studio/DeepSSM/DeepSSMTool.h </li> </ul> </li> <li>dir Studio/Groom <ul> <li>file Studio/Groom/GroomTool.h </li> </ul> </li> <li>dir Studio/Interface <ul> <li>file Studio/Interface/CompareWidget.h </li> <li>file Studio/Interface/CustomSlider.h </li> <li>file Studio/Interface/ExportImageDialog.h </li> <li>file Studio/Interface/KeyboardShortcuts.h </li> <li>file Studio/Interface/LogWindow.h </li> <li>file Studio/Interface/ShapeWorksStudioApp.h </li> <li>file Studio/Interface/SplashScreen.h </li> <li>file Studio/Interface/StatusBarWidget.h </li> <li>file Studio/Interface/StudioLogger.h </li> <li>file Studio/Interface/Style.h </li> <li>file Studio/Interface/UpdateChecker.h </li> <li>file Studio/Interface/WheelEventForwarder.h </li> </ul> </li> <li>dir Studio/Job <ul> <li>file Studio/Job/GroupPvalueJob.h </li> <li>file Studio/Job/NetworkAnalysisJob.h </li> <li>file Studio/Job/ParticleAreaJob.h </li> <li>file Studio/Job/ParticleNormalEvaluationJob.h </li> <li>file Studio/Job/ShapeScalarJob.h </li> <li>file Studio/Job/StatsGroupLDAJob.h </li> </ul> </li> <li>dir Studio/Optimize <ul> <li>file Studio/Optimize/OptimizeTool.h </li> <li>file Studio/Optimize/QOptimize.h </li> </ul> </li> <li>dir Studio/Resources <ul> <li>file Studio/Resources/resource.h </li> </ul> </li> <li>dir Studio/ShapeWorksMONAI <ul> <li>file Studio/ShapeWorksMONAI/MonaiLabelJob.h </li> <li>file Studio/ShapeWorksMONAI/MonaiLabelTool.h </li> <li>file Studio/ShapeWorksMONAI/MonaiLabelUtils.h </li> </ul> </li> <li>dir Studio/Utils <ul> <li>file Studio/Utils/AnalysisUtils.h </li> <li>file Studio/Utils/ImageLabel.h </li> <li>file Studio/Utils/StackWalker.h </li> <li>file Studio/Utils/StudioUtils.h </li> <li>file Studio/Utils/WindowsCrashHandler.h </li> </ul> </li> <li>dir Studio/Visualization <ul> <li>file Studio/Visualization/ColorMap.h </li> <li>file Studio/Visualization/ColorSchemes.h </li> <li>file Studio/Visualization/LandmarkWidget.h </li> <li>file Studio/Visualization/Lightbox.h </li> <li>file Studio/Visualization/MeshSlice.h </li> <li>file Studio/Visualization/PaintWidget.h </li> <li>file Studio/Visualization/ParticleColors.h </li> <li>file Studio/Visualization/PlaneWidget.h </li> <li>file Studio/Visualization/SliceView.h </li> <li>file Studio/Visualization/StudioHandleWidget.h </li> <li>file Studio/Visualization/StudioImageActorPointPlacer.h </li> <li>file Studio/Visualization/StudioInteractorStyle.h </li> <li>file Studio/Visualization/StudioSliceInteractorStyle.h </li> <li>file Studio/Visualization/Viewer.h </li> <li>file Studio/Visualization/Visualizer.h </li> </ul> </li> </ul> </li> </ul> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/itkAdvancedTransform_8h.html","title":"Libs/Alignment/Transforms/itkAdvancedTransform.h","text":""},{"location":"api/Files/itkAdvancedTransform_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkAdvancedTransform_8h.html#classes","title":"Classes","text":"Name class itk::AdvancedTransform Transform maps points, vectors and covariant vectors from an input space to an output space."},{"location":"api/Files/itkAdvancedTransform_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n *\n *  Copyright UMC Utrecht and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0.txt\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *=========================================================================*/\n/*=========================================================================\n\n  Program:   Insight Segmentation &amp; Registration Toolkit\n  Module:    $RCSfile: itkTransform.h,v $\n  Language:  C++\n  Date:      $Date: 2008-06-29 12:58:58 $\n  Version:   $Revision: 1.64 $\n\n  Copyright (c) Insight Software Consortium. All rights reserved.\n  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n#ifndef __itkAdvancedTransform_h\n#define __itkAdvancedTransform_h\n\n#include \"itkTransform.h\"\n#include \"itkMatrix.h\"\n#include \"itkFixedArray.h\"\n\nnamespace itk\n{\n\ntemplate&lt; class TScalarType,\nunsigned int NInputDimensions  = 3,\nunsigned int NOutputDimensions = 3 &gt;\nclass AdvancedTransform :\n  public Transform&lt; TScalarType, NInputDimensions, NOutputDimensions &gt;\n{\npublic:\n\n  typedef AdvancedTransform Self;\n  typedef Transform&lt; TScalarType,\n    NInputDimensions,\n    NOutputDimensions &gt;               Superclass;\n  typedef SmartPointer&lt; Self &gt;       Pointer;\n  typedef SmartPointer&lt; const Self &gt; ConstPointer;\n\n  //itkNewMacro( Self );\n\n  itkTypeMacro( AdvancedTransform, Transform );\n\n  itkStaticConstMacro( InputSpaceDimension, unsigned int, NInputDimensions );\n  itkStaticConstMacro( OutputSpaceDimension, unsigned int, NOutputDimensions );\n\n  typedef typename Superclass::ScalarType             ScalarType;\n  typedef typename Superclass::ParametersType         ParametersType;\n  typedef typename Superclass::ParametersValueType    ParametersValueType;\n  typedef typename Superclass::NumberOfParametersType NumberOfParametersType;\n  typedef typename Superclass::DerivativeType         DerivativeType;\n  typedef typename Superclass::JacobianType           JacobianType;\n  typedef typename Superclass::InputVectorType        InputVectorType;\n  typedef typename Superclass::OutputVectorType       OutputVectorType;\n  typedef typename Superclass\n    ::InputCovariantVectorType InputCovariantVectorType;\n  typedef typename Superclass\n    ::OutputCovariantVectorType OutputCovariantVectorType;\n  typedef typename Superclass::InputVnlVectorType  InputVnlVectorType;\n  typedef typename Superclass::OutputVnlVectorType OutputVnlVectorType;\n  typedef typename Superclass::InputPointType      InputPointType;\n  typedef typename Superclass::OutputPointType     OutputPointType;\n\n  typedef typename Superclass::InverseTransformBaseType    InverseTransformBaseType;\n  typedef typename Superclass::InverseTransformBasePointer InverseTransformBasePointer;\n\n  typedef Transform&lt; TScalarType,\n    NInputDimensions,\n    NOutputDimensions &gt;                             TransformType;\n  typedef typename TransformType::Pointer      TransformTypePointer;\n  typedef typename TransformType::ConstPointer TransformTypeConstPointer;\n\n  typedef std::vector&lt; unsigned long &gt; NonZeroJacobianIndicesType;\n  typedef Matrix&lt; ScalarType,\n    OutputSpaceDimension, InputSpaceDimension &gt;     SpatialJacobianType;\n  typedef std::vector&lt; SpatialJacobianType &gt; JacobianOfSpatialJacobianType;\n  // \\todo: think about the SpatialHessian type, should be a 3D native type\n  typedef FixedArray&lt;\n    Matrix&lt; ScalarType,\n    InputSpaceDimension, InputSpaceDimension &gt;,\n    OutputSpaceDimension &gt;                          SpatialHessianType;\n  typedef std::vector&lt; SpatialHessianType &gt;                JacobianOfSpatialHessianType;\n  typedef typename SpatialJacobianType::InternalMatrixType InternalMatrixType;\n\n  typedef OutputCovariantVectorType                   MovingImageGradientType;\n  typedef typename MovingImageGradientType::ValueType MovingImageGradientValueType;\n\n  virtual NumberOfParametersType GetNumberOfNonZeroJacobianIndices( void ) const;\n\n  itkGetConstMacro( HasNonZeroSpatialHessian, bool );\n  itkGetConstMacro( HasNonZeroJacobianOfSpatialHessian, bool );\n\n  virtual void GetJacobian(\n    const InputPointType &amp; ipp,\n    JacobianType &amp; j,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const = 0;\n\n  virtual void EvaluateJacobianWithImageGradientProduct(\n    const InputPointType &amp; ipp,\n    const MovingImageGradientType &amp; movingImageGradient,\n    DerivativeType &amp; imageJacobian,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const;\n\n  virtual void GetSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj ) const = 0;\n\n  virtual void ComputeJacobianWithRespectToParameters(\n    const InputPointType &amp; itkNotUsed( p ), JacobianType &amp; itkNotUsed( j ) ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"This ITK4 function is currently not used in elastix.\" );\n  }\n\n\n  virtual void ComputeJacobianWithRespectToPosition(\n    const InputPointType &amp; itkNotUsed( p ), JacobianType &amp; itkNotUsed( j ) ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"This ITK4 function is currently not used in elastix.\" );\n  }\n\n\n  virtual void GetSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh ) const = 0;\n\n  virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const = 0;\n\n  virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp,\n    SpatialJacobianType &amp; sj,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const = 0;\n\n  virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const = 0;\n\n  virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp,\n    SpatialHessianType &amp; sh,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const = 0;\n\nprotected:\n\n  AdvancedTransform();\n  AdvancedTransform( NumberOfParametersType numberOfParameters );\n  virtual ~AdvancedTransform() {}\n\n  bool m_HasNonZeroSpatialHessian;\n  bool m_HasNonZeroJacobianOfSpatialHessian;\n\nprivate:\n\n  AdvancedTransform( const Self &amp; ); // purposely not implemented\n  void operator=( const Self &amp; );    // purposely not implemented\n\n};\n\n} // end namespace itk\n\n#include \"itkAdvancedTransform.cpp\"\n\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/itkCompactlySupportedRBFSparseKernelTransform_8h.html","title":"Libs/Alignment/Transforms/itkCompactlySupportedRBFSparseKernelTransform.h","text":""},{"location":"api/Files/itkCompactlySupportedRBFSparseKernelTransform_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkCompactlySupportedRBFSparseKernelTransform_8h.html#classes","title":"Classes","text":"Name class itk::CompactlySupportedRBFSparseKernelTransform"},{"location":"api/Files/itkCompactlySupportedRBFSparseKernelTransform_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n\n  Program:   Insight Segmentation &amp; Registration Toolkit\n  Module:    $RCSfile: itkCompactlySupportedRBFSparseKernelTransform.h,v $\n  Language:  C++\n  Date:      $Date: 2014-1-28 14:22:18 $\n  Version:   $Revision: 1.1 $\n\n  Copyright (c) Insight Software Consortium. All rights reserved.\n  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n#ifndef __itkCompactlySupportedRBFSparseKernelTransform_h\n#define __itkCompactlySupportedRBFSparseKernelTransform_h\n\n#include \"itkSparseKernelTransform.h\"\n\nnamespace itk\n{\ntemplate &lt;class TScalarType,         // Data type for scalars (float or double)\n          unsigned int NDimensions = 3&gt;          // Number of dimensions\nclass ITK_EXPORT CompactlySupportedRBFSparseKernelTransform :\n        public SparseKernelTransform&lt;   TScalarType, NDimensions&gt;\n{\npublic:\n    typedef CompactlySupportedRBFSparseKernelTransform Self;\n    typedef SparseKernelTransform&lt;    TScalarType, NDimensions&gt;   Superclass;\n    typedef SmartPointer&lt;Self&gt;        Pointer;\n    typedef SmartPointer&lt;const Self&gt;  ConstPointer;\n\n    itkNewMacro( Self );\n\n    itkTypeMacro( CompactlySupportedRBFSparseKernelTransform, SparseKernelTransform );\n\n    typedef typename Superclass::ScalarType  ScalarType;\n\n    typedef typename Superclass::ParametersType  ParametersType;\n\n    typedef typename Superclass::JacobianType  JacobianType;\n\n    itkStaticConstMacro(SpaceDimension, unsigned int,Superclass::SpaceDimension);\n\n    typedef typename Superclass::InputPointType  InputPointType;\n    typedef typename Superclass::OutputPointType  OutputPointType;\n    typedef typename Superclass::InputVectorType InputVectorType;\n    typedef typename Superclass::OutputVectorType OutputVectorType;\n    typedef typename Superclass::InputCovariantVectorType InputCovariantVectorType;\n    typedef typename Superclass::OutputCovariantVectorType OutputCovariantVectorType;\n    typedef typename Superclass::PointsIterator PointsIterator;\n    //  void SetParameters( const ParametersType &amp; parameters );\n\n    void SetSigma(double sigma){this-&gt;Sigma = sigma;}\n\n    virtual void ComputeJacobianWithRespectToParameters(\n        const InputPointType  &amp;in, JacobianType &amp;jacobian) const;\n\n\nprotected:\n    CompactlySupportedRBFSparseKernelTransform() {this-&gt;Sigma = 1; }\n    virtual ~CompactlySupportedRBFSparseKernelTransform() {}\n\n    typedef typename Superclass::GMatrixType GMatrixType;\n\n    const GMatrixType &amp; ComputeG(const InputVectorType &amp; x) const override;\n\n    virtual void ComputeDeformationContribution( const InputPointType &amp; inputPoint,\n                                                 OutputPointType &amp; result ) const override;\n\nprivate:\n    CompactlySupportedRBFSparseKernelTransform(const Self&amp;); //purposely not implemented\n    void operator=(const Self&amp;); //purposely not implemented\n\n    // basis support\n    double Sigma;\n\n};\n\n} // namespace itk\n\n#include \"itkCompactlySupportedRBFSparseKernelTransform.cpp\"\n\n\n#endif // __itkCompactlySupportedRBFSparseKernelTransform_h\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/itkKernelTransform2_8h.html","title":"Libs/Alignment/Transforms/itkKernelTransform2.h","text":""},{"location":"api/Files/itkKernelTransform2_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkKernelTransform2_8h.html#classes","title":"Classes","text":"Name class itk::KernelTransform2"},{"location":"api/Files/itkKernelTransform2_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n *\n *  Copyright UMC Utrecht and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0.txt\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *=========================================================================*/\n/*=========================================================================\n\nProgram:   Insight Segmentation &amp; Registration Toolkit\nModule:    $RCSfile: itkKernelTransform2.h,v $\nLanguage:  C++\nDate:      $Date: 2006-11-28 14:22:18 $\nVersion:   $Revision: 1.1 $\n\nCopyright (c) Insight Software Consortium. All rights reserved.\nSee ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\nThis software is distributed WITHOUT ANY WARRANTY; without even\nthe implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n#ifndef __itkKernelTransform2_h\n#define __itkKernelTransform2_h\n\n#include \"itkAdvancedTransform.h\"\n#include \"itkPoint.h\"\n#include \"itkVector.h\"\n#include \"itkMatrix.h\"\n#include \"itkPointSet.h\"\n#include &lt;deque&gt;\n#include &lt;math.h&gt;\n#include \"vnl/vnl_matrix_fixed.h\"\n#include \"vnl/vnl_matrix.h\"\n#include \"vnl/vnl_vector.h\"\n#include \"vnl/vnl_vector_fixed.h\"\n#include \"vnl/vnl_sample.h\"\n#include \"vnl/algo/vnl_svd.h\"\n#include \"vnl/algo/vnl_qr.h\"\n\nnamespace itk\n{\n\ntemplate&lt; class TScalarType, // probably only float and double make sense here\nunsigned int NDimensions &gt;\n// Number of dimensions\nclass KernelTransform2 :\n  public AdvancedTransform&lt; TScalarType, NDimensions, NDimensions &gt;\n{\npublic:\n\n  typedef KernelTransform2 Self;\n  typedef AdvancedTransform&lt;\n    TScalarType, NDimensions, NDimensions &gt; Superclass;\n  typedef SmartPointer&lt; Self &gt;       Pointer;\n  typedef SmartPointer&lt; const Self &gt; ConstPointer;\n\n  itkTypeMacro( KernelTransform2, AdvancedTransform );\n\n  itkNewMacro( Self );\n\n  itkStaticConstMacro( SpaceDimension, unsigned int, NDimensions );\n\n  typedef typename Superclass::ScalarType                ScalarType;\n  typedef typename Superclass::ParametersType            ParametersType;\n  typedef typename Superclass::NumberOfParametersType    NumberOfParametersType;\n  typedef typename Superclass::JacobianType              JacobianType;\n  typedef typename Superclass::InputPointType            InputPointType;\n  typedef typename Superclass::OutputPointType           OutputPointType;\n  typedef typename Superclass::InputVectorType           InputVectorType;\n  typedef typename Superclass::OutputVectorType          OutputVectorType;\n  typedef typename Superclass::InputCovariantVectorType  InputCovariantVectorType;\n  typedef typename Superclass::OutputCovariantVectorType OutputCovariantVectorType;\n  typedef typename Superclass::InputVnlVectorType        InputVnlVectorType;\n  typedef typename Superclass::OutputVnlVectorType       OutputVnlVectorType;\n\n  typedef typename Superclass\n    ::NonZeroJacobianIndicesType NonZeroJacobianIndicesType;\n  typedef typename Superclass::SpatialJacobianType SpatialJacobianType;\n  typedef typename Superclass\n    ::JacobianOfSpatialJacobianType JacobianOfSpatialJacobianType;\n  typedef typename Superclass::SpatialHessianType SpatialHessianType;\n  typedef typename Superclass\n    ::JacobianOfSpatialHessianType JacobianOfSpatialHessianType;\n  typedef typename Superclass::InternalMatrixType InternalMatrixType;\n\n  typedef DefaultStaticMeshTraits&lt; TScalarType,\n    NDimensions, NDimensions, TScalarType, TScalarType &gt;       PointSetTraitsType;\n  typedef PointSet&lt; InputPointType, NDimensions,\n    PointSetTraitsType &gt;                                       PointSetType;\n  typedef typename PointSetType::Pointer                      PointSetPointer;\n  typedef typename PointSetType::PointsContainer              PointsContainer;\n  typedef typename PointSetType::PointsContainerIterator      PointsIterator;\n  typedef typename PointSetType::PointsContainerConstIterator PointsConstIterator;\n\n  typedef VectorContainer&lt; unsigned long, InputVectorType &gt; VectorSetType;\n  typedef typename VectorSetType::Pointer                   VectorSetPointer;\n\n  typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; IMatrixType;\n\n  virtual NumberOfParametersType GetNumberOfParameters( void ) const\n  {\n    return ( this-&gt;m_SourceLandmarks-&gt;GetNumberOfPoints() * SpaceDimension );\n  }\n\n\n  itkGetObjectMacro( SourceLandmarks, PointSetType );\n\n  virtual void SetSourceLandmarks( PointSetType * );\n\n  itkGetObjectMacro( TargetLandmarks, PointSetType );\n\n  virtual void SetTargetLandmarks( PointSetType * );\n\n  itkGetObjectMacro( Displacements, VectorSetType );\n\n  void ComputeWMatrix( void );\n\n  void ComputeLInverse( void );\n\n  virtual OutputPointType TransformPoint( const InputPointType &amp; thisPoint ) const;\n\n  virtual OutputVectorType TransformVector( const InputVectorType &amp; ) const\n  {\n    itkExceptionMacro(\n        &lt;&lt; \"TransformVector(const InputVectorType &amp;) is not implemented \"\n        &lt;&lt; \"for KernelTransform\" );\n  }\n\n\n  virtual OutputVnlVectorType TransformVector( const InputVnlVectorType &amp; ) const\n  {\n    itkExceptionMacro(\n        &lt;&lt; \"TransformVector(const InputVnlVectorType &amp;) is not implemented \"\n        &lt;&lt; \"for KernelTransform\" );\n  }\n\n\n  virtual OutputCovariantVectorType TransformCovariantVector( const InputCovariantVectorType &amp; ) const\n  {\n    itkExceptionMacro(\n        &lt;&lt; \"TransformCovariantVector(const InputCovariantVectorType &amp;) is not implemented \"\n        &lt;&lt; \"for KernelTransform\" );\n  }\n\n\n  virtual void GetJacobian(\n    const InputPointType &amp;,\n    JacobianType &amp;,\n    NonZeroJacobianIndicesType &amp; ) const;\n\n  virtual void SetIdentity( void );\n\n  virtual void SetParameters( const ParametersType &amp; );\n\n  virtual void SetFixedParameters( const ParametersType &amp; );\n\n  virtual void UpdateParameters( void );\n\n  virtual const ParametersType &amp; GetParameters( void ) const;\n\n  virtual const ParametersType &amp; GetFixedParameters( void ) const;\n\n  virtual void SetStiffness( double stiffness )\n  {\n    this-&gt;m_Stiffness        = stiffness &gt; 0 ? stiffness : 0.0;\n    this-&gt;m_LMatrixComputed  = false;\n    this-&gt;m_LInverseComputed = false;\n    this-&gt;m_WMatrixComputed  = false;\n  }\n\n\n  itkGetMacro( Stiffness, double );\n\n  virtual void SetAlpha( TScalarType itkNotUsed( Alpha ) ) {}\n  virtual TScalarType GetAlpha( void ) const { return -1.0; }\n\n  itkSetMacro( PoissonRatio, TScalarType );\n  virtual const TScalarType GetPoissonRatio( void ) const\n  {\n    return this-&gt;m_PoissonRatio;\n  }\n\n\n  itkSetMacro( MatrixInversionMethod, std::string );\n  itkGetConstReferenceMacro( MatrixInversionMethod, std::string );\n\n  virtual void GetSpatialJacobian(\n    const InputPointType &amp; ipp, SpatialJacobianType &amp; sj ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\n  virtual void GetSpatialHessian(\n    const InputPointType &amp; ipp, SpatialHessianType &amp; sh ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\n  virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp, JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\n  virtual void GetJacobianOfSpatialJacobian(\n    const InputPointType &amp; ipp, SpatialJacobianType &amp; sj,\n    JacobianOfSpatialJacobianType &amp; jsj,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\n  virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp, JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\n  virtual void GetJacobianOfSpatialHessian(\n    const InputPointType &amp; ipp, SpatialHessianType &amp; sh,\n    JacobianOfSpatialHessianType &amp; jsh,\n    NonZeroJacobianIndicesType &amp; nonZeroJacobianIndices ) const\n  {\n    itkExceptionMacro( &lt;&lt; \"Not implemented for KernelTransform2\" );\n  }\n\n\nprotected:\n\n  KernelTransform2();\n  virtual ~KernelTransform2();\n  void PrintSelf( std::ostream &amp; os, Indent indent ) const;\n\npublic:\n\n  typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; GMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; LMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; KMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; PMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; YMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; WMatrixType;\n\n  typedef vnl_matrix&lt; TScalarType &gt; DMatrixType;\n\n  typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, NDimensions &gt; AMatrixType;\n\n  typedef vnl_vector_fixed&lt; TScalarType, NDimensions &gt; BMatrixType;\n\n  typedef vnl_matrix_fixed&lt; TScalarType, 1, NDimensions &gt; RowMatrixType;\n\n  typedef vnl_matrix_fixed&lt; TScalarType, NDimensions, 1 &gt; ColumnMatrixType;\n\n  PointSetPointer m_SourceLandmarks;\n\n  PointSetPointer m_TargetLandmarks;\n\nprotected:\n\n  virtual void ComputeG( const InputVectorType &amp; landmarkVector,\n    GMatrixType &amp; GMatrix ) const;\n\n  virtual void ComputeReflexiveG( PointsIterator, GMatrixType &amp; GMatrix ) const;\n\n  virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint,\n    OutputPointType &amp; result ) const;\n\n  void ComputeK( void );\n\n  void ComputeL( void );\n\n  void ComputeP( void );\n\n  void ComputeY( void );\n\n  void ComputeD( void );\n\n  void ReorganizeW( void );\n\n  double m_Stiffness;\n\n  VectorSetPointer m_Displacements;\n\n  LMatrixType m_LMatrix;\n\n  LMatrixType m_LMatrixInverse;\n\n  KMatrixType m_KMatrix;\n\n  PMatrixType m_PMatrix;\n\n  YMatrixType m_YMatrix;\n\n  WMatrixType m_WMatrix;\n\n  DMatrixType m_DMatrix;\n\n  AMatrixType m_AMatrix;\n\n  BMatrixType m_BVector;\n\n  //GMatrixType m_GMatrix;\n\n  bool m_WMatrixComputed;\n  bool m_LMatrixComputed;\n  bool m_LInverseComputed;\n  bool m_LMatrixDecompositionComputed;\n\n  typedef vnl_svd&lt; ScalarType &gt; SVDDecompositionType;\n  typedef vnl_qr&lt; ScalarType &gt;  QRDecompositionType;\n\n  SVDDecompositionType * m_LMatrixDecompositionSVD;\n  QRDecompositionType *  m_LMatrixDecompositionQR;\n\n  IMatrixType m_I;\n\n  NonZeroJacobianIndicesType m_NonZeroJacobianIndices;\n\n  mutable NonZeroJacobianIndicesType m_NonZeroJacobianIndicesTemp;\n\n  bool m_FastComputationPossible;\n\nprivate:\n\n  KernelTransform2( const Self &amp; ); // purposely not implemented\n  void operator=( const Self &amp; );   // purposely not implemented\n\n  TScalarType m_PoissonRatio;\n\n  std::string m_MatrixInversionMethod;\n\n};\n\n} // end namespace itk\n\n\n#include \"itkKernelTransform2.cpp\"\n\n#endif // __itkKernelTransform2_h\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/itkMultiplyByConstantImageFilter_8h.html","title":"Libs/Mesh/itkMultiplyByConstantImageFilter.h","text":""},{"location":"api/Files/itkMultiplyByConstantImageFilter_8h.html#namespaces","title":"Namespaces","text":"Name itk itk::Functor"},{"location":"api/Files/itkMultiplyByConstantImageFilter_8h.html#classes","title":"Classes","text":"Name class itk::Functor::MultiplyByConstant class itk::MultiplyByConstantImageFilter Multiply input pixels by a constant."},{"location":"api/Files/itkMultiplyByConstantImageFilter_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n\n  Program:   Insight Segmentation &amp; Registration Toolkit\n  Module:    itkMultiplyByConstantImageFilter.h\n  Language:  C++\n  Date:      $Date$\n  Version:   $Revision$\n\n  Copyright (c) Insight Software Consortium. All rights reserved.\n  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even \n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \n     PURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n\n#ifndef __itkMultiplyByConstantImageFilter_h\n#define __itkMultiplyByConstantImageFilter_h\n\n#include &lt;itkUnaryFunctorImageFilter.h&gt;\n#include &lt;itkNumericTraits.h&gt;\n\nnamespace itk\n{\n\nnamespace Functor {  \n\ntemplate&lt; class TInput, class TConstant, class TOutput&gt;\nclass MultiplyByConstant\n{\npublic:\n  MultiplyByConstant() : m_Constant(NumericTraits&lt;TConstant&gt;::One) {};\n  ~MultiplyByConstant() {};\n  bool operator!=( const MultiplyByConstant &amp; other ) const\n    {\n    return !(*this == other);\n    }\n  bool operator==( const MultiplyByConstant &amp; other ) const\n    {\n    return other.m_Constant == m_Constant;\n    }\n  inline TOutput operator()( const TInput &amp; A ) const\n    {\n    // Because the user has to specify the constant we don't\n    // check if the cte is not 0;\n    return static_cast&lt;TOutput&gt;( A * m_Constant );\n    }\n  void SetConstant(TConstant ct) {this-&gt;m_Constant = ct; }\n  const TConstant &amp; GetConstant() const { return m_Constant; }\n\n  TConstant m_Constant;\n};\n}\n\ntemplate &lt;class TInputImage, class TConstant, class TOutputImage&gt;\nclass ITK_EXPORT MultiplyByConstantImageFilter :\n      public\nUnaryFunctorImageFilter&lt;TInputImage,TOutputImage, \n                        Functor::MultiplyByConstant&lt; \n   typename TInputImage::PixelType, TConstant,\n   typename TOutputImage::PixelType&gt; &gt;\n{\npublic:\n  typedef MultiplyByConstantImageFilter                 Self;\n  typedef UnaryFunctorImageFilter&lt;\n    TInputImage,TOutputImage, \n    Functor::MultiplyByConstant&lt; \n      typename TInputImage::PixelType, TConstant,\n      typename TOutputImage::PixelType&gt;   &gt;             Superclass;\n  typedef SmartPointer&lt;Self&gt;                            Pointer;\n  typedef SmartPointer&lt;const Self&gt;                      ConstPointer;\n\n  itkNewMacro(Self);\n\n  itkTypeMacro(MultiplyByConstantImageFilter, UnaryFunctorImageFilter);\n\n\n  void SetConstant(TConstant ct)\n    {\n    if( ct != this-&gt;GetFunctor().GetConstant() )\n      {\n      this-&gt;GetFunctor().SetConstant(ct);\n      this-&gt;Modified();\n      }\n    }\n  const TConstant &amp; GetConstant() const\n    {\n    return this-&gt;GetFunctor().GetConstant();\n    }\n\n\n#ifdef ITK_USE_CONCEPT_CHECKING\n  itkConceptMacro(InputConvertibleToOutputCheck,\n                  (Concept::Convertible&lt;typename TInputImage::PixelType,\n                   typename TOutputImage::PixelType&gt;));\n  itkConceptMacro(Input1Input2OutputMultiplyOperatorCheck,\n                  (Concept::MultiplyOperator&lt;typename TInputImage::PixelType,\n                   TConstant,\n                   typename TOutputImage::PixelType&gt;));\n#endif\n\nprotected:\n  MultiplyByConstantImageFilter() {};\n  virtual ~MultiplyByConstantImageFilter() {};\n\n  void PrintSelf(std::ostream &amp;os, Indent indent) const\n    {\n    Superclass::PrintSelf(os, indent);\n    os &lt;&lt; indent &lt;&lt; \"Constant: \" \n       &lt;&lt; static_cast&lt;typename NumericTraits&lt;TConstant&gt;::PrintType&gt;(this-&gt;GetConstant())\n       &lt;&lt; std::endl;\n    }\n\nprivate:\n  MultiplyByConstantImageFilter(const Self&amp;); //purposely not implemented\n  void operator=(const Self&amp;); //purposely not implemented\n\n};\n\n\n} // end namespace itk\n\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/itkSparseKernelTransform_8h.html","title":"Libs/Alignment/Transforms/itkSparseKernelTransform.h","text":""},{"location":"api/Files/itkSparseKernelTransform_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkSparseKernelTransform_8h.html#classes","title":"Classes","text":"Name class itk::SparseKernelTransform"},{"location":"api/Files/itkSparseKernelTransform_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n\n  Program:   Insight Segmentation &amp; Registration Toolkit\n  Module:    $RCSfile: itkSparseKernelTransform.h,v $\n  Language:  C++\n  Date:      $Date: 2006-11-28 14:22:18 $\n  Version:   $Revision: 1.1 $\n\n  Copyright (c) Insight Software Consortium. All rights reserved.\n  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n#ifndef __itkSparseKernelTransform_h\n#define __itkSparseKernelTransform_h\n\n#include &lt;itkTransform.h&gt;\n#include &lt;itkPoint.h&gt;\n#include &lt;itkVector.h&gt;\n#include &lt;itkMatrix.h&gt;\n#include &lt;itkPointSet.h&gt;\n#include &lt;deque&gt;\n#include &lt;math.h&gt;\n#include &lt;vnl/vnl_matrix_fixed.h&gt;\n#include &lt;vnl/vnl_matrix.h&gt;\n#include &lt;vnl/vnl_vector.h&gt;\n#include &lt;vnl/vnl_vector_fixed.h&gt;\n#include &lt;vnl/algo/vnl_svd.h&gt;\n#include &lt;vnl/vnl_sample.h&gt;\n\n//#define EIGEN_USE_MKL_ALL\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n#include &lt;stdint.h&gt;\n#include &lt;iostream&gt;\n\n\nnamespace itk\n{\n\ntemplate &lt;class TScalarType, // probably only float and double make sense here\n          unsigned int NDimensions&gt;   // Number of dimensions\nclass ITK_EXPORT SparseKernelTransform :\n        public Transform&lt;TScalarType, NDimensions,NDimensions&gt;\n{\npublic:\n    typedef SparseKernelTransform Self;\n    typedef Transform&lt;TScalarType, NDimensions, NDimensions &gt;   Superclass;\n    typedef SmartPointer&lt;Self&gt;        Pointer;\n    typedef SmartPointer&lt;const Self&gt;  ConstPointer;\n\n    itkTypeMacro( SparseKernelTransform, Transform );\n\n    itkNewMacro( Self );\n\n    itkStaticConstMacro(SpaceDimension, unsigned int, NDimensions);\n\n    typedef typename Superclass::ScalarType  ScalarType;\n\n    typedef typename Superclass::ParametersType  ParametersType;\n\n    typedef typename Superclass::JacobianType  JacobianType;\n\n    typedef typename Superclass::InputPointType   InputPointType;\n    typedef typename Superclass::OutputPointType  OutputPointType;\n\n    typedef typename Superclass::InputVectorType   InputVectorType;\n    typedef typename Superclass::OutputVectorType  OutputVectorType;\n\n    typedef DefaultStaticMeshTraits&lt;TScalarType,\n    NDimensions,\n    NDimensions,\n    TScalarType,\n    TScalarType&gt; PointSetTraitsType;\n    typedef PointSet&lt;InputPointType, NDimensions, PointSetTraitsType&gt; PointSetType;\n    typedef typename PointSetType::Pointer                        PointSetPointer;\n    typedef typename PointSetType::PointsContainer                PointsContainer;\n    typedef typename PointSetType::PointsContainerIterator        PointsIterator;\n    typedef typename PointSetType::PointsContainerConstIterator   PointsConstIterator;\n\n    typedef itk::VectorContainer&lt;unsigned long,InputVectorType&gt; VectorSetType;\n    typedef typename VectorSetType::Pointer        VectorSetPointer;\n\n    itkGetObjectMacro( SourceLandmarks, PointSetType);\n\n    virtual void SetSourceLandmarks(PointSetType *);\n\n    itkGetObjectMacro( TargetLandmarks, PointSetType);\n\n    virtual void SetTargetLandmarks(PointSetType *);\n\n    itkGetObjectMacro( Displacements, VectorSetType );\n\n    void ComputeWMatrix(void) const;\n\n    //void ComputeLInverse() const;\n\n    virtual OutputPointType TransformPoint(const InputPointType&amp; thisPoint) const;\n\n    typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; IMatrixType;\n    //typedef vnl_matrix_fixed&lt;TScalarType, NDimensions, NDimensions&gt; IMatrixType;\n\n\n    //virtual const JacobianType &amp; GetJacobian(const InputPointType  &amp;point ) const;\n\n    virtual void SetIdentity();\n\n    virtual void SetParameters(const ParametersType &amp;);\n\n    virtual void SetFixedParameters(const ParametersType &amp;);\n\n    virtual void UpdateParameters(void) const;\n\n    virtual const ParametersType&amp; GetParameters(void) const;\n\n    virtual const ParametersType&amp; GetFixedParameters(void) const;\n    virtual void ComputeJacobianWithRespectToParameters(\n        const InputPointType  &amp;in, JacobianType &amp;jacobian) const;\n\n    virtual void SetStiffness(double stiffness)\n    {m_Stiffness=(stiffness&gt;0)?stiffness:0.0;\n        m_LMatrixComputed=false;\n        m_LInverseComputed=false;\n        m_WMatrixComputed=false;\n    }\n    //itkSetClampMacro(Stiffness, double, 0.0, NumericTraits&lt;double&gt;::max());\n    // Cant use the macro because the matrices must be recomputed\n    itkGetMacro(Stiffness, double);\n\n\nprotected:\n    SparseKernelTransform();\n    virtual ~SparseKernelTransform();\n    void PrintSelf(std::ostream&amp; os, Indent indent) const;\n\npublic:\n    typedef Eigen::Triplet&lt;TScalarType&gt; TripletType;\n\n    typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; GMatrixType;\n    //typedef vnl_matrix_fixed&lt;TScalarType, NDimensions, NDimensions&gt; GMatrixType;\n\n    typedef Eigen::SparseMatrix&lt;TScalarType&gt; LMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; LMatrixType;\n\n    typedef Eigen::SparseMatrix&lt;TScalarType&gt; KMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; KMatrixType;\n\n    typedef Eigen::SparseMatrix&lt;TScalarType&gt; PMatrixType;\n    //typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, NDimensions*(NDimensions+1)&gt; PMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; PMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; YMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; YMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; WMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; WMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType, Eigen::Dynamic, Eigen::Dynamic&gt; DMatrixType;\n    //typedef vnl_matrix&lt;TScalarType&gt; DMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType, NDimensions, NDimensions&gt; AMatrixType;\n    //typedef vnl_matrix_fixed&lt;TScalarType,NDimensions,NDimensions&gt; AMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType,NDimensions,1&gt; BMatrixType; // column vector\n    //typedef vnl_vector_fixed&lt;TScalarType,NDimensions&gt; BMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType,1,NDimensions&gt; RowMatrixType;\n    //typedef vnl_matrix_fixed&lt;TScalarType, 1, NDimensions&gt; RowMatrixType;\n\n    typedef Eigen::Matrix&lt;TScalarType,NDimensions,1&gt; ColumnMatrixType;\n    //typedef vnl_matrix_fixed&lt;TScalarType, NDimensions, 1&gt; ColumnMatrixType;\n\n    PointSetPointer m_SourceLandmarks;\n\n    PointSetPointer m_TargetLandmarks;\n\nprotected:\n    virtual const GMatrixType &amp; ComputeG(const InputVectorType &amp; landmarkVector) const;\n\n    virtual const GMatrixType &amp; ComputeReflexiveG(PointsIterator) const;\n\n\n    virtual void ComputeDeformationContribution( const InputPointType &amp; inputPoint,\n                                                 OutputPointType &amp; result ) const;\n\n    void ComputeK() const;\n\n    void ComputeL() const;\n\n\n    void ComputeP() const;\n\n    void ComputeY() const;\n\n    void ComputeD() const;\n\n    void ReorganizeW(void) const;\n\n    double m_Stiffness;\n\n    VectorSetPointer m_Displacements;\n\n    mutable LMatrixType m_LMatrix;\n\n    mutable LMatrixType m_LMatrixInverse;\n\n    mutable KMatrixType m_KMatrix;\n\n    mutable PMatrixType m_PMatrix;\n\n    mutable YMatrixType m_YMatrix;\n\n    mutable WMatrixType m_WMatrix;\n\n    mutable DMatrixType m_DMatrix;\n\n    mutable AMatrixType m_AMatrix;\n\n    mutable BMatrixType m_BVector;\n\n    mutable GMatrixType m_GMatrix;\n\n    mutable bool m_WMatrixComputed;\n    mutable bool m_LMatrixComputed;\n    mutable bool m_LInverseComputed;\n\n    IMatrixType m_I;\n\nprivate:\n    SparseKernelTransform(const Self&amp;); //purposely not implemented\n    void operator=(const Self&amp;); //purposely not implemented\n\n};\n\n} // end namespace itk\n\n#include \"itkSparseKernelTransform.cpp\"\n\n#endif // __itkSparseKernelTransform_h\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html","title":"Libs/Image/itkTPGACLevelSetImageFilter.h","text":""},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#classes","title":"Classes","text":"Name class itk::TPGACLevelSetImageFilter"},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#defines","title":"Defines","text":"Name TPGAC_EPSILON"},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#define-tpgac_epsilon","title":"define TPGAC_EPSILON","text":"<pre><code>#define TPGAC_EPSILON 1e-5;\n</code></pre>"},{"location":"api/Files/itkTPGACLevelSetImageFilter_8h.html#source-code","title":"Source code","text":"<pre><code>#ifndef __itkTPGACLevelSetImageFilter_h\n#define __itkTPGACLevelSetImageFilter_h\n\n#include \"itkGeodesicActiveContourLevelSetImageFilter.h\"\n\nnamespace itk {\n\ntemplate &lt;class TInputImage, class TFeatureImage, class TOutputPixelType = float &gt;\nclass ITK_EXPORT TPGACLevelSetImageFilter : public GeodesicActiveContourLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputPixelType&gt;\n{\npublic:\n    typedef TPGACLevelSetImageFilter                                                                       Self;\n    typedef GeodesicActiveContourLevelSetImageFilter&lt;TInputImage, TFeatureImage, TOutputPixelType&gt;         Superclass;\n    typedef SmartPointer&lt;Self&gt;                                                                             Pointer;\n    typedef SmartPointer&lt;const Self&gt;                                                                       ConstPointer;\n\n    typedef TInputImage                                                           ImageType;\n    typedef typename ImageType::IndexType                                         IndexType;\n    typedef typename Superclass::TimeStepType                                     TimeStepType;\n\n    typedef typename Superclass::ValueType                                        ValueType;\n    typedef typename Superclass::OutputImageType                                  OutputImageType;\n    typedef typename Superclass::FeatureImageType                                 FeatureImageType;\n\n    itkNewMacro(Self);\n\n    itkTypeMacro(TPGACLevelSetImageFilter, GeodesicActiveContourLevelSetImageFilter);\n\nprotected:\n    ~TPGACLevelSetImageFilter() {}\n    TPGACLevelSetImageFilter();\n\n    virtual void PrintSelf(std::ostream &amp;os, Indent indent) const;\n\n    TPGACLevelSetImageFilter(const Self &amp;); // purposely not implemented\n    void operator=(const Self&amp;); //purposely not implemented\n\n    inline virtual ValueType CalculateUpdateValue(const IndexType &amp;idx, const TimeStepType &amp;dt, const ValueType &amp;value, const ValueType &amp;change);\n};\n\ntemplate &lt;class TInputImage, class TFeatureImage, class TOutputType&gt;\nTPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputType&gt;\n::TPGACLevelSetImageFilter()\n    : GeodesicActiveContourLevelSetImageFilter&lt;TInputImage, TFeatureImage, TOutputType&gt;()\n{\n    // call parent constructor\n}\n\ntemplate &lt;class TInputImage, class TFeatureImage, class TOutputType&gt;\nvoid TPGACLevelSetImageFilter&lt;TInputImage, TFeatureImage, TOutputType&gt;\n::PrintSelf(std::ostream &amp;os, Indent indent) const\n{\n    Superclass::PrintSelf(os, indent);\n}\n\n// 6-neighbour table (including centre voxel, i.e. voxel 13)\nstatic int nbh6Table[27][6] = {\n    {1, 3, 9, -1, -1, -1}, // 0\n    {0, 2, 4, 10, -1, -1}, // 1\n    {1, 5, 11, -1, -1, -1}, // 2\n    {0, 4, 6, 12, -1, -1}, // 3\n    {1, 3, 5, 7, 13, -1}, // 4\n    {2, 4, 8, 14, -1, -1}, // 5\n    {3, 7, 15, -1, -1, -1}, // 6\n    {4, 6, 8, 16, -1, -1}, // 7\n    {5, 7, 17, -1, -1, -1}, // 8\n    {0, 10, 12, 18, -1, -1}, // 9\n    {1, 9, 11, 13, 19, -1}, // 10\n    {2, 10, 14, 20, -1, -1}, // 11\n    {3, 9, 13, 15, 21, -1}, // 12\n    {4, 10, 12, 14, 16, 22}, // 13\n    {5, 11, 13, 17, 23, -1}, // 14\n    {6, 12, 16, 24, -1, -1}, // 15\n    {7, 13, 15, 17, 25, -1}, // 16\n    {8, 14, 16, 26, -1, -1}, // 17\n    {9, 19, 21, -1, -1, -1}, // 18\n    {10, 18, 20, 22, -1, -1}, // 19\n    {11, 19, 23, -1, -1, -1}, // 20\n    {12, 18, 22, 24, -1, -1}, // 21\n    {13, 19, 21, 23, 25, -1}, // 22\n    {14, 20, 22, 26, -1, -1}, // 23\n    {15, 21, 25, -1, -1, -1}, // 24\n    {16, 22, 24, 26, -1, -1}, // 25\n    {17, 23, 25, -1, -1, -1} // 26\n};\n\n// generated by gen26neighbourTable.py\n// includes the centre voxel\nstatic int nbh26Table[27][26] = {\n    {1, 3, 4, 9, 10, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 0\n    {0, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, -1, -1,-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 1\n    {1, 4, 5, 10, 11, 13, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 2\n    {0, 1, 4, 6, 7, 9, 10, 12, 13, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 3\n    {0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 4\n    {1, 2, 4, 7, 8, 10, 11, 13, 14, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 5\n    {3, 4, 7, 12, 13, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 6\n    {3, 4, 5, 6, 8, 12, 13, 14, 15, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 7\n    {4, 5, 7, 13, 14, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 8\n    {0, 1, 3, 4, 10, 12, 13, 18, 19, 21, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 9\n    {0, 1, 2, 3, 4, 5, 9, 11, 12, 13, 14, 18, 19, 20, 21, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10\n    {1, 2, 4, 5, 10, 13, 14, 19, 20, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 11\n    {0, 1, 3, 4, 6, 7, 9, 10, 13, 15, 16, 18, 19, 21, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 12\n    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26}, // 13\n    {1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 20, 22, 23, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 14\n    {3, 4, 6, 7, 12, 13, 16, 21, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 15\n    {3, 4, 5, 6, 7, 8, 12, 13, 14, 15, 17, 21, 22, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 16\n    {4, 5, 7, 8, 13, 14, 16, 22, 23, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 17\n    {9, 10, 12, 13, 19, 21, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 18\n    {9, 10, 11, 12, 13, 14, 18, 20, 21, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 19\n    {10, 11, 13, 14, 19, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 20\n    {9, 10, 12, 13, 15, 16, 18, 19, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 21\n    {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 22\n    {10, 11, 13, 14, 16, 17, 19, 20, 22, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 23\n    {12, 13, 15, 16, 21, 22, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 24\n    {12, 13, 14, 15, 16, 17, 21, 22, 23, 24, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 25\n    {13, 14, 16, 17, 22, 23, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1} // 26\n};\n\nstatic inline void fillLocal6Neighbours(int *srcNbh, int *dstNbh, int centre, int i0, int i1, int i2, int i3)\n{\n    if (srcNbh[centre])\n    {\n        dstNbh[centre] = 1;\n\n        if (srcNbh[i0])\n            dstNbh[i0] = 1;\n\n        if (srcNbh[i1])\n            dstNbh[i1] = 1;\n\n        if (srcNbh[i2])\n            dstNbh[i2] = 1;\n\n        if (srcNbh[i3])\n            dstNbh[i3] = 1;\n    }\n\n}\n\nstatic void label6Neighbours(int *nbh, int *nbhlabels, int *nbhv, int curlabel, int idx)\n{\n    // needs good initial value\n    int nbhIdx = 0;\n\n    // 6 neighbours max (also in the lookup table)\n    for (int i = 0; i &lt; 6 &amp;&amp; nbhIdx &gt;= 0; i++)\n    {\n        nbhIdx = nbh6Table[idx][i];\n        // valid nbh index and the voxel exists and it hasn't been labeled\n        // yet\n        if (nbhIdx &gt;= 0 &amp;&amp; nbh[nbhIdx] &amp;&amp; nbhlabels[nbhIdx] == 0)\n        {\n            // then label it\n            nbhlabels[nbhIdx] = curlabel;\n            // and record that it has been labeled, but needs to recursed\n            // we only do this if V doesn't have a value yet\n            if (nbhv[nbhIdx] == 0)\n                nbhv[nbhIdx] = 1;\n        }\n    }\n}\n\nstatic void label26Neighbours(int *nbh, int *nbhlabels, int *nbhv, int curlabel, int idx)\n{\n    // needs good initial value\n    int nbhIdx = 0;\n\n    // 26 neighbours max (also in the lookup table)\n    for (int i = 0; i &lt; 26 &amp;&amp; nbhIdx &gt;= 0; i++)\n    {\n        nbhIdx = nbh26Table[idx][i];\n        // valid nbh index and the voxel exists and it hasn't been labeled\n        // yet\n        if (nbhIdx &gt;= 0 &amp;&amp; nbh[nbhIdx] &amp;&amp; nbhlabels[nbhIdx] == 0)\n        {\n            // then label it\n            nbhlabels[nbhIdx] = curlabel;\n            // and record that it has been labeled, but needs to recursed\n            // we only do this if V doesn't have a value yet\n            if (nbhv[nbhIdx] == 0)\n                nbhv[nbhIdx] = 1;\n        }\n    }\n}\n\n\nstatic inline int connectedComponents(int *nbh, int *nbhLabels, void (*labelNeighboursFunc)(int *, int *, int *, int, int) )\n{\n    // create and init V struct\n    int nbhV[27];\n    memset(nbhV, 0, 27 * sizeof(int));\n\n    int curlabel = 1, assignedlabel = 0;\n    for (int i = 0; i &lt; 27; i++)\n    {\n        // is there a voxel at this position, and has it not been labeled yet?\n        if (nbh[i] &amp;&amp; nbhLabels[i] == 0)\n        {\n            // ON voxel not labeled yet\n            nbhLabels[i] = curlabel;\n            // this is to keep track of how many labels we've actually USED\n            assignedlabel = curlabel;\n            // mark it as being labeled\n            nbhV[i] = 1;\n\n            // now recurse through n26v finding ALL voxels of curlabel\n            // we continue doing this until there are no 1s, i.e. only\n            // 2s (neighbours examined) and 0s (no connected labels)\n            int onesFound;\n            do\n            {\n                onesFound = 0;\n                for (int j = 0; j &lt; 27; j++)\n                {\n                    if (nbhV[j] == 1)\n                    {\n                        onesFound = 1;\n                        // this will label 6-neighbours and also flag the fact\n                        // that they're labeled by setting a '1' in n26v\n                        // neighbours that are already 2 will be left alone\n\n                        labelNeighboursFunc(nbh, nbhLabels, nbhV, curlabel, j);\n                        // now all neighbours of voxel j have also been labeled\n                        nbhV[j] = 2;\n                    }\n                } // for (int j = 0 ...\n            }\n            while (onesFound);\n\n\n            // if we find the next unlabeled thing, it has to be a new\n            // component by definition\n            curlabel++;\n\n        } // if (n26nbh[i] &amp;&amp; n26labels[i] == 0) ...\n    } // for (int i = 0; i &lt; 27 ...\n\n    return assignedlabel;\n\n}\n\n// you could also use epsilon from the levelset function\n#define TPGAC_EPSILON 1e-5;\n\ntemplate &lt;class TInputImage, class TFeatureImage, class TOutputType&gt;\ntypename TPGACLevelSetImageFilter&lt; TInputImage, TFeatureImage, TOutputType&gt;::ValueType\nTPGACLevelSetImageFilter&lt;TInputImage, TFeatureImage, TOutputType&gt;\n::CalculateUpdateValue(const IndexType &amp;idx, const TimeStepType &amp;dt, const ValueType &amp;value, const ValueType &amp;change)\n{\n\n    // * calculate new value\n    // * if new value has the same sign as current value, make the\n    // change\n    // * ELSE:\n    // * extract 3x3x3 neighbourhood of the current voxel\n    // * calculate N^2_6(x,X) and N^1_26(x,X')\n    // * count connected components (bail if more than 1)\n    // * if both 1, then x is simple point, allow change\n    // * if not (or bailed) x is not simple point\n    // * newValue = epsilon * sign(value) (epsilon small and positive)\n\n    ValueType temp_value = value + dt * change;\n\n    // sign is the same, we can return what we have\n    if (temp_value * value &gt;= 0)\n    {\n        return temp_value;\n    }\n\n    // create a 3x3x3 nbh iterator over the output image\n    Size&lt;3&gt; radius = {1,1,1};\n    NeighborhoodIterator&lt;OutputImageType&gt;\n            nbhIterator(radius, this-&gt;GetOutput(),\n                        this-&gt;GetOutput()-&gt;GetRequestedRegion());\n\n    // move the 3x3x3 nbh iterator over the current voxel\n    nbhIterator.SetLocation(idx);\n\n    // offset of centre pixel\n//#define c 13\n\n    // transfer nbh to our interior/exterior nbh\n    int ieNbh[27];\n    for (int i = 0; i &lt; 27; i++)\n    {\n        if (nbhIterator.GetPixel(i) &gt;= 0)\n        {\n            // interior / inside / foreground\n            ieNbh[i] = 1;\n        }\n        else\n        {\n            // exterior / outside / background\n            ieNbh[i] = 0;\n        }\n    }\n\n    // N^2_6 == n26\n    // N^1_26 == n126\n\n    // now calculate N^2_6(interior) - we do this as straight-forward as\n    // possible for speed reasons\n    // first allocate and clear the nbh array\n    int n26nbh[27];\n    memset(n26nbh, 0, 27 * sizeof(int));\n\n\n    // if (ieNbh[4])\n    // {\n    // n26nbh[4] = 1;\n\n    // if (ieNbh[1]) n26nbh[1] = 1;\n    // if (ieNbh[3]) n26nbh[3] = 1;\n    // if (ieNbh[5]) n26nbh[5] = 1;\n    // if (ieNbh[7]) n26nbh[7] = 1;\n    // }\n\n\n    // then check the 6-neighbours of 4, i.e. 1, 3, 5, 7, but NOT the\n    // center voxel itself... that's explicitly excluded\n    fillLocal6Neighbours(ieNbh, n26nbh, 4, 1, 3, 5, 7);\n    fillLocal6Neighbours(ieNbh, n26nbh, 10, 1, 9, 11, 19);\n    fillLocal6Neighbours(ieNbh, n26nbh, 12, 3, 9, 15, 21);\n    fillLocal6Neighbours(ieNbh, n26nbh, 14, 5, 11, 17, 23);\n    fillLocal6Neighbours(ieNbh, n26nbh, 16, 7, 15, 17, 25);\n    fillLocal6Neighbours(ieNbh, n26nbh, 22, 19, 21, 23, 25);\n\n    // we should have a complete n^2_6(x,X) now...\n    // now determine number of connected components using\n    // fast method described in borgefors1997\n\n    int n26labels[27];\n    memset(n26labels, 0, 27 * sizeof(int));\n\n    int ncc6 = connectedComponents( n26nbh, n26labels, label6Neighbours);\n\n    if (ncc6 != 1)\n    {\n        // already T6(x,X) != 1, so we bail with epsilon * sign of old\n        // value... this saves us from the 26-neighbourhood background check\n        if (value &lt; 0)\n        {\n            return -1 * TPGAC_EPSILON;\n        }\n        else\n        {\n            return TPGAC_EPSILON;\n        }\n    }\n\n    int n126nbh[27];\n    memset(n126nbh, 0, 27 * sizeof(int));\n\n    // we just invert ieNbh, because we're going to check the background\n    for (int i = 0; i &lt; 27; i++)\n    {\n        n126nbh[i] = ! ieNbh[i];\n    }\n\n    // the centre voxel is NEVER used\n    n126nbh[13] = 0;\n\n    int n126labels[27];\n    memset(n126labels, 0, 27 * sizeof(int));\n\n    int ncc26 = connectedComponents(n126nbh, n126labels, label26Neighbours);\n\n    if (ncc26 != 1)\n    {\n        // T26(x,X') != 1, so we bail with epsilon * sign of old\n        // value...\n        if (value &lt; 0)\n        {\n            return -1 * TPGAC_EPSILON;\n        }\n        else\n        {\n            return TPGAC_EPSILON;\n        }\n    }\n\n    //    this means the voxel that is to be added is simple... we can just\n    //   return the new value\n    return temp_value;\n}\n\n} // end namespace itk\n\n//#if ITK_MANUAL_INSTANTIATION\n//#include \"itkTPGACLevelSetImageFilter.txx\"\n//#endif\n\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/itkThinPlateSplineKernelTransform2_8h.html","title":"Libs/Alignment/Transforms/itkThinPlateSplineKernelTransform2.h","text":""},{"location":"api/Files/itkThinPlateSplineKernelTransform2_8h.html#namespaces","title":"Namespaces","text":"Name itk"},{"location":"api/Files/itkThinPlateSplineKernelTransform2_8h.html#classes","title":"Classes","text":"Name class itk::ThinPlateSplineKernelTransform2"},{"location":"api/Files/itkThinPlateSplineKernelTransform2_8h.html#source-code","title":"Source code","text":"<pre><code>/*=========================================================================\n *\n *  Copyright UMC Utrecht and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0.txt\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *=========================================================================*/\n/*=========================================================================\n\n  Program:   Insight Segmentation &amp; Registration Toolkit\n  Module:    $RCSfile: itkThinPlateSplineKernelTransform2.h,v $\n  Language:  C++\n  Date:      $Date: 2006-11-28 14:22:18 $\n  Version:   $Revision: 1.1 $\n\n  Copyright (c) Insight Software Consortium. All rights reserved.\n  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notices for more information.\n\n=========================================================================*/\n#ifndef __itkThinPlateSplineKernelTransform2_h\n#define __itkThinPlateSplineKernelTransform2_h\n\n#include \"itkKernelTransform2.h\"\n\nnamespace itk\n{\ntemplate&lt; class TScalarType,         // Data type for scalars (float or double)\nunsigned int NDimensions = 3 &gt;\n// Number of dimensions\nclass ThinPlateSplineKernelTransform2 :\n  public KernelTransform2&lt; TScalarType, NDimensions &gt;\n{\npublic:\n\n  typedef ThinPlateSplineKernelTransform2              Self;\n  typedef KernelTransform2&lt; TScalarType, NDimensions &gt; Superclass;\n  typedef SmartPointer&lt; Self &gt;                         Pointer;\n  typedef SmartPointer&lt; const Self &gt;                   ConstPointer;\n\n  itkNewMacro( Self );\n\n  itkTypeMacro( ThinPlateSplineKernelTransform2, KernelTransform2 );\n\n  typedef typename Superclass::ScalarType ScalarType;\n\n  typedef typename Superclass::ParametersType ParametersType;\n\n  typedef typename Superclass::JacobianType JacobianType;\n\n  itkStaticConstMacro( SpaceDimension, unsigned int, Superclass::SpaceDimension );\n\n  typedef typename Superclass::InputPointType            InputPointType;\n  typedef typename Superclass::OutputPointType           OutputPointType;\n  typedef typename Superclass::InputVectorType           InputVectorType;\n  typedef typename Superclass::OutputVectorType          OutputVectorType;\n  typedef typename Superclass::InputCovariantVectorType  InputCovariantVectorType;\n  typedef typename Superclass::OutputCovariantVectorType OutputCovariantVectorType;\n  typedef typename Superclass::PointsIterator            PointsIterator;\n\n  void SetSigma(double sigma){}; // this is only to match the compact supported class\n\nprotected:\n\n  ThinPlateSplineKernelTransform2()\n  {\n    this-&gt;m_FastComputationPossible = true;\n  }\n\n\n  virtual ~ThinPlateSplineKernelTransform2() {}\n\n  typedef typename Superclass::GMatrixType GMatrixType;\n\n  void ComputeG( const InputVectorType &amp; x, GMatrixType &amp; GMatrix ) const;\n\n  virtual void ComputeDeformationContribution(\n    const InputPointType &amp; inputPoint, OutputPointType &amp; result ) const;\n\nprivate:\n\n  ThinPlateSplineKernelTransform2( const Self &amp; ); // purposely not implemented\n  void operator=( const Self &amp; );                  // purposely not implemented\n\n};\n\n} // namespace itk\n\n#include \"itkThinPlateSplineKernelTransform2.cpp\"\n\n#endif // __itkThinPlateSplineKernelTransform2_h\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Files/math3d_8h.html","title":"Libs/Mesh/PreviewMeshQC/math3d.h","text":""},{"location":"api/Files/math3d_8h.html#classes","title":"Classes","text":"Name class vec2d class vec3d class vec6d class mat3d class matrix class quatd class GLCOLOR"},{"location":"api/Files/math3d_8h.html#types","title":"Types","text":"Name typedef unsigned char uchar"},{"location":"api/Files/math3d_8h.html#functions","title":"Functions","text":"Name quatd operator*(const double a, const quatd &amp; q)"},{"location":"api/Files/math3d_8h.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Files/math3d_8h.html#typedef-uchar","title":"typedef uchar","text":"<pre><code>typedef unsigned char uchar;\n</code></pre>"},{"location":"api/Files/math3d_8h.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Files/math3d_8h.html#function-operator","title":"function operator*","text":"<pre><code>inline quatd operator*(\n    const double a,\n    const quatd &amp; q\n)\n</code></pre>"},{"location":"api/Files/math3d_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;math.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n//-----------------------------------------------------------------------------\n// class vec2d defines a 2D vector\nclass vec2d\n{\npublic:\n    vec2d() { x = y = 0.0; }\n    vec2d(double X, double Y) { x = X; y = Y; }\n\n    vec2d operator - () { return vec2d(-x, -y); }\n\n    vec2d operator - (const vec2d&amp; r) { return vec2d(x - r.x, y - r.y); }\n    vec2d operator + (const vec2d&amp; r) { return vec2d(x + r.x, y + r.y); }\n    vec2d operator * (double g) { return vec2d(x*g, y*g); }\n\n    double operator * (const vec2d&amp; r) { return (x*r.x + y*r.y); }\n\n    double norm() { return sqrt(x*x + y*y); }\n    double unit() { double R = sqrt(x*x + y*y); if (R != 0) {x /= R; y/= R; }; return R; }\n\n    bool operator == (const vec2d&amp; r) const { return (x==r.x)&amp;&amp;(y==r.y); }\n\npublic:\n    double  x, y;\n};\n\n//-----------------------------------------------------------------------------\n// class vec3d defines a 3D vector\n//\nclass vec3d\n{\npublic:\n    vec3d() { x = y = z = 0; }\n    vec3d(double rx, double ry, double rz) { x = rx; y = ry; z = rz; }\n    vec3d(const vec2d&amp; r) { x = r.x; y = r.y; z = 0; }\n\n    vec3d operator + (const vec3d&amp; v) const { return vec3d( x + v.x, y + v.y, z + v.z); }\n    vec3d operator - (const vec3d&amp; v) const { return vec3d( x - v.x, y - v.y, z - v.z); }\n    vec3d operator ^ (const vec3d&amp; v) const\n    { \n        return vec3d( y*v.z - z*v.y, z*v.x - x*v.z, x*v.y - y*v.x); \n    }\n\n    double operator * (const vec3d&amp; v) const { return (x*v.x + y*v.y + z*v.z); }\n\n    vec3d operator * (const double g) const { return vec3d(x*g, y*g, z*g); }\n    vec3d operator / (const double g) const { return vec3d(x/g, y/g, z/g); }\n\n    const vec3d&amp; operator += (const vec3d&amp; v) { x += v.x; y += v.y; z += v.z; return (*this); }\n    const vec3d&amp; operator -= (const vec3d&amp; v) { x -= v.x; y -= v.y; z -= v.z; return (*this); }\n    const vec3d&amp; operator /= (const double f) { x /= f; y /= f; z /= f; return (*this); }\n    const vec3d&amp; operator /= (const int n) { x /= n; y /= n; z /= n; return (*this); }\n    const vec3d&amp; operator *= (const double f) { x*=f; y*=f; z*=f; return (*this); }\n\n    vec3d operator - () const { return vec3d(-x, -y, -z); }\n\n    double Length() const { return (double) sqrt(x*x + y*y + z*z); }\n    double SqrLength() const { return x*x + y*y + z*z; }\n\n    vec3d&amp; Normalize()\n    {\n        double L = Length();\n        if (L != 0) { x /= L; y /= L; z /= L; }\n\n        return (*this);\n    }\n\npublic:\n    double x, y, z;\n};\n\n// vec6d\n\nclass vec6d\n{\npublic:\n    vec6d() { x = y = z = xy = yz = xz = 0; }\n\npublic:\n    double x, y, z;\n    double xy, yz, xz;\n};\n\n\n// mat3d\n\nclass mat3d\n{\npublic:\n    mat3d() \n    {\n        zero();\n    }\n\n    mat3d(double a00, double a01, double a02, double a10, double a11, double a12, double a20, double a21, double a22);\n\n    double* operator [] (int i) { return m_data[i]; }\n    double&amp; operator () (int i, int j) { return m_data[i][j]; }\n\n    mat3d operator * (mat3d&amp; m)\n    {\n        mat3d a;\n\n        int k;\n        for (k=0; k&lt;3; k++)\n        {\n            a[0][0] += m_data[0][k]*m[k][0]; a[0][1] += m_data[0][k]*m[k][1]; a[0][2] += m_data[0][k]*m[k][2];\n            a[1][0] += m_data[1][k]*m[k][0]; a[1][1] += m_data[1][k]*m[k][1]; a[1][2] += m_data[1][k]*m[k][2];\n            a[2][0] += m_data[2][k]*m[k][0]; a[2][1] += m_data[2][k]*m[k][1]; a[2][2] += m_data[2][k]*m[k][2];\n        }\n\n        return a;\n    }\n\n    mat3d&amp; operator *=(mat3d&amp; m)\n    {\n        mat3d a;\n\n        int k;\n        for (k=0; k&lt;3; k++)\n        {\n            a[0][0] += m_data[0][k]*m[k][0]; a[0][1] += m_data[0][k]*m[k][1]; a[0][2] += m_data[0][k]*m[k][2];\n            a[1][0] += m_data[1][k]*m[k][0]; a[1][1] += m_data[1][k]*m[k][1]; a[1][2] += m_data[1][k]*m[k][2];\n            a[2][0] += m_data[2][k]*m[k][0]; a[2][1] += m_data[2][k]*m[k][1]; a[2][2] += m_data[2][k]*m[k][2];\n        }\n\n        m_data[0][0] = a.m_data[0][0]; m_data[0][1] = a.m_data[0][1]; m_data[0][2] = a.m_data[0][2];\n        m_data[1][0] = a.m_data[1][0]; m_data[1][1] = a.m_data[1][1]; m_data[1][2] = a.m_data[1][2];\n        m_data[2][0] = a.m_data[2][0]; m_data[2][1] = a.m_data[2][1]; m_data[2][2] = a.m_data[2][2];\n\n        return (*this);\n    }\n\n    mat3d&amp; operator +=(mat3d&amp; m)\n    {\n        m_data[0][0] += m[0][0]; m_data[0][1] += m[0][1]; m_data[0][2] += m[0][2];\n        m_data[1][0] += m[1][0]; m_data[1][1] += m[1][1]; m_data[1][2] += m[1][2];\n        m_data[2][0] += m[2][0]; m_data[2][1] += m[2][1]; m_data[2][2] += m[2][2];\n\n        return (*this);\n    }\n    mat3d&amp; operator -=(mat3d&amp; m)\n    {\n        m_data[0][0] -= m[0][0]; m_data[0][1] -= m[0][1]; m_data[0][2] -= m[0][2];\n        m_data[1][0] -= m[1][0]; m_data[1][1] -= m[1][1]; m_data[1][2] -= m[1][2];\n        m_data[2][0] -= m[2][0]; m_data[2][1] -= m[2][1]; m_data[2][2] -= m[2][2];\n\n        return (*this);\n    }\n\n    mat3d&amp; operator /=(const double f)\n    {\n        m_data[0][0] /= f; m_data[0][1] /= f; m_data[0][2] /= f;\n        m_data[1][0] /= f; m_data[1][1] /= f; m_data[1][2] /= f;\n        m_data[2][0] /= f; m_data[2][1] /= f; m_data[2][2] /= f;\n\n        return (*this);\n    }\n\n    vec3d operator * (vec3d b)\n    {\n        vec3d r;\n        r.x = m_data[0][0]*b.x + m_data[0][1]*b.y + m_data[0][2]*b.z;\n        r.y = m_data[1][0]*b.x + m_data[1][1]*b.y + m_data[1][2]*b.z;\n        r.z = m_data[2][0]*b.x + m_data[2][1]*b.y + m_data[2][2]*b.z;\n\n        return r;\n    }\n\n    double det() const\n    {\n        double det = 0;\n        det += m_data[0][0]*m_data[1][1]*m_data[2][2];\n        det += m_data[0][1]*m_data[1][2]*m_data[2][0];\n        det += m_data[0][2]*m_data[1][0]*m_data[2][1];\n        det -= m_data[0][2]*m_data[1][1]*m_data[2][0];\n        det -= m_data[0][1]*m_data[1][0]*m_data[2][2];\n        det -= m_data[0][0]*m_data[1][2]*m_data[2][1];\n        return det;\n    }\n\n    double Invert();\n\n    mat3d inverse() const;\n\n    void zero()\n    {\n        m_data[0][0] = m_data[0][1] = m_data[0][2] = 0;\n        m_data[1][0] = m_data[1][1] = m_data[1][2] = 0;\n        m_data[2][0] = m_data[2][1] = m_data[2][2] = 0;\n    }\n\n    void unit()\n    {\n        m_data[0][0] = m_data[1][1] = m_data[2][2] = 1;\n        m_data[0][1] = m_data[0][2] = m_data[1][2] = 0;\n        m_data[1][0] = m_data[2][0] = m_data[2][1] = 0;\n    }\n\n    mat3d transpose();\n\nprotected:\n    double  m_data[3][3];\n};\n\n\n\n// matrix\n\nclass matrix\n{\npublic:\n    matrix(int r, int c);\n    ~matrix() { delete [] d; }\n\n    void zero();\n\n    double* operator [] (int i) { return d + i*m_nc; }\n    double&amp; operator () (int i, int j) { return d[i*m_nc + j]; }\n\n    bool solve(vector&lt;double&gt;&amp; x, vector&lt;double&gt;&amp; b);\n\n    bool lsq_solve(vector&lt;double&gt;&amp; x, vector&lt;double&gt;&amp; b);\n    bool eigen_vectors(matrix&amp; Eigen,vector&lt;double&gt;&amp; eigen_values);\n    int Rows() { return m_nr; }\n\n    void mult_transpose(vector&lt;double&gt;&amp; x, vector&lt;double&gt;&amp; y);\n\n    void mult_transpose_self(matrix&amp; AAt);\n\nprivate:\n    double* d;\n    int     m_nr, m_nc;\n    int     m_ne;\n};\n\n\n// quatd\n\nclass quatd\n{\npublic:\n    // constructors\n    quatd () { x = y = z = 0; w = 1; }\n\n    quatd( const double angle, vec3d v)\n    {\n        w = (double) cos(angle * 0.5);\n\n        double sina = (double) sin(angle * 0.5);\n\n        v.Normalize();\n\n        x = v.x*sina;\n        y = v.y*sina;\n        z = v.z*sina;\n    }\n\n    quatd (vec3d v1, vec3d v2)\n    {\n        vec3d n = v1^v2;\n        n.Normalize();\n\n        double d = v1*v2;\n\n        double sina = (double) sqrt((1.0-d)*0.5);\n        double cosa = (double) sqrt((1.0+d)*0.5);\n\n        w = cosa;\n\n        x = n.x*sina;\n        y = n.y*sina;\n        z = n.z*sina;\n\n    }\n\n    quatd(const double qx, const double qy, const double qz, const double qw = 1.0)\n    {\n        w = qw;\n        x = qx;\n        y = qy;\n        z = qz;\n    }\n\n    bool operator != (const quatd&amp; q) { return ((x!=q.x) || (y!=q.y) || (z!=q.z) || (w!=q.w)); }\n\n    quatd operator - () { return quatd(-x, -y, -z, -w); }\n\n    // addition and substraction\n\n    quatd operator + (const quatd&amp; q) const\n    {\n        return quatd(x + q.x, y + q.y, z + q.z, w + q.w);\n    }\n\n    quatd operator - (const quatd&amp; q) const\n    {\n        return quatd(x - q.x, y - q.y, z - q.z, w - q.w);\n    }\n\n    quatd&amp; operator += (const quatd&amp; q)\n    {\n        x += q.x;\n        y += q.y;\n        z += q.z;\n        w += q.w;\n\n        return *this;\n    }\n\n    quatd&amp; operator -= (const quatd&amp; q)\n    {\n        x -= q.x;\n        y -= q.y;\n        z -= q.z;\n        w -= q.w;\n\n        return *this;\n    }\n\n\n    // multiplication\n\n    quatd operator * (const quatd&amp; q) const\n    {\n        double qw = w*q.w - x*q.x - y*q.y - z*q.z;\n        double qx = w*q.x + x*q.w + y*q.z - z*q.y;\n        double qy = w*q.y + y*q.w + z*q.x - x*q.z;\n        double qz = w*q.z + z*q.w + x*q.y - y*q.x;\n\n        return quatd(qx, qy, qz, qw);\n    }\n\n    quatd&amp; operator *= (const quatd&amp; q)\n    {\n        double qw = w*q.w - x*q.x - y*q.y - z*q.z;\n        double qx = w*q.x + x*q.w + y*q.z - z*q.y;\n        double qy = w*q.y + y*q.w + z*q.x - x*q.z;\n        double qz = w*q.z + z*q.w + x*q.y - y*q.x;\n\n        x = qx;\n        y = qy;\n        z = qz;\n        w = qw;\n\n        return *this;\n    }\n\n    quatd operator*(const double a) const\n    {\n        return quatd(x*a, y*a, z*a, w*a);\n    }\n\n    // division\n\n    quatd operator / (const double a) const\n    {\n        return quatd(x/a, y/a, z/a, w/a);\n    }\n\n    quatd&amp; operator /= (const double a)\n    {\n        x /= a;\n        y /= a;\n        z /= a;\n        w /= a;\n\n        return *this;\n    }\n\n    // Special ops\n\n    quatd Conjugate() const { return quatd(-x, -y, -z, w); }\n\n    double Norm() const { return w*w + x*x + y*y + z*z; } \n\n    void MakeUnit() \n    {\n        double N = (double) sqrt(w*w + x*x + y*y + z*z);\n\n        if (N != 0)\n        {\n            x /= N;\n            y /= N;\n            z /= N;\n            w /= N;\n        }\n        else w = 1.f;\n    }\n\n    quatd Inverse() const\n    {\n        double N = w*w + x*x + y*y + z*z;\n\n        return quatd(-x/N, -y/N, -z/N, w/N);\n    }\n\n    double DotProduct(const quatd&amp; q) const\n    {\n        return w*q.w + x*q.x + y*q.y + z*q.z;\n    }\n\n    vec3d GetVector() const\n    {\n        return vec3d(x, y, z).Normalize();\n    }\n\n    double GetAngle() const\n    {\n        return (double)(acos(w)*2.0);\n    }\n\n/*  quatd&amp; MultiplyAngle(double fa)\n    {\n        double angle = fa*acos(w)*2.0;\n\n        w = cos(angle * 0.5);\n\n        double sina = sin(angle * 0.5);\n\n        x *= sina;\n        y *= sina;\n        z *= sina;\n    }\n*/\n\n\n    // use only when *this is unit vector\n    void RotateVector(vec3d&amp; v) const\n    {\n        if ((w == 0) || ((x==0) &amp;&amp; (y==0) &amp;&amp; (z==0))) return;\n\n        // v*q^-1\n        double qw = v.x*x + v.y*y + v.z*z;\n        double qx = v.x*w - v.y*z + v.z*y;\n        double qy = v.y*w - v.z*x + v.x*z;\n        double qz = v.z*w - v.x*y + v.y*x;\n\n        // q* (v* q^-1)\n        v.x = (double) (w*qx + x*qw + y*qz - z*qy);\n        v.y = (double) (w*qy + y*qw + z*qx - x*qz);\n        v.z = (double) (w*qz + z*qw + x*qy - y*qx);\n    }\n\n    // use only when *this is unit vector\n    vec3d operator * (const vec3d&amp; r)\n    {\n        vec3d n = r;\n\n        // v*q^-1\n        double qw = n.x*x + n.y*y + n.z*z;\n        double qx = n.x*w - n.y*z + n.z*y;\n        double qy = n.y*w - n.z*x + n.x*z;\n        double qz = n.z*w - n.x*y + n.y*x;\n\n        // q* (v* q^-1)\n        n.x = (w*qx + x*qw + y*qz - z*qy);\n        n.y = (w*qy + y*qw + z*qx - x*qz);\n        n.z = (w*qz + z*qw + x*qy - y*qx);\n\n        return n;\n    }\n\n    mat3d operator * (mat3d m)\n    {\n        mat3d a;\n        double qw, qx, qy, qz;\n        for (int i=0; i&lt;3; ++i)\n        {\n            // v*q^-1\n            qw = m[0][i]*x + m[1][i]*y + m[2][i]*z;\n            qx = m[0][i]*w - m[1][i]*z + m[2][i]*y;\n            qy = m[1][i]*w - m[2][i]*x + m[0][i]*z;\n            qz = m[2][i]*w - m[0][i]*y + m[1][i]*x;\n\n            // q* (v* q^-1)\n            a[0][i] = (w*qx + x*qw + y*qz - z*qy);\n            a[1][i] = (w*qy + y*qw + z*qx - x*qz);\n            a[2][i] = (w*qz + z*qw + x*qy - y*qx);\n        }\n\n        return a;\n    }\n\n    void RotateVectorP(double* v, double* r) const\n    {\n        static double fx, fy, fz, fw;\n        static double qw, qx, qy, qz;\n\n        fx = (double) x;\n        fy = (double) y;\n        fz = (double) z;\n        fw = (double) w;\n\n        qw = v[0]*fx + v[1]*fy + v[2]*fz;\n        qx = v[0]*fw - v[1]*fz + v[2]*fy;\n        qy = v[1]*fw - v[2]*fx + v[0]*fz;\n        qz = v[2]*fw - v[0]*fy + v[1]*fx;\n\n        r[0] = (double) (fw*qx + fx*qw + fy*qz - fz*qy);\n        r[1] = (double) (fw*qy + fy*qw + fz*qx - fx*qz);\n        r[2] = (double) (fw*qz + fz*qw + fx*qy - fy*qx);\n    }\n\n    static double dot(quatd &amp;q1, quatd &amp;q2) \n    { return q1.x*q2.x + q1.y*q2.y + q1.z*q2.z + q1.w*q2.w; }\n\n    static quatd lerp(quatd &amp;q1, quatd &amp;q2, double t) \n    { quatd q = (q1*(1-t) + q2*t); q.MakeUnit(); return q; }\n\n    static quatd slerp(quatd &amp;q1, quatd &amp;q2, double t) ;\n\npublic:\n    double x, y, z;\n    double w;\n};\n\ninline quatd operator * (const double a, const quatd&amp; q)\n{\n    return q*a;\n}\n\ntypedef unsigned char uchar;\n\nclass GLCOLOR\n{\npublic:\n    uchar   a, b, g, r;\n\npublic:\n    GLCOLOR() : a(255), b(0), g(0), r(0){}\n    GLCOLOR(uchar ur, uchar ug, uchar ub, uchar ua = 255)\n    {\n        r = ur; g = ug; b = ub; a = ua;\n    }\n\n    GLCOLOR operator * (double f)\n    {\n        return GLCOLOR((uchar) (r*f), (uchar) (g*f), (uchar) (b*f));\n    }\n\n    GLCOLOR operator + (GLCOLOR&amp; c)\n    {\n        return GLCOLOR(r+c.r, g+c.g, b+c.b);\n    }\n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/meshFIM_8h.html","title":"Libs/Mesh/meshFIM.h","text":""},{"location":"api/Files/meshFIM_8h.html#classes","title":"Classes","text":"Name class meshFIM"},{"location":"api/Files/meshFIM_8h.html#defines","title":"Defines","text":"Name _EPS ONE CURVATURE GENERATE_GEO_FILES"},{"location":"api/Files/meshFIM_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/meshFIM_8h.html#define-_eps","title":"define _EPS","text":"<pre><code>#define _EPS 1e-06\n</code></pre>"},{"location":"api/Files/meshFIM_8h.html#define-one","title":"define ONE","text":"<pre><code>#define ONE 1\n</code></pre>"},{"location":"api/Files/meshFIM_8h.html#define-curvature","title":"define CURVATURE","text":"<pre><code>#define CURVATURE 2\n</code></pre>"},{"location":"api/Files/meshFIM_8h.html#define-generate_geo_files","title":"define GENERATE_GEO_FILES","text":"<pre><code>#define GENERATE_GEO_FILES 1\n</code></pre>"},{"location":"api/Files/meshFIM_8h.html#source-code","title":"Source code","text":"<pre><code>#ifndef MESHFIM_H\n#define MESHFIM_H\n\n\n#include \"TriMesh.h\"\n#include \"TriMesh_algo.h\"\n#include \"KDtree.h\"\n#include \"Color.h\"\n\n\n//#include \"itkImageToImageFilter.h\"\n//#include \"itkLevelSet.h\"\n//#include \"itkIndex.h\"\n//#include \"vnl/vnl_math.h\"\n//#include \"itkDiffusionTensor3D.h\"\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;time.h&gt;\n\n#include &lt;iterator&gt;\n#include &lt;vnl/vnl_math.h&gt;\n#include &lt;vnl/vnl_sparse_matrix.h&gt;\n#include &lt;vnl/algo/vnl_svd.h&gt;\n#include &lt;vnl/algo/vnl_sparse_lu.h&gt;\n#include &lt;vcl_legacy_aliases.h&gt;\n\n\n//#include &lt;vxl/core/vgl/algo/vgl_homg_operators_2d.h&gt;\n//#include &lt;vgl/vgl_conic.h&gt;\n#include &lt;vnl/vnl_matrix.h&gt;\n#include &lt;vnl/vnl_vector.h&gt;\n#include &lt;vnl/algo/vnl_matrix_inverse.h&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;vcl_compiler.h&gt;\n\n#ifndef _EPS\n#define _EPS 1e-06\n#endif\n\n#define ONE 1 \n#define CURVATURE 2 \n\n\n\n// SHIREEN\n#define GENERATE_GEO_FILES 1 // now disable till we incorporate the geodesic repulsion\n// end SHIREEN\n\nusing trimesh::TriMesh;\nusing trimesh::vec3;\nusing trimesh::point;\nusing trimesh::KDtree;\nusing trimesh::Color;\n\nclass meshFIM {\n\npublic:\n  typedef int VoxelIndexType;\n\n    typedef int index;\n    enum LabelType { MaskPoint, SeedPoint, ActivePoint, FarPoint, StopPoint, AlivePoint,ToBeAlivePoint };\n\n    TriMesh *m_meshPtr;\n    int NumComputation;\n    float imageOrigin[3];\n    float imageSpacing[3];\n    int imageSize[3];\n    int imageIndex[3];\n\n    std::vector&lt;Color&gt; colors;\n\n\n    void ComputeDistanceToLandmarksGivenTriangleInfo(TriMesh *mesh, const char *infilename, const char *outfilename);\n    void computeFIM(TriMesh *mesh, const char *vertT_filename);\n    void GetFeatureValues(point x, std::vector&lt;float&gt; &amp;vals);\n    void ReadFaceIndexMap(const char *infilename);\n    void ReadFeatureFromFile(const char *infilename);\n    void ReadFeatureGradientFromFile(const char *infilename);\n    point GetFeatureDerivative(point p, int fIndex);\n\n    void need_abs_curvatures();\n    void need_edge_lengths();\n    void need_speed();\n    void need_oneringfaces();\n    void need_kdtree();\n\n\n    void SetMesh(TriMesh *mesh);\n    void SetStopDistance(float d) {\n      m_StopDistance = d;\n    }\n    void setSpeedType(int st) {\n      speedType = st;\n      if (st != ONE &amp;&amp; st != CURVATURE) {\n        std::cout &lt;&lt; \"Impossible SpeedType set\" &lt;&lt; std::endl;\n        throw(1);\n      }\n    }\n\n\n    meshFIM() {\n      m_meshPtr = NULL;\n    };\n    ~meshFIM() {};\n\nprotected:\n\n\nprivate:\n\n  std::list&lt;index&gt;                             m_ActivePoints;\n  std::vector&lt;index&gt;                           m_SeedPoints;\n  std::vector&lt;LabelType&gt;                       m_Label;\n  float                                        m_StopDistance;\n\n  TriMesh *GetOutputMesh() {\n    return m_meshPtr;\n  }\n  void MeshReader(char *filename);\n\n  bool IsNonObtuse(int v, TriMesh::Face f);\n  void SplitFace(std::vector&lt;TriMesh::Face&gt; &amp;acFaces, int v, TriMesh::Face cf, int nfAdj);\n  std::vector&lt;TriMesh::Face&gt; GetOneRing(int v);\n  float Upwind(index currentVert, index vet);\n  void InitializeAttributes(int currentVert, std::vector&lt;int&gt; seeds);\n  void CleanupAttributes();\n  float LocalSolver(index C, TriMesh::Face triangle, index currentVert);\n\n  void SetSeedPoint(std::vector&lt;index&gt; SeedPoints) {\n    m_SeedPoints = SeedPoints;\n  }\n\n  int getSpeedType() {\n    return speedType;\n  }\n  float GetStopDistance() {\n    return m_StopDistance;\n  }\n\n\n  void InitializeLabels();\n  void InitializeActivePoints();\n  float PointLength(point v);\n\n  void GenerateReducedData();\n\n  void loadGeodesicFile(TriMesh *mesh, const char *geoFilename);\n\n  void computeCoordXFiles(TriMesh *mesh, const char *vertT_filename);\n  void computeCoordYFiles(TriMesh *mesh, const char *vertT_filename);\n  void computeCoordZFiles(TriMesh *mesh, const char *vertT_filename);\n  void computeCurvFiles(TriMesh *mesh, const char *vertT_filename);\n\n  void ComputeDistanceToCurve(TriMesh *mesh, std::vector&lt; point &gt; curvePoints, const char *outfilename);\n\n  void physicalPointToXYZ(point x, VoxelIndexType *imageX, float imageOrigin[3], float imageSpacing[3]);\n  VoxelIndexType indexToLinearIndex(VoxelIndexType *imageX, int imageSize[3]);\n  VoxelIndexType physicalPointToLinearIndex(point x);\n  VoxelIndexType physicalPointToLinearIndex(point x, float imageOrigin[3], float imageSpacing[3], int imageSize[3]);\n  double pointTriangleDistance(point P, TriMesh::Face face, point &amp;PP);\n  vec3 ComputeBarycentricCoordinates(point p, TriMesh::Face f);\n  void need_maxedgelength();\n  int FindNearestVertex(point pt);\n  int GetTriangleInfoForPoint(point x, TriMesh::Face &amp;triangleX, float &amp;alphaX, float &amp;betaX, float &amp;gammaX);\n\n  //Praful - for Riddhish project\n  //float GetVirtualSource(vnl_vector&lt;float&gt; baryCoord, vnl_matrix&lt;float&gt; X, vnl_vector&lt;float&gt; ds, vnl_vector&lt; float &gt; &amp;x0);\n  //float ComputeThreePointApproximatedGeodesic(vnl_vector&lt;float&gt; x, vnl_vector&lt;float&gt; baryCoord, vnl_matrix&lt;float&gt; X, vnl_vector&lt;float&gt; ds, char *method);\n  float ComputeCanonicalForm(point s, vnl_vector&lt;float&gt; &amp;x, vnl_matrix&lt;float&gt; &amp;X);\n  float GetGeodesicDistance(int v1, int v2);\n  //float GetBronsteinGeodesicDistance(TriMesh::Face Sa, TriMesh::Face Sb, vnl_vector &lt;float&gt; baryCoord_a, vnl_vector &lt;float&gt; baryCoord_b, char *method);\n\n  // SHIREEN - compute distance to landmarks based on geodesic approximation\n  //float GetBronsteinGeodesicDistance(point a, point b, char *method);\n  void ComputeDistanceToLandmark(TriMesh *mesh, point landmark, bool apply_log, const char *outfilename);\n  void UpdateGeodesicMapWithDistancesFromVertices(std::vector&lt;int&gt; vertexIdlist);\n  // end SHIREEN\n\n  // SHIREEN - computing geo distance on the fly for fuzzy geodesics\n  int GetVertexInfoForPoint(point x);\n  //std::vector&lt;float&gt; ComputeDistanceToCurve(TriMesh *mesh, std::vector&lt; point &gt; curvePoints);\n  void WriteFeaFile(TriMesh *mesh, char *outfilename);\n  void WriteFeaFile(std::vector&lt;float&gt; fea, char *outfilename);\n  // end SHIREEN\n\n  point ComputeFeatureDerivative(int v, int nFeature);\n\n\n\n  int speedType;\n\n  // maps face index to speedInv\n  std::vector&lt;float&gt; speedInvVector;\n\n  // maps vertex index to abs_curv\n  std::vector&lt;float&gt; abs_curv;\n\n  // maps face index to vec3 of edge lengths with edges in this order: {01, 12, 20}\n  std::vector&lt;vec3&gt; edgeLengthsVector;\n\n  // maps vertex index to vertex index to distance?\n  std::vector&lt; std::map&lt;unsigned int, float&gt; &gt; geodesicMap;\n\n  // maps vertex index to something to do with the geodesic computation\n  std::vector&lt;float&gt; geodesic;\n\n  // maps something to something\n  std::map&lt;VoxelIndexType, std::vector&lt;int&gt; &gt; faceIndexMap;\n\n  // Used for ComputeBaryCentricCoordinates when faceIndexMap is unavailable.\n  KDtree *kd;\n\n  // Used for GetNearestVertex;\n  double maxEdgeLength;\n\n  std::vector&lt; std::vector&lt;TriMesh::Face&gt; &gt; vertOneringFaces;\n\n  std::vector&lt; std::vector&lt;float&gt; &gt; features;\n\n  std::vector &lt; std::vector&lt;point&gt; &gt; featureGradients;\n\n};\n\n\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/pybind__utils_8h.html","title":"Libs/Python/pybind_utils.h","text":""},{"location":"api/Files/pybind__utils_8h.html#namespaces","title":"Namespaces","text":"Name shapeworks User usage reporting (telemetry)"},{"location":"api/Files/pybind__utils_8h.html#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace shapeworks {\n\nvoid printNumpyArrayInfo(const py::array&amp; np_array) {\n  // get input array info\n  auto info = np_array.request();\n\n  /*\n    struct buffer_info {\n    void *ptr;\n    py::ssize_t itemsize;\n    std::string format;\n    py::ssize_t ndim;\n    std::vector&lt;py::ssize_t&gt; shape;\n    std::vector&lt;py::ssize_t&gt; strides;\n    };\n  */\n\n  std::cout &lt;&lt; \"buffer info: \\n\"\n            &lt;&lt; \"\\tinfo.ptr: \" &lt;&lt; info.ptr &lt;&lt; std::endl\n            &lt;&lt; \"writeable: \" &lt;&lt; np_array.writeable() &lt;&lt; std::endl\n            &lt;&lt; \"owns data: \" &lt;&lt; np_array.owndata() &lt;&lt; std::endl\n            &lt;&lt; \"\\tinfo.itemsize: \" &lt;&lt; info.itemsize &lt;&lt; std::endl\n            &lt;&lt; \"\\tinfo.format: \" &lt;&lt; info.format &lt;&lt; std::endl\n            &lt;&lt; \"\\tinfo.ndim: \" &lt;&lt; info.ndim &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"shape ([z][y]x): \";\n  for (auto&amp; n: info.shape) {\n    std::cout &lt;&lt; n &lt;&lt; \" \";\n  }\n  std::cout &lt;&lt; \"\\nstrides ([z][y]x): \";\n  for (auto&amp; n: info.strides) {\n    std::cout &lt;&lt; n &lt;&lt; \" \";\n  }\n  std::cout &lt;&lt; \"\\nsize : \";\n  std::cout &lt;&lt; np_array.size();\n\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid verifyOrderAndPacking(const py::array&amp; np_array) {\n  auto info = np_array.request();\n\n  // verify it's C order, not Fortran order\n  auto c_order = pybind11::detail::array_proxy(np_array.ptr())-&gt;flags &amp; pybind11::detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_;\n  if (!c_order) {\n    throw std::invalid_argument(\"array must be C_CONTIGUOUS; use numpy.transpose() to reorder\");\n  }\n\n  // verify data is densely packed by checking strides is same as shape\n  std::vector&lt;py::ssize_t&gt; strides(info.ndim, info.itemsize);\n  for (int i = 0; i &lt; info.ndim-1; i++) {\n    for (int j = i+1; j &lt; info.ndim; j++) {\n      strides[i] *= info.shape[j];\n    }\n  }\n\n  for (int i = 0; i &lt; info.ndim; i++) {\n    if (info.strides[i] != strides[i]) {\n      throw std::invalid_argument(std::string(\"array not densely packed in \") + std::to_string(i) +\n                                  std::string(\"th dimension: expected \") + std::to_string(strides[i]) +\n                                  std::string(\" strides, not \") + std::to_string(info.strides[i]));\n    }\n  }\n}\n\nvoid setOwnership(py::array&amp; array, bool owns) {\n  std::bitset&lt;32&gt; own_data_flag(pybind11::detail::npy_api::NPY_ARRAY_OWNDATA_);\n  if (!owns) {\n    int disown_data_flag = static_cast&lt;int&gt;(~own_data_flag.to_ulong());\n    pybind11::detail::array_proxy(array.ptr())-&gt;flags &amp;= disown_data_flag;\n  }\n  else {\n    pybind11::detail::array_proxy(array.ptr())-&gt;flags |= static_cast&lt;int&gt;(own_data_flag.to_ulong());\n  }\n\n  if (array.owndata() != owns) {\n    throw std::runtime_error(\"error modifying python array ownership\");\n  }\n}\n\nImage::ImageType::Pointer wrapNumpyArr(py::array&amp; np_array) {\n  //printNumpyArrayInfo(np_array);\n\n  // get input array info\n  auto info = np_array.request();\n\n  // verify it's 3d\n  if (info.ndim != 3) {\n    throw std::invalid_argument(std::string(\"array must be 3d, but ndim = \") + std::to_string(info.ndim));\n  }\n\n  // verify py::array (throws on error)\n  verifyOrderAndPacking(np_array);\n\n  // array must be dtype.float32 and own its data to transfer it to Image\n  if (info.format != py::format_descriptor&lt;Image::PixelType&gt;::format()) {\n    // inform the user how to create correct type array rather than copy\n    throw std::invalid_argument(\"array must be same dtype as Image; convert using `np.array(arr, dtype=np.float32)`\");\n  }\n  if (!np_array.owndata()) {\n    throw std::invalid_argument(\"error: numpy array does not own data (see `arr.flags()`) to be transferred to Image\");\n  }\n\n  // Pass ownership of the array to Image to prevent Python from\n  // deallocating (the shapeworks Image will dealloate when it's time).\n  setOwnership(np_array, false);\n\n  // import data, passing ownership of memory to ensure there will be no leak\n  using ImportType = itk::ImportImageFilter&lt;Image::PixelType, 3&gt;;\n  auto importer = ImportType::New();\n\n  ImportType::SizeType size; // i.e., Dims (remember numpy orders zyx)\n  size[0] = np_array.shape()[2];\n  size[1] = np_array.shape()[1];\n  size[2] = np_array.shape()[0];\n\n  assert(size[0]*size[1]*size[2] == np_array.size());\n  importer-&gt;SetImportPointer(static_cast&lt;Image::PixelType *&gt;(info.ptr),\n                             size[0]*size[1]*size[2],\n                             true /*importer take_ownership*/);\n  ImportType::IndexType start({0,0,0}); // i.e., Coord\n  ImportType::RegionType region;\n  region.SetIndex(start);\n  region.SetSize(size);\n  importer-&gt;SetRegion(region);\n  importer-&gt;Update();\n  return importer-&gt;GetOutput();\n}\n\nArray pyToArr(py::array&amp; np_array, bool take_ownership = true) {\n  //printNumpyArrayInfo(np_array);\n\n  //\n  // Verify the data is of appropriate size, shape, type, and ownership.\n  //\n  // get input array info\n  auto info = np_array.request();\n\n  // verify py::array (throws on error)\n  verifyOrderAndPacking(np_array);\n\n  // verify format\n  if (!(info.format == py::format_descriptor&lt;float&gt;::format() ||\n        info.format == py::format_descriptor&lt;double&gt;::format())) {\n    throw std::invalid_argument(std::string(\"numpy dtype \") + std::string(info.format) + std::string(\" not yet accepted (currently only float32 and float64) (i.e., \" + py::format_descriptor&lt;float&gt;::format()) + \" and \" + py::format_descriptor&lt;double&gt;::format() + \")\");\n  }\n\n  // verify dims (ex: 2d is an array of vectors, 1d is an array of scalars)\n  if (info.ndim &lt; 1 || info.ndim &gt; 2) {\n    throw std::invalid_argument(std::string(\"array must be either 1d or 2d, but ndim = \") + std::to_string(info.ndim));\n  }\n\n  // array must own its data to transfer it to Image\n  // NOTE: it could be shared, but this avoids a potential dangling pointer\n  if (take_ownership &amp;&amp; !np_array.owndata()) {\n    throw std::invalid_argument(\"numpy array must own the data to be transferred to Mesh (maybe pass `arr.copy()`)\");\n  }\n\n  //\n  // Create the vtkDataArray and pass the numpy data in.\n  //\n  // determine nvalues, ncomponents\n  auto nvalues = info.shape[0];\n  auto ncomponents = info.ndim &gt; 1 ? info.shape[1] : 1;\n\n  // create vtkDataArray pointer, set number of components, allocate and pass data\n  auto vtkarr = Array();\n  if (info.format == py::format_descriptor&lt;float&gt;::format()) {\n    auto arr = vtkFloatArray::New();\n    arr-&gt;SetArray(static_cast&lt;float*&gt;(info.ptr), nvalues * ncomponents, !take_ownership /*0 passes ownership*/);\n    vtkarr = arr;\n  }\n  else if (info.format == py::format_descriptor&lt;double&gt;::format()) {\n    auto arr = vtkDoubleArray::New();\n    arr-&gt;SetArray(static_cast&lt;double*&gt;(info.ptr), nvalues * ncomponents, !take_ownership /*0 passes ownership*/);\n    vtkarr = arr;\n  }\n  else {\n    throw std::invalid_argument(\"numpy dtype not yet accepted (currently only float32 and float64)\");\n    // Other options: vtkUnsignedShortArray, vtkUnsignedLongLongArray, vtkUnsignedLongArray, vtkUnsignedIntArray, vtkUnsignedCharArray, vtkSignedCharArray, vtkShortArray, vtkLongLongArray, vtkLongArray, vtkIntArray, vtkIdTypeArray, vtkFloatArray, vtkDoubleArray, vtkCharArray, and vtkBitArray.\n  }\n  vtkarr-&gt;SetNumberOfComponents(ncomponents);\n\n  // prevent Python from deallocating since vtk will do that when it's time\n  if (take_ownership) {\n    setOwnership(np_array, false);\n  }\n\n  return vtkarr;\n}\n\nenum ArrayTransferOptions {\n  COPY_ARRAY,  // copies and (by definition) grants ownership\n  SHARE_ARRAY, // does not copy or grant ownership\n  MOVE_ARRAY   // does not copy, grants ownership if possible\n};\n\npy::array arrToPy(Array&amp; array, ArrayTransferOptions xfer = COPY_ARRAY) {\n  const size_t elemsize = array-&gt;GetElementComponentSize();\n  auto shape = std::vector&lt;size_t&gt; { static_cast&lt;size_t&gt;(array-&gt;GetNumberOfTuples()) };\n  if (array-&gt;GetNumberOfComponents() &gt; 1) {\n    shape.push_back(static_cast&lt;size_t&gt;(array-&gt;GetNumberOfComponents()));\n  }\n  auto strides = std::vector&lt;size_t&gt;();\n  if (array-&gt;GetNumberOfComponents() &gt; 1) {\n    strides = std::vector&lt;size_t&gt; {\n      static_cast&lt;size_t&gt;(array-&gt;GetNumberOfComponents() * elemsize),\n      elemsize\n    };\n  }\n  else {\n    strides = std::vector&lt;size_t&gt; { elemsize };\n  }\n\n  py::dtype py_type;\n  if (vtkDoubleArray::SafeDownCast(array)) {\n    py_type = py::dtype::of&lt;double&gt;();\n  }\n  else if (vtkFloatArray::SafeDownCast(array)) {\n    py_type = py::dtype::of&lt;float&gt;();\n  }\n  else {\n    throw std::invalid_argument(\"arrToPy passed currently unhandled array type\");\n    // Other options: vtkUnsignedShortArray, vtkUnsignedLongLongArray, vtkUnsignedLongArray, vtkUnsignedIntArray, vtkUnsignedCharArray, vtkSignedCharArray, vtkShortArray, vtkLongLongArray, vtkLongArray, vtkIntArray, vtkIdTypeArray, vtkFloatArray, vtkDoubleArray, vtkCharArray, and vtkBitArray.\n  }\n#if 0\n  std::cout &lt;&lt; \"type of array: \" &lt;&lt; typeid(array).name() &lt;&lt; std::endl\n            &lt;&lt; \"X (num_components): \" &lt;&lt; array-&gt;GetNumberOfComponents() &lt;&lt; std::endl\n            &lt;&lt; \"Y (num_tuples): \" &lt;&lt; array-&gt;GetNumberOfTuples() &lt;&lt; std::endl\n            &lt;&lt; \"sizeof(element): \" &lt;&lt; array-&gt;GetElementComponentSize() &lt;&lt; std::endl\n            &lt;&lt; \"py_type: \" &lt;&lt; py_type.kind() &lt;&lt; std::endl\n            &lt;&lt; \"size: \" &lt;&lt; py_type.itemsize() &lt;&lt; std::endl;\n#endif\n\n  py::str dummyDataOwner;\n  py::array img{\n    py_type,\n    shape,\n    strides,\n    array-&gt;GetVoidPointer(0),\n    (xfer == COPY_ARRAY ? pybind11::handle() : dummyDataOwner)\n  };\n\n  if (xfer == MOVE_ARRAY) {\n    if (array-&gt;GetReferenceCount() == 1) {\n      array-&gt;SetReferenceCount(2); // NOTE: tricks vtk into never deleting this array\n      setOwnership(img, true);\n    }\n    else {\n      // If array has other references, it will only be shared with Python.\n      std::cerr &lt;&lt; \"NOTE: sharing array (unable to transfer ownership from C++)\" &lt;&lt; std::endl;\n    }\n  }\n\n  // set c-contiguous and not f-contiguous, not both (i.e., \"NPY_ARRAY_FORCECAST_\")\n  std::bitset&lt;32&gt; f_order_flag = pybind11::detail::npy_api::NPY_ARRAY_F_CONTIGUOUS_;\n  f_order_flag = ~f_order_flag;\n  int f_order_flag_int = static_cast&lt;int&gt;(f_order_flag.to_ulong());\n  pybind11::detail::array_proxy(img.ptr())-&gt;flags &amp;= f_order_flag_int;\n  pybind11::detail::array_proxy(img.ptr())-&gt;flags |= pybind11::detail::npy_api::NPY_ARRAY_C_CONTIGUOUS_;\n\n  return img;\n}\n\n}\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/resource_8h.html","title":"Studio/Resources/resource.h","text":""},{"location":"api/Files/resource_8h.html#defines","title":"Defines","text":"Name IDI_ICON1"},{"location":"api/Files/resource_8h.html#macros-documentation","title":"Macros Documentation","text":""},{"location":"api/Files/resource_8h.html#define-idi_icon1","title":"define IDI_ICON1","text":"<pre><code>#define IDI_ICON1 101\n</code></pre>"},{"location":"api/Files/resource_8h.html#source-code","title":"Source code","text":"<pre><code>//{{NO_DEPENDENCIES}}\n// Microsoft Visual C++ generated include file.\n// Used by ShapeWorksStudio.rc\n//\n#define IDI_ICON1                       101\n\n// Next default values for new objects\n// \n#ifdef APSTUDIO_INVOKED\n#ifndef APSTUDIO_READONLY_SYMBOLS\n#define _APS_NEXT_RESOURCE_VALUE        102\n#define _APS_NEXT_COMMAND_VALUE         40001\n#define _APS_NEXT_CONTROL_VALUE         1001\n#define _APS_NEXT_SYMED_VALUE           101\n#endif\n#endif\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/stdafx_8h.html","title":"Libs/Mesh/PreviewMeshQC/stdafx.h","text":""},{"location":"api/Files/stdafx_8h.html#source-code","title":"Source code","text":"<pre><code>// stdafx.h : include file for standard system include files,\n// or project specific include files that are used frequently, but\n// are changed infrequently\n//\n\n#pragma once\n\n#include &lt;stdio.h&gt;\n\n\n// TODO: reference additional headers your program requires here\n</code></pre> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Files/vtkPolyDataToImageData_8h.html","title":"Libs/Analyze/vtkPolyDataToImageData.h","text":""},{"location":"api/Files/vtkPolyDataToImageData_8h.html#classes","title":"Classes","text":"Name class vtkPolyDataToImageData"},{"location":"api/Files/vtkPolyDataToImageData_8h.html#source-code","title":"Source code","text":"<pre><code>// This filter takes a vtkPolyData input and produces a vtkImageData output.\n// It is intended to take a closed surface mesh and produce a binary rasterization.\n// \n// Options are:\n//\n//  Border: optional border around object (useful for isosurfacing)\n//\n//  Spacing: output image spacing\n//\n//  SampleDistance: sample distance for point sampling along surface\n//                  if you get a blank/full image, try reducing this value\n//\n//  InitialBallSize: dilate/erode ball size for morphological closing\n//                  if you get a blank/full image, try increasing this value\n//\n//  FinalBallSize: dilate/erode ball size step at the end\n\n#ifndef __vtkPolyDataToImageData_h\n#define __vtkPolyDataToImageData_h\n\n#include \"vtkImageAlgorithm.h\"\n\nclass vtkPolyDataToImageData : public vtkImageAlgorithm\n{\npublic:\n\n  vtkTypeMacro( vtkPolyDataToImageData, vtkImageAlgorithm );\n  void PrintSelf( ostream&amp; os, vtkIndent indent );\n\n  static vtkPolyDataToImageData* New();\n\n  // Set the number of voxels bordering the object\n  vtkSetMacro( Border, unsigned int );\n  vtkGetMacro( Border, unsigned int );\n\n  // Set the spacing of the produced image\n  vtkSetMacro( Spacing, double );\n  vtkGetMacro( Spacing, double );\n\n  // Set the sample distance of the point sampler\n  vtkSetMacro( SampleDistance, double );\n  vtkGetMacro( SampleDistance, double );\n\n  // Set the initial dilate/erode ball size for morphological closing\n  vtkSetMacro( InitialBallSize, unsigned int );\n  vtkGetMacro( InitialBallSize, unsigned int );\n\n  // Set the final dilate/erode ball size for morphological closing\n  vtkSetMacro( FinalBallSize, unsigned int );\n  vtkGetMacro( FinalBallSize, unsigned int );\n\n  virtual int FillInputPortInformation( int port, vtkInformation* info );\n\nprotected:\n  vtkPolyDataToImageData();\n  ~vtkPolyDataToImageData() {}\n\n  virtual int RequestInformation( vtkInformation* request,\n                                  vtkInformationVector** inputVector,\n                                  vtkInformationVector* outputVector );\n\n  virtual int RequestData( vtkInformation* request,\n    vtkInformationVector** inputVector,\n    vtkInformationVector* outputVector );\n\n  virtual int RequestUpdateExtent( vtkInformation* request,\n    vtkInformationVector** inputVector,\n    vtkInformationVector* outputVector );\n\n\n\n\nprivate:\n  vtkPolyDataToImageData( const vtkPolyDataToImageData&amp; );  // Not implemented.\n  void operator=( const vtkPolyDataToImageData&amp; );  // Not implemented.\n\n  void GetOutputInfo( vtkInformationVector** inputVector,\n                      int dim[3], double origin[3], double spacing[3] );\n\n  unsigned int Border;\n  double Spacing;\n  double SampleDistance;\n\n  unsigned int InitialBallSize;\n  unsigned int FinalBallSize;\n};\n\n#endif // ifndef __vtkPolyDataToImageData_h\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Modules/group__Group-Common.html","title":"Common Classes","text":""},{"location":"api/Modules/group__Group-Common.html#classes","title":"Classes","text":"Name class shapeworks::Logging ShapeWorks Logging Library. <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Modules/group__Group-Constraint.html","title":"Constraint Classes","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Modules/group__Group-Image.html","title":"Image Classes","text":""},{"location":"api/Modules/group__Group-Image.html#classes","title":"Classes","text":"Name class shapeworks::Image <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Modules/group__Group-Mesh.html","title":"Mesh Classes","text":""},{"location":"api/Modules/group__Group-Mesh.html#classes","title":"Classes","text":"Name class shapeworks::Mesh class shapeworks::MeshUtils class shapeworks::MeshWarper <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Modules/index_groups.html","title":"Modules","text":"<ul> <li>group Common Classes </li> <li>group Constraint Classes </li> <li>group Image Classes </li> <li>group Mesh Classes </li> </ul> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Namespaces/index_namespaces.html","title":"Namespaces","text":"<ul> <li>namespace Ui </li> <li>namespace fmt </li> <li>namespace itk <ul> <li>namespace Functor </li> </ul> </li> <li>namespace monailabel </li> <li>namespace shapeworks User usage reporting (telemetry) <ul> <li>namespace mesh </li> <li>namespace particles </li> <li>namespace project <ul> <li>namespace prefixes </li> <li>namespace types </li> </ul> </li> </ul> </li> <li>namespace std </li> <li>namespace utils </li> </ul> <p>Updated on 2026-01-14 at 21:44:22 +0000</p>"},{"location":"api/Namespaces/namespaceUi.html","title":"Ui","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespacefmt.html","title":"fmt","text":""},{"location":"api/Namespaces/namespacefmt.html#classes","title":"Classes","text":"Name struct fmt::formatter&lt; QString &gt; <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Namespaces/namespaceitk.html","title":"itk","text":""},{"location":"api/Namespaces/namespaceitk.html#namespaces","title":"Namespaces","text":"Name itk::Functor"},{"location":"api/Namespaces/namespaceitk.html#classes","title":"Classes","text":"Name class itk::AdvancedTransform Transform maps points, vectors and covariant vectors from an input space to an output space. class itk::BSplineInterpolateImageFunctionWithDoubleCoefficents class itk::CompactlySupportedRBFSparseKernelTransform class itk::KernelTransform2 class itk::MultiplyByConstantImageFilter Multiply input pixels by a constant. class itk::SparseKernelTransform class itk::ThinPlateSplineKernelTransform2 class itk::TPGACLevelSetImageFilter"},{"location":"api/Namespaces/namespaceitk.html#functions","title":"Functions","text":"Name void fillLocal6Neighbours(int * srcNbh, int * dstNbh, int centre, int i0, int i1, int i2, int i3) void label6Neighbours(int * nbh, int * nbhlabels, int * nbhv, int curlabel, int idx) void label26Neighbours(int * nbh, int * nbhlabels, int * nbhv, int curlabel, int idx) int connectedComponents(int * nbh, int * nbhLabels, void()(int , int , int , int, int) labelNeighboursFunc)"},{"location":"api/Namespaces/namespaceitk.html#attributes","title":"Attributes","text":"Name int nbh6Table int nbh26Table"},{"location":"api/Namespaces/namespaceitk.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Namespaces/namespaceitk.html#function-filllocal6neighbours","title":"function fillLocal6Neighbours","text":"<pre><code>static inline void fillLocal6Neighbours(\n    int * srcNbh,\n    int * dstNbh,\n    int centre,\n    int i0,\n    int i1,\n    int i2,\n    int i3\n)\n</code></pre> <p>Checks if the centre'th element of srcNbh is on. If it is, activate that element in dstNbh and also i0 to i3 if they are active in srcNbh. This is used during the recursive 6 connectivity determination. </p>"},{"location":"api/Namespaces/namespaceitk.html#function-label6neighbours","title":"function label6Neighbours","text":"<pre><code>static void label6Neighbours(\n    int * nbh,\n    int * nbhlabels,\n    int * nbhv,\n    int curlabel,\n    int idx\n)\n</code></pre> <p>The idx'th voxel in nbh is ALREADY labeled. This checks for existing 6-neighbours and gives them label curlabel. </p>"},{"location":"api/Namespaces/namespaceitk.html#function-label26neighbours","title":"function label26Neighbours","text":"<pre><code>static void label26Neighbours(\n    int * nbh,\n    int * nbhlabels,\n    int * nbhv,\n    int curlabel,\n    int idx\n)\n</code></pre> <p>The idx'th voxel in nbh is ALREADY labeled. This checks for existing 26-neighbours and gives them label curlabel. </p>"},{"location":"api/Namespaces/namespaceitk.html#function-connectedcomponents","title":"function connectedComponents","text":"<pre><code>static inline int connectedComponents(\n    int * nbh,\n    int * nbhLabels,\n    void(*)(int *, int *, int *, int, int) labelNeighboursFunc\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceitk.html#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Namespaces/namespaceitk.html#variable-nbh6table","title":"variable nbh6Table","text":"<pre><code>static int nbh6Table = {\n    {1, 3, 9, -1, -1, -1}, \n    {0, 2, 4, 10, -1, -1}, \n    {1, 5, 11, -1, -1, -1}, \n    {0, 4, 6, 12, -1, -1}, \n    {1, 3, 5, 7, 13, -1}, \n    {2, 4, 8, 14, -1, -1}, \n    {3, 7, 15, -1, -1, -1}, \n    {4, 6, 8, 16, -1, -1}, \n    {5, 7, 17, -1, -1, -1}, \n    {0, 10, 12, 18, -1, -1}, \n    {1, 9, 11, 13, 19, -1}, \n    {2, 10, 14, 20, -1, -1}, \n    {3, 9, 13, 15, 21, -1}, \n    {4, 10, 12, 14, 16, 22}, \n    {5, 11, 13, 17, 23, -1}, \n    {6, 12, 16, 24, -1, -1}, \n    {7, 13, 15, 17, 25, -1}, \n    {8, 14, 16, 26, -1, -1}, \n    {9, 19, 21, -1, -1, -1}, \n    {10, 18, 20, 22, -1, -1}, \n    {11, 19, 23, -1, -1, -1}, \n    {12, 18, 22, 24, -1, -1}, \n    {13, 19, 21, 23, 25, -1}, \n    {14, 20, 22, 26, -1, -1}, \n    {15, 21, 25, -1, -1, -1}, \n    {16, 22, 24, 26, -1, -1}, \n    {17, 23, 25, -1, -1, -1} \n};\n</code></pre>"},{"location":"api/Namespaces/namespaceitk.html#variable-nbh26table","title":"variable nbh26Table","text":"<pre><code>static int nbh26Table = {\n    {1, 3, 4, 9, 10, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, -1, -1,-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {1, 4, 5, 10, 11, 13, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 4, 6, 7, 9, 10, 12, 13, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {1, 2, 4, 7, 8, 10, 11, 13, 14, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {3, 4, 7, 12, 13, 15, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {3, 4, 5, 6, 8, 12, 13, 14, 15, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {4, 5, 7, 13, 14, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 3, 4, 10, 12, 13, 18, 19, 21, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 2, 3, 4, 5, 9, 11, 12, 13, 14, 18, 19, 20, 21, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {1, 2, 4, 5, 10, 13, 14, 19, 20, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 3, 4, 6, 7, 9, 10, 13, 15, 16, 18, 19, 21, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26}, \n    {1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 20, 22, 23, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {3, 4, 6, 7, 12, 13, 16, 21, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {3, 4, 5, 6, 7, 8, 12, 13, 14, 15, 17, 21, 22, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {4, 5, 7, 8, 13, 14, 16, 22, 23, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {9, 10, 12, 13, 19, 21, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {9, 10, 11, 12, 13, 14, 18, 20, 21, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {10, 11, 13, 14, 19, 22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {9, 10, 12, 13, 15, 16, 18, 19, 22, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {10, 11, 13, 14, 16, 17, 19, 20, 22, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {12, 13, 15, 16, 21, 22, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {12, 13, 14, 15, 16, 17, 21, 22, 23, 24, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, \n    {13, 14, 16, 17, 22, 23, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1} \n};\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Namespaces/namespaceitk_1_1Functor.html","title":"itk::Functor","text":""},{"location":"api/Namespaces/namespaceitk_1_1Functor.html#classes","title":"Classes","text":"Name class itk::Functor::MultiplyByConstant <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Namespaces/namespacemonailabel.html","title":"monailabel","text":""},{"location":"api/Namespaces/namespacemonailabel.html#classes","title":"Classes","text":"Name class monailabel::MonaiLabelJob class monailabel::MonaiLabelTool class monailabel::MonaiLabelUtils class monailabel::UrlValidator"},{"location":"api/Namespaces/namespacemonailabel.html#types","title":"Types","text":"Name typedef float PixelType typedef itk::Image&lt; PixelType, 3 &gt; ImageType"},{"location":"api/Namespaces/namespacemonailabel.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Namespaces/namespacemonailabel.html#typedef-pixeltype","title":"typedef PixelType","text":"<pre><code>typedef float monailabel::PixelType;\n</code></pre>"},{"location":"api/Namespaces/namespacemonailabel.html#typedef-imagetype","title":"typedef ImageType","text":"<pre><code>typedef itk::Image&lt; PixelType, 3 &gt; monailabel::ImageType;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks.html","title":"shapeworks","text":"<p>User usage reporting (telemetry)  More...</p>"},{"location":"api/Namespaces/namespaceshapeworks.html#namespaces","title":"Namespaces","text":"Name shapeworks::mesh shapeworks::particles shapeworks::project"},{"location":"api/Namespaces/namespaceshapeworks.html#classes","title":"Classes","text":"Name class shapeworks::AnalysisTool class shapeworks::AnalysisUtils class shapeworks::Analyze High level analyze API. class shapeworks::AnalyzeCommandGroup class shapeworks::ColorMap class shapeworks::ColorMaps class shapeworks::Command class shapeworks::CompareSettings class shapeworks::CompareWidget class shapeworks::Constraint class shapeworks::Constraints class shapeworks::ContourDomain class shapeworks::CorrespondenceFunction Correspondence term. class shapeworks::DataTool class shapeworks::DeepSSMCommandGroup class shapeworks::DeepSSMJob Qt Wrapper for DeepSSM. class shapeworks::DeepSSMParameters class shapeworks::DeepSSMTool class shapeworks::DisentangledCorrespondenceFunction class shapeworks::DualVectorFunction class shapeworks::EarlyStopping struct shapeworks::EarlyStoppingConfig Configuration for early stopping criteria. class shapeworks::EigenUtils class shapeworks::ExcelProjectReader Excel file format reader for Project. class shapeworks::ExcelProjectWriter Excel file format writer for Project. class shapeworks::Executable class shapeworks::ExportImageDialog class shapeworks::ExportUtils Export utilities for Studio. class shapeworks::FreeFormConstraint class shapeworks::GenericContainer This class seems to be only a wrapper around std::vector implementing ITK DataObject (for smart pointer?) class shapeworks::GenericContainerArray This class appears to be an array of GenericContainers (e.g. std::vector) that implements the Observer interface. The array size tracks the number of domains in the system. E.g. one per domain. class shapeworks::GradientDescentOptimizer Optimizes particle system positions using gradient descent. class shapeworks::Groom High level groom API. class shapeworks::GroomCommandGroup class shapeworks::GroomParameters class shapeworks::GroomTool class shapeworks::GroupPvalueJob class shapeworks::Image class shapeworks::ImageCommand class shapeworks::ImageDomain class shapeworks::ImageDomainWithCurvature class shapeworks::ImageDomainWithGradients class shapeworks::ImageDomainWithGradN class shapeworks::ImageLabel An extention of QLabel especially for scaled images. class shapeworks::ImageUtils Helper functions for image. class shapeworks::ImplicitSurfaceDomain class shapeworks::IndexRegion Indices into a 3d region of memory (can be negative, e.g., for the purpose of padding an image) class shapeworks::Job class shapeworks::JsonProjectReader JSON file format reader for Project. class shapeworks::JsonProjectWriter JSON file format writer for Project. class shapeworks::KeyboardShortcuts class shapeworks::LandmarkDefinition Landmark class containing properties of each landmark. class shapeworks::LandmarkItemDelegate class shapeworks::LandmarkTableModel class shapeworks::LandmarkWidget LandmarkWidget. class shapeworks::LegacyCorrespondenceFunction class shapeworks::LegacyShapeMatrix class shapeworks::Lightbox Display multiple Viewers in a tiled display. class shapeworks::LinearRegressionShapeMatrix class shapeworks::Logging ShapeWorks Logging Library. class shapeworks::LogWindow Log Window. class shapeworks::MatrixContainer class shapeworks::MeanCurvatureContainer class shapeworks::Mesh class shapeworks::MeshCache Thread safe cache for meshes index by shape. class shapeworks::MeshCommand class shapeworks::MeshDomain class shapeworks::MeshGenerator struct shapeworks::MeshGeoEntry class shapeworks::MeshGroup Representation of a group of meshes. class shapeworks::MeshManager Class to manage meshes. class shapeworks::MeshReader reads mesh (used only by one of the Mesh constructors) class shapeworks::MeshReconstructors class shapeworks::MeshSlice MeshSlice. class shapeworks::MeshUtils class shapeworks::MeshWarper class shapeworks::MeshWorker class shapeworks::MeshWorkItem Provides concurrent access to a list of shapes to work needing reconstruction. class shapeworks::MeshWorkQueue class shapeworks::MixedEffectsShapeMatrix class shapeworks::MorphologicalDeviationScore struct shapeworks::MultiVariateNormalRandom class shapeworks::NetworkAnalysisJob class shapeworks::Observer This class is an observer interface for classes to monitor for changes to the optimizer (observer pattern) class shapeworks::OptimizationVisualizer class shapeworks::Optimize class shapeworks::OptimizeCommandGroup class shapeworks::OptimizeParameterFile class shapeworks::OptimizeParameters class shapeworks::OptimizeTool class shapeworks::PaintWidget class shapeworks::Parameters Parameter settings. class shapeworks::ParticleArea class shapeworks::ParticleAreaJob class shapeworks::ParticleAreaPanel class shapeworks::ParticleColors Supplies particle colors. class shapeworks::ParticleDomain class shapeworks::ParticleEvent class shapeworks::ParticleGaussianModeWriter class shapeworks::ParticleGoodBadAssessment Performs good/bad points assessment and reports the bad positions of the particle system. class shapeworks::ParticleNeighborhood class shapeworks::ParticleNormalEvaluation class shapeworks::ParticleNormalEvaluationJob struct shapeworks::ParticlePointIndexPair class shapeworks::ParticleRegionDomain class shapeworks::Particles Representation of correspondence points for a shape including multiple domains. class shapeworks::ParticleShapeStatistics class shapeworks::ParticleSystem A facade class managing interactions with a particle system. class shapeworks::ParticleSystemCommand class shapeworks::ParticleSystemEvaluation class shapeworks::PhysicalRegion physical bounds of a 3d region of space class shapeworks::PickResult class shapeworks::PlaneConstraint class shapeworks::PlaneWidget PlaneWidget. class shapeworks::PlatformUtils Platform utility functions. class shapeworks::PreferencesWindow Qt UI dialog to control preferences. class shapeworks::ProcrustesRegistration struct shapeworks::ProfileEntry class shapeworks::Profiler class shapeworks::Project Representation of a project. class shapeworks::ProjectCommandGroup class shapeworks::ProjectReader Base class for Project readers. class shapeworks::ProjectUtils class shapeworks::PythonWorker class shapeworks::QMeshWarper Wraps MeshWarper as a QObject. class shapeworks::QOptimize Wraps Optimize as a QObject. struct shapeworks::Reconstruction class shapeworks::ReconstructSurface class shapeworks::Sampler class shapeworks::SamplingFunction class shapeworks::ScopedTimer class shapeworks::SegmentationToolPanel class shapeworks::Session Representation of a session. class shapeworks::Shape Representation of a single shape/patient/subject. class shapeworks::ShapeEvaluation class shapeworks::ShapeEvaluationJob The ShapeEvaluationJob class is a worker class that computes shape evaluation metrics of compactness, specificity, and generalization. It runs asynchronously using the Job and Worker interfaces. class shapeworks::ShapeGradientMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! class shapeworks::ShapeMatrix Each column describes a shape. A shape may be composed of m_DomainsPerShape domains (default 1). ALL DOMAINS ARE NOT ASSUMED TO HAVE THE SAME NUMBER OF PARTICLES! class shapeworks::ShapeScalarJob class shapeworks::ShapeScalarPanel class shapeworks::ShapeworksCommand class shapeworks::ShapeWorksStudioApp Main ShapeWorksStudio window. class shapeworks::ShapeWorksUtils class shapeworks::ShapeWorksVtkOutputWindow Implementation of vtkOutputWindow to capture and display VTK error messages. class shapeworks::ShapeworksWorker struct shapeworks::SharedCommandData class shapeworks::SliceView SliceView. class shapeworks::SplashScreen class shapeworks::StatsGroupLDAJob class shapeworks::StatusBarWidget StatusBarWidget. class shapeworks::StringUtils String utility functions. class shapeworks::StudioHandleWidget class shapeworks::StudioInteractorStyle class shapeworks::StudioMesh Representation of a single mesh. class shapeworks::StudioSliceInteractorStyle class shapeworks::StudioUtils Utilities for Studio. class shapeworks::Style class shapeworks::Subject Representation of a single subject. class shapeworks::Surface class shapeworks::Telemetry class shapeworks::TimerStackEntry struct shapeworks::TraceEvent class shapeworks::UpdateChecker Update Checker. class shapeworks::Variant Variant class to represent multiple types. class shapeworks::VectorFunction class shapeworks::VectorImage Gradient (vector) image. class shapeworks::Viewer 3D Viewer class shapeworks::Visualizer Controls display of objects in viewers. class shapeworks::WheelEventForwarder class shapeworks::Worker"},{"location":"api/Namespaces/namespaceshapeworks.html#types","title":"Types","text":"Name enum DisplayMode enum Axis { invalid = -1, X, Y, Z}handy way to specify an axis enum class char ConstraintType enum class int CorrespondenceMode enum class DomainType enum class EarlyStoppingStrategy { RelativeDifference, ExponentialMovingAverage}strategies for early stopping enum ArrayTransferOptions { COPY_ARRAY, SHARE_ARRAY, MOVE_ARRAY}ways of tranferring Arrays to Python, copy being the least efficient but most conservative enum LandmarkColumns enum LandmarkVisibility enum class MessageType using std::map&lt; MeshWorkItem, MeshHandle &gt; CacheMap using std::list&lt; MeshWorkItem &gt; CacheList using std::shared_ptr&lt; Shape &gt; ShapeHandle using std::vector&lt; ShapeHandle &gt; ShapeList using std::shared_ptr&lt; StudioMesh &gt; MeshHandle using std::vector&lt; MeshHandle &gt; MeshList using itk::Index&lt; 3 &gt; Coord Simple names for common types used in the framework. using itk::Size&lt; 3 &gt; Dims using itk::Point&lt; double, 3 &gt; Point3 using itk::Vector&lt; double, 3 &gt; Vector3 using itk::Matrix&lt; double, 4, 4 &gt; Matrix44 using itk::Matrix&lt; double, 3, 3 &gt; Matrix33 using itk::Point&lt; int, 3 &gt; IPoint3 using itk::Point&lt; float, 3 &gt; FPoint3 using itk::CovariantVector&lt; float, 3 &gt; Covariant using Vector3 Vector using Point3 Point using Matrix33 Matrix using vtkSmartPointer&lt; vtkPlane &gt; Plane using vtkSmartPointer&lt; vtkDataArray &gt; Array using Array Field using std::vector&lt; Point3 &gt; PointArray using itk::Transform&lt; double, 3 &gt; GenericTransform All transforms can be accessed using a generic transform pointer. using itk::IdentityTransform&lt; double, 3 &gt; IdentityTransform using GenericTransform::Pointer TransformPtr using itk::AffineTransform&lt; double, 3 &gt; AffineTransform Affine transforms are used for many Image manipulation commands. using AffineTransform::Pointer AffineTransformPtr using vtkSmartPointer&lt; vtkTransform &gt; MeshTransform Mesh transforms. using float PixelType using itk::Image&lt; PixelType, 3 &gt; ImageType using itk::ThinPlateSplineKernelTransform2&lt; double, 3 &gt; ThinPlateSplineTransform Transforms that can be used for ReconstructSurface. using itk::CompactlySupportedRBFSparseKernelTransform&lt; double, 3 &gt; RBFSSparseTransform using std::shared_ptr&lt; Project &gt; ProjectHandle template &lt;typename T &gt; using Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; VnlMatrix typedef QSharedPointer&lt; Session &gt; SessionHandle using vtkSmartPointer&lt; vtkTransform &gt; TransformType TODO: replace this. typedef QSharedPointer&lt; Lightbox &gt; LightboxHandle typedef QSharedPointer&lt; Viewer &gt; ViewerHandle typedef QVector&lt; ViewerHandle &gt; ViewerList typedef QSharedPointer&lt; Visualizer &gt; VisualizerHandle"},{"location":"api/Namespaces/namespaceshapeworks.html#functions","title":"Functions","text":"Name COMMAND_DECLARE(ReadImage , ImageCommand ) COMMAND_DECLARE(WriteImage , ImageCommand ) COMMAND_DECLARE(ImageInfo , ImageCommand ) COMMAND_DECLARE(Antialias , ImageCommand ) COMMAND_DECLARE(ResampleImage , ImageCommand ) COMMAND_DECLARE(ResizeImage , ImageCommand ) COMMAND_DECLARE(RecenterImage , ImageCommand ) COMMAND_DECLARE(PadImage , ImageCommand ) COMMAND_DECLARE(TranslateImage , ImageCommand ) COMMAND_DECLARE(ScaleImage , ImageCommand ) COMMAND_DECLARE(Rotate , ImageCommand ) COMMAND_DECLARE(ExtractLabel , ImageCommand ) COMMAND_DECLARE(CloseHoles , ImageCommand ) COMMAND_DECLARE(Binarize , ImageCommand ) COMMAND_DECLARE(ComputeDT , ImageCommand ) COMMAND_DECLARE(CurvatureFilter , ImageCommand ) COMMAND_DECLARE(GradientFilter , ImageCommand ) COMMAND_DECLARE(SigmoidFilter , ImageCommand ) COMMAND_DECLARE(TPLevelSetFilter , ImageCommand ) COMMAND_DECLARE(TopologyPreservingFilter , ImageCommand ) COMMAND_DECLARE(IntensityFilter , ImageCommand ) COMMAND_DECLARE(Blur , ImageCommand ) COMMAND_DECLARE(BoundingBoxImage , ImageCommand ) COMMAND_DECLARE(ImageBounds , ImageCommand ) COMMAND_DECLARE(CropImage , ImageCommand ) COMMAND_DECLARE(ICPRigid , ImageCommand ) COMMAND_DECLARE(ClipImage , ImageCommand ) COMMAND_DECLARE(ReflectImage , ImageCommand ) COMMAND_DECLARE(SetOrigin , ImageCommand ) COMMAND_DECLARE(SetSpacing , ImageCommand ) COMMAND_DECLARE(WarpImage , ImageCommand ) COMMAND_DECLARE(CompareImage , ImageCommand ) COMMAND_DECLARE(NegateImage , ImageCommand ) COMMAND_DECLARE(AddImage , ImageCommand ) COMMAND_DECLARE(SubtractImage , ImageCommand ) COMMAND_DECLARE(MultiplyImage , ImageCommand ) COMMAND_DECLARE(DivideImage , ImageCommand ) COMMAND_DECLARE(ImageToMesh , ImageCommand ) COMMAND_DECLARE(SetRegion , ImageCommand ) COMMAND_DECLARE(Isolate , ImageCommand ) COMMAND_DECLARE(ReadParticleSystem , ParticleSystemCommand ) COMMAND_DECLARE(Compactness , ParticleSystemCommand ) COMMAND_DECLARE(Generalization , ParticleSystemCommand ) COMMAND_DECLARE(Specificity , ParticleSystemCommand ) COMMAND_DECLARE(ReadMesh , MeshCommand ) COMMAND_DECLARE(WriteMesh , MeshCommand ) COMMAND_DECLARE(MeshInfo , MeshCommand ) COMMAND_DECLARE(Coverage , MeshCommand ) COMMAND_DECLARE(Smooth , MeshCommand ) COMMAND_DECLARE(SmoothSinc , MeshCommand ) COMMAND_DECLARE(Remesh , MeshCommand ) COMMAND_DECLARE(RemeshPercent , MeshCommand ) COMMAND_DECLARE(InvertNormals , MeshCommand ) COMMAND_DECLARE(ReflectMesh , MeshCommand ) COMMAND_DECLARE(TransformMesh , MeshCommand ) COMMAND_DECLARE(FillHoles , MeshCommand ) COMMAND_DECLARE(ProbeVolume , MeshCommand ) COMMAND_DECLARE(ClipMesh , MeshCommand ) COMMAND_DECLARE(TranslateMesh , MeshCommand ) COMMAND_DECLARE(ScaleMesh , MeshCommand ) COMMAND_DECLARE(BoundingBoxMesh , MeshCommand ) COMMAND_DECLARE(MeshBounds , MeshCommand ) COMMAND_DECLARE(Distance , MeshCommand ) COMMAND_DECLARE(ComputeNormals , MeshCommand ) COMMAND_DECLARE(SetField , MeshCommand ) COMMAND_DECLARE(GetField , MeshCommand ) COMMAND_DECLARE(SetFieldValue , MeshCommand ) COMMAND_DECLARE(GetFieldValue , MeshCommand ) COMMAND_DECLARE(FieldRange , MeshCommand ) COMMAND_DECLARE(FieldMean , MeshCommand ) COMMAND_DECLARE(FieldStd , MeshCommand ) COMMAND_DECLARE(FieldNames , MeshCommand ) COMMAND_DECLARE(FixElement , MeshCommand ) COMMAND_DECLARE(MeshLargestComponent , MeshCommand ) COMMAND_DECLARE(ClipClosedSurface , MeshCommand ) COMMAND_DECLARE(ClosestPoint , MeshCommand ) COMMAND_DECLARE(GeodesicDistance , MeshCommand ) COMMAND_DECLARE(GeodesicDistanceToLandmark , MeshCommand ) COMMAND_DECLARE(MeanNormals , MeshCommand ) COMMAND_DECLARE(Curvature , MeshCommand ) COMMAND_DECLARE(MeshToImage , MeshCommand ) COMMAND_DECLARE(MeshToDT , MeshCommand ) COMMAND_DECLARE(CompareMesh , MeshCommand ) COMMAND_DECLARE(WarpMesh , MeshCommand ) COMMAND_DECLARE(ComputeThickness , MeshCommand ) COMMAND_DECLARE(LandmarkGeodesics , MeshCommand ) COMMAND_DECLARE(Seed , ShapeworksCommand ) COMMAND_DECLARE(OptimizeCommand , OptimizeCommandGroup ) COMMAND_DECLARE(GroomCommand , GroomCommandGroup ) COMMAND_DECLARE(AnalyzeCommand , AnalyzeCommandGroup ) COMMAND_DECLARE(ConvertProjectCommand , ProjectCommandGroup ) COMMAND_DECLARE(DeepSSMCommand , DeepSSMCommandGroup ) std::string display_mode_to_string(DisplayMode display_mode) DisplayMode string_to_display_mode(std::string str) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const IndexRegion &amp; region) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const PhysicalRegion &amp; region) Vector3 makeVector(std::array&lt; double, 3 &gt; &amp;&amp; arr)Enables <code>makeVector({1,2,3});</code>, construction using an initializer list (likely an accidental omission in current ITK version) PointArray makePointArray(int size, Point3 value) TransformPtr createTransform(const Matrix33 &amp; mat, const Vector3 &amp; translate =makeVector({0, 0, 0})) TransformPtr convert_to_image_transform(vtkSmartPointer&lt; vtkTransform &gt; vtk_transform)Convert VTK to ITK transform. Plane makePlane(const Point &amp; p, const Vector3 &amp; n)Make a plane. Plane makePlane(const Point &amp; p0, const Point &amp; p1, const Point &amp; p2) Point getOrigin(const Plane plane)Get origin and normal of plane. Vector3 getNormal(const Plane plane) MeshTransform createMeshTransform(const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat) Point toPoint(const Dims &amp; d)For deliberate conversions between types. Point toPoint(const Coord &amp; c) Vector toVector(const Dims &amp; d) Vector toVector(const Point &amp; p) Vector toVector(const itk::CovariantVector&lt; double, 3 &gt; &amp; v) Point toPoint(const Vector &amp; v) Coord toCoord(const Dims &amp; d) Dims toDims(const Coord &amp; c) Dims toDims(const Point &amp; p) Coord toCoord(const Point &amp; p) template &lt;typename P &gt; P negate(const P &amp; p)Negation operator (ITK only has it for Vectors, but sometimes useful for Points) Vector3 negate(const Vector3 &amp; v)Negate function for Vector (requires makeVector) template &lt;typename P &gt; P invertValue(const P &amp; p)Inversion function for all but Vector. Vector3 invertValue(const Vector3 &amp; v)Inversion function for Vector (requires makeVector) Vector3 dotProduct(const Vector3 &amp; a, const Vector3 &amp; b)Vector dot and cross products. Vector3 crossProduct(const Vector3 &amp; a, const Vector3 &amp; b) double length(const Vector3 &amp; v) Axis toAxis(const std::string &amp; str) std::string axisToString(Axis axis) bool axis_is_valid(const Vector3 &amp; axis)Ensure an axis is valid. bool axis_is_valid(const Axis &amp; axis) double degToRad(const double deg)convert degrees to radians double mean(const Field field)incrementally compute (single-component) mean of field double stddev(const Field field)compute (single-component) standard deviation of field std::vector&lt; double &gt; range(const Field field)compute (single-component) range of field template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value template &lt;typename T &gt; bool epsEqual(T a, T b, T epsilon) template &lt;typename P ,typename  =std::enable_if_t&lt;std::is_same::value bool epsEqual(double a, double b, double eps) template &lt;typename T &gt; T clamp(T value, T min, T max)Simple clamp operation until C++17. std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Image &amp; img)stream insertion operators for Image Image operator*(const Image &amp; img, const double x)override templates defined in [Shapeworks.h] Image operator/(const Image &amp; img, const double x) Image &amp; operator*=(Image &amp; img, const double x) Image &amp; operator/=(Image &amp; img, const double x) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Mesh &amp; mesh)stream insertion operators for Mesh itkEventMacro(ParticleDomainAddEvent , ParticleEvent ) itkEventMacro(ParticleTransformSetEvent , ParticleEvent ) itkEventMacro(ParticlePrefixTransformSetEvent , ParticleEvent ) itkEventMacro(ParticlePositionSetEvent , ParticleEvent ) itkEventMacro(ParticlePositionAddEvent , ParticleEvent ) itkEventMacro(ParticlePositionRemoveEvent , ParticleEvent ) void SaveReconstructions(std::vector&lt; Reconstruction &gt; &amp; reconstructions, const std::vector&lt; std::string &gt; &amp; srcPaths, const std::string &amp; saveTo) template &lt;typename T &gt; std::string variant_to_string(T begin, T end) void printNumpyArrayInfo(const py::array &amp; np_array)print buffer info for the given array (dims, format, strides, etc) void verifyOrderAndPacking(const py::array &amp; np_array)verify py::array has expected order and is densely packed, throw if not void setOwnership(py::array &amp; array, bool owns)sets the OWNDATA flag of the given array to <code>owns</code> Image::ImageType::Pointer wrapNumpyArr(py::array &amp; np_array)helper function for Image.init and Image.assign Array pyToArr(py::array &amp; np_array, bool take_ownership =true)converts py::array to vtkDataArray, optionally taking ownership of data py::array arrToPy(Array &amp; array, ArrayTransferOptions xfer =COPY_ARRAY)convert a vtkDataArray (AOS assumed) to a py::array using specified means of transfer Eigen::MatrixXd itkTransformToEigen(TransformPtr itk_xform) TransformPtr eigen44ToItkTransform(const Eigen::Matrix&lt; double, 4, 4 &gt; &amp; eigen_mat) Eigen::Matrix&lt; double, 4, 4, Eigen::RowMajor &gt; vtkTransformToEigen(MeshTransform vtk_xform) MeshTransform eigen44ToVtkTransform(const Eigen::Matrix&lt; double, 4, 4, Eigen::RowMajor &gt; &amp; eigen_mat) template &lt;typename T ,unsigned NRows,unsigned NCols&gt; Eigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; itkToEigen(const itk::Matrix&lt; T, NRows, NCols &gt; &amp; itk_mat)Conversion (by copy) of itk matrix to Eigen::Matrix. template &lt;typename T ,int NRows,int NCols&gt; itk::Matrix&lt; T, NRows, NCols &gt; eigenToItk(const Eigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; &amp; eigen_mat)Conversion (by copy) of Eigen::Matrix to itk (i.e., vnl) matrix. template &lt;typename T &gt; Eigen::Map&lt; VnlMatrix&lt; T &gt; &gt; vnlToEigen(const vnl_matrix&lt; T &gt; &amp; vnl_mat)Wrap vnl matrix data to Eigen Matrix. template &lt;int NRows,int NCols,typename T &gt; Eigen::Map&lt; Eigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; &gt; wrapDataWithEigen(T * data) template &lt;typename T &gt; Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt; wrapDataWithEigen(T * data, size_t nrows, size_t ncols)Wrap a data pointer of the specified size with Eigen::Matrix. template &lt;unsigned NRows,unsigned NCols,typename T &gt; itk::Matrix&lt; T, NRows, NCols &gt; wrapDataWithItk(T * data)"},{"location":"api/Namespaces/namespaceshapeworks.html#attributes","title":"Attributes","text":"Name const auto Pi pi that doesn't depend on deprecated or non-std lib defines"},{"location":"api/Namespaces/namespaceshapeworks.html#detailed-description","title":"Detailed Description","text":"<p>User usage reporting (telemetry) </p> <p>This class posts anonymous usage reporting statistics for usage tracking and software improvement purposes </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks.html#enum-displaymode","title":"enum DisplayMode","text":"Enumerator Value Description Original 0 Groomed 1 Reconstructed 2"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-axis","title":"enum Axis","text":"Enumerator Value Description invalid -1 X Y Z <p>handy way to specify an axis </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-constrainttype","title":"enum ConstraintType","text":"Enumerator Value Description CuttingPlane 'C' FreeForm 'F'"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-correspondencemode","title":"enum CorrespondenceMode","text":"Enumerator Value Description MeanEnergy 0 EnsembleEntropy 1 EnsembleRegressionEntropy 3 EnsembleMixedEffectsEntropy 4 MeshBasedGeneralEntropy 5 MeshBasedGeneralMeanEnergy 6 DisentagledEnsembleEntropy 7 DisentangledEnsembleMeanEnergy 8"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-domaintype","title":"enum DomainType","text":"Enumerator Value Description Image Mesh Contour"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-earlystoppingstrategy","title":"enum EarlyStoppingStrategy","text":"Enumerator Value Description RelativeDifference stop when relative improvement falls below a threshold ExponentialMovingAverage stop using EMA of improvements to detect convergence <p>strategies for early stopping </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-arraytransferoptions","title":"enum ArrayTransferOptions","text":"Enumerator Value Description COPY_ARRAY SHARE_ARRAY MOVE_ARRAY <p>ways of tranferring Arrays to Python, copy being the least efficient but most conservative </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-landmarkcolumns","title":"enum LandmarkColumns","text":"Enumerator Value Description VISIBLE_E COLOR_E NAME_E POSITION_E SET_BUTTON_E COMMENT_E END_E"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-landmarkvisibility","title":"enum LandmarkVisibility","text":"Enumerator Value Description ALL_VISIBLE_E NONE_VISIBLE_E SOME_VISIBLE_E"},{"location":"api/Namespaces/namespaceshapeworks.html#enum-messagetype","title":"enum MessageType","text":"Enumerator Value Description normal warning error debug"},{"location":"api/Namespaces/namespaceshapeworks.html#using-cachemap","title":"using CacheMap","text":"<pre><code>using shapeworks::CacheMap = typedef std::map&lt;MeshWorkItem, MeshHandle&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-cachelist","title":"using CacheList","text":"<pre><code>using shapeworks::CacheList = typedef std::list&lt;MeshWorkItem&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-shapehandle","title":"using ShapeHandle","text":"<pre><code>using shapeworks::ShapeHandle = typedef std::shared_ptr&lt;Shape&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-shapelist","title":"using ShapeList","text":"<pre><code>using shapeworks::ShapeList = typedef std::vector&lt;ShapeHandle&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-meshhandle","title":"using MeshHandle","text":"<pre><code>using shapeworks::MeshHandle = typedef std::shared_ptr&lt;StudioMesh&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-meshlist","title":"using MeshList","text":"<pre><code>using shapeworks::MeshList = typedef std::vector&lt;MeshHandle&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-coord","title":"using Coord","text":"<pre><code>using shapeworks::Coord = typedef itk::Index&lt;3&gt;;\n</code></pre> <p>Simple names for common types used in the framework. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-dims","title":"using Dims","text":"<pre><code>using shapeworks::Dims = typedef itk::Size&lt;3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-point3","title":"using Point3","text":"<pre><code>using shapeworks::Point3 = typedef itk::Point&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-vector3","title":"using Vector3","text":"<pre><code>using shapeworks::Vector3 = typedef itk::Vector&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-matrix44","title":"using Matrix44","text":"<pre><code>using shapeworks::Matrix44 = typedef itk::Matrix&lt;double, 4, 4&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-matrix33","title":"using Matrix33","text":"<pre><code>using shapeworks::Matrix33 = typedef itk::Matrix&lt;double, 3, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-ipoint3","title":"using IPoint3","text":"<pre><code>using shapeworks::IPoint3 = typedef itk::Point&lt;int, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-fpoint3","title":"using FPoint3","text":"<pre><code>using shapeworks::FPoint3 = typedef itk::Point&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-covariant","title":"using Covariant","text":"<pre><code>using shapeworks::Covariant = typedef itk::CovariantVector&lt;float, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-vector","title":"using Vector","text":"<pre><code>using shapeworks::Vector = typedef Vector3;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-point","title":"using Point","text":"<pre><code>using shapeworks::Point = typedef Point3;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-matrix","title":"using Matrix","text":"<pre><code>using shapeworks::Matrix = typedef Matrix33;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-plane","title":"using Plane","text":"<pre><code>using shapeworks::Plane = typedef vtkSmartPointer&lt;vtkPlane&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-array","title":"using Array","text":"<pre><code>using shapeworks::Array = typedef vtkSmartPointer&lt;vtkDataArray&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-field","title":"using Field","text":"<pre><code>using shapeworks::Field = typedef Array;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-pointarray","title":"using PointArray","text":"<pre><code>using shapeworks::PointArray = typedef std::vector&lt;Point3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-generictransform","title":"using GenericTransform","text":"<pre><code>using shapeworks::GenericTransform = typedef itk::Transform&lt;double, 3&gt;;\n</code></pre> <p>All transforms can be accessed using a generic transform pointer. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-identitytransform","title":"using IdentityTransform","text":"<pre><code>using shapeworks::IdentityTransform = typedef itk::IdentityTransform&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-transformptr","title":"using TransformPtr","text":"<pre><code>using shapeworks::TransformPtr = typedef GenericTransform::Pointer;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-affinetransform","title":"using AffineTransform","text":"<pre><code>using shapeworks::AffineTransform = typedef itk::AffineTransform&lt;double, 3&gt;;\n</code></pre> <p>Affine transforms are used for many Image manipulation commands. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-affinetransformptr","title":"using AffineTransformPtr","text":"<pre><code>using shapeworks::AffineTransformPtr = typedef AffineTransform::Pointer;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-meshtransform","title":"using MeshTransform","text":"<pre><code>using shapeworks::MeshTransform = typedef vtkSmartPointer&lt;vtkTransform&gt;;\n</code></pre> <p>Mesh transforms. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-pixeltype","title":"using PixelType","text":"<pre><code>using shapeworks::PixelType = typedef float;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-imagetype","title":"using ImageType","text":"<pre><code>using shapeworks::ImageType = typedef itk::Image&lt;PixelType, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-thinplatesplinetransform","title":"using ThinPlateSplineTransform","text":"<pre><code>using shapeworks::ThinPlateSplineTransform = typedef itk::ThinPlateSplineKernelTransform2&lt;double, 3&gt;;\n</code></pre> <p>Transforms that can be used for ReconstructSurface. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-rbfssparsetransform","title":"using RBFSSparseTransform","text":"<pre><code>using shapeworks::RBFSSparseTransform = typedef itk::CompactlySupportedRBFSparseKernelTransform&lt;double, 3&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-projecthandle","title":"using ProjectHandle","text":"<pre><code>using shapeworks::ProjectHandle = typedef std::shared_ptr&lt;Project&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-vnlmatrix","title":"using VnlMatrix","text":"<pre><code>template &lt;typename T &gt;\nusing shapeworks::VnlMatrix = typedef Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#typedef-sessionhandle","title":"typedef SessionHandle","text":"<pre><code>typedef QSharedPointer&lt;Session&gt; shapeworks::SessionHandle;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#using-transformtype","title":"using TransformType","text":"<pre><code>using shapeworks::TransformType = typedef vtkSmartPointer&lt;vtkTransform&gt;;\n</code></pre> <p>TODO: replace this. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#typedef-lightboxhandle","title":"typedef LightboxHandle","text":"<pre><code>typedef QSharedPointer&lt;Lightbox&gt; shapeworks::LightboxHandle;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#typedef-viewerhandle","title":"typedef ViewerHandle","text":"<pre><code>typedef QSharedPointer&lt;Viewer&gt; shapeworks::ViewerHandle;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#typedef-viewerlist","title":"typedef ViewerList","text":"<pre><code>typedef QVector&lt;ViewerHandle&gt; shapeworks::ViewerList;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#typedef-visualizerhandle","title":"typedef VisualizerHandle","text":"<pre><code>typedef QSharedPointer&lt;Visualizer&gt; shapeworks::VisualizerHandle;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ReadImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_1","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    WriteImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_2","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ImageInfo ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_3","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Antialias ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_4","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ResampleImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_5","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ResizeImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_6","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    RecenterImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_7","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    PadImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_8","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    TranslateImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_9","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ScaleImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_10","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Rotate ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_11","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ExtractLabel ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_12","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    CloseHoles ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_13","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Binarize ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_14","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ComputeDT ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_15","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    CurvatureFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_16","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GradientFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_17","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SigmoidFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_18","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    TPLevelSetFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_19","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    TopologyPreservingFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_20","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    IntensityFilter ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_21","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Blur ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_22","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    BoundingBoxImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_23","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ImageBounds ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_24","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    CropImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_25","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ICPRigid ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_26","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ClipImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_27","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ReflectImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_28","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SetOrigin ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_29","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SetSpacing ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_30","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    WarpImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_31","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    CompareImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_32","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    NegateImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_33","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    AddImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_34","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SubtractImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_35","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MultiplyImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_36","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    DivideImage ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_37","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ImageToMesh ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_38","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SetRegion ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_39","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Isolate ,\n    ImageCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_40","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ReadParticleSystem ,\n    ParticleSystemCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_41","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Compactness ,\n    ParticleSystemCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_42","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Generalization ,\n    ParticleSystemCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_43","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Specificity ,\n    ParticleSystemCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_44","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ReadMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_45","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    WriteMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_46","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeshInfo ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_47","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Coverage ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_48","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Smooth ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_49","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SmoothSinc ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_50","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Remesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_51","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    RemeshPercent ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_52","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    InvertNormals ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_53","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ReflectMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_54","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    TransformMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_55","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FillHoles ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_56","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ProbeVolume ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_57","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ClipMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_58","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    TranslateMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_59","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ScaleMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_60","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    BoundingBoxMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_61","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeshBounds ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_62","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Distance ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_63","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ComputeNormals ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_64","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SetField ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_65","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GetField ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_66","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    SetFieldValue ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_67","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GetFieldValue ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_68","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FieldRange ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_69","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FieldMean ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_70","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FieldStd ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_71","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FieldNames ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_72","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    FixElement ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_73","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeshLargestComponent ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_74","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ClipClosedSurface ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_75","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ClosestPoint ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_76","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GeodesicDistance ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_77","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GeodesicDistanceToLandmark ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_78","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeanNormals ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_79","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Curvature ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_80","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeshToImage ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_81","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    MeshToDT ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_82","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    CompareMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_83","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    WarpMesh ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_84","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ComputeThickness ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_85","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    LandmarkGeodesics ,\n    MeshCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_86","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    Seed ,\n    ShapeworksCommand \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_87","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    OptimizeCommand ,\n    OptimizeCommandGroup \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_88","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    GroomCommand ,\n    GroomCommandGroup \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_89","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    AnalyzeCommand ,\n    AnalyzeCommandGroup \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_90","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    ConvertProjectCommand ,\n    ProjectCommandGroup \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-command_declare_91","title":"function COMMAND_DECLARE","text":"<pre><code>COMMAND_DECLARE(\n    DeepSSMCommand ,\n    DeepSSMCommandGroup \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-display_mode_to_string","title":"function display_mode_to_string","text":"<pre><code>std::string display_mode_to_string(\n    DisplayMode display_mode\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-string_to_display_mode","title":"function string_to_display_mode","text":"<pre><code>DisplayMode string_to_display_mode(\n    std::string str\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const IndexRegion &amp; region\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const PhysicalRegion &amp; region\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-makevector","title":"function makeVector","text":"<pre><code>Vector3 makeVector(\n    std::array&lt; double, 3 &gt; &amp;&amp; arr\n)\n</code></pre> <p>Enables <code>makeVector({1,2,3});</code>, construction using an initializer list (likely an accidental omission in current ITK version) </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-makepointarray","title":"function makePointArray","text":"<pre><code>PointArray makePointArray(\n    int size,\n    Point3 value\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-createtransform","title":"function createTransform","text":"<pre><code>TransformPtr createTransform(\n    const Matrix33 &amp; mat,\n    const Vector3 &amp; translate =makeVector({0, 0, 0})\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-convert_to_image_transform","title":"function convert_to_image_transform","text":"<pre><code>TransformPtr convert_to_image_transform(\n    vtkSmartPointer&lt; vtkTransform &gt; vtk_transform\n)\n</code></pre> <p>Convert VTK to ITK transform. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-makeplane","title":"function makePlane","text":"<pre><code>Plane makePlane(\n    const Point &amp; p,\n    const Vector3 &amp; n\n)\n</code></pre> <p>Make a plane. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-makeplane_1","title":"function makePlane","text":"<pre><code>Plane makePlane(\n    const Point &amp; p0,\n    const Point &amp; p1,\n    const Point &amp; p2\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-getorigin","title":"function getOrigin","text":"<pre><code>Point getOrigin(\n    const Plane plane\n)\n</code></pre> <p>Get origin and normal of plane. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-getnormal","title":"function getNormal","text":"<pre><code>Vector3 getNormal(\n    const Plane plane\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-createmeshtransform","title":"function createMeshTransform","text":"<pre><code>MeshTransform createMeshTransform(\n    const vtkSmartPointer&lt; vtkMatrix4x4 &gt; &amp; mat\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-topoint","title":"function toPoint","text":"<pre><code>Point toPoint(\n    const Dims &amp; d\n)\n</code></pre> <p>For deliberate conversions between types. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-topoint_1","title":"function toPoint","text":"<pre><code>Point toPoint(\n    const Coord &amp; c\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-tovector","title":"function toVector","text":"<pre><code>Vector toVector(\n    const Dims &amp; d\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-tovector_1","title":"function toVector","text":"<pre><code>Vector toVector(\n    const Point &amp; p\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-tovector_2","title":"function toVector","text":"<pre><code>Vector toVector(\n    const itk::CovariantVector&lt; double, 3 &gt; &amp; v\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-topoint_2","title":"function toPoint","text":"<pre><code>Point toPoint(\n    const Vector &amp; v\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-tocoord","title":"function toCoord","text":"<pre><code>Coord toCoord(\n    const Dims &amp; d\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-todims","title":"function toDims","text":"<pre><code>Dims toDims(\n    const Coord &amp; c\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-todims_1","title":"function toDims","text":"<pre><code>Dims toDims(\n    const Point &amp; p\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-tocoord_1","title":"function toCoord","text":"<pre><code>Coord toCoord(\n    const Point &amp; p\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-negate","title":"function negate","text":"<pre><code>template &lt;typename P &gt;\nP negate(\n    const P &amp; p\n)\n</code></pre> <p>Negation operator (ITK only has it for Vectors, but sometimes useful for Points) </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-negate_1","title":"function negate","text":"<pre><code>Vector3 negate(\n    const Vector3 &amp; v\n)\n</code></pre> <p>Negate function for Vector (requires makeVector) </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-invertvalue","title":"function invertValue","text":"<pre><code>template &lt;typename P &gt;\nP invertValue(\n    const P &amp; p\n)\n</code></pre> <p>Inversion function for all but Vector. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-invertvalue_1","title":"function invertValue","text":"<pre><code>Vector3 invertValue(\n    const Vector3 &amp; v\n)\n</code></pre> <p>Inversion function for Vector (requires makeVector) </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-dotproduct","title":"function dotProduct","text":"<pre><code>Vector3 dotProduct(\n    const Vector3 &amp; a,\n    const Vector3 &amp; b\n)\n</code></pre> <p>Vector dot and cross products. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-crossproduct","title":"function crossProduct","text":"<pre><code>Vector3 crossProduct(\n    const Vector3 &amp; a,\n    const Vector3 &amp; b\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-length","title":"function length","text":"<pre><code>double length(\n    const Vector3 &amp; v\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-toaxis","title":"function toAxis","text":"<pre><code>Axis toAxis(\n    const std::string &amp; str\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-axistostring","title":"function axisToString","text":"<pre><code>std::string axisToString(\n    Axis axis\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-axis_is_valid","title":"function axis_is_valid","text":"<pre><code>bool axis_is_valid(\n    const Vector3 &amp; axis\n)\n</code></pre> <p>Ensure an axis is valid. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-axis_is_valid_1","title":"function axis_is_valid","text":"<pre><code>bool axis_is_valid(\n    const Axis &amp; axis\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-degtorad","title":"function degToRad","text":"<pre><code>double degToRad(\n    const double deg\n)\n</code></pre> <p>convert degrees to radians </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-mean","title":"function mean","text":"<pre><code>double mean(\n    const Field field\n)\n</code></pre> <p>incrementally compute (single-component) mean of field </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-stddev","title":"function stddev","text":"<pre><code>double stddev(\n    const Field field\n)\n</code></pre> <p>compute (single-component) standard deviation of field </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-range","title":"function range","text":"<pre><code>std::vector&lt; double &gt; range(\n    const Field field\n)\n</code></pre> <p>compute (single-component) range of field </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_2","title":"function operator+","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator+(\n    const P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator-(\n    const P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_3","title":"function operator*","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Vector, P&gt;::value ||                                                  std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator*(\n    const P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_4","title":"function operator/","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Vector, P&gt;::value ||                                                  std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator/(\n    const P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_5","title":"function operator+=","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP &amp; operator+=(\n    P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator-_1","title":"function operator-=","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP &amp; operator-=(\n    P &amp; p,\n    const P &amp; q\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_6","title":"function operator*","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator*(\n    const P &amp; p,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_7","title":"function operator/","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP operator/(\n    const P &amp; p,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_8","title":"function operator*=","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP &amp; operator*=(\n    P &amp; p,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_9","title":"function operator/=","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nP &amp; operator/=(\n    P &amp; p,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-epsequal","title":"function epsEqual","text":"<pre><code>template &lt;typename T &gt;\nbool epsEqual(\n    T a,\n    T b,\n    T epsilon\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-epsequal_1","title":"function epsEqual","text":"<pre><code>template &lt;typename P ,\ntypename  =std::enable_if_t&lt;std::is_same&lt;Image, P&gt;::value ||                                                 std::is_same&lt;Coord, P&gt;::value ||                                                 std::is_same&lt;Dims, P&gt;::value ||                                                 std::is_same&lt;Vector, P&gt;::value ||                                                 std::is_same&lt;Point, P&gt;::value ||                                                 std::is_same&lt;IPoint3, P&gt;::value ||                                                 std::is_same&lt;FPoint3, P&gt;::value&gt;&gt;\nbool epsEqual(\n    const P &amp; a,\n    const P &amp; b,\n    const typename P::ValueType &amp; eps\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-epsequal_2","title":"function epsEqual","text":"<pre><code>bool epsEqual(\n    double a,\n    double b,\n    double eps\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-clamp","title":"function clamp","text":"<pre><code>template &lt;typename T &gt;\nT clamp(\n    T value,\n    T min,\n    T max\n)\n</code></pre> <p>Simple clamp operation until C++17. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_10","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Image &amp; img\n)\n</code></pre> <p>stream insertion operators for Image</p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_11","title":"function operator*","text":"<pre><code>Image operator*(\n    const Image &amp; img,\n    const double x\n)\n</code></pre> <p>override templates defined in [Shapeworks.h]</p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_12","title":"function operator/","text":"<pre><code>Image operator/(\n    const Image &amp; img,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_13","title":"function operator*=","text":"<pre><code>Image &amp; operator*=(\n    Image &amp; img,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_14","title":"function operator/=","text":"<pre><code>Image &amp; operator/=(\n    Image &amp; img,\n    const double x\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-operator_15","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Mesh &amp; mesh\n)\n</code></pre> <p>stream insertion operators for Mesh</p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticleDomainAddEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro_1","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticleTransformSetEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro_2","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticlePrefixTransformSetEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro_3","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticlePositionSetEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro_4","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticlePositionAddEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itkeventmacro_5","title":"function itkEventMacro","text":"<pre><code>itkEventMacro(\n    ParticlePositionRemoveEvent ,\n    ParticleEvent \n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-savereconstructions","title":"function SaveReconstructions","text":"<pre><code>void SaveReconstructions(\n    std::vector&lt; Reconstruction &gt; &amp; reconstructions,\n    const std::vector&lt; std::string &gt; &amp; srcPaths,\n    const std::string &amp; saveTo\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-variant_to_string","title":"function variant_to_string","text":"<pre><code>template &lt;typename T &gt;\nstd::string variant_to_string(\n    T begin,\n    T end\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-printnumpyarrayinfo","title":"function printNumpyArrayInfo","text":"<pre><code>void printNumpyArrayInfo(\n    const py::array &amp; np_array\n)\n</code></pre> <p>print buffer info for the given array (dims, format, strides, etc) </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-verifyorderandpacking","title":"function verifyOrderAndPacking","text":"<pre><code>void verifyOrderAndPacking(\n    const py::array &amp; np_array\n)\n</code></pre> <p>verify py::array has expected order and is densely packed, throw if not </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-setownership","title":"function setOwnership","text":"<pre><code>void setOwnership(\n    py::array &amp; array,\n    bool owns\n)\n</code></pre> <p>sets the OWNDATA flag of the given array to <code>owns</code></p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-wrapnumpyarr","title":"function wrapNumpyArr","text":"<pre><code>Image::ImageType::Pointer wrapNumpyArr(\n    py::array &amp; np_array\n)\n</code></pre> <p>helper function for Image.init and Image.assign </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-pytoarr","title":"function pyToArr","text":"<pre><code>Array pyToArr(\n    py::array &amp; np_array,\n    bool take_ownership =true\n)\n</code></pre> <p>converts py::array to vtkDataArray, optionally taking ownership of data </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-arrtopy","title":"function arrToPy","text":"<pre><code>py::array arrToPy(\n    Array &amp; array,\n    ArrayTransferOptions xfer =COPY_ARRAY\n)\n</code></pre> <p>convert a vtkDataArray (AOS assumed) to a py::array using specified means of transfer </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itktransformtoeigen","title":"function itkTransformToEigen","text":"<pre><code>Eigen::MatrixXd itkTransformToEigen(\n    TransformPtr itk_xform\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-eigen44toitktransform","title":"function eigen44ToItkTransform","text":"<pre><code>TransformPtr eigen44ToItkTransform(\n    const Eigen::Matrix&lt; double, 4, 4 &gt; &amp; eigen_mat\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-vtktransformtoeigen","title":"function vtkTransformToEigen","text":"<pre><code>Eigen::Matrix&lt; double, 4, 4, Eigen::RowMajor &gt; vtkTransformToEigen(\n    MeshTransform vtk_xform\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-eigen44tovtktransform","title":"function eigen44ToVtkTransform","text":"<pre><code>MeshTransform eigen44ToVtkTransform(\n    const Eigen::Matrix&lt; double, 4, 4, Eigen::RowMajor &gt; &amp; eigen_mat\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-itktoeigen","title":"function itkToEigen","text":"<pre><code>template &lt;typename T ,\nunsigned NRows,\nunsigned NCols&gt;\nEigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; itkToEigen(\n    const itk::Matrix&lt; T, NRows, NCols &gt; &amp; itk_mat\n)\n</code></pre> <p>Conversion (by copy) of itk matrix to Eigen::Matrix. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-eigentoitk","title":"function eigenToItk","text":"<pre><code>template &lt;typename T ,\nint NRows,\nint NCols&gt;\nitk::Matrix&lt; T, NRows, NCols &gt; eigenToItk(\n    const Eigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; &amp; eigen_mat\n)\n</code></pre> <p>Conversion (by copy) of Eigen::Matrix to itk (i.e., vnl) matrix. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-vnltoeigen","title":"function vnlToEigen","text":"<pre><code>template &lt;typename T &gt;\nEigen::Map&lt; VnlMatrix&lt; T &gt; &gt; vnlToEigen(\n    const vnl_matrix&lt; T &gt; &amp; vnl_mat\n)\n</code></pre> <p>Wrap vnl matrix data to Eigen Matrix. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-wrapdatawitheigen","title":"function wrapDataWithEigen","text":"<pre><code>template &lt;int NRows,\nint NCols,\ntypename T &gt;\nEigen::Map&lt; Eigen::Matrix&lt; T, NRows, NCols, Eigen::RowMajor &gt; &gt; wrapDataWithEigen(\n    T * data\n)\n</code></pre> <p>Wrap data pointer with Eigen::Matrix. Handy for efficiently going back and forth between Python numpy arrays. WARNING: if data goes out of scope (e.g., numpy array size changes), matrix will point to invalid location. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-wrapdatawitheigen_1","title":"function wrapDataWithEigen","text":"<pre><code>template &lt;typename T &gt;\nEigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt; wrapDataWithEigen(\n    T * data,\n    size_t nrows,\n    size_t ncols\n)\n</code></pre> <p>Wrap a data pointer of the specified size with Eigen::Matrix. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#function-wrapdatawithitk","title":"function wrapDataWithItk","text":"<pre><code>template &lt;unsigned NRows,\nunsigned NCols,\ntypename T &gt;\nitk::Matrix&lt; T, NRows, NCols &gt; wrapDataWithItk(\n    T * data\n)\n</code></pre> <p>Wrap data pointer with itk::Matrix. Handy for efficiently going back and forth between Python numpy arrays. WARNING: This function actually just copies data. </p>"},{"location":"api/Namespaces/namespaceshapeworks.html#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks.html#variable-pi","title":"variable Pi","text":"<pre><code>const auto Pi = std::atan(1.0) * 4.0;\n</code></pre> <p>pi that doesn't depend on deprecated or non-std lib defines </p> <p>Updated on 2026-01-14 at 21:44:20 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html","title":"shapeworks::mesh","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html#functions","title":"Functions","text":"Name void compute_thickness(Mesh &amp; mesh, Image &amp; image, Image * dt, double max_dist, double median_radius, std::string distance_mesh)Compute the cortical thickness of a mesh and image (e.g. CT) Mesh compute_inner_mesh(const Mesh &amp; mesh, std::string array_name)Compute an internal mesh based on the thickness values. void summarize_internal_intensities(Mesh &amp; outer_mesh, Mesh &amp; inner_mesh, Image &amp; image)Summarize the internal intensities values of the area inside the inner mesh on the outer mesh."},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html#function-compute_thickness","title":"function compute_thickness","text":"<pre><code>void compute_thickness(\n    Mesh &amp; mesh,\n    Image &amp; image,\n    Image * dt,\n    double max_dist,\n    double median_radius,\n    std::string distance_mesh\n)\n</code></pre> <p>Compute the cortical thickness of a mesh and image (e.g. CT) </p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html#function-compute_inner_mesh","title":"function compute_inner_mesh","text":"<pre><code>Mesh compute_inner_mesh(\n    const Mesh &amp; mesh,\n    std::string array_name\n)\n</code></pre> <p>Compute an internal mesh based on the thickness values. </p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1mesh.html#function-summarize_internal_intensities","title":"function summarize_internal_intensities","text":"<pre><code>void summarize_internal_intensities(\n    Mesh &amp; outer_mesh,\n    Mesh &amp; inner_mesh,\n    Image &amp; image\n)\n</code></pre> <p>Summarize the internal intensities values of the area inside the inner mesh on the outer mesh. </p> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html","title":"shapeworks::particles","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#functions","title":"Functions","text":"Name Eigen::VectorXd read_particles(std::string filename) std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; read_particles_as_vector(std::string filename) void write_particles(std::string filename, const Eigen::VectorXd &amp; points) void write_particles_from_vector(std::string filename, std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points)"},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#functions-documentation","title":"Functions Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#function-read_particles","title":"function read_particles","text":"<pre><code>Eigen::VectorXd read_particles(\n    std::string filename\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#function-read_particles_as_vector","title":"function read_particles_as_vector","text":"<pre><code>std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; read_particles_as_vector(\n    std::string filename\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#function-write_particles","title":"function write_particles","text":"<pre><code>void write_particles(\n    std::string filename,\n    const Eigen::VectorXd &amp; points\n)\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1particles.html#function-write_particles_from_vector","title":"function write_particles_from_vector","text":"<pre><code>void write_particles_from_vector(\n    std::string filename,\n    std::vector&lt; itk::Point&lt; double, 3 &gt; &gt; points\n)\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project.html","title":"shapeworks::project","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1project.html#namespaces","title":"Namespaces","text":"Name shapeworks::project::prefixes shapeworks::project::types <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html","title":"shapeworks::project::prefixes","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#attributes","title":"Attributes","text":"Name constexpr const char * SEGMENTATION_PREFIX constexpr const char * LANDMARKS_FILE_PREFIX constexpr const char * SHAPE_PREFIX constexpr const char * MESH_PREFIX constexpr const char * CONTOUR_PREFIX constexpr const char * GROOMED_PREFIX constexpr const char * GROOMED_CONTOUR_PREFIX constexpr const char * CONSTRAINTS_PREFIX constexpr const char * GROOMED_TRANSFORMS_PREFIX constexpr const char * PROCRUSTES_TRANSFORMS_PREFIX constexpr const char * IMAGE_PREFIX constexpr const char * FEATURE_PREFIX constexpr const char * GROUP_PREFIX constexpr const char * LOCAL_PARTICLES constexpr const char * WORLD_PARTICLES constexpr const char * LOCAL_PARTICLES_PREFIX constexpr const char * WORLD_PARTICLES_PREFIX"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-segmentation_prefix","title":"variable SEGMENTATION_PREFIX","text":"<pre><code>static constexpr const char * SEGMENTATION_PREFIX = \"segmentation_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-landmarks_file_prefix","title":"variable LANDMARKS_FILE_PREFIX","text":"<pre><code>static constexpr const char * LANDMARKS_FILE_PREFIX = \"landmarks_file_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-shape_prefix","title":"variable SHAPE_PREFIX","text":"<pre><code>static constexpr const char * SHAPE_PREFIX = \"shape_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-mesh_prefix","title":"variable MESH_PREFIX","text":"<pre><code>static constexpr const char * MESH_PREFIX = \"mesh_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-contour_prefix","title":"variable CONTOUR_PREFIX","text":"<pre><code>static constexpr const char * CONTOUR_PREFIX = \"contour_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-groomed_prefix","title":"variable GROOMED_PREFIX","text":"<pre><code>static constexpr const char * GROOMED_PREFIX = \"groomed_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-groomed_contour_prefix","title":"variable GROOMED_CONTOUR_PREFIX","text":"<pre><code>static constexpr const char * GROOMED_CONTOUR_PREFIX = \"groomed_contour_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-constraints_prefix","title":"variable CONSTRAINTS_PREFIX","text":"<pre><code>static constexpr const char * CONSTRAINTS_PREFIX = \"constraints_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-groomed_transforms_prefix","title":"variable GROOMED_TRANSFORMS_PREFIX","text":"<pre><code>static constexpr const char * GROOMED_TRANSFORMS_PREFIX = \"alignment_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-procrustes_transforms_prefix","title":"variable PROCRUSTES_TRANSFORMS_PREFIX","text":"<pre><code>static constexpr const char * PROCRUSTES_TRANSFORMS_PREFIX = \"procrustes_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-image_prefix","title":"variable IMAGE_PREFIX","text":"<pre><code>static constexpr const char * IMAGE_PREFIX = \"image_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-feature_prefix","title":"variable FEATURE_PREFIX","text":"<pre><code>static constexpr const char * FEATURE_PREFIX = \"feature_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-group_prefix","title":"variable GROUP_PREFIX","text":"<pre><code>static constexpr const char * GROUP_PREFIX = \"group_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-local_particles","title":"variable LOCAL_PARTICLES","text":"<pre><code>static constexpr const char * LOCAL_PARTICLES = \"local_particles\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-world_particles","title":"variable WORLD_PARTICLES","text":"<pre><code>static constexpr const char * WORLD_PARTICLES = \"world_particles\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-local_particles_prefix","title":"variable LOCAL_PARTICLES_PREFIX","text":"<pre><code>static constexpr const char * LOCAL_PARTICLES_PREFIX = \"local_particles_\";\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1prefixes.html#variable-world_particles_prefix","title":"variable WORLD_PARTICLES_PREFIX","text":"<pre><code>static constexpr const char * WORLD_PARTICLES_PREFIX = \"world_particles_\";\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html","title":"shapeworks::project::types","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#types","title":"Types","text":"Name using tsl::ordered_map&lt; std::string, std::string &gt; StringMap using std::vector&lt; std::string &gt; StringList using std::vector&lt; StringMap &gt; StringMapList using std::map&lt; std::string, StringMap &gt; StringMultiMap"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#types-documentation","title":"Types Documentation","text":""},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#using-stringmap","title":"using StringMap","text":"<pre><code>using shapeworks::project::types::StringMap = typedef tsl::ordered_map&lt;std::string, std::string&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#using-stringlist","title":"using StringList","text":"<pre><code>using shapeworks::project::types::StringList = typedef std::vector&lt;std::string&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#using-stringmaplist","title":"using StringMapList","text":"<pre><code>using shapeworks::project::types::StringMapList = typedef std::vector&lt;StringMap&gt;;\n</code></pre>"},{"location":"api/Namespaces/namespaceshapeworks_1_1project_1_1types.html#using-stringmultimap","title":"using StringMultiMap","text":"<pre><code>using shapeworks::project::types::StringMultiMap = typedef std::map&lt;std::string, StringMap&gt;;\n</code></pre> <p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespacestd.html","title":"std","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"api/Namespaces/namespaceutils.html","title":"utils","text":"<p>Updated on 2026-01-14 at 21:44:21 +0000</p>"},{"location":"cloud/cloud-analyze-module.html","title":"ShapeWorks Cloud Analyze Module","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p>The analyze module can be viewed after a successful optimization job. There are three panels in the analyze module, View PCA, Charts, Shape Viewer.</p> <p></p>"},{"location":"cloud/cloud-analyze-module.html#view-pca","title":"View PCA","text":"<p>The View PCA panel shows reconstructed shapes (surface meshes) along PCA modes of variation. Modes of variations are shape parameters learned/discovered from your data that describes shape variations. You can control the location along the PCA mode with the Standard Deviation slider and/or the animate option.</p> <p>The animate option allows for an automatic adjustment of the Standard Deviation slider within a mode of variation. Upon selecting the animate option, the comparison vectors and colormap for each shape in the mode will be calculated. This will only occur the first time that the option is selected for a given mode.</p> <p>Values displayed:</p> <p><code>Lambda</code> - This shows the PCA loading of current position of the slider.  The middle of the slider, at the mean value, will be 0.  The extent of lambda is defined by the number of standard deviations of the slider as described above.  At standard deviation of 1.0, it will be the square root of the mode's eigenvalue.</p> <p><code>Eigenvalue</code> - This shows the eigenvalue of the currently selected mode.  This is a unitless measure of how much variance is explained by this mode.  The modes are sorted in decreasing order of eigenvalue, corresponding to the most variance explained first.</p>"},{"location":"cloud/cloud-analyze-module.html#group-difference","title":"Group Difference","text":"<p>The Group Difference mode allows for group comparison to quantify and visualize population-level differences. Each <code>group_&lt;value&gt;</code> column from the project can be selected and the differences between any two values (i.e., group identifiers) in the groups can be displayed by selecting the group values in the left and right dropdown boxes. A group difference display showing vectors and a colormap of distance can be shown using the \"Diff --&gt;\" button.</p> <p>The animate option allows for an automatic adjustment of the slider to display real-time changes between the group pairing selected. Upon selecting the animate option, the comparison vectors and colormap for each shape in the group comparison will be calculated. This will only occur the first time that the option is selected for a given group value pairing.</p> <p></p>"},{"location":"cloud/cloud-analyze-module.html#charts","title":"Charts","text":"<p>The analysis charts provide visualizations of the shape evaulation data. For more information about shape evaluation, see Shape Model Evaluation. You can zoom into a chart with the mouse scroll wheel and click and drag to pan.</p> <p>Chart Options</p> Tool Description Save as Image Save the chart as an SVG View Data View the chart data in table format View Data: Download Download the chart data as a .csv file View Data: Copy to Clipboard Copy the chart data in CSV format Zoom Zoom into an area by mouse rectangle selection Zoom Reset Reset the zoom level to zero Restore Restore the chart to default view"},{"location":"cloud/cloud-analyze-module.html#shape-viewer","title":"Shape Viewer","text":"<p>While in the analyze tab, the Shape Viewer displays the mean (average) shape generated.</p>"},{"location":"cloud/cloud-analyze-module.html#show-difference-from-mean","title":"Show Difference From Mean","text":"<p>This checkbox allows for visualization from any surface to the mean. The arrows are placed on each particle. The direction and color of the vector/surface indicate the difference from the mean shape.</p>"},{"location":"cloud/cloud-data-module.html","title":"ShapeWorks Cloud Data Module","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p>The ShapeWorks Cloud data module contains the project's anatomies and subjects, including the associated data.</p> <p></p>"},{"location":"cloud/cloud-data-module.html#anatomies","title":"Anatomies","text":"<p>Anatomies can be selected or deselected to allow you to choose what is viewed in the Shape Viewer. For more information on how multiple anatomies are implemented in ShapeWorks Studio, navigate here.</p> <p></p>"},{"location":"cloud/cloud-data-module.html#subjects","title":"Subjects","text":"<p>Subjects contain each individual mesh in the dataset. Each subject can be selected or deselected to allow you to choose what is viewed in the Shape Viewer.</p> <p></p>"},{"location":"cloud/cloud-data-module.html#landmarks","title":"Landmarks","text":"<p>Landmarks can be displayed in ShapeWorks Cloud to mark anatomical features. Landmarks can be viewed and/or modified in the \"Info\" tab while in a project with landmarks.</p>"},{"location":"cloud/cloud-dataset.html","title":"ShapeWorks Cloud Dataset","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p></p> <p>The dataset list displays the uploaded datasets. Each dataset contains projects, which are where you interact with the data. A dataset can contain meshes and segmentations.</p>"},{"location":"cloud/cloud-dataset.html#create-subset","title":"Create Subset","text":"<p>The \"Create Subset\" option allows you to create a new subset dataset from the selected dataset. Here, you are able to provide a name, description, and keywords. You are also able to select which anatomies and subjects you wish you include in the subset.</p>"},{"location":"cloud/cloud-dataset.html#thumbnail","title":"Thumbnail","text":"<p>The thumbnail for a dataset can be generated in the Shape Viewer. The thumbnail will appear as a preview on the dataset view.</p>"},{"location":"cloud/cloud-dataset.html#upload-dataset","title":"Upload Dataset","text":"<p>Uploading a dataset to Shapeworks Cloud can only be done from SWCC, the ShapeWorks Cloud Client. Go to ShapeWorks Cloud Client for more information.</p>"},{"location":"cloud/cloud-groom-module.html","title":"ShapeWorks Cloud Groom Module","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p></p> <p>The groom module provides option for mesh grooming and alighnment. The groomed object is able to be viewed in the Shape Viewer. You also have the option of skipping grooming if your data is already prepped. For more information on how to groom your data, navigate here.</p> <p>To groom the data, click the \"Groom\" option. If you wish to re-groom data, simply click \"Regroom\".</p> <p>To restore the groom parameters to the default values, click \"Restore Defaults\".</p> <p>Mesh Grooming Parameters</p> Parameter Description Fill Holes Fill small holes in the mesh Smooth Perform either Laplacian or Windowed Sinc smoothing Laplacian Smoothing Laplacian smoothing option with specified iterations and relaxation factor.  In general, it is recommended to use smaller relaxation factors and more iterations rather than larger relaxation and fewer iterations Windowed Sinc Smoothing Windowed Sinc smoothing with specified iterations and passband (typically between 0 and 2).  Lower passpand values produce more smoothing Smoothing Iterations Number of iterations of selected smoothing. More iterations provides more smoothing Laplacian Relaxation Controls the amount of smoothing in each iteration Windowed Sinc Pass Band Alters how much smoothing each iteration performs Remesh Enabled remeshing using ACVD library Remesh Percent Specify target vertices as a percentage of existing vertices Remesh Vertices Specify target vertices directly Remesh Adaptivity Curvature adaptivity of remeshing (0 = uniform, 2.0 most adaptive).  This allocates more triangles/vertices to areas of higher curvature <p>Alignment Parameters</p> Parameter Description Reflect Option to reflect some shapes over a given axis if a given column matches a given value (e.g. reflect 'side' over 'Y' if 'left') Alignment Option to align with centering (center of mass), iterative closest point (translation and rotation), or landmarks (best fit, when specified)"},{"location":"cloud/cloud-optimize-module.html","title":"ShapeWorks Cloud Optimize Module","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p>The optimize module provides options for particle-based optimization. The optimization particles can be viewed on the shapes in the Shape Viewer.</p> <p></p> <p>To optimize the data, click the \"Optimize\" option. If you wish to re-optimize data, simply click \"Reoptimize\".</p> <p>To restore the optimization parameters to the default values, click \"Restore Defaults\".</p> <p>Optimization Parameters</p> Parameter Description Number of Particles The desired number of particles to be placed. ShapeWorks will produce the smallest power-of-2 number of particles greater than or equal to the given value Relative Weighting The relative weight of the correspondence term in the optimization steps. Initial Relative Weighting The relative weight of the correspondence term in the initialization steps to make sure that optimization steps start with evenly spaced particle distributions that cover the entire surfaces (usually in the order of ~0.1 or 0.01) Starting Regularization Sets the starting regularization value.  See details about regularization here Ending Regularization Sets the ending regularization value. See details about regularization here Iterations per Split The number of iterations in the initialization step for each split (i.e., scale) Optimization Iterations Number of iterations for each optimization step. Landmarks Enable the use of landmarks as starting particles Geodesic Distance Enable the use of geodesic distance for particle to particle interactions.  This is much slower, but can help with some complex structures/ Normals Enable the use of surface normals as a correspondence feature Normals Strength Amount to scale surface normals feature to give it enough weight relative to XYZ. Multiscale Mode Enable multiscale optimization where each particle split level after the multiscale start number runs in both initialization and optimization modes Multiscale Start Number of particles to begin multscale mode Procrustes Enable use of procrustes registration as part of optimization Procrustes Scaling Enable scaling as part of procrustes to remove overall scale from the model Procrustes Rotation/Translation Enable procrustes rotation/translation to remove translation/rotation from the model Procrustes Interval Interval of iterations to run procrustes Narrow Band Number of voxels surrounding zero level for distance transform based optimizations.  Normally a value of 4 is sufficient"},{"location":"cloud/cloud-project.html","title":"ShapeWorks Cloud Project","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p></p> <p>Within the project list, you can select or delete a project as well as create a new project.</p> <p>Each project contains a separate copy of the data.</p>"},{"location":"cloud/cloud-project.html#create-a-project","title":"Create a Project","text":"<p>To create a project, select a dataset and click \"Create Project\". Here, you will be able to add a name, description, and keywords for the project, as well as designate the new project as <code>private</code>.</p> <p>A project can also be created via the ShapeWorks Cloud Client.</p> <p></p>"},{"location":"cloud/cloud-project.html#edit-a-project","title":"Edit a Project","text":"<p>To edit a project, select \"EDIT\" on any project you have permissions to edit. You are able to modify the name, description, or keywords.</p> <p></p>"},{"location":"cloud/cloud-shape-viewer.html","title":"ShapeWorks Cloud Shape Viewer","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p></p> <p>The Shape Viewer displays the subjects selected in the data module. The Shape Viewer contains options to select layers, select an axis system, set the dataset thumbnail, reset view, and if the analyze module is active, the difference from mean.</p>"},{"location":"cloud/cloud-shape-viewer.html#shape-viewer-options","title":"Shape Viewer Options","text":"Option Description Layers Set the layer(s) to display Axis System Choose which axis system to use. Options: XYZ, Medical Set Thumbnail Set the dataset thumbnail Show Difference From Mean Shows the difference from the mean shape (analyze module only) Reset View Reset the view back to the default zoom and angle"},{"location":"cloud/cloud-shape-viewer.html#layers","title":"Layers","text":"<p>The layer choice option is NOT available in the analyze module.</p> Layer Description Original The original mesh data Groomed The groomed mesh (colored green) Reconstructed The reconstructed mesh (colored red) Particles Optimization particles for the shape Landmarks Landmarks which mark anatomical features"},{"location":"cloud/cloud-shape-viewer.html#set-thumbnail","title":"Set Thumbnail","text":"<p>Set the thumbnail for the dataset. The current shape orientation will be saved and then be visible in the dataset list for that dataset.</p> <p></p>"},{"location":"cloud/getting-started-with-cloud.html","title":"Getting Stared with ShapeWorks Cloud","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p>ShapeWorks Cloud provides an All-in-one browser interface to the ShapeWorks toolkit. In ShapeWorks Cloud, you can access datasets, create projects, as well view and interact with, groom, optimize, and analyze your data.</p>"},{"location":"cloud/getting-started-with-cloud.html#login-screen","title":"Login Screen","text":"<p>To access and use ShapeWorks Cloud, you must first create an account. To login to ShapeWorks Cloud, navigate to www.shapeworks-cloud.org/.</p> <p></p>"},{"location":"cloud/getting-started-with-cloud.html#dataset-list","title":"Dataset List","text":"<p>The dataset list shows uploaded datasets. In this page you can preview a dataset via the thumbnail, select a dataset and create a subset. By selecting a dataset, you access the project list for the selected dataset.</p> <p></p> <p>See ShapeWorks Cloud Dataset for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#project-list","title":"Project List","text":"<p>The project list for a selected dataset displays the current projects for that dataset. Each project can be selected to interact with the data and run ShapeWorks operations. The project list also allows the creation of more projects within the dataset.</p> <p></p> <p>See ShapeWorks Cloud Project for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#data-module","title":"Data Module","text":"<p>The data module contains the project's anatomies/domains and subjects and their associated data.</p> <p></p> <p>See ShapeWorks Cloud Data Module for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#groom-module","title":"Groom Module","text":"<p>The groom module provides options for mesh grooming and alignment. The groomed object is able to be viewed in the Shape Viewer. If the data is already groomed, you do not need to run a groom step in ShapeWorks Cloud.</p> <p></p> <p>See ShapeWorks Cloud Groom Module for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#optimize-module","title":"Optimize Module","text":"<p>The optimize module provides options for particle-based optimization. The optimization particles can be viewed on the shapes in the Shape Viewer.</p> <p></p> <p>See ShapeWorks Cloud Optimize Module for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#analyze-module","title":"Analyze Module","text":"<p>The analyze module can be viewed after a successful optimization job. The analyze module contains PCA data and analysis charts.</p> <p></p> <p>See ShapeWorks Cloud Analyze Module for more information.</p>"},{"location":"cloud/getting-started-with-cloud.html#shape-viewer","title":"Shape Viewer","text":"<p>The Shape Viewer displays the subjects selected in the data module. The Shape Viewer contains options to select layers, select an axis system, set the dataset thumbnail, reset view, and if the analyze module is active, the difference from mean.</p> <p></p> <p>See ShapeWorks Cloud Shape Viewer for more information.</p>"},{"location":"cloud/swcc.html","title":"ShapeWorks Cloud Client (SWCC)","text":"<p>Note: This documentation version could be outdated. Click here to get the most up-to-date version.</p> <p>The ShapeWorks Cloud Client (SWCC) is a Python module that acts as an interface for sending requests to an active ShapeWorks Cloud server. The average use cases for this module include downloading data for custom analysis, uploading new datasets, and creating new projects.</p> <p>Currently, this python module is the only way to upload datasets to ShapeWorks Cloud, since this action should only be performed by trusted and informed users.</p>"},{"location":"cloud/swcc.html#authentication-sessions","title":"Authentication &amp; Sessions","text":"<p>This library includes a session class called <code>SwccSession</code> which handles authentication to a live ShapeWorks Cloud server. This class is context-managed, so you can open a session in a python <code>with</code> block, and it will be closed for you after the block is complete. Within the live context, you can provide your credentials to the <code>login</code> method and receive a token. You do not need to do anything with the token, but it is available to you. After the login statement, you may begin sending requests to the server with various other methods (see following sections).</p> <p>Below is an example:</p> <pre><code>from swcc.api import swcc_session\n\nwith swcc_session() as session:\n    token = session.login(username, password)\n    # begin sending requests\n\n# automatically logged out\n</code></pre>"},{"location":"cloud/swcc.html#datasets-and-projects","title":"Datasets and Projects","text":"<p>The primary use cases for the python client include uploading and downloading Datasets and Projects. It is not likely that you will need to manipulate other classes directly, since Datasets and Projects manage subsequent classes for you.</p>"},{"location":"cloud/swcc.html#datasets","title":"Datasets","text":"<p>The <code>Dataset</code> class has the following attributes, for which you can provide values either in the constructor or by setting them directly: <code>name, file, license, description, acknowledgement, keywords, contributors, publications</code>. It also has properties which may be read from the object: <code>subjects, projects, segmentations, meshes, contours, images, landmarks, constraints</code>.</p> <p>The <code>Dataset</code> class has the following methods:</p> <ol> <li><code>download(output_path)</code>: Download all files related to subsequent objects including Segmentations, Meshes, Images, etc.</li> <li><code>create()</code>: Save the state of the python object as a database object on the server</li> <li><code>force_create()</code>: Save the object to the database, overwriting it if it already exists</li> <li><code>from_name(name)</code>: Returns an iterator of all Dataset objects in the server database that match the provided name string</li> <li><code>add_project(file, keywords, description)</code>: A shortcut for creating a Project object associated with this Dataset, without using the Project constructor directly</li> <li><code>add_subject(subject_name)</code>: A shortcut for creating a Subject object associated with this Dataset, without using the Subject constructor directly</li> </ol> <p>Below is an example.</p> <pre><code>my_dataset = Dataset(name=\u201dMy Dataset\u201d, description=\u201dThis is my first dataset object\u201d)\nmy_dataset.license = license_file.read()\nmy_dataset.acknowledgement = acknowledgement_file.read()\nmy_dataset.add_subject(\u201cSubject One\u201d)\nmy_dataset.add_project(project_file, \u201cKeywords\u201d, \u201cFirst Project for My Dataset\u201d)\nmy_dataset.create()\nmy_dataset.force_create()  # has no effect\nprint(my_dataset.id) # after saving, the object has an id\nprint(my_dataset.meshes)\n\nother_dataset = Dataset.from_name(\u201cOther\u201d)\nother_dataset.download(\u201c/tmp\u201d)\n</code></pre>"},{"location":"cloud/swcc.html#projects","title":"Projects","text":"<p>The <code>Project</code> class has the following attributes, for which you can provide values either in the constructor or by setting them directly: <code>file, keywords, description, dataset, last_cached_analysis</code>. It also has properties which may be read from the object: <code>groomed_segmentations, groomed_meshes, particles</code>.</p> <p>The <code>Project</code> class has the following methods:</p> <ol> <li><code>download(output_path)</code>: Download all files related to subsequent objects including Subjects, Segmentations, Meshes, Images, Groomed Segmentations, Groomed Meshes, Particles, etc.</li> <li><code>create()</code>: Save the state of the python object as a database object on the server and interpret the contents of the file saved to the \u201cfile\u201d attribute as subsequent objects</li> </ol>"},{"location":"cloud/swcc.html#the-project-file","title":"The Project File","text":"<p>The file saved to a Project encodes the project\u2019s relationship to all subsequent objects, and it should be formatted properly so that the <code>create</code> method can correctly interpret the contents. The Project file is a JSON-type file with the extension \u201c.swproj\u201d. The contents of the file should reference the paths of relevant files via absolute or relative paths. Be sure that these files are accessible to the script you run.</p>"},{"location":"cloud/swcc.html#other-classes-and-methods","title":"Other Classes and Methods","text":"<p>As mentioned above, the most common use cases of the SWCC API involve using the Dataset and Project classes, which will handle their subsequent objects. In a rarer use case, one might need to manipulate one of the subsequent objects directly.</p> <p>The Project and Dataset classes inherit from a class called <code>APIModel</code>. The following other classes exist and also inherit from this model:</p> <ol> <li>Segmentation</li> <li>Mesh</li> <li>Contour</li> <li>Image</li> <li>GroomedSegmentation</li> <li>GroomedMesh</li> <li>OptimizedParticles</li> <li>Landmarks</li> <li>Constraints</li> <li>CachedAnalysisGroup</li> <li>CachedAnalysisModePCA</li> <li>CachedAnalysisMode</li> <li>CachedAnalysis</li> </ol> <p>Each of these classes has the following methods:</p> <ol> <li><code>from_id(id)</code>: Class method. Fetch an existing object of this type from the server that matches the provided id</li> <li><code>list()</code>: Class method. Return a list of all existing objects of this type from the server</li> <li><code>delete()</code>: Delete an object from the database</li> <li><code>create()</code>: Save an object to the database</li> </ol>"},{"location":"cloud/swcc.html#examples","title":"Examples","text":"<pre><code>def upload_dataset(dataset_name, description, project_file, private=True):\n   username = input(\"Username: \")\n   password = getpass(\"Password: \")\n\n\n   with swcc_session(base_url=\"[shapeworks server url]/api/v1\") as session:\n       token = session.login(username, password)\n       session = swcc_session(token=token).__enter__()\n\n\n       print(f'Uploading {dataset_name} dataset and project (overwrite=True)')\n       dataset = Dataset(\n           name=dataset_name,\n           private=private,\n           description=description,\n           license='No license',\n           acknowledgement='No acknowledgement',\n       ).force_create()\n       project_file = Path(upload_dir, project_file)\n       project = Project(\n           file=project_file,\n           description='Project created via SWCC',\n           dataset=dataset,\n           # last_cached_analysis=\"project_demo_analysis.json\",\n       ).create()\n       print(project)\n\n       print('Done. \\n')\n\ndef download_project(dataset_name, folder_name):\n   username = input(\"Username: \")\n   password = getpass(\"Password: \")\n\n\n   with swcc_session(base_url=\"[shapeworks server url]/api/v1\") as session:\n       token = session.login(username, password)\n       session = swcc_session(token=token).__enter__()\n\n\n       print(f'Downloading {dataset_name} dataset and project.')\n       dataset = Dataset.from_name(dataset_name)\n       for project in dataset.projects:\n           project.download(Path(download_dir, folder_name))\n\n       print('Done. \\n')\n</code></pre>"},{"location":"deep-learning/data-augmentation.html","title":"Data Augmentation for Deep Learning","text":"<p>ShapeWorks includes a Python package, <code>DataAugmentationUtils</code>, that supports model-based data augmentation. This package is useful to increase the training sample size to train deep networks such as DeepSSM (see SSMs Directly from Images). The <code>DataAugmentationUtils</code> particularly has tools to generate thousands of image-shape pairs based on the available real data. Fabricated (i.e., augmented) examples are generated to preserve the population shape statistics and exhibit realistic intensity variations.</p>"},{"location":"deep-learning/data-augmentation.html#using-the-data-augmentation-package","title":"Using the Data Augmentation Package","text":"<p>The ShapeWorks data augmentation package, <code>DataAugmentationUtils</code>, is installed with the rest of the ShapeWorks Anaconda environment using <code>install_shapeworks</code>.</p> <p>Activate shapeworks environment</p> <p>Each time you use ShapeWorks and/or its Python packages, you must first activate its environment using the <code>conda activate shapeworks</code> command on the terminal.</p> <p>To use the <code>DataAugmentationUtils</code> package, make sure you have the shapeworks conda environment is activated and add the following import to your Python code.</p> <pre><code>import DataAugmentationUtils\n</code></pre>"},{"location":"deep-learning/data-augmentation.html#running-data-augmentation","title":"Running Data Augmentation","text":"<p>To run the complete data augmentation process as detailed in Data Augmentation Steps, add the following to your Python code.</p> <pre><code>DataAugmentationUtils.runDataAugmentation(out_dir, img_list, \n                                          world_point_list, num_samples, \n                                          num_dim, percent_variability, \n                                          sampler_type, mixture_num)\n</code></pre> <p>This generates image/particle pairs in the world coordinate system and assumes the images in <code>img_list</code> are groomed/aligned.</p> <p>Local image/particle pairs can alos be generated using:</p> <p><pre><code>DataAugmentationUtils.runLocalDataAugmentation(out_dir, img_list, \n                                          world_point_list, local_point_list, \n                                          num_samples, num_dim, percent_variability, \n                                          sampler_type, mixture_num)\n</code></pre> This generates image/particle pairs in the local coordinate system and assumes the images in img_list are the original/unaligned images. The world_point_list needs to be provided in this case so that PCA is done in the world coordinate system. New samples are generated by sampling the world PCA subspace, then mapping it to local points using the transform from world to local of the closest real example.</p> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to the directory where augmented data will be stored</li> <li><code>img_list</code>: List of paths to images of the original dataset.</li> <li><code>world_point_list</code>: List of paths to the world <code>.particles</code> files of the original dataset. Note, this list should be ordered in correspondence with the <code>img_list</code>.</li> <li><code>num_dim</code>: The number of dimensions to reduce to in PCA embedding. If zero or not specified, the percent_variability option is used to select the numnber of dimensions.</li> <li><code>percent_variability</code>: The proportion of variability in the data to be preserved in embedding. Used if <code>num_dim</code> is zero or not specified. Default value is 0.95 which preserves 95% of the varibaility in the data.</li> <li><code>sampler_type</code>: The type of parametric distribution to fit and sample from. Options: <code>gaussian</code>, <code>mixture</code>, or <code>kde</code>. Default: <code>kde</code>.</li> <li><code>mixture_num</code>: Only necessary if <code>sampler_type</code> is <code>mixture</code>. The number of clusters (i.e., mixture components) to be used in fitting a mixture model. If zero or not specified, the optimal number of clusters will be automatically determined using the elbow method.</li> </ul> <p>For <code>runLocalDataAugmentation()</code> the following argument must also be provided: * <code>local_point_list</code>: List of paths to local <code>.particles</code> files of the original dataset. Note, this list should be ordered in correspondence with the <code>img_list</code> and <code>world_point_list</code>.</p>"},{"location":"deep-learning/data-augmentation.html#visualizing-data-augmentation","title":"Visualizing Data Augmentation","text":"<p>This function creates a visualization for augmented data. It creates a matrix of scatterplots that opens automatically in the default web browser. The scatterplots show the PCA values of the real and augmented data so that they can be compared pairwise across the PCA dimensions.</p> <pre><code>DataAugmentationUtils.visualizeAugmentation(data_csv, viz_type)\n</code></pre> <p>Input arguments:</p> <ul> <li><code>data_csv</code>: The path to the CSV file created by running the data augmentation process.</li> <li><code>viz_type</code>: The type of visulazation to display. Options <code>splom</code> or <code>violin</code> (default: <code>splom</code>). If set to <code>splom</code>, a scatterplot matrix of pairwise PCA comparisions will open in the default browser. If set to <code>violin</code> a violin plot or rotated kernel density plot will be displayed. </li> </ul>"},{"location":"deep-learning/data-augmentation.html#data-augmentation-steps","title":"Data Augmentation Steps","text":""},{"location":"deep-learning/data-augmentation.html#0-collect-real-data","title":"0. Collect Real Data","text":"<p>As a preliminary step, the data on which augmentation will be based on is needed. This includes the shape model <code>.particles</code> files and their corresponding images. This can be acquired using ShapeWorks or any other method of generating point distribution models (PDM).</p> <p></p>"},{"location":"deep-learning/data-augmentation.html#1-embed-real-data","title":"1. Embed Real Data","text":"<p>First, the real shape data (i.e., PDM) is embedded into a lower-dimensional subspace. This is done by creating a matrix that contains all of the real examples, then reducing the dimension via Principal Component Analysis (PCA).</p> <p></p>"},{"location":"deep-learning/data-augmentation.html#2-fit-a-parametric-distribution","title":"2. Fit a Parametric Distribution","text":"<p>Next, a parametric distribution that can be sampled from is fit to the shape examples embedded in the low-dimension subspace.</p> <p></p>"},{"location":"deep-learning/data-augmentation.html#3-sample-from-the-distribution","title":"3. Sample from the Distribution","text":"<p>Shape samples are randomly drawn from this distribution, and the closest real shape example to each sample is saved.</p> <p></p>"},{"location":"deep-learning/data-augmentation.html#4-project-samples","title":"4. Project Samples","text":"<p>The embedded shape samples are then projected back to shape space, providing new generated shape/correspondence examples.</p> <p></p>"},{"location":"deep-learning/data-augmentation.html#5-complete-sample-generation","title":"5. Complete Sample Generation","text":"<p>The closest real shape example to each generated shape sample is then used to generate the image corresponding to the fabricated shape sample, giving the full pair of generated samples. This is done by finding the warp between the closest real correspondence points and the generated correspondence points, then applying that warp to the corresponding image of the closest real example. This provides us with an image with the intensity profile of the real example but the shape of the generated sample. </p> <p></p>"},{"location":"deep-learning/data-augmentation.html#sampling-distributions","title":"Sampling Distributions","text":"<p>The <code>sampler_type</code> parameter determines which type of distribution to fit to the embedded data. The options are <code>Gaussian</code> (a single multivariate Gaussian\u00a0distribution), <code>mixture</code> (a mixture of Gaussian distributions) or <code>KDE</code> (kernel density estimate).</p>"},{"location":"deep-learning/data-augmentation.html#multivariate-gaussian-distribution","title":"Multivariate Gaussian Distribution","text":"<p>To fit a multivariate Gaussian distribution (which can be seen in Step 2 of Data Augmentation Steps), the probability density function is parameterized by the mean and the covariance matrix of the embedded data matrix. New samples are then randomly sampled for this normal distribution. The closest real example to each sampled point is found by calculating the Mahalanobis distance within the embedded space. </p>"},{"location":"deep-learning/data-augmentation.html#mixture-of-multivariate-gaussians-distribution","title":"Mixture of Multivariate Gaussians Distribution","text":"<p>A Gaussian mixture model can provide a more appropriate probability density function when the embedded data distribution is mutli-modal. To fit a mixture model, first we cluster the embedded samples and select the optimal number of clusters by minimizing Akaike information criterion (AIC) and Bayesian information criterion (BIC). This number determines how many Gaussian distributions (or components) should be used. Next, the expectation-maximization (EM) algorithm is used to fit a mixture-of-Gaussian model with this number of components. This distribution can then be randomly sampled from, and the closest real example is chosen using Mahalanobis distance within the embedded space.  </p> <p></p>"},{"location":"deep-learning/data-augmentation.html#kernel-density-estimate-distribution","title":"Kernel Density Estimate Distribution","text":"<p>Kernel density estimate (KDE) is a non-parametric way of estimating the probability density function of the embedded data. It is fit by defining a Gaussian ball around each real data point in the embedded space, the combination of which provides the distribution. The kernel bandwidth or variance of the Gaussian balls is computed as the average distance to the nearest neighbor computed using the Mahalanobis distance within the embedded space.  </p> <p>To sample from the KDE distribution, a real example is randomly selected, then a point is randomly sampled from its kernel. The selected real example is also returned to use its corresponding image to generate the augmented image-shape pair.</p> <p></p> <p>Relevant papers</p> <ul> <li>Jadie Adams, Riddhish Bhalodia, Shireen Elhabian. Uncertain-DeepSSM: From Images to Probabilistic Shape Models. In MICCAI-ShapeMI, Springer, Cham, 2020.</li> <li>Riddhish Bhalodia, Shireen Elhabian, Ladislav Kavan, and Ross Whitaker. DeepSSM: a deep learning framework for statistical shape modeling from raw images. In MICCAI-ShapeMI, pp. 244-257. Springer, Cham, 2018.</li> <li>Riddhish Bhalodia, Anupama Goparaju, Tim Sodergren, Alan Morris, Evgueni Kholmovski, Nassir Marrouche, Joshua Cates, Ross Whitaker, Shireen Elhabian. Deep Learning for End-to-End Atrial Fibrillation Recurrence Estimation. Computing in Cardiology (CinC), 2018.</li> </ul>"},{"location":"deep-learning/deep-ssm.html","title":"SSMs Directly from Images","text":"<p>DeepSSM is a deep learning framework that estimates statistical representations of shape directly from unsegmented images once trained. DeepSSM includes a data augmentation process and a convolutional neural network (CNN) model. This documentation provides an overview of the DeepSSM process; see relevant papers for a full explanation.</p> <p>Relevant papers</p> <ul> <li>Jadie Adams, Riddhish Bhalodia, Shireen Elhabian. Uncertain-DeepSSM: From Images to Probabilistic Shape Models. In MICCAI-ShapeMI, Springer, Cham, 2020.</li> <li>Riddhish Bhalodia, Shireen Elhabian, Ladislav Kavan, and Ross Whitaker. DeepSSM: a deep learning framework for statistical shape modeling from raw images. In MICCAI-ShapeMI, pp. 244-257. Springer, Cham, 2018.</li> <li>Riddhish Bhalodia, Anupama Goparaju, Tim Sodergren, Alan Morris, Evgueni Kholmovski, Nassir Marrouche, Joshua Cates, Ross Whitaker, Shireen Elhabian. Deep Learning for End-to-End Atrial Fibrillation Recurrence Estimation. Computing in Cardiology (CinC), 2018.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#what-is-deepssm","title":"What is DeepSSM?","text":"<p>The input to the DeepSSM network is unsegmented 3D images of the anatomy of interest, and the output is the point distribution model (PDM). </p> <p></p> <p>DeepSSM requires training examples of image/PDM pairs that are generated via the traditional Shapeworks grooming and optimization pipeline or other particle distribution models. Once the network has been trained on these examples, it can predict the PDM of unseen examples given only\u00a0images of the same anatomy/object class, bypassing the need for labor-intensive segmentation, grooming, and optimization parameter tuning. </p> <p></p>"},{"location":"deep-learning/deep-ssm.html#why-deepssm","title":"Why DeepSSM?","text":"<p>The benefits of the DeepSSM pipeline include:</p> <ul> <li>Less Labor: DeepSSM does not require segmentation, only a bounding box about where the anatomy of interest lies in the image. \u00a0</li> <li>End-to-end: Does not require separate grooming and optimization steps; it is an end-to-end process. This also reduces memory requirement as images do not need to be saved after intermediate grooming steps.</li> <li>Faster Results: Once a DeepSSM network has been trained, it can be used to predict the shape model on a new image in seconds on a GPU.</li> </ul> <p>The DeepSSM network is implemented in PyTorch and requires a GPU to run efficiently. </p>"},{"location":"deep-learning/deep-ssm.html#deepssm-steps","title":"DeepSSM Steps","text":""},{"location":"deep-learning/deep-ssm.html#1-data-augmentation","title":"1. Data Augmentation","text":"<p>The first step to creating a DeepSSM model is generating training data. Deep networks require thousands of training instances and since medical imaging data is typically limited, data augmentation is necessary. The data augmentation process is described here: \u00a0Data Augmentation for Deep Learning.</p> <p>The data augmentation process involves reducing the PDM's to a low-dimensional space via Principal Component Analysis (PCA), preserving a chosen percentage of the variation. The PCA scores are saved and used as the target output for DeepSSM prediction. The PCA scores are deterministically mapped back to the PDM (i.e., shape space) using the eigenvalues and vectors once the DeepSSM model makes a prediction. </p>"},{"location":"deep-learning/deep-ssm.html#2-creation-of-data-loaders","title":"2. Creation of Data Loaders","text":"<p>The next step is to reformat the data (original and augmented) into PyTorch tensors. 80% of the data is randomly selected to be training data, and the remaining 20% of the data is used as a validation set. The input images are whitened and turned into tensors. They can also be optionally downsampled to a smaller size to allow for faster training. The corresponding PCA scores are also normalized or whitened to avoid DeepSSM learning to favor the primary modes of variation and are then turned to tensors. PyTorch data loaders are then created with a batch size specified by the user. </p>"},{"location":"deep-learning/deep-ssm.html#3-training","title":"3. Training","text":"<p>PyTorch is used in constructing and training DeepSSM. We have implemented two different network architectures: </p> <ul> <li>Base-DeepSSM: The network architecture is defined to have five convolution layers followed by two fully connected layers, as illustrated in the figure below. Parametric ReLU activation is used, and the weights are initialized using Xavier initialization. The network is trained for the specified number of epochs using Adam optimization to minimize the L2 loss function with a learning rate of 0.0001. The average training and validation error are printed and logged each epoch to determine convergence.</li> </ul> <p></p> <ul> <li>TL-DeepSSM: In TL-DeepSSM, the input is an image and correspondence pair. The network architecture of the TL-DeepSSM consists of two parts: (i) the autoencoder that learns the latent dimension for each correspondence, and (ii) the network that learns the latent dimension from the image (this is called the T-flank and it is similar to the Base-DeepSSM architecture). The training routine is broken into three parts. First, the correspondence autoencoder is trained. Next, the T-flank is trained while the correspondence autoencoder weights are kept frozen. Finally, the entire model is trained jointly. For inference using a testing sample, one can directly obtain the correspondences from an image via the T-flank and decoder.</li> </ul> <p></p>"},{"location":"deep-learning/deep-ssm.html#4-testing","title":"4. Testing","text":"<p>The trained model is then used to predict the PCA score from the images in the test set. These PCA scores are then un-whitened and mapped back to the particle coordinates using the eigenvalues and eigenvectors from PCA. Thus a PDM is acquired for each test image.</p>"},{"location":"deep-learning/deep-ssm.html#5-evaluation","title":"5. Evaluation","text":"<p>To evaluate the accuracy of DeepSSM output, we compare a mesh created from the ground truth segmentation to a mesh created from the predicted PDM. To obtain the original mesh, we use the ShapeWorks <code>MeshFromDistanceTransforms</code> command to the isosurface mesh from the distance transform created from the true segmentation. To obtain the predicted mesh, we use the ShapeWorks <code>ReconstructSurface</code> command with the mean and predicted particles to reconstruct a surface.</p> <p>We then compare the original mesh to the predicted mesh via surface-to-surface distance. To find the distance from the original to the predicted, we consider each vertex in the original and find the shortest distance to the predicted mesh's surface. This process is not symmetric as it depends on the vertices of one mesh, so the distance from the predicted to the original will be slightly different. We compute the Hausdorff distance that takes the max of these vertex-wise distances to return a single value as a measure of accuracy. We also consider the vertex-wise distances as a scalar field on the mesh vertices and visualize them as a heat map on the surface. This provides us with a way of seeing where the predicted PDM was more or less accurate.</p> <p></p>"},{"location":"deep-learning/deep-ssm.html#using-the-deepssm-python-package","title":"Using the DeepSSM Python Package","text":"<p>The ShapeWorks DeepSSM package, <code>DeepSSMUtils</code>, is installed with the rest of the ShapeWorks Anaconda environment using <code>install_shapeworks</code>.</p> <p>Activate shapeworks environment</p> <p>Each time you use ShapeWorks and/or its Python packages, you must first activate its environment using the <code>conda activate shapeworks</code> command on the terminal.</p> <p>To use the <code>DeepSSMUtils</code> package, make sure you have the shapeworks conda environment is activated and add the following import to your Python code:</p> <pre><code>import DeepSSMUtils\n</code></pre>"},{"location":"deep-learning/deep-ssm.html#get-train-and-validation-torch-loaders","title":"Get train and validation torch loaders","text":"<p>This function turns the original and augmented data into training and validation torch loaders. The data provided is randomly split so that 80% is used in the training set and 20% is used in the validation set.</p> <pre><code>DeepSSMUtils.getTrainValLoaders(out_dir, data_aug_csv, batch_size=1, down_factor=1, down_dir=None)\n</code></pre> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to the directory to store the torch loaders.</li> <li><code>data_aug_csv</code>: The path to the csv containing original and augmented data, which is the output when running data augmentation as detailed in Data Augmentation for Deep Learning.</li> <li><code>batch_size</code>: The batch size for training data. The default value is 1.</li> <li><code>down_factor</code> Determines if the images should be downsampled for faster training. For example a value of 1 indicates the images should not be downsampled, while a value of 0.5 indicates the images should be downsampled to half of their original size. The default value is 1. </li> <li><code>down_dir</code> The directory to which downsampled images should be written. The default value is <code>None</code>.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#get-test-torch-loader","title":"Get test torch loader","text":"<p>This function turns the provided data into a test torch loader.</p> <pre><code>DeepSSMUtils.getTestLoader(out_dir, test_img_list, down_factor=1, down_dir=None)\n</code></pre> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to the directory to store the torch loader.</li> <li><code>test_img_list</code>: A list of paths to the images that are in the test set.</li> <li><code>down_factor</code> Determines if the images should be downsampled for faster training. For example a value of 1 indicates the images should not be downsampled, while a value of 0.5 indicates the images should be downsampled to half of their original size. This should match what is done for the training and validation loaders. The default value is 1. </li> <li><code>down_dir</code> The directory to which downsampled image should be written. The default value is <code>None</code>.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#train-deepssm","title":"Train DeepSSM","text":"<p>This function defines a DeepSSM model and trains it on the data provided. After training the \"final\" and \"best\" model are saved. The final model is saved after all training epochs have run. The best model is saved after the epoch which had the lowest prediction error on the validation set. The best model makes use of early stopping to prevent overfitting.</p> <pre><code>DeepSSMUtils.trainDeepSSM(config_file)\n</code></pre> <p>Config file:</p> <p>Training requires a JSON config file which defines all model architecture and training parameters.</p>"},{"location":"deep-learning/deep-ssm.html#config-file-parameter-descriptions","title":"Config File Parameter Descriptions","text":"<ul> <li><code>model_name</code>: The name of the model, typically this matches the name of the JSON configuration file. The model and predictions will be saved in the directory: <code>out_dir/model_name/</code></li> <li><code>num_latent_dim</code>: The size of the latent dimension.</li> <li><code>paths</code>: A dictionary with all the needed paths.<ul> <li><code>out_dir</code>: The directory to which output should be written.</li> <li><code>loader_dir</code>: The directory that has the training, validation, and test torch data loaders.</li> <li><code>aug_dir</code>: The directory that has the augmented data.</li> </ul> </li> <li><code>encoder</code>: A dictionary with information about the encoder. <ul> <li><code>deterministic</code>: If true indicates the encoder should be deterministic. If false indicates the encoder should be stochastic.</li> </ul> </li> <li><code>decoder</code>: A dictionary with information about the decoder.<ul> <li><code>deterministic</code>: If true indicates the decoder should be deterministic. If false indicates the decoder should be stochastic.</li> <li><code>linear</code>: If true indicates the decoder should be linear. If false indicates the decoder should be non-linear.</li> </ul> </li> <li><code>loss</code>: A dictionary with info about the loss. <ul> <li><code>function</code>: The loss function to be used in training. Options: <code>MSE</code> or <code>Focal</code>. Default: <code>MSE</code>.</li> <li><code>supervised_latent</code>:  If true then the latent space is supervised during training. For example, the PCA scores in the original DeepSSM model. If false then the latent space is unsupervised. </li> </ul> </li> <li><code>trainer</code>: A dictionary with info about training.<ul> <li><code>epochs</code>: The number of training epochs.</li> <li><code>learning_rate</code>: The learning rate to use in training.</li> <li><code>decay_lr</code>: A dictionary with the information about the learning rate decay during training. <ul> <li><code>enabled</code>: If true the learning rate should decay during training. </li> <li><code>type</code>: The type of learning rate scheduler to be used.  Options: <code>CosineAnnealing</code> or <code>Step</code>. Default: <code>CosineAnnealing</code>.</li> <li><code>parameters</code>: A dictionary with the information about the learning rate scheduler.</li> </ul> </li> <li><code>val_freq</code>: How often to evaluate the error on the validation set in training (i.e., one means every epoch, two means every other, etc.)</li> </ul> </li> <li><code>fine_tune</code>: A dictionary with the information about fine tuning.<ul> <li><code>enabled</code>: If true the model should be fine tuned after general training. If false fine tuning should not be done and the following fine tuning parameters need not be set.</li> <li><code>loss</code>: The loss function to be used in fine tuning.</li> <li><code>epochs</code>: The number of fine tuning epochs.</li> <li><code>learning_rate</code>: The learning rate to use in fine tuning.</li> <li><code>decay_lr</code>: If true the learning rate should decay during fine tuning.</li> <li><code>val_freq</code>: How often to evaluate the error on the validation set in fine tuning (i.e., one means every epoch, two means every other, etc.)</li> </ul> </li> <li><code>tl_net</code>: A dictionary with the information about the TL-DeepSSM model.<ul> <li><code>enabled</code>: If true the model will be trained using TL-DeepSSM model. If false the Base DeepSSM will be used.</li> <li><code>ae_epochs</code>: The number of epochs to train the autoencoder.</li> <li><code>tf_epochs</code>: The number of epochs to train the T-flank.</li> <li><code>joint_epochs</code>: The number of epochs to train the whole model.</li> <li><code>alpha</code>: The weight applied to the T-flank with respect to the autoencoder loss when training the whole model.</li> <li><code>a_ae</code>: Focal loss parameter when calculating the autoencoder loss. <code>a</code> is a scaling parameter that adjusts the intensity of the loss; higher values accentuate the loss, while lower values dampen it.</li> <li><code>c_ae</code>: Focal loss parameter when calculating the autoencoder loss. <code>c</code> is a threshold parameter that modulates the loss contribution of each particle. When the particle difference is below c, the particle's impact on the overall loss is reduced.</li> <li><code>a_lat</code>: Focal loss parameter when calculating the T-flank loss.</li> <li><code>c_lat</code>: Focal loss parameter when calculating the T-flank loss.</li> </ul> </li> <li><code>use_best_model</code>: If true the model from the epoch which achieved the best validation accuracy is used in testing (essentially the early stopping model). If false then the final model after all training epochs is used in testing.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#test-deepssm","title":"Test DeepSSM","text":"<p>This function gets predicted shape models based on the images provided using a trained DeepSSM model.</p> <p><pre><code>DeepSSMUtils.testDeepSSM(config_file)\n</code></pre> The testing function takes the same config paremeters file as the training function above.</p> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to directory where predictions are saved.</li> <li><code>model_path</code>: Path to train DeepSSM model.</li> <li><code>loader_dir</code>: Path to the directory containing test torch loader.</li> <li><code>PCA_scores_path</code>: Path to eigenvalues and eigenvectors from data augmentation that are used to map predicted PCA scores to particles.</li> <li><code>num_PCA</code>: The number of PCA scores the DeepSSM model is trained to predict.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#analyze-results","title":"Analyze Results","text":"<p>This function analyzes the shape models predicted by DeepSSM by comparing them to the true segmentation. </p> <pre><code>DeepSSMUtils.analyzeResults(out_dir, DT_dir, prediction_dir, mean_prefix)\n</code></pre> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to the directory where meshes and analysis should be saved.</li> <li><code>DT_dir</code>: Path to the directory containing distance transforms based on the true segmentations of the test images.</li> <li><code>prediction_dir</code>: Path to the directory containing predicted particle files from testing DeepSSM.</li> <li><code>mean_prefix</code>: Path to the mean particle and mesh files for the dataset.</li> </ul>"},{"location":"deep-learning/deep-ssm.html#visualizing-error","title":"Visualizing Error","text":"<p>The error meshes that are output from the analiyze step can be visualized in Studio. These meshes have a distance scalar field on them which captures the distance between the true and predicted mesh. To view in Studio, run the following from the command line:</p> <pre><code>ShapeWorksStudio path/to/error/mesh.vtk\n</code></pre> <p></p>"},{"location":"deep-learning/pytorch-gpu.html","title":"PyTorch GPU Support for ShapeWorks","text":"<p>ShapeWorks deep learning tools, such as the <code>DeepSSMUtils</code> package, requires PyTorch with GPU support.  This is installed with the rest of the ShapeWorks Anaconda environment using <code>install_shapeworks</code>.  It selects the most recent stable release of PyTorch which can be found at pytorch.org.  </p> <p>When the Anaconda enironment is created using <code>install_shapeworks</code>, PyTorch with GPU support is installed if the system's current CUDA driver version is supported. Otherwise it selects the CPU version of PyTorch.</p>"},{"location":"deep-learning/pytorch-gpu.html#checking-if-pytorch-installation-has-gpu-support","title":"Checking if PyTorch installation has GPU support","text":"<p>To check if your <code>shapeworks</code> environment has PyTorch with GPU support, run the following: <pre><code>conda activate shapeworks\npython\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; print(torch.cuda.is_available())\n&gt;&gt;&gt; exit()\n</code></pre> If <code>torch.cuda.is_available()</code> is True then PyTorch has GPU support, otherwise the CPU version was installed.  If <code>torch</code> cannot be imported than PyTorch was not installed to the <code>shapeworks</code> environment. </p>"},{"location":"deep-learning/pytorch-gpu.html#reinstalling-the-correct-pytorch-version","title":"Reinstalling the Correct PyTorch Version","text":"<p>If you find that your system requires an older version of PyTorch or <code>install_shapeworks</code> did not correcty find your CUDA version,  the following steps explain how to install a different PyTorch version in the <code>shapeworks</code> conda environment.</p> <p>Detailed instructions about the different ways to install PyTorch can be found here: PyTorch Getting Started </p> <p>CUDA compatibility can be checked here: CUDA-Compatibility</p> <ol> <li>If the CPU version of PyTorch was installed, that first needs to be uninstalled. To uninstall run: <pre><code>conda activate shapeworks\npip uninstall torch torchvision torchaudio\n</code></pre></li> <li>Check which CUDA version is installed on your system using one of the methods explained here: How to check CUDA version</li> <li> <p>Install the correct PyTorch to <code>shapeworks</code> environment using:  <pre><code>pip install torch===1.7.1+cu&lt;VERSION&gt; torchvision===0.8.2+cu&lt;VERSION&gt; torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html\n</code></pre>   Where <code>VERSION</code> is your CUDA version with no dot (such as 92 for 9.2 or 110 for 11.0).</p> </li> <li> <p>Restart your system and check if <code>shapeworks</code> now has PyTorch with GPU support using the instructions above. </p> </li> </ol>"},{"location":"dev/build.html","title":"How to Build ShapeWorks from Source?","text":"<p>If you encounter problems, have questions, or need help, please contact <code>&lt;shapeworks-dev-support@sci.utah.edu&gt;</code>.</p> <p>After you finish building...</p> <p>While user installations have everything you need in the PATH, developer builds like these need those additions. Please See Adding Environment Variables for Development for instructions on the simple devenv script that takes care of everything.</p>"},{"location":"dev/build.html#minimum-requirements","title":"Minimum Requirements","text":""},{"location":"dev/build.html#linux","title":"Linux","text":"<ul> <li>CMake 3.11 (provided by conda below if not already installed)</li> <li>GCC 9.0.0</li> </ul>"},{"location":"dev/build.html#mac","title":"Mac","text":"<ul> <li>CMake 3.11 (provided by conda below if not already installed)</li> <li>Clang 10.0.0</li> </ul>"},{"location":"dev/build.html#windows","title":"Windows","text":"<ul> <li>CMake 3.11 (provided by conda below if not already installed)</li> <li>MSVC 2019</li> </ul>"},{"location":"dev/build.html#clone-source","title":"Clone source","text":"<p>To clone the ShapeWorks source: <pre><code>$ git clone https://github.com/SCIInstitute/ShapeWorks\n</code></pre> See How to Contribute? for more details on git commands.  </p>"},{"location":"dev/build.html#install-dependencies","title":"Install dependencies","text":""},{"location":"dev/build.html#linux-and-mac","title":"Linux and Mac","text":""},{"location":"dev/build.html#anaconda","title":"Anaconda","text":"<p>We use Anaconda (conda) to install many dependencies required for both building and running ShapeWorks. Conda [sub]environments do not affect a machine's global setup in any way, do not require sudo to install, and are only available at the user level when activated.</p> <p>To install conda and the dependencies it provides (currently requires either bash or zsh shell), run: <pre><code>$ source install_shapeworks.sh [environment name]`  \n</code></pre> Note: By default this creates an environment named shapeworks, but you can specify a different name and it's okay to have multiple environments.  </p> <p>ShapeWorks uses git-lfs to store image data for testing.  If git-lfs was not already installed before cloning ShapeWorks, please use the following commands to get this data: <pre><code>$ git lfs fetch\n$ git lfs install\n$ git lfs checkout\n</code></pre></p> <p>Activate shapeworks environment</p> <p>Each time you build or use ShapeWorks from the command line, you must first activate its environment using the <code>conda activate shapeworks</code> command on the terminal.</p>"},{"location":"dev/build.html#vxl-vtk-itk-eigen-and-openvdb","title":"VXL, VTK, ITK, Eigen and OpenVDB","text":"<p>These dependencies can be installed using the <code>build_dependencies.sh</code> script.  </p> <p>Use <code>$ ./build_dependencies.sh --help</code> for more details on the available options.  </p> <p>Note</p> <p>If you get an error that looks like this: <pre><code>which: no qmake in (...) \nFor GUI applications, please make sure at least version $QT_MIN_VER of Qt5 is installed and that its qmake is in the path.\nDownload Qt5 from: https://download.qt.io/archive/qt/\n</code></pre></p> <p>Make sure you added Qt to your path as explained in the Qt5 installation step.  </p> <p>Note</p> <p>OpenSUSE Users: If you get an error that looks like this: <pre><code>Could NOT find OpenGL (missing: OPENGL_opengl_LIBRARY OPENGL_glx_LIBRARY OPENGL_INCLUDE_DIR)\n</code></pre></p> <p>Make sure the following are installed: Mesa-devel, freeglut-devel, libX11-devel  </p> <p>Important</p> <p>If you decide to build ITK yourself and you would like to use the ShapeWorks GUI applications, ITK must be built with VTK.  </p>"},{"location":"dev/build.html#windows_1","title":"Windows","text":""},{"location":"dev/build.html#cmake","title":"CMake","text":"<p>Download and install [CMake] Download and install [Visual Studio 2019]</p>"},{"location":"dev/build.html#anaconda_1","title":"Anaconda","text":"<p>Download and install [Anaconda]. </p> <p>Important</p> <p>It is recommended not to add Anaconda to your PATH and not to register Anaconda as your default Python.  </p> <p>Using an MSYS2 Prompt (e.g. git-bash), run <code>source install_shapeworks.sh [environment name]</code> Note: By default this creates an environment named shapeworks, but you can specify a different name and it's okay to have multiple environments.  </p>"},{"location":"dev/build.html#vtk-itk-eigen-xlnt-jkqtplotter-libigl-geometry-central-acvd-and-openvdb","title":"VTK, ITK, Eigen, XLNT, jkqtplotter, libIGL, geometry central, ACVD, and OpenVDB","text":"<p>These dependencies can be installed using the <code>build_dependencies.sh</code> script. Use an msys2 shell (e.g., git bash) to do this on Windows.  </p> <p>Use <code>$ ./build_dependencies.sh --help</code> for more details on the available build_dependencies options.  </p> <p>Important</p> <p>If you get an error that says: <code>which: no qmake in (...)</code> Make sure you added Qt to your path as explained in the Qt5 installation step.</p> <p>Important</p> <p>If you decide to build ITK yourself and you would like to use the ShapeWorks GUI applications, ITK must be built with VTK.  </p>"},{"location":"dev/build.html#configure-and-build","title":"Configure and Build","text":""},{"location":"dev/build.html#linux-mac","title":"Linux &amp; Mac","text":"<p>Make a build directory and use cmake to configure your build: <pre><code>mkdir build\ncd build\ncmake &lt;options&gt; ..\n</code></pre> There is a CMake GUI to see and change any of the options: - On OSX/Linux, you can use the GUI by running <code>ccmake</code> instead of <code>cmake</code>.  </p>"},{"location":"dev/build.html#options","title":"Options","text":"<p>If you used the <code>build_dependencies.sh</code> script above, the prefix for all dependencies is the same. Otherwise, the specific paths to all the dependencies are all required.</p> <p>Required (if you used build_dependencies.sh): <pre><code>  -DCMAKE_PREFIX_PATH=&lt;dependencies install path&gt;\n</code></pre></p> <p>Required (otherwise): <pre><code>  -DVTK_DIR=&lt;vtk cmake path&gt;           (contains VTKConfig.cmake)\n  -DITK_DIR=&lt;itk cmake path&gt;           (contains ITKConfig.cmake)\n  -DEigen3_DIR=&lt;eigen3 cmake path&gt;     (contains Eigen3Config.cmake)\n  -DOpenVDB_DIR=&lt;openvdb cmake path&gt;   (contains FindOpenVDB.cmake)\n  ... and so on for each dependency ...\n</code></pre></p> <p>Optional: <pre><code>  -G&lt;generator&gt;                       default: Unix Makefiles (ex: -GXCode or -G\"Visual Studio 16 2019\" -Ax64)  \n  -DBuild_Studio=[OFF|ON]             default: OFF\n  -DCMAKE_INSTALL_PREFIX=&lt;path&gt;       default: ./install\n  -DCMAKE_BUILD_TYPE=[Debug|Release]  default: Release (only required is default generator is used)\n</code></pre></p> <p>See Examples below for common values of the variables.</p>"},{"location":"dev/build.html#building","title":"Building","text":"<ul> <li>Makefiles: <ul> <li><code>make -j&lt;num_procs&gt;</code> where num_procs is the number of parallel processes, say 8.  </li> <li>You might need to build using <code>cmake --build . -j 16</code> to pass parallel flags to dependent projects (e.g., vtk) </li> </ul> </li> <li>XCode project: <code>open ShapeWorks.xcodeproj</code> and build from there.  </li> </ul>"},{"location":"dev/build.html#before-running-examplespython-scripts-and-examplespythonnotebooks","title":"Before running Examples/Python scripts and Examples/Python/notebooks","text":"<p>Developer environment should be set by using the <code>devenv.sh</code> script by running this:</p> <pre><code>$ source devenv.sh [build_directory]\n</code></pre>"},{"location":"dev/build.html#examples","title":"Examples","text":"<p>OSX example that builds dependencies separately, then generates an XCode project for ShapeWorks:  </p> <pre><code>$ ./build_dependencies.sh\nmkdir build\ncd build\ncmake -DCMAKE_PREFIX_PATH=\"${PWD}/../dependencies/install\" -DBuild_Studio:BOOL=ON -Wno-dev -Wno-deprecated -GXcode ..\nopen ShapeWorks.xcodeproj\n</code></pre>"},{"location":"dev/build.html#windows_2","title":"Windows","text":"<p>Use the cmake from the Anaconda Prompt with shapeworks env activated to configure and generate project files for your preferred build system (e.g., Visual Studio 16 2019). Like with all the other platforms, after running <code>build_dependencies.sh</code> a suggested cmake command is printed. Create a build directory and use it.  </p>"},{"location":"dev/build.html#examples_1","title":"Examples","text":"<p>An example that builds dependencies separately then generates a Visual Studio project for ShapeWorks (note that by default a Visual Studio project will be created): <pre><code>&gt; conda activate shapeworks\n&gt; ./build_dependencies.sh --build-dir=../dependencies --install-dir=../dependencies\n&gt; mkdir build\n&gt; cd build\n&gt; cmake -G\"Visual Studio 16 2019\" -Ax64 -DVXL_DIR=../dependencies/vxl/build -DCMAKE_PREFIX_PATH=../dependencies -DBuild_Studio:BOOL=ON ..\n</code></pre></p>"},{"location":"dev/build.html#options_1","title":"Options","text":"<p>Required: <pre><code>  -DCMAKE_PREFIX_PATH=&lt;qt cmake path&gt;  (This is different from qmake path in the Install Qt5 step\n  -DVTK_DIR=&lt;vtk cmake path&gt;           (contains VTKConfig.cmake)\n  -DITK_DIR=&lt;itk cmake path&gt;           (contains ITKConfig.cmake)\n  -DEigen3_DIR=&lt;eigen cmake path&gt;      (contains Eigen3Config.cmake)\n  -DOpenVDB_DIR=&lt;openvdb cmake path&gt;   (contains FindOpenVDB.cmake)\n  ... and so on for each dependency ...\n</code></pre> Optional: <pre><code>  -D BUILD_TESTS=[OFF|ON]              default: ON\n  -D CMAKE_INSTALL_PREFIX=&lt;path&gt;       default: ./install\n  -D CMAKE_BUILD_TYPE=[Debug|Release]  \n</code></pre></p> <p>After cmake the Visual Studio solution can be opened with <code>start ShapeWorks.sln</code> from the build directory.</p> <p>RelWithDebInfo only</p> <p>Currently it's only possible to build RelWithDebInfo on Windows.</p>"},{"location":"dev/commands.html","title":"How to Add ShapeWorks Commands?","text":"<p>To add ShapeWorks Commands, the following steps need to be followed:</p> <ol> <li> <p>Declare command in Applications/shapeworks/Commands.h</p> <p><code>COMMAND_DECLARE(CommandName, CommandType);</code></p> <p>CommandName is the name of the command. CommandType is the type of command. ShapeWorks supports ImageCommand, MeshCommand, ParticleSystemCommand, OptimizeCommandGroup and GroomCommandGroup  </p> </li> <li> <p>Define command in  </p> <ul> <li>Applications/shapeworks/ImageCommands.cpp if CommandType is ImageCommand  </li> <li>Applications/shapeworks/MeshCommands.cpp if CommandType is MeshCommand  </li> <li>Applications/shapeworks/ParticleSystemCommands.cpp if CommandType is ParticleSystemCommand  </li> <li>Applications/shapeworks/Commands.cpp for other types of commands  </li> </ul> <pre><code>///////////////////////////////////////////////////////////////////////////////\n// CommandName\n///////////////////////////////////////////////////////////////////////////////\nvoid CommandName::buildParser()\n{\n  const std::string prog = \"commandname\"; // supports command-name as well\n  const std::string desc = \"brief description of command\";\n  parser.prog(prog).description(desc);\n\n  parser.add_option(\"--optionname\").action(\"store\").type(\"double\").set_default(0.01).help(\"Description of optionname.\");\n  // additional options/arguments... \n\n  Command::buildParser();\n}\n\nbool CommandName::execute(const optparse::Values &amp;options, SharedCommandData &amp;sharedData)\n{\n  if (!sharedData.validImage())\n  {\n    std::cerr &lt;&lt; \"No image to operate on\\n\";\n    return false;\n  }\n\n  double optionName = static_cast&lt;double&gt;(options.get(\"optionname\"));\n  // read additional options/arguments... \n\n  sharedData.image.example(optionName, ...); // call related function\n  return true;\n}\n</code></pre> </li> <li> <p>Add command to Applications/shapeworks/shapeworks.cpp</p> <p><code>shapeworks.addCommand(CommandName::getCommand());</code></p> </li> </ol>"},{"location":"dev/contribute.html","title":"How to Contribute to ShapeWorks?","text":"<p>ShapeWorks uses <code>git</code> for managing source code so changes can be integrated from multiple people. Here are some of the basics to check out the repository, make and share modifications, and keep track of all your changes along the way. The ShapeWorks repositories are stored on GitHub. </p> <p>Imporant</p> <p>If you want to contribute, first make sure you have a developer account.  </p>"},{"location":"dev/contribute.html#source-and-branches","title":"Source and Branches","text":"<p>To clone the ShapeWorks source, use one of the following commands: <pre><code>$ git clone https://github.com/SCIInstitute/ShapeWorks\n</code></pre></p> <p>To avoid having to type your password every time you refresh your source code, you can copy your public ssh key (found in ~/.ssh/id_rsa.pub) and add it to your GitHub account. Now you can use this version to clone the code:  <pre><code>$ git clone git@github.com:sciinstitute/ShapeWorks\n</code></pre> If you've already cloned your code, simply change the <code>[remote \"origin\"]</code> in .git/config to <code>url = git@github.com:SCIInstitute/ShapeWorks</code>. All git commands remain the same.</p> <p>Now that you've cloned the source you can build ShapeWorks from source if you want.</p> <p>View current state (branch and modifications, both staged and unstaged): <pre><code>$ git status\n</code></pre></p> <p>View all branches: <pre><code>$ git branch -a\n</code></pre></p> <p>Checkout an exising branch (or a tag or a specific commit): <pre><code>$ git checkout &lt;branchname&gt;\n</code></pre></p> <p>Create a new branch <pre><code>$ git checkout -b &lt;branchname&gt;\n</code></pre></p> <p>Fetch changes for a specific branch from GitHub: <pre><code>$ git fetch origin &lt;branchname&gt;\n</code></pre></p> <p>Fetch changes for all branches from GitHub: <pre><code>$ git fetch --all\n</code></pre></p> <p>Merge the fetched changes to your current branch: <pre><code>$ git merge origin/&lt;branchname&gt;\n</code></pre> For example, use this command to merge the latest master to your current branch. After that, you can test as necessary, then push your branch and make a pull request when it's ready: <code>git merge origin/master</code></p> <p>Shortcut to both fetch and merge upstream changes to the current branch: <pre><code>$ git pull\n</code></pre></p> <p>Push a branch to GitHub: <pre><code>$ git push origin &lt;branchname&gt;\n</code></pre></p> <p>Delete a branch (e.g., after a pull request has been completed and merged ): <pre><code>$ git branch -d &lt;branchname&gt;\n</code></pre></p> <p>Force delete a branch whether or not it's been merged: <pre><code>$ git branch -D &lt;branchname&gt;\n</code></pre></p> <p>Prune old branches that have been removed from GitHub (--dry-run will show you what will be pruned): <pre><code>$ git remote prune origin [--dry-run]\n</code></pre></p>"},{"location":"dev/contribute.html#commits","title":"Commits","text":"<p>Check the current status of your changes scheduled to be committed using: <pre><code>$ git status\n</code></pre></p> <p>To commit your current changes to current local branch (first, use <code>git diff</code> to ensure they are correct): <pre><code>$ git diff\n$ git commit -m \"description of changes\"\n</code></pre></p> <p>This commits only the files specifically scheduled to be committed. If you want all changes to be committed, use the <code>-a</code> switch: <pre><code>$ git commit -am \"description of changes\"\n</code></pre> If you only want to commit scheduled files and a file has been changed after being scheduled, add it again to be updated: <pre><code>$ git add &lt;filename&gt;\n</code></pre></p> <p>To push your local changes for a given branch to GitHub, first use <code>git diff</code> to ensure they are correct, then push to origin: <pre><code>$ git diff origin/&lt;branchname&gt; &lt;branchname&gt;\n$ git push origin &lt;branchname&gt;\n</code></pre></p> <p>Never push directly to master </p> <p>After pushing, submit a pull request (click the \"New pull request\" button on the main GitHub page) for your changes to be checked and merged to the master branch.</p>"},{"location":"dev/contribute.html#logs-and-diffs","title":"Logs and diffs","text":"<p>View the diff of the most recent commit: <pre><code>$ git diff HEAD~1\n</code></pre></p> <p>View the log of a particular file (including moves/renames): <pre><code>$ git log --follow -- &lt;filename&gt;\n</code></pre></p> <p>View the commit history for a file showing the detailed diffs for each commit: <pre><code>$ git log -p &lt;filename&gt;\n</code></pre></p> <p>View the commit history of a file/dir when its name is the same as a branch: <pre><code>$ git log -- &lt;filename&gt;\n</code></pre></p> <p>View the diff between one commit and its predecessor: <pre><code>$ git diff &lt;commit_SHA&gt;~1..&lt;commit_SHA&gt;\n</code></pre></p> <p>View only the files that changes for a given range of commits: <pre><code>$ git diff --name-only &lt;SHA1&gt; &lt;SHA2&gt;\n</code></pre></p>"},{"location":"dev/contribute.html#tags","title":"Tags","text":"<p>Specific versions and releases can be identified using tags. </p> <p>List current tags: <pre><code>$ git tag --list\n</code></pre></p> <p>Show details for a specific tag (<code>--quiet</code> hides the diffs): <pre><code>$ git show &lt;tagname&gt; --quiet\n</code></pre></p> <p>By default, checking out a tag puts your repo into a 'detached head' state. Use the following command the first time you check out a tag or a specific commit to create a local branch with that name (this happens automatically when checking out branches): <pre><code>$ git checkout origin/&lt;tag&gt; -b &lt;tagname&gt;\n</code></pre></p> <p>Create a new tag using the following: <pre><code>$ git tag &lt;tagname&gt;\n</code></pre></p> <p>Tags must be explicitly pushed to GitHub. Push your new tag using: <pre><code>$ git push origin &lt;tagname&gt;\n</code></pre></p> <p>Delete a tag using: <pre><code>$ git tag delete &lt;tagname&gt;\n$ git push origin --delete &lt;tagname&gt;\n</code></pre> The second command is only necessary if the tag has been pushed to Github.  </p>"},{"location":"dev/contribute.html#advanced","title":"Advanced","text":"<p>There are many other things that can be done, such as mashing together commits, temporarily \"stashing\" and retrieving stashed changes, etc. Please add anything here that seems useful.</p> <p>Stash your current changes (temporarily set them aside without committing): <pre><code>$ git stash -m \"what is being stashed\"\n</code></pre></p> <p>Retrieve the stashed changes: <pre><code>$ git stash pop\n</code></pre></p> <p>Modify the description of the most recent commit:  </p> <p>Imporant</p> <p>Only use this if the commit has not yet been pushed to GitHub. </p> <pre><code>$ git commit --amend\n</code></pre> <p>For further study please find various Git tutorials online, for example:</p> <p>githowto</p>"},{"location":"dev/docs.html","title":"Getting Started with Documentation","text":"<p>Which branch to use?</p> <p>Please use the <code>mkdocs</code> branch to add/edit your documentation according to the guidelines detailed in this page. Once you are done with your edits, please submit a Pull Request (PR) to get your changes reviewed and merged to the master branch.</p> <p>For PRs that include documentation changes</p> <p>At the beginning of the PR, please add instructions on how one could compile the documentation and what pages should be reviewed. For example, these instructions could include the following: </p> <ul> <li>Checkout the <code>mkdocs</code> branch</li> <li>Run <code>mkdocs serve</code> from the root directory (containing mkdocs.yml)</li> <li>Open and review <code>path/to/edited-or-added-md-files</code></li> </ul>"},{"location":"dev/docs.html#naming-and-organization","title":"Naming and Organization","text":"<p>Where are the documentation files?</p> <p>ShapeWorks documentation is written using Markdown, a text layout language that enables simple formatting for section headers, code samples, weblinks, and images, yet is still readable as plain text. All documentation markdown files are located in the <code>docs/</code> folder. Documentation settings are configured by using the <code>mkdocs.yml</code> configuration file in the ShapeWorks directory.</p> <p>Naming convention</p> <p>To maintain consistency, please use lower-case letters and dashes for your markdown files, e.g., <code>fixed-domain-ellipsoid.md</code>.  </p> <p>Docs organization</p> <p>ShapeWorks documentation is organized into main sections (e.g., \"Getting Started\", \"Use Cases\", ... etc), which map to subfolders in the <code>docs/</code> folder (e.g., \"getting-started\", \"use-cases\", ... etc) and images used in their markdown files are located in the corresponding subfolders in the <code>docs/img</code> folder.</p>"},{"location":"dev/docs.html#adding-call-outs","title":"Adding Call-outs","text":"<p>We are now using the Admonition extension to include side content that is minimally disruptive to the document flow. It is also very useful to a reader's draw attention. Below are some examples.</p> <p>To add a note block with a title, use the following markdown syntax.</p> <pre><code>!!! note \"Title of the note\"\n    Here is a note to keep in mind.\n</code></pre> <p>It will render as follows.</p> <p>Title of the note</p> <p>Here is a note to keep in mind.</p> <p>You can also add a note without a title.</p> <pre><code>!!! note \n    This is a note without a title. This also applies to other call-outs.\n</code></pre> <p>It will render as follows.</p> <p>Note</p> <p>This is a note without a title</p> <p>To make a note (or any call-out collapsable, use <code>???</code> as follows.</p> <pre><code>??? note \n    This is a collapsable note without a title. This also applies to other call-outs.\n</code></pre> <p>It will render as follows.</p> Note <p>This is a collapsable note without a title. This also applies to other call-outs.</p> <p>To add a danger block with a title, use the following markdown syntax.</p> <pre><code>!!! danger \"Don't try this at home\"\n    Seriously don't try this; this is a dangerous step to take.\n</code></pre> <p>It will render as follows.</p> <p>Don't try this at home</p> <p>Seriously don't try this; this is a dangerous step to take.</p> <p>To add an important block without a title, use the following markdown syntax.   </p> <pre><code>!!! important \n    This is an admonition box without a title.\n</code></pre> <p>It will render as follows.</p> <p>Important</p> <p>This is an admonition box without a title.</p>"},{"location":"dev/docs.html#locally-building-documentation","title":"Locally Building Documentation","text":"<p>To see local changes to documentation in realtime, <code>cd</code> to where source documentation (i.e., <code>mkdocs.yml</code>) is maintained and run the following command:</p> <pre><code>mkdocs serve\n</code></pre> <p>This command builds markdown files into HTML and starts a development server to browse the documentation. </p> <p>Open up <code>http://127.0.0.1:8000/</code> in your favorite browser to see the documentation. Changes you make to the markdown files are automatically rebuilt.</p>"},{"location":"dev/docs.html#deploying-on-github-pages","title":"Deploying on GitHub Pages","text":"<p>As ShapeWorks is hosted on GitHub, we use GitHub Pages to host the documentation for ShapeWorks. </p> <p>We use Project Pages sites for documentation deployment. The site files are deployed to the <code>gh-pages</code> branch within the ShapeWorks repository.</p> <p>Deployment is taken care of automatically by GitHub Actions using the script <code>Support/deploy_docs.sh</code></p> <p>Do not edit gh-pages</p> <p>Never manually edit files on the <code>gh-pages</code> branch because you will lose your work the next time the docs are deployed.</p>"},{"location":"dev/docs.html#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>Important</p> <p>If you added a new markdown file to <code>docs/</code>, please make sure to include it in it relevant section in <code>mkdocs.yml</code> to make it accessible.</p> <p>We use GitHub to keep track of issues pertaining to ShapeWorks documentation. For an internal list of todos, which will be turned to issues, visit Documentation ToDo List.</p>"},{"location":"dev/docs.html#inserting-videos-in-documentation","title":"Inserting Videos in Documentation","text":"<p>Request on GitHub for your video to be uploaded to the SCI ShapeWorks server.</p> <p>Insert it in the markdown file using <code>&lt;p&gt;&lt;video src=\"https://sci.utah.edu/~shapeworks/doc-resources/mp4s/video.mp4\" autoplay muted loop controls style=\"width:100%\"&gt;&lt;/p&gt;</code>.</p> <p>Where are the videos stored?</p> <p>On SCI servers, at <code>/usr/sci/www/shapeworks/doc-resources/mp4s/</code>.</p>"},{"location":"dev/docs.html#auto-generating-shapeworks-commands-documentation","title":"Auto-generating ShapeWorks Commands Documentation","text":"<p>The <code>DocumentationUtils</code> package in <code>Python</code> has APIs for auto-documenting command-line tools and to-come-soon python APIs. We use the <code>docs</code> folder to save the generated documentation.</p> <p>To generate documentation for the <code>shapeworks</code> commands, first be sure to run <code>install_shapeworks.sh</code> as described in How to Build ShapeWorks from Source? to install <code>DocumentationUtils</code>.</p> <p>Then, make sure that the <code>shapeworks</code> command is in your path (<code>set PATH=/path/to/shapeworks:$PATH</code>), then use Python to run the following command:</p> <pre><code>$ python Python/RunShapeWorksAutoDoc.py --md_filename docs/tools/ShapeWorksCommands.md\n</code></pre> <p>Parameters:    </p> <ul> <li><code>md_filename</code> is the markdown file name for the documentation file to be generated</li> </ul>"},{"location":"dev/docs.html#auto-generating-c-doxygen-api-documentation","title":"Auto-generating C++ Doxygen API Documentation","text":"<p>To generate C++ Doxygen API output into mkdocs, configure ShapeWorks with BUILD_DOCUMENTATION=ON.</p> <p>After building, run (from the root source directory):</p> <pre><code>$ ./Support/build_docs.sh ${BUILD_DIR}/Documentation/Doxygen/xml\n</code></pre>"},{"location":"dev/docs.html#see-also","title":"See Also","text":"<ul> <li>MkDocs documentation</li> <li>Getting started with MkDocs</li> <li>Setting up MkDocs</li> <li>Projects documentation</li> <li>MkDocs recipes</li> </ul>"},{"location":"dev/gh-actions.html","title":"Getting Started with GitHub Actions","text":"<p>ShapeWorks uses GitHub Actions for automated CI/CD (Continuous Integration / Continuous Deployment).  GitHub Actions will automatically build ShapeWorks pull requests, run automated tests, and build deployable packages (artifacts).</p> <p>Documentation for GitHub Actions is found here</p> <p>The YAML files for ShapeWorks are found in the source code repository in the <code>.github/workflows</code> folder.</p> <p><code>build-linux.yml</code> - GitHub Actions recipe for Linux <code>build-windows.yml</code> - GitHub Actions recipe for Windows <code>build-mac.yml</code> - GitHub Actions recipe for MacOS  </p>"},{"location":"dev/markdown.html","title":"Getting Started with Markdown","text":"<p>ShapeWorks documentation is written using Markdown, a text layout language that enables simple formatting for section headers, code samples, weblinks, and images, yet is still readable as plain text. </p> <p>Note</p> <p>If you are viewing this document in GitHub, you can click on the pencil icon in the top-right corner to see its source. On GitHub, it can be used for issues and wiki documentation and edited inline.</p>"},{"location":"dev/markdown.html#grip","title":"Grip","text":"<p>To edit your Markdown, it helps to have a convenient viewer. The <code>grip</code> instant preview application is beneficial, and is installed by the install_shapeworks script (see How to Build ShapeWorks from Source?. From the ShapeWorks directory, just run <code>grip</code> (be sure to <code>conda activate shapeworks</code> beforehand), and then navigate to <code>http://localhost:6419</code> in your favorite browser. It will load and display markdown files just like GitHub, showing README.md by default. You can also specify relative paths to any markdown file below the directory from which it was run. Happy editing!</p>"},{"location":"dev/markdown.html#markdown-basics","title":"Markdown Basics","text":"<p>ShapeWorks uses Markdown for much of its documentation. Here are the basics of using Markdown. The plain text is readable, and there are many editors available, such as Dillinger. One method is to use a plain text editor along with an automatic rendering tool such as grip to view the formatted results in a browser as the files are edited.</p> <p>Use hash symbols to create section headers. Use more hashes for subsequent subsections. <pre><code># Main section\n## Subsection\n### Sub-subsection\n#### And\n##### so\n###### on... \n</code></pre></p> <p>Links are created by enclosing the text shown for the link in brackets and the link directly adjacent to parenthesis. Links to other '#'-indicated sections of the document are formed using a '#' followed by the lowercase text of the section name separated with dashes. For icons, add some additional brackets and a '!'. external site link text </p> <pre><code>[external site](http://google.com)\n[link text](#local-section-name)\n[![thumbs up](https://66.media.tumblr.com/1f45d6ab69e02479f85ac1c9f1eb4301/tumblr_inline_pkaqpvkvHH1syktzs_540.png)](http://google.com)\n</code></pre> <p>HTML comments can be utilized within a Markdown document if you don't want something shown in the rendered output: <pre><code>&lt;!--\n  commented stuff\n--&gt;\n</code></pre></p> <p>Finally, code can be shown using triple back-ticks (the backward apostrophe: '`' ), even highlighted for a particular language by following the first set of back-ticks with the language name.  </p> <pre><code>```python  \nprint(\"Hello Markdown!\")\n```  \n</code></pre> <pre><code>print(\"Hello Markdown!\")\n</code></pre> <p>Use just a single tick to keep monospaced text <code>inline with the rest of the text</code>.</p> <p>You can also add tables, quoted text like you'd see in an email, bulleted items, images and more. Here are several Markdown quick references.</p> <p>To quickly turn a URL or email address into a link, enclose it in angle brackets.</p> <p><code>&lt;https://www.markdownguide.org&gt;</code> <code>&lt;fake@example.com&gt;</code></p> <p>renders as</p> <p>https://www.markdownguide.org fake@example.com</p>"},{"location":"dev/markdown.html#see-also","title":"See Also","text":"<p>GitHub Markdown Markdown Guide Markdown Editors</p>"},{"location":"dev/new-notebook.html","title":"How to Add a New Notebook?","text":"<p>Adding a new use case entails the following.</p> <ul> <li>Creating a notebook</li> <li>Notebook documentation </li> </ul>"},{"location":"dev/new-notebook.html#creating-a-notebook","title":"Creating a notebook","text":"<p>To add a new notebook to the codebase: </p> <ul> <li>Add <code>&lt;notebook-name&gt;.ipynb</code> to <code>Examples/Python/tutorials/notebooks/</code>, where the <code>&lt;notebook-name&gt;</code> is a descriptive name for what is demonstrated in the notebook.</li> <li>Include links to other notebooks explaining how to import shapeworks and define visualization functions. </li> <li>Before checking in a notebook in clear all output by clicking <code>Kernel -&gt; Restart &amp; Clear Output</code>.</li> </ul>"},{"location":"dev/new-notebook.html#notebook-documentation","title":"Notebook documentation","text":"<p>Screenshots and videos of all notebook output should be added so that a user can view notebook output without running the notebook.</p>"},{"location":"dev/new-notebook.html#adding-a-video-to-a-notebook","title":"Adding a video to a notebook","text":"<ol> <li>Capture a screen recording in the format '.gif' or '.mp4'.</li> <li>To screen record on Mac: Use <code>Shift + cmd + 5</code> to begin recording. This will generate a '.mov' video which can be converted to '.mp4' using the command line tool <code>FFmpeg</code>.</li> <li>To screen record on Linux: The open source software 'XVidCap Screen Capture' can be downloaded and used to record screen videos. The video can then be saved in any format.</li> <li>To screen record on Windows: Use <code>Windows key + Alt + R</code> to begin recording. The video format can be converted using the command line tool <code>FFmpeg</code>.</li> <li>Copy the image or video to <code>/usr/sci/www/shapeworks/doc-resources/</code>. This requires access to the 'shapeworks' group which SCI support can grant. </li> <li>Add a markdown cell to the notebook that includes the video source. For example:     <pre><code>&lt;p&gt;&lt;video src=\"https://sci.utah.edu/~shapeworks/doc-resources/mp4s/example-video.mp4\" autoplay muted loop controls style=\"width:100%\"&gt;&lt;/p&gt;\n</code></pre> Once all output is included as an image or video in the notebook, add a copy of the notebook to <code>/ShapeWorks/docs/notebooks/</code>. Then update <code>/ShapeWorks/mkdocs.yml</code> to include the new notebook. </li> </ol>"},{"location":"dev/new-use-case.html","title":"How to Add New Use Cases?","text":"<p>Adding a new use case entails the following.</p> <ul> <li>Python-scripted workflow</li> <li>Use case dataset</li> <li>Use case documentation </li> </ul>"},{"location":"dev/new-use-case.html#python-scripted-workflow","title":"Python-scripted workflow","text":"<p>To add a new use case to the codebase: </p> <ul> <li>Add <code>&lt;use-case-name&gt;.py</code> python script to <code>Examples/Python/</code>, where the <code>&lt;use-case-name&gt;</code> is a descriptive name for the use case, typically associated with the class of shapes to be modeled (e.g., anatomy name)</li> <li>Update <code>Examples/Python/RunUseCase.py</code> to add the new use case to the list of cases. Look for the line <code>parser.add_argument(\"--use_case\" ...)</code>. Make sure to use the <code>&lt;use-case-name&gt;</code> to the use case list.</li> <li>Each use case needs to include the option to run a tiny test, which typically runs on only the first three shapes. </li> <li>Each use case needs to have the option to run on a representative subsample of the dataset of any size. This subsample is selected via clustering on the shapes and selecting one shape from each cluster. </li> </ul>"},{"location":"dev/new-use-case.html#use-case-dataset","title":"Use case dataset","text":"<p>To add the dataset associated with the new use case:</p> <ul> <li>Upload the datset to ShapeWorks Cloud</li> </ul>"},{"location":"dev/new-use-case.html#use-case-documentation","title":"Use case documentation","text":"<p>To add the documentation of the new dataset, add a markdown file <code>&lt;use-case-name&gt;.md</code> in <code>docs/use-cases</code> with the following structure. Please use the Naming and Organization conventions currently deployed for ShapeWorks documentation. Then, add a corresponding entry in <code>mkdocs.yml</code>.</p> <p>Important</p> <p>If you use the documentation of an existing use case as a starting point, PLEASE make sure to adapt the documentation to your new use case. </p> <p>Important</p> <p>PLEASE, use a spell and grammar checker (e.g., grammarly).</p> <ul> <li>What is the Use Case?: The goal of this use case, i.e., what does this use case demonstrate about ShapeWorks? Details about the dataset, e.g., number of samples, class of shapes, shape representation (meshes, segmentation, or contours), dataset source ... etc.</li> <li>Grooming Steps: Details about the data preprocessing pipeline for this use case that highlights specific considerations for this use case. Snapshots of intermediate and final groom outputs for illustration.</li> <li>Supported Tags: List of tags that can be used with the use case.</li> <li>Optimization Parameters: Default optimization parameters used for this use case, including a discussion of intuitions/insights on how these parameters were chosen.</li> <li>Analyzing Shape Model: Videos and snapshots of the optimized shape model(s), including the mean shape, scree plot, modes of variations, and individual samples. When applicable, also include videos and snapshots of results that are specific to the use case (e.g., group differences, linear discriminant analysis ... etc.).</li> </ul>"},{"location":"dev/onboarding.html","title":"ShapeWorks Developer Onboarding","text":"<p>Welcome to ShapeWorks Development!</p> <p>This page contains pointers to help get you started building and developing with ShapeWorks.</p>"},{"location":"dev/onboarding.html#git","title":"Git","text":"<p>A brief introduction to how Git is used with ShapeWorks can be found in the section, How to Contribute to ShapeWorks? </p> <p>Also highly recommended is the Git How To.</p>"},{"location":"dev/onboarding.html#github","title":"GitHub","text":"<p>The ShapeWorks Git repository is hosted on GitHub:</p> <p>https://github.com/SCIInstitute/ShapeWorks</p> <p>As described in the section about Git, the ShapeWorks team uses Pull Requests (PR) with peer review to integrate changes.  </p> <p>Pull Requests with new features should include automated tests using the Google Test framework.  Please look at existing tests for examples.</p>"},{"location":"dev/onboarding.html#coding-style-guide","title":"Coding Style Guide","text":"<p>We adopt the Google Style Guide for C++ coding style.</p>"},{"location":"dev/onboarding.html#c-core-guidelines","title":"C++ Core Guidelines","text":"<p>A highly recommended resource for C++ are the C++ Core Guidelines.</p>"},{"location":"dev/onboarding.html#building-shapeworks","title":"Building ShapeWorks","text":"<p>Please see: How to Build ShapeWorks from Source?</p>"},{"location":"dev/onboarding.html#continuous-integration-continuous-delivery","title":"Continuous Integration / Continuous Delivery","text":"<p>Each pull request triggers builds on Windows, Mac, and Linux runners using GitHub Actions.  More about GitHub Actions with ShapeWorks can be found here.</p> <p>Build artifacts are created for each build and kept automatically for a period of time.  These are full binary installers suitable for end-user install.</p>"},{"location":"dev/paths.html","title":"Adding Environment Variables for Development","text":"<p>This is unnecessary for users!</p> <p>Users only need to activate their conda environments (<code>conda activate shapeworks</code>). In the past, setting PATH was necessary. Now it will only cause problems. </p> <p>The simplest way for developers</p> <p>A script called devenv is provided to setup developer environments on all platforms.</p>"},{"location":"dev/paths.html#using-devenv-script-to-configure-developer-environment","title":"Using devenv script to configure developer environment","text":"<p>The devenv script, short for developer environment, only requires one parameter: the path to the build binaries. It infers the source path from its own location.  </p> <p>It configures the environment of the terminal from which it is sourced such that:  </p> <ul> <li>PATH and PYTHONPATH point to $BUILD_BIN directory  </li> <li>PYTHONPATH points to each module in $SOURCE/Python  </li> </ul> <p>This is very useful for development, since after sourcing this, processes in the environment will use executables from the given build and import modules from the developer's source--this includes the compiled portion of the Python bindings!</p> <p>It dramatically reduces the probability of using the wrong paths for testing, and eliminates the need to pip install any of the Python modules during development.</p> <p>As an example of using it with a make-based build directory inside source on Linux or OSX: <pre><code>(shapeworks) ~/code/ShapeWorks$ source ./devenv.sh ./build/bin\n</code></pre></p> <p>On Windows, to point to the RelWithDebInfo binaries in a build directory inside source: <pre><code>(shapeworks) ~/code/ShapeWorks&gt; devenv .\\build\\bin\\RelWithDebInfo\n</code></pre></p> <p>Using git-bash on Windows</p> <p>Windows may also have a git-bash command line available. This also works with <code>devenv</code>: just <code>source ./devenv.sh</code> like you would on linux/osx. There is one important issue: running Python scripts requires prefixing with <code>winpty</code>. For example, <code>winpty python RunUseCase.py ...</code>.</p> <p>Any path can be passed as the parameter for this script and it can be called from any location. Another example: <pre><code>(shapeworks) ~/code/ShapeWorks/build_xcode/bin/Debug$ source ../../devenv.sh Debug\n</code></pre></p>"},{"location":"dev/paths.html#manually-adding-paths","title":"Manually adding paths","text":"<p>While unnecessary for the use of ShapeWorks, these are the steps to manually add items to your paths.</p>"},{"location":"dev/paths.html#osxlinux","title":"OSX/Linux","text":"<p><code>$ export PATH=path/to/add:$PATH</code> </p> <p>Verify the results with the command: <code>$ echo $PATH</code> </p>"},{"location":"dev/paths.html#windows","title":"Windows","text":"<p><code>$ set PATH=path/to/add;%PATH%</code> This only modifies the path for the current command prompt.  </p> <p>To permanently add to the path (or so you can remove what has previously been added):  </p> <ul> <li>Go to Settings/Edit the system environment variables/Environment Variables </li> <li>Choose the Path variable and press Edit... </li> <li>Add your path entry to the list  </li> </ul> <p>Verify the results with the command: <code>$ echo %PATH%</code> </p>"},{"location":"dev/python-apis.html","title":"How to Add Python APIs?","text":"<p>Python APIs in ShapeWorks are pybind wrappers of C++ functions and additions/modifications can be made in Python/shapeworks/ShapeworksPython.cpp</p> <ul> <li> <p>Header file must be included.</p> </li> <li> <p>To add a new class,</p> </li> </ul> <pre><code>py:class_&lt;c++ClassName&gt; objectName(m, \"pythonClassName);\n</code></pre> <ul> <li>To add a new function,</li> </ul> <pre><code>objectName.def(\"pythonFunctionName\", &amp;c++ClassName::c++FunctionName, \"description/help\", \"argument1\"_a, \"argument2\"_a=defaultValue)\n</code></pre> <p>For more information on how to add pybind bindings, check out pybind documentation.</p>"},{"location":"dev/release-process.html","title":"ShapeWorks Release Process","text":"<p>This document outlines the steps to release a new version of ShapeWorks.</p> <ul> <li> <p>Create a new branch for the release.  E.g. <code>git co -b release_v6.5</code></p> </li> <li> <p>Update the version number in <code>CMakeLists.txt</code></p> </li> </ul> <pre><code>SET(SHAPEWORKS_MAJOR_VERSION 6 CACHE INTERNAL \"Major version number\" FORCE)\nSET(SHAPEWORKS_MINOR_VERSION 5 CACHE INTERNAL \"Minor version number\" FORCE)\nSET(SHAPEWORKS_PATCH_VERSION 0 CACHE INTERNAL \"Patch version number\" FORCE)\nSET(SHAPEWORKS_VERSION_STRING \"6.5.0-RC1\")\nSET(SHAPEWORKS_VERSION \"${SHAPEWORKS_MAJOR_VERSION}.${SHAPEWORKS_MINOR_VERSION}.${SHAPEWORKS_PATCH_VERSION}\")\n</code></pre> <ul> <li>Confirm the API version is set correctly in the following files</li> </ul> <p>TODO - This should be automated from a single place</p> <ul> <li><code>Studio/Python/PythonWorker.h</code></li> </ul> <pre><code>  constexpr static const char* python_api_version = \"6.5\";\n</code></pre> <ul> <li><code>Python/shapeworks/shapeworks/utils.py</code></li> </ul> <pre><code>def get_api_version():\n    return \"6.5\"\n</code></pre> <ul> <li><code>install_shapeworks.sh</code> </li> </ul> <pre><code>SW_MAJOR_VERSION=6.5\n</code></pre> <ul> <li><code>install_shapeworks.bat</code></li> </ul> <pre><code>python -c \"import sys; print('\\n'.join(sys.path))\" &gt; \"%USERPROFILE%\\.shapeworks\\python_path_6.5.txt\"\npython -c \"import sys; print(sys.prefix)\" &gt; \"%USERPROFILE%\\.shapeworks\\python_home_6.5.txt\"\necho %PATH% &gt; \"%USERPROFILE%\\.shapeworks\\path_6.5.txt\"\n</code></pre> <ul> <li> <p>Update Release Notes</p> </li> <li> <p>Update <code>docs/about/release_notes.md</code> with the new release notes</p> </li> <li> <p>Create Walkthrough Video</p> </li> <li> <p>Update Documentation</p> </li> <li>Update release screenshot in <code>docs/index.md</code></li> <li> <p>Add tour video to <code>docs/index.md</code></p> </li> <li> <p>When release candidate is final, set the version number in <code>CMakeLists.txt</code> to the final version number</p> </li> <li> <p>After the release, set the version to the next development version</p> </li> </ul>"},{"location":"dev/shapeworks-library.html","title":"Using ShapeWorks as a library","text":"<p>ShapeWorks can be used as a library, for example as part of an ITK based application.  To do so, when building ShapeWorks, specify CMAKE_INSTALL_PREFIX and use <code>make install</code>:</p> <pre><code>$ ccmake -DCMAKE_INSTALL_PREFIX=&lt;/path/to/sw/install&gt;\n$ make install\n</code></pre> <p>An example using ShapeWorks as a library in an ITK application is given in <code>Examples/C++</code></p> <p>CMakeLists.txt:</p> <pre><code>cmake_minimum_required(VERSION 3.10.2)\n\nproject(HelloShapeWorksItk)\n\nset(CMAKE_CXX_STANDARD 17)\n\n# Find ShapeWorks\nfind_package(ShapeWorks REQUIRED)\n\nSET(CMAKE_EXE_LINKER_FLAGS \"-Wl,--disable-new-dtags\")\n\n# Find ITK\n#find_package(ITK REQUIRED)\n#include(${ITK_USE_FILE})\n\nadd_executable(HelloShapeWorksItk HelloShapeWorksItk.cpp)\n\ntarget_link_libraries(HelloShapeWorksItk\n  ${ITK_LIBRARIES}\n  shapeworks::Optimize\n  shapeworks::Groom\n  shapeworks::Analyze\n  pybind11::embed\n  )\n</code></pre> <p>HelloShapeWorksItk.cpp: <pre><code>#include &lt;iostream&gt;\n\n// itk includes\n#include \"itkImage.h\"\n#include \"itkMesh.h\"\n#include \"itkRegularSphereMeshSource.h\"\n#include \"itkMeshFileWriter.h\"\n#include \"itkMeshIOFactory.h\"\n#include \"itkVTKPolyDataMeshIOFactory.h\"\n\n// shapeworks includes\n#include &lt;Project/Project.h&gt;\n#include &lt;Groom/Groom.h&gt;\n#include &lt;Optimize/OptimizeParameters.h&gt;\n#include &lt;Optimize/Optimize.h&gt;\n#include &lt;Analyze/Analyze.h&gt;\n\nconstexpr unsigned int Dimension = 3;\nusing TCoordinate = float;\nusing TMesh = itk::Mesh&lt;TCoordinate, Dimension&gt;;\nusing TSphere = itk::RegularSphereMeshSource&lt;TMesh&gt;;\nusing TMeshWriter = itk::MeshFileWriter&lt;TMesh&gt;;\n\nvoid create_sphere(double radius, std::string name) {\n  // Create the sphere source.\n  auto sphere = TSphere::New();\n\n  TSphere::VectorType scale;\n  scale.Fill( radius );\n  sphere-&gt;SetScale( scale );\n  sphere-&gt;SetResolution( 5 );\n  sphere-&gt;Update();\n\n  // We now assign it to a mesh pointer.\n  TMesh::Pointer mesh = sphere-&gt;GetOutput();\n\n  // It is necessary to disconnect the mesh from the pipeline;\n  // otherwise, the point and cell data will be deallocated\n  // when we call \"Update()\" on the writer later in the program.\n  mesh-&gt;DisconnectPipeline();\n\n  auto mesh_writer = TMeshWriter::New();\n  mesh_writer-&gt;SetFileName(name);\n  mesh_writer-&gt;SetInput(mesh);\n  mesh_writer-&gt;Update();\n}\n\nint main() {\n\n  itk::VTKPolyDataMeshIOFactory::RegisterOneFactory();\n  // auto registeredIOs = itk::ObjectFactoryBase::CreateAllInstance( \"itkMeshIOBase\" );\n\n  typedef itk::Image&lt; unsigned short, 3 &gt; ImageType;\n  ImageType::Pointer image = ImageType::New();\n\n  std::cout &lt;&lt; \"Hello ShapeWorks ITK World!\" &lt;&lt; std::endl;\n\n  // create a ShapeWorks Project\n  auto project = std::make_shared&lt;shapeworks::Project&gt;();\n\n  std::cout &lt;&lt; \"Step 1: Use ITK to generate input data\\n\";\n  for (int i=5;i&lt;9;i++) {\n    auto filename = \"mesh\" + std::to_string(i) + \".vtk\";\n    std::cout &lt;&lt; \"Creating input file: \" &lt;&lt; filename &lt;&lt; \"\\n\";\n    create_sphere(i, filename);\n    auto subject = std::make_shared&lt;shapeworks::Subject&gt;();\n    subject-&gt;set_original_filenames({filename});\n    project-&gt;get_subjects().push_back(subject);\n  }\n\n  // groom the inputs\n  std::cout &lt;&lt; \"Step 2: Groom Inputs\\n\";\n  shapeworks::Groom groom{project};\n  groom.run();\n\n  // create a ShapeWorks Optimizer\n  std::cout &lt;&lt; \"Step 3: Creating Shape Model\\n\";\n  shapeworks::Optimize optimize;\n  shapeworks::OptimizeParameters params(project);\n  params.set_up_optimize(&amp;optimize);\n  optimize.SetProject(project);\n\n  // run the optimizer\n  bool success = optimize.Run();\n  project-&gt;save(\"HelloShapeWorksItk.swproj\");\n\n  // perform analysis\n  std::cout &lt;&lt; \"Step 4: Analyze\\n\";\n  shapeworks::Analyze analyze{project};\n  analyze.run_offline_analysis(\"analysis.json\");\n\n  return 0;\n}\n</code></pre></p> <p>Configure using <code>-DShapeWorks_DIR</code> and the prefix module path used for building ShapeWorks. For example:</p> <pre><code>cd /path/to/shapeworks/Examples/C++\nmkdir build\ncd build\ncmake .. -DShapeWorks_DIR=&lt;/path/to/sw/install&gt;/lib/cmake/ShapeWorks -DCMAKE_PREFIX_PATH=&lt;/path/to/shapeworks/dependencies/install&gt;\n</code></pre> <p>Build: <pre><code>make\n</code></pre></p> <p>Run: <pre><code>./HelloShapeWorksItk\n</code></pre></p> <p>Output: <pre><code>Hello ShapeWorks ITK World!\nStep 1: Use ITK to generate input data\nCreating input file: mesh5.vtk\nCreating input file: mesh6.vtk\nCreating input file: mesh7.vtk\nCreating input file: mesh8.vtk\nStep 2: Groom Inputs\nStep 3: Creating Shape Model\nShapeWorks: TBB using 16 threads\nVerbosity 0: This will be the only output on your screen, unless there are any errors. Increase the verbosity if needed.\nStep 4: Analyze\n[2022-10-02 23:31:39.663] [info] ShapeWorks Offline Analysis\n[2022-10-02 23:31:39.663] [info] number of subjects: 4\n[2022-10-02 23:31:39.665] [info] Computing stats...\n[2022-10-02 23:31:39.665] [info] Computed stats successfully\n[2022-10-02 23:31:39.665] [info] number of modes: 3\n[2022-10-02 23:31:39.676] [info] eigen value [0]: 213.72417259473602\n[2022-10-02 23:31:39.676] [info] explained_variance [0]: 99.12\n[2022-10-02 23:31:39.676] [info] cumulative_explained_variance [0]: 99.12\n[2022-10-02 23:31:39.793] [info] eigen value [1]: 1.8944878261819007\n[2022-10-02 23:31:39.793] [info] explained_variance [1]: 0.88\n[2022-10-02 23:31:39.793] [info] cumulative_explained_variance [1]: 100.00\n[2022-10-02 23:31:39.902] [info] eigen value [2]: 0.0016418139547566765\n[2022-10-02 23:31:39.902] [info] explained_variance [2]: 0.00\n[2022-10-02 23:31:39.902] [info] cumulative_explained_variance [2]: 100.00\n</code></pre></p>"},{"location":"dev/tests.html","title":"How to Add and Run Unit Tests?","text":""},{"location":"dev/tests.html#running-shapeworks-automated-tests","title":"Running ShapeWorks Automated Tests","text":"<p>To run the automated tests, after building, run:</p> <p>$ ctest</p> <p>or</p> <p>$ make test</p> <p>If using Unix Makefile, for example</p>"},{"location":"dev/tests.html#adding-new-shapeworks-automated-tests","title":"Adding New ShapeWorks Automated Tests","text":"<p>Depending on the type of operation to be tested, they should be defined in the associated Tests.cpp</p> <p>Testing from C++ interface:</p> <ul> <li>For project related functions, use Testing/GroomTests/GroomTests.cpp  </li> <li>For image related functions, use Testing/ImageTests/ImageTests.cpp  </li> <li>For mesh related functions, use Testing/MeshTests/MeshTests.cpp  </li> <li>For optimize related functions, use Testing/OptimizeTests/OptimizeTests.cpp  </li> <li>For particles related functions, use Testing/ParticlesTests/ParticlesTests.cpp  </li> </ul> <pre><code>TEST(typeofoperationTests, nameoftestTest)\n{\n  // define test\n\n  ASSERT_TRUE(); // compare result\n}\n</code></pre> <p>For testing from Python interface, use Testing/PythonTests/PythonTests.cpp Python scripts should be added to Testing/PythonTests</p> <pre><code>TEST(pythonTests, nameoftestTest)\n{\n  run_use_case(\"script.py\");\n}\n</code></pre> <p>For testing from Command Line interface, use Testing/shapeworksTests/shapeworksTests.cpp Shell scripts should be added to Testing/shapeworksTests</p> <pre><code>TEST(shapeworksTests, nameoftestTest)\n{\n  run_use_case(\"script.sh\");\n}\n</code></pre> <p>Testing data should be placed in Testing/data.</p>"},{"location":"getting-started/examples.html","title":"Examples","text":"<p>Visit Getting Started with Use Cases for information about downloading a use case dataset and running use cases. Here we list the available use cases grouped according to different categories based on their unique features.</p>"},{"location":"getting-started/examples.html#segmentation-based-use-cases","title":"Segmentation Based Use Cases","text":"<p>This use case set demonstrates the Shape Modeling Workflow on segmentation images.</p>"},{"location":"getting-started/examples.html#ellipsoid-basic-example","title":"Ellipsoid: Basic Example","text":"<p>This example is a stepping stone for the user to get familiar with the workflow of ShapeWorks. This use case represents the standard ShapeWorks workflow on a synthetically generated ellipsoid dataset, including the entire grooming process.</p>"},{"location":"getting-started/examples.html#left-atrium-shape-model-from-segmentations","title":"Left Atrium: Shape Model from Segmentations","text":"<p>This use case demonstrates using the ShapeWorks functionality to groom real segmentations and corresponding imaging data (e.g., MRI) of a real-world left atrium dataset. This use case also showcases a single-scale and multi-scale optimization for correspondence models.</p>"},{"location":"getting-started/examples.html#fixed-domains-ellipsoid-shape-model-on-new-shapes","title":"Fixed Domains Ellipsoid: Shape Model on New Shapes","text":"<p>This use case is designed to demonstrate the functionality of the fixed domain of ShapeWorks. Fixed domains are used for the cases where we need to place correspondences on new shapes using a pre-existing shape model.</p>"},{"location":"getting-started/examples.html#shape-model-for-multiple-domains-from-segmentations","title":"Shape Model for Multiple Domains from Segmentations","text":"<p>This use case demonstrates using ShapeWorks to perform shape modelings for anatomies with multiple structures (domains), e.g., joints, to capture inter-domain correlations and interactions on segmentation images. This use case uses a synthetically generated ellipsoid joint dataset. This use case exhibits how local alignment can be performed for multiple domain datasets.</p>"},{"location":"getting-started/examples.html#mesh-based-use-cases","title":"Mesh-Based Use Cases","text":"<p>This use case demonstrates the Shape Modeling Workflow directly on meshes. Currently, mesh-based use cases run on pre-groomed meshes. They will be updated soon to demonstrate mesh grooming.</p>"},{"location":"getting-started/examples.html#ellipsoid-mesh-basic-example","title":"Ellipsoid Mesh: Basic Example","text":"<p>This use case uses the same dataset as the Ellipsoid: Basic Example use case, but optimization is done on meshes rather than distance transforms.</p>"},{"location":"getting-started/examples.html#lumps-shape-model-directly-from-mesh","title":"Lumps: Shape Model directly from Mesh","text":"<p>This use case demonstrates a minimal example of running ShapeWorks directly on a mesh using a synthetic dataset. The shapes in this dataset are spheres with two lumps or nodes that vary in size. The use case demonstrates that the ShapeWorks workflow results in a correct shape model- i.e., only the position of particles on the lumps vary; the rest are constant across the shape population.</p>"},{"location":"getting-started/examples.html#thin-cavity-bean-shape-model-with-geodesic-distances","title":"Thin Cavity Bean: Shape Model with Geodesic Distances","text":"<p>This use case demonstrates using ShapeWorks tools to perform Geodesic distance-based repulsion for mesh domains. The dataset comprises ellipsoids or beans with a thin cavity where the shapes vary only in the location of the thin cavity. This use case demonstrates that ShapeWorks optimization with geodesic distance can correctly capture this single mode of variation.</p>"},{"location":"getting-started/examples.html#shape-model-for-multiple-domains-directly-from-mesh","title":"Shape Model for Multiple Domains directly from Mesh","text":"<p>This use case uses the same dataset as the Shape Model for Multiple Domains from Segmentations; use case optimization is done on meshes rather than distance transforms.  </p>"},{"location":"getting-started/examples.html#contour-based-use-cases","title":"Contour Based Use Cases","text":""},{"location":"getting-started/examples.html#supershapesshape-model-for-contour-domains","title":"Supershapes:Shape Model for Contour Domains","text":"<p>This use case demonstrates using ShapeWorks tools to perform optimization for N-dimensional contours. Contours are represented as a series of lines that may be a closed loop. </p>"},{"location":"getting-started/examples.html#constraints-based-use-cases","title":"Constraints Based Use Cases","text":""},{"location":"getting-started/examples.html#ellipsoid-shape-model-with-cutting-planes","title":"Ellipsoid: Shape Model with Cutting Planes","text":"<p>This use case demonstrates using multiple cutting planes to constrain the distribution of particles on ellipsoids that are already aligned. Cutting planes can be used in modeling scenarios where statistical modeling/analysis is needed for a region of interest in the anatomy/object class without affecting the input data. </p>"},{"location":"getting-started/examples.html#femur-shape-model-from-meshes-with-cutting-planes","title":"Femur: Shape Model from Meshes with Cutting Planes","text":"<p>This use case demonstrates using shape modeling workflow using ShapeWorks on a real-world femur dataset. It involves performing grooming on femur meshes and corresponding imaging data (CT scans) of the hip. The femur meshes in this dataset have been segmented with various shaft lengths, so cutting planes are used in optimization to remove this variability, preventing it from being captured in the shape model. Cutting planes can limit the statistical analysis to the standard anatomical regions across all samples.</p>"},{"location":"getting-started/examples.html#multi-step-optimization-use-cases","title":"Multi-Step Optimization Use Cases","text":""},{"location":"getting-started/examples.html#fixed-domains-ellipsoid-shape-model-on-new-shapes_1","title":"Fixed Domains Ellipsoid: Shape Model on New Shapes","text":"<p>This use case is designed to demonstrate the functionality of the fixed domain of ShapeWorks. Fixed domains are used for the cases where we need to place correspondences on new shapes using a pre-existing shape model. </p>"},{"location":"getting-started/examples.html#incremental-supershapes-building-a-shape-model-incrementally","title":"Incremental Supershapes: Building a Shape Model Incrementally","text":"<p>This use case demonstrates how a shape model can be built incrementally. In this case, by initially fitting a model on the most similar shapes, then incrementally adding outlier shapes, we can achieve a more compact shape model with better correspondence than if we were to optimize the whole dataset at once.</p>"},{"location":"getting-started/examples.html#studio-femur-shape-model-from-meshes-with-cutting-planes-using-studio","title":"Studio Femur: Shape Model from Meshes with Cutting Planes Using Studio","text":"<p>This use case demonstrates using shape modeling workflow using ShapeWorks on real-world femur dataset. This tutorial use-case teaches you how to use constraints in Studio to limit the statistical analysis to certain anatomical regions.</p>"},{"location":"getting-started/examples.html#statistics-based-use-cases","title":"Statistics Based Use Cases","text":""},{"location":"getting-started/examples.html#femur-group-difference-statistics-in-python","title":"Femur: Group Difference Statistics in Python","text":"<p>This use case demonstrates the functionality of shape statistics tools to perform hypothesis testing of group shape differences. It also shows the use of Linear Discrimination of Variation (LDA) for analyzing shape variation between the subgroups of patients. This use case explores the femur shape model obtained from running the Femur: Shape Model on Distance Transforms from Meshes use case. </p>"},{"location":"getting-started/examples.html#ellipsoid-shape-statistics-in-python","title":"Ellipsoid: Shape Statistics in Python","text":"<p>This use case demonstrates the functionality of shape statistics tools of ShapeWorks python API. These APIs include reading particle files and computing eigenvectors, eigenvalues, and PCA loadings. This use case reads the correspondence model of the Ellipsoid: Basic Example use case.</p>"},{"location":"getting-started/examples.html#ellipsoid-shape-evaluation-in-python","title":"Ellipsoid: Shape Evaluation in Python","text":"<p>This use case demonstrates the functionality of shape evaluation tools of ShapeWorks python API. These APIs include the calculation of quantitative evaluation metrics such as specificity, generalization, and compactness.For detailed explanation of the evaluation metrics, refer to Shape Model Evaluation. </p>"},{"location":"getting-started/examples.html#deep-learning-based-use-cases","title":"Deep Learning Based Use Cases","text":""},{"location":"getting-started/examples.html#femur-shape-model-directly-from-images","title":"Femur Shape Model Directly from Images","text":"<p>This use case demonstrates how to get shape models from unsegmented images using deep learning on the femur data. This includes performing data augmentation and building, training, and testing a DeepSSM model. For a detailed description of these processes, please see Data Augmentation for Deep Learning and SSMs Directly from Images.</p>"},{"location":"getting-started/examples.html#shared-boundary-use-cases","title":"Shared Boundary Use Cases","text":""},{"location":"getting-started/examples.html#peanut-shape-model-of-multiple-domains-with-shared-boundaries","title":"Peanut: Shape Model of Multiple Domains with Shared Boundaries","text":"<p>This use case demonstrates using ShapeWorks tools to perform shape modelings for anatomies with multiple structures (domains), e.g., joints, with shared boundaries to capture inter-domain correlations and interactions.</p>"},{"location":"getting-started/examples.html#your-use-case","title":"Your Use Case","text":"<p>You can use any of these use cases as a starting point and customize it to your dataset.</p> <p>In <code>Examples/notebooks/tutorials</code>, we provide step-by-step, hands-on tutorials on different aspects of the shape modeling workflow in a transparent, reproducible, and sharable manner. For this purpose, we have chosen Juypter Notebooks as the front-end tools for these demonstrations. These hands-on tutorials are designed to reflect the thought process that a non-expert user could go through during different shape modeling phases, starting from processing or grooming your data to analyze your optimized shape model. See ShapeWorks in Python for more details.</p> <p>ShapeWorks with Python support.</p> <p>ShapeWorks Python library is currently under active development and is part of our major releases as of ShapeWorks 6.</p> <p>Please contact ShapeWorks team if you need further questions and guidance. Software maintenance and support are provided within the funding period.</p>"},{"location":"getting-started/how-tos.html","title":"How-Tos","text":"<p>Important</p> <p>When using up-to-date development builds from the master branch, please understand that these are in-progress development builds, not official releases.</p> <ul> <li>How to install ShapeWorks on Windows, Mac, or Linux.</li> <li>How to get the latest ShapeWorks binary release or up-to-date development builds from the master branch for Windows, Mac, or Linux. </li> <li>How to run and see ShapeWorks in action on exemplar use cases. </li> <li>How to preprocess or groom your dataset.</li> <li>How to optimize your shape model.</li> <li>How to visualize and analyze your optimized shape model.</li> <li>How to get started with ShapeWorks in Python.</li> <li>How to contact ShapeWorks team to help you customize a use case to your own dataset.</li> <li>How to build ShapeWorks from source (for developers).</li> <li>How to auto-generate documentation for ShapeWorks interfaces and code (for developers).</li> </ul>"},{"location":"getting-started/interfaces.html","title":"ShapeWorks Interfaces","text":"<p>ShapeWorks tools are designed to support different usage scenarios, including execution on a local computing platform through the terminal (command line) and the user-friendly Studio application, APIs including Python, and remote systems such as private or public clouds. </p>"},{"location":"getting-started/interfaces.html#shapeworks-command","title":"ShapeWorks Command","text":"<p>ShapeWorks consists of a set of independent command line tools for preprocessing binary segmentations and surface meshes (Groom) and computing landmark-based shape models (Optimize). It also includes an interactive user interface called ShapeWorks Studio to analyze and visualize the optimized shape models (Analyze). </p> <p>We are consolidating these tools into a single, reusable API that is shared across different computational libraries in ShapeWorks, and a standalone <code>shapeworks</code> command. Visit ShapeWorks Command for an illustrative example.</p> <p>The <code>shapeworks</code> executable is highly flexible, modular, and loosely coupled, with standardized subcommands and interactive help to perform individual operations needed for a typical shape modeling workflow that includes the Groom, Optimize, and Analyze phases. Please see shapeworks commands documentation for the list of available commands.</p> <p>Activate shapeworks environment</p> <p>Each time you use ShapeWorks from the command line, you must first activate its environment using the <code>conda activate shapeworks</code> command on the terminal.</p>"},{"location":"getting-started/interfaces.html#shapeworks-in-python","title":"ShapeWorks in Python","text":"<p>We are developing Python bindings to enable users to script their customized shape modeling workflows. See ShapeWorks in Python for more details and pointers to step-by-step, hands-on tutorials on different aspects of the shape modeling workflow in a transparent, reproducible, and sharable manner.</p> <p>ShapeWorks with Python support</p> <p>ShapeWorks Python library is currently under active development and is part of our major releases as of ShapeWorks 6. </p> <p>About use cases</p> <p>Exemplar use cases will be updated to use these Python APIs to showcase their use and flexibility.</p>"},{"location":"getting-started/interfaces.html#shapeworks-studio","title":"ShapeWorks Studio","text":"<p>ShapeWorks Studio is a cross-platform graphical user interface (GUI) to support the standard shape analysis workflow needed by most ShapeWorks users, enabling a wide variety of research scenarios. It is currently supporting image-based grooming and is actively under development to support surface meshes, more sophisticated grooming operations (including user annotations), and offline processing.  ShapeWorks Studio enables real-time parameter tuning and visualization of the optimization process and statistical analyses.</p> <p> <p>For more information about ShapeWorks Studio, see here</p>"},{"location":"getting-started/interfaces.html#shapeworks-in-the-cloud","title":"ShapeWorks in the Cloud","text":"<p>Work in progress ... Stay tuned!</p> <p></p>"},{"location":"getting-started/shapes.html","title":"Shapes, What &amp; From Where?","text":""},{"location":"getting-started/shapes.html#what-is-shape","title":"What is Shape?","text":"<p>The shape is the characteristic that remains after removing all global geometrical information from an object. To study shape, we would like to study the differences among these characteristics in populations of objects belonging to the same class.</p>"},{"location":"getting-started/shapes.html#where-shapes-come-from","title":"Where Shapes Come From?","text":"<p>In medical imaging, shapes can be obtained from images of anatomies (e.g., CTs and MRIs), where anatomies of interest can be manually or semi-automatically segmented/delineated. Other applications could entail modeling geometries using computer-aided design systems, or acquiring real-world objects through sampling (2D via image acquisition devices, 3D via laser scanners).</p> <p></p> <p>Here are some examples of free software packages that include enable both manual and semi-automated anatomy segmentation:</p> <ul> <li>Seg3D</li> <li>ITK-SNAP</li> <li>3DSlicer</li> </ul>"},{"location":"getting-started/shapes.html#what-surfaces-are-good-for-shape-modeling","title":"What surfaces are \u201dgood\u201d for shape modeling?","text":"<p>The results from the segmentation process are often not directly usable for shape modeling tools. Let\u2019s go over some examples of good and bad segmentation results for shape modeling.</p> <p>Here is an example of a poor segmentation for the calcaneus on the right of the below figure. Segmentation methods, especially those that rely on intensity thresholding, can easily result in bone islands. Segmented anatomies can have rough surfaces and aliasing artifacts due to intensity noise and limitations on voxel spacing. Planar striations and non-physiological bone holes can result due to imaging artifacts. All these types of artifacts are not anatomically relevant and should not be captured when we study the statistics of shapes. This is in comparison to a smoothed and decimated segmentation on the left of the below figure where we can see relevant morphological features to be studied.</p> <p></p> <p>Below on the right is an example of a scapula segmentation where limitations in voxel spacing, noisy image intensities, and patient positioning in the scanner can result in stair-step features, irrelevant bone protrusions, and non-anatomical holes in thin structures. These types of artifacts negatively affect the integrity of the underlying geometry, however, they can be fixed by some data preprocessing steps before feeding the surfaces to shape modeling. On the left is the same scapula after hole filing and surface smoothing.</p> <p></p> <p>Below are another examples of bad surfaces for shape modeling where the surface meshing step can  produce some connectivity artifacts such as non-watertight meshes. A surface mesh could also have evident transverse slices due to voxel spacing and patient positioning resulting in some ringing artifacts on the surface. A smooth surface mesh like that one on the left is the best fit for shape modeling and analysis.</p> <p></p> <p>Data preparation and quality control is the first step!</p> <p>For shape modeling purposes, it is recommended that we quality control segmentation results before feeding them to the shape modeling process. Most of these surface integrity issues can be resolved by some data preprocessing step, which is the groom stage in a typical shape modeling workflow. </p>"},{"location":"getting-started/shapes.html#what-is-shape-modeling","title":"What is Shape Modeling?","text":""},{"location":"getting-started/shapes.html#shape-parameters","title":"Shape Parameters","text":"<p>Let\u2019s first consider parameterized geometric shapes. For example, disregarding location, orientiation, and global scale, an ellipse can be fully described by its major and minor radii. A torus can be parameterized by its inner and outer radii.</p> <p>Here is a more complex example of parameterized shapes called supershapes, which be used to describe many complex shapes and curves that are found in nature.\u00a0On the left, you can see sliders that control shape parameters describing a supershape. Every time we change any of these parameters, we get a different shape that belongs to the supershapes family. Hence, these parameters fully describe a shape in this family or population. This video was captured using Andrew Marsh's app website for supershapes generation.</p> <p> <p>But, how about anatomies that one would want to study? Most real-world objects have a characteristic shape relative to other objects, and anatomy is no exception. Across a population, instances vary in shape, while retaining the \u201ckey features\u201d of the shape, so shape varies statistically. So how can we quantitatively describe a subject\u2019s anatomy within a population? and capture such statistical variations? </p> <p>Or in other words:  - How can we define these sliders or knobs for a given anatomical population? What does each knob represent? - How many knobs or shape parameters are significant to describe an anatomy of interest? - How can we rank these shape parameters based on their significance?</p> <p>Answering the above questions for the anatomical population at hand is the crux of shape modeling. </p> <p>Shape modeling is about learning population-specific parameterization</p> <p>Shape modeling is the process of discovering significant shape parameters directly from medical data that can fully describe an anatomy in the context of a population.</p> <p></p>"},{"location":"getting-started/shapes.html#discovering-shape-parameters-via-optimization","title":"Discovering Shape Parameters via Optimization","text":"<p>ShapeWorks allows for discovering the modes of variation in shape cohorts for which the parameters are unknown. This is done by first optimizing particles that are in correspondence across the population (see Shape Model Optimization). Next statistical analysis is performed using principal component analysis (PCA), where the mean and modes of shape variation are computed based on the optimized correspondence model. These modes of shape variation can be visualized and used in downstream medical tasks.</p> <p>Below is an example of a shape model from parameterized ellipsoids that differ along the x and y radius. The mean shape is shown and we can see that 99.9% of the shape variability is explained by just two PCA modes as expected.</p> <p></p> <p>By animating how the shape changes along the first PCA mode, we can conclude that this represents the variation in the radius along the y-axis.</p> <p></p> <p>And animating along the second PCA mode, we can conclude this represents the variation in the radius along the x-axis.</p> <p></p> <p>This example demonstrates that correspondence points defined via ShapeWorks optimization can correctly capture the parameters of a class of shapes. </p>"},{"location":"getting-started/sw-stories.html","title":"ShapeWorks Success Stories (selected)","text":""},{"location":"getting-started/sw-stories.html#hip-joint-fai-pathology","title":"Hip Joint FAI Pathology","text":"<p>Cam-type femoroacetabular impingement (FAI) is a morphologic deformity of the femur that may reduce the femoral neck and acetabulum's clearance, resulting in high shear forces to the cartilage. </p> <p>By analyzing the femur cortical bone thickness between asymptomatic controls and cam-FAI patients, collaborators have used ShapeWorks to show that impingement likely induces bone hypertrophy. </p> <p></p> <p>Information provided by ShapeWorks has resulted in resection guidelines that can be easily executed in the operating room.</p> <p></p> <p>Moreover, the limitations of radiographic measurements of plain film radiographs were established, which are often used in the clinical diagnosis of cam-FAI. With a shape score that depends on group-specific mean shapes, the optimized correspondence model from ShapeWorks was used to place subject-specific anatomy on a disease spectrum that is statistically derived from the shape population, providing an objective metric to assess severity. </p> <p> </p> <p>ShapeWorks has further helped develop cost-effective patient-specific meshes (which otherwise require hundreds of man-hours) of the cartilage and labrum to develop computational models and simulations to model contact mechanics and the pathogenesis of hip osteoarthritis.</p> <p> </p> <p>Relevant Papers</p> <ul> <li>P. Atkins, P. Mukherjee, S. Elhabian, S. Singla, M. Harris, J. Weiss, R. Whitaker, and A. Anderson. Proximal femoral cortical bone thickness in patients with femoroacetabular impingement and normal hips analyzed using statistical shape modeling. In Summer Biomechanics, Bioengineering and Biotransport Conference, 2015.</li> <li>P. R. Atkins, S. Y. Elhabian, P. Agrawal, M. D. Harris, R. T. Whitaker, J. A. Weiss, C. L. Peters, and A. E. Anderson. Quantitative comparison of cortical bone thickness using correspondence-based shape modeling in patients with cam femoroacetabular impingement. Journal of Orthopaedic Research, 35(8):1743\u20131753, 2017.</li> <li>P. R. Atkins, S. K. Aoki, R. T. Whitaker, J. A. Weiss, C. L. Peters, and A. E. Anderson. Does removal of subchondral cortical bone provide sufficient resection depth for treatment of cam femoroacetabular impingement? Clinical Orthopaedics and Related ResearchR , 475(8):1977\u20131986, 2017.</li> <li>P. R. Atkins, S. K. Aoki, S. Y. Elhabian, P. Agrawal, R. T. Whitaker, J. A. Weiss, C. L. Peters, and A. E. Anderson. Evaluation of the Sclerotic Subchondral Bone Boundary as a Surgical Resection Guide in the Treatment of Cam-type Femoroacetabular Impingement. In Annual Meeting of Orthopaedic Research Society, 2017.</li> <li>P. Atkins, S. Elhabian, P. Agrawal, R. Whitaker, J. Weiss, S. Aoki, C. Peters, and A. Anderson. Can the sclerotic subchondral bone of the proximal femur cam lesion be used as a surgical resection guide? An objective analysis using 3D computed tomography and statistical shape modeling. In International Society of Hip Arthroscopy Annual Scientific Meeting, 2016.</li> <li>P. Atkins, S. Elhabian, P. Agrawal, R. Whitaker, J. Weiss, C. Peters, S. Aoki, and A. Anderson. Which radiographic measurements best identify anatomical variation in femoral head anatomy? Analysis using 3D computed tomography and statistical shape modeling. In International Society of Hip Arthroscopy Annual Scientific Meeting, 2016.</li> <li>P. Atkins, Y. Shin, P. Agrawal, S. Elhabian, R. Whitaker, J. Weiss, S. Aoki, C. Peters, and A. Anderson. Which Two-dimensional Radiographic Measurements of Cam Femoroacetabular Impingement Best Describe the Three-dimensional Shape of the Proximal Femur? Clinical Orthopaedics and Related ResearchR, 477(1):242\u2013253, 2019.</li> <li>P. Atkins, P. Mukherjee, S. Elhabian, S. Singla, R. Whitaker, J. Weiss, and A. Anderson. Warping of template meshes for efficient subject-specific FE mesh generation. In International Symposium of Computer Methods in Biomechanics and Biomedical Engineering, 2015.</li> </ul>"},{"location":"getting-started/sw-stories.html#pose-and-shape-of-the-dysplastic-hip-joint","title":"Pose and Shape of the Dysplastic Hip Joint","text":"<p>Developmental dysplasia of the hip (DDH) describes an undercoverage of the femoral head by the acetabulum and is most often described using angular measurements from radiographs used to estimate joint coverage. Since 3D analyses of the hip joint would be advantageous to defining the true morphology of DDH, an articulated, multiple-domain SSM was developed in ShapeWorks to isolate the morphological variation of the disease. The first four modes of variation largely represented variation in scale and pose, while all six modes included some subtle variations in bone morphology. </p> <p></p> <p>While radiographic measurements provide some insight to joint morphology, there may be additional morphological features that better explain joint coverage and hip degeneration in these patients. By evaluating the modes of variation from our joint model against 3D measurements of coverage, we isolated the morphology associated with increased and decreased coverage within this population.</p> <p></p> <p>Relevant Papers</p> <ul> <li>P. Agrawal, J.D. Mozingo, S.Y. Elhabian, A.E. Anderson, R.T. Whitaker. Combined Estimation of Shape and Pose for Statistical Analysis of Articulating Joints. Proceedings of Shape in Medical Imaging: International Workshop, ShapeMI 2020, pp. 111-121, 2020.</li> <li>J.D. Mozingo, P.R. Atkins, P. Agrawal, K. Uemura, S.Y. Elhabian, R.T. Whitaker, A.E. Anderson. Morphology of Hip Dysplasia in Japanese Females: A Statistical Shape Modeling Study. Abstract for poster presentation at the 45th Meeting of the American Society of Biomechanics, 2021.</li> <li>P.R. Atkins, P. Agrawal, J.D. Mozingo, K. Uemura, A.E. Anderson. Application of an Articulated Statistical Shape Model of the Hip to Predict Clinical Measures of Coverage. Abstract for podium presentation for the International Symposium on Computer Methods in Biomechanics and Biomedical Engineering, 2021.</li> </ul>"},{"location":"getting-started/sw-stories.html#scapular-morphology-in-hill-sachs-patients","title":"Scapular Morphology in Hill-Sachs Patients","text":"<p>Surgical procedures for anterior shoulder instability reconstruct the glenoid and its soft tissue by creating an anterior buttress or overcome glenoid bone loss with an additional dynamic stabilizer (e.g., Latarjet procedure). However, the native anatomy must be sacrificed to obtain a stable shoulder. Recent findings suggest that there might be a place for more subtle changes of the periarticular structures, using, for example, a directional osteotomy of the coracoid, so that more normative anatomy is obtained. </p> <p>To this end, ShapeWorks has been used to define a data-driven linear discriminant between the Hill-Sachs lesions and control shapes in the shape space that demonstrates the spectrum of normal and pathologic scapulae (PDF - probability density function).</p> <p> </p> <p>Modes of variations discovered by ShapeWorks were found to relate to clinically relevant shape variations. Mode 1 (33.0% of variation) represented scaling differences. Mode 2 (32.0% of variation) demonstrated large differences around the acromion. In Mode 3 (11.8% of variation), the glenoid inclination and concavity of the glenoid surface were the most substantial. Mode 4 (9.0% of variation) captured primarily differences in orientation of the coracoid pillar, coracoid process size, and bony prominence. Variation in deviation of the coracoid process and the resulting coracoacromial relationship were captured in Mode 5 (3.1% of variation).</p> <p> </p> <p>Relevant Papers</p> <ul> <li>Matthijs Jacxsens, Shireen Y. Elhabian, Sarah Brady, Peter Chalmers, Andreas Mueller, Robert Tashjian, Heath Henninger. Thinking outside the glenohumeral box: Hierarchical shape variation of the periarticular anatomy of the scapula using statistical shape modeling. Journal of Orthopaedic Research, in press, 2020.</li> <li>Matthijs Jacxsens, Shireen Y. Elhabian, Sarah Brady, Peter Chalmers, Robert Tashjian, Heath Henninger. Coracoacromial Morphology: A Contributor to Recurrent Traumatic Anterior Glenohumeral Instability?. Journal of Shoulder and Elbow Surgery, 28(7), pp. 1316-1325, 2019.</li> <li>Matthijs Jacxsens, Shireen Y. Elhabian, Robert Z. Tashjian1, Heath B. Henninger. Scapular Morphology In Patients With Hill-Sachs Lesions Using Statistical Shape Modeling. Abstract for podium presentation for the 27th Congress of the European Society for Surgery of the Shoulder and the Elbow (SECEC-ESSSE) conference, 2017.</li> </ul>"},{"location":"getting-started/sw-stories.html#shape-changes-in-atrial-fibrillation","title":"Shape Changes in Atrial Fibrillation","text":"<p>Shape changes of the left atrium (LA) and LA appendage (LAA) in AF are hypothesized to be linked to AF pathology and may play a role in thrombogenesis. Thrombus in the LA or LAA, due to stagnant blood flow in these chambers, is thought to be a significant cause of cardioembolic stroke in AF patients. However, many aspects of shape variation in the heart are poorly understood. </p> <p>ShapeWorks models have been used to develop predictive indices of spontaneous echocardiographic contrast (SEC) and thrombus using LAA/LA shape (an indicator for the risk of stroke). Results showed distinct patterns of shape that are statistically more likely to be observed in patients with SEC. </p> <p> </p> <p>Shape-based AF severity has indicated significant differences (p-value &lt; 0.001) in the LA among normal controls, paroxysmal AF, and persistent AF populations. </p> <p> </p> <p>In a recent study, ShapeWorks was used to discover that LA shape was shown to be an independent predictor of AF recurrence after ablation. Hence, ShapeWorks may become a useful tool to improve patient selection for ablation.</p> <p> </p> <p>Relevant Papers</p> <ul> <li>J. Cates, E. Bieging, A. Morris, G. Gardner, N. Akoum, E. Kholmovski, N. Marrouche, C. McGann, and R. S. MacLeod. Computational shape models characterize shape change of the left atrium in atrial fibrillation. Clinical Medicine Insights. Cardiology, 8(Suppl 1):99, 2015.</li> <li>E. T. Bieging, A. Morris, B. D. Wilson, C. J. McGann, N. F. Marrouche, and J. Cates. Left atrial shape predicts recurrence after atrial fibrillation catheter ablation. Journal of Cardiovascular Electrophysiology, 2018.</li> </ul>"},{"location":"getting-started/sw-stories.html#benchmarking-shapeworks-in-clinical-applications","title":"Benchmarking ShapeWorks in Clinical Applications","text":"<p>A recent benchmarking study has evaluated and validated ShapeWorks, Deformetrica, and SPHARM-PDM in clinical applications that rely on morphometric quantifications, particularly anatomical landmark/measurement inference and lesion screening. </p> <p>Results demonstrate that SSM tools display different levels of consistency. ShapeWorks and Deformetrica models are more consistent than models from SPHARM-PDM due to the groupwise approach of estimating surface correspondences. </p> <p></p> <p>Furthermore, ShapeWorks and Deformetrica shape models are found to capture clinically relevant population-level variability compared to SPHARM-PDM models.</p> <p></p> <p></p> <p>Relevant Papers</p> <ul> <li>Anupama Goparaju, Ibolya Csecs, Alan Morris, Evgueni Kholmovski, Nassir Marrouche, Ross T. Whitaker, and Shireen Y. Elhabian. On the Evaluation and Validation of Off-the-shelf Statistical Shape Modeling Tools: A Clinical Application. ShapeMI-MICCAI 2018: Workshop on Shape in Medical Imaging, 2018.</li> <li>Anupama Goparaju, Alexandre Bone, Nan Hu, Heath Henninger, Andrew Anderson, Stanely Durrleman, MatthijsJacxsens, Alan Morris, Ibolya Csecs, Nassir Marrouche, Shireen Elhabian, 2020. Benchmarking off-the-shelf statistical shape modeling tools in clinical applications. arXiv preprint arXiv:2009.02878.</li> </ul>"},{"location":"getting-started/sw-stories.html#next-story-can-be-yours","title":"Next Story Can be Yours!","text":""},{"location":"getting-started/workflow.html","title":"Shape Modeling Workflow","text":"<p>ShapeWorks supports the typical three-stage workflow for shape modeling. </p> <p></p>"},{"location":"getting-started/workflow.html#groom-stage","title":"Groom Stage","text":"<p>The groom stage entails data inspection and preprocessing, including conversion of the input segmentations and surface meshes into the appropriate data types that are optimization friendly so that landmarks can be optimized in a numerically stable way. It also includes visualization for preprocessed/groomed data for quality control, and we are planning to include annotations for user-defined modeling preferences such as landmarks and constraints.</p> <p>The grooming stage entails rigid transformations to align samples for groupwise modeling and analysis. Imaging data (e.g., CT, MRI) becomes out of alignment and cannot be tied to the resulting shape models. We have developed segmentation-based and mesh-based grooming tools and associated python scripts (i.e., use cases) to carry volumetric data through each grooming step with the shapes (meshes or segmentations) such that they can be used for subsequent analysis and visualization. These tools include image reflection (for paired anatomies), isotropic voxel resampling, image padding, applying shape-based alignment to images (center of mass and rigid alignment), and image cropping.</p>"},{"location":"getting-started/workflow.html#optimize-stage","title":"Optimize Stage","text":"<p>The optimize stage is an iterative cycle of correspondences (landmarks/particles) optimization, visualization/quality control of resulting correspondence model and parameter tuning. </p> <p>The model initialization proceeds simultaneously with the optimization in a multi-scale fashion using an iterative particle splitting strategy to generate progressively detailed correspondence models with each split.</p> <p></p>"},{"location":"getting-started/workflow.html#analyze-stage","title":"Analyze Stage","text":"<p>The analyze stage is the model analysis phase that supports the computation and visualization of the principal components of shape variation, average shapes, and group differences. </p> <p></p>"},{"location":"java/java.html","title":"Using the ShapeWorks Java Interface","text":"<p>This example Java program demonstrates how to use the ShapeWorks Java interface to perform the following tasks:</p> <ol> <li>Create a ShapeWorks project</li> <li>Add a shape to the project</li> <li>Set grooming parameters</li> <li>Set correspondence parameters</li> <li>Save/Load the project</li> <li>Run the ShapeWorks grooming pipeline</li> <li>Run the ShapeWorks correspondence optimization</li> <li>Launch the ShapeWorks Analysis GUI</li> </ol>"},{"location":"java/java.html#building-the-shapeworks-java-interface","title":"Building the ShapeWorks Java Interface","text":"<p>The ShapeWorks Java interface is built using the Java Compiler.  To build it:</p> <pre><code>cd shapeworks/Java\njavac -d . *.java\n</code></pre> <p>This will place the compiled classes in the <code>shapeworks/Java</code> directory.</p>"},{"location":"java/java.html#building-the-example-java-program","title":"Building the Example Java Program","text":"<pre><code>cd shapeworks/Examples/Java\njavac -cp ../../Java *.java\n</code></pre>"},{"location":"java/java.html#running-the-example-java-program","title":"Running the Example Java Program","text":"<p>Note: The example Java program assumes that the ShapeWorks executable is in $PATH.  Ensure that you can run <code>shapeworks</code> from the command line before running the example Java program.</p> <pre><code>java -cp ../../Java:. JavaExample\n</code></pre> <p>This will run the example Java program. The output should look like this:</p> <pre><code>Saving project...\nLoading project...\nRunning groom...\nRunning optimize...\nOpening ShapeWorksStudio...\n</code></pre> <p>And the ShapeWorks Analysis GUI will open.</p> <p>From here you can change to the analysis module and examine the shape model.</p> <p></p>"},{"location":"java/matlab.html","title":"Using the ShapeWorks Matlab Interface","text":"<p>This example Matlab program demonstrates how to use the ShapeWorks Matlab interface via Java to perform the following tasks:</p> <ol> <li>Create a ShapeWorks project</li> <li>Generate Ellipsoids</li> <li>Add shapes to the project</li> <li>Set grooming parameters</li> <li>Set correspondence parameters</li> <li>Save/Load the project</li> <li>Run the ShapeWorks grooming pipeline</li> <li>Run the ShapeWorks correspondence optimization</li> <li>Launch the ShapeWorks Analysis GUI</li> </ol>"},{"location":"java/matlab.html#building-the-shapeworks-java-interface","title":"Building the ShapeWorks Java Interface","text":"<p>The ShapeWorks Java interface is built using the Java Compiler.  To build it:</p> <pre><code>cd shapeworks/Java\njavac -d . *.java\n</code></pre> <p>This will place the compiled classes in the <code>shapeworks/Java</code> directory.</p>"},{"location":"java/matlab.html#building-the-example-java-program","title":"Building the Example Java Program","text":"<pre><code>cd shapeworks/Examples/Java\njavac -cp ../../Java *.java\n</code></pre>"},{"location":"java/matlab.html#running-the-example-matlab-program","title":"Running the Example Matlab Program","text":"<p>Note: The example Matlab program uses the Java interface and needs the paths to the ShapeWorks executables.  Ensure that you update the paths in the start of the script.</p>"},{"location":"java/matlab.html#running-the-example-matlab-program_1","title":"Running the Example Matlab Program","text":"<p>From the Matlab terminal, run the following:</p> <pre><code>cd shapeworks/Examples/Matlab\njavaaddpath('../../Java')\nMatlabExample\n</code></pre> <p></p> <p></p>"},{"location":"new/ai-assisted-segmentation.html","title":"AI-Assisted Segmentation in ShapeWorks","text":""},{"location":"new/ai-assisted-segmentation.html#getting-started-with-monai-label-in-shapeworks","title":"Getting Started with MONAI Label in ShapeWorks","text":"<p><code>Medical Open Network for AI (MONAI) Label</code> is a deep learning framework designed for efficient annotation and segmentation of medical images.  </p>"},{"location":"new/ai-assisted-segmentation.html#whats-new","title":"What\u2019s New?","text":"<p>ShapeWorks Studio now integrates MONAI Label, enabling seamless access to fully automated and interactive deep learning models for segmenting radiology images across various modalities.  </p> <p>For a detailed demo and step-by-step instructions on using MONAI Label within ShapeWorks Studio, refer to the following guide:  </p>"},{"location":"new/ai-assisted-segmentation.html#getting-started-with-ai-assisted-segmentation","title":"Getting Started with AI-Assisted Segmentation","text":""},{"location":"new/ellipsoid-joint-generation.html","title":"Ellipsoid Joint Generation","text":""},{"location":"new/ellipsoid-joint-generation.html#about-shapecohortgenerator","title":"About ShapeCohortGenerator","text":"<p><code>ShapeCohortGenerator</code> is a python package that generates synthetic shape cohorts with ground truth surface correspondences by varying different parameters describing such shape families.</p>"},{"location":"new/ellipsoid-joint-generation.html#what-is-new","title":"What is new?","text":"<p>We have added a new family of shapes in the <code>ShapeCohortGenerator</code> package. You can now generate ellipsoid joints (two anatomies per shape) which can be used for troubleshooting multiple domain shape modeling workflows.</p> <p>Similar to the <code>ellipsoid</code> and <code>supershapes</code> generator, the joint generator has three functions: - <code>generate()</code> for mesh generation (function specific to generator type) - <code>generate_segmentations()</code> for segmentation generation based on meshes (general function shared by all generator types) - <code>generate_images()</code> for image generation based on segmentations (general function shared by all generator types)</p> <p>Please refer to this notebook for all the options for generating the cohorts. </p>"},{"location":"new/ellipsoid-joint-generation.html#getting-started-with-shape-cohort-generator","title":"Getting Started with Shape Cohort Generator","text":"<p>Arguments specific to ellipsoid joint generation are:</p> <ul> <li><code>mode_size</code>: uses size as the mode of variation </li> <li><code>mode_rotation</code>: uses rotation as the mode of variation</li> <li><code>separation</code>: distance between the two anatomies of the joint</li> </ul> <p>The notebook will soon be updated with examples of ellipsoid joint generation</p>"},{"location":"new/free-form-constraints.html","title":"Free-Form Constraints","text":"<p>The free-form constraint (FFC) functionality allows the definition of arbitrary areas of interest on domains. These areas are defined using a member point and any number of boundaries loops that define exclusion areas. The area where the member point lives is where particles are allowed to live, and will not step into exclusion areads deliniated by the boundary loops.</p> <p>For example, for a use case with d domains, one would add an xml parameter  with d numbers denoting how many FFCs there will be per input. Then each of these will be defined as filenames under the tag . Each file will have the following format: <pre><code>query\n[member_point]\nboundary_pts\n[boundary_pt1]\n[boundary_pt2]\n...\n[boundary_ptn]\nboundary_pts\n[boundary_pt1]\n[boundary_pt2]\n...\n[boundary_ptn]\n</code></pre>"},{"location":"new/new-studio.html","title":"New in ShapeWorks Studio 6.2","text":""},{"location":"new/new-studio.html#deepssm-in-studio","title":"DeepSSM in Studio","text":"<p>New in ShapeWorks 6.2, we have added the ability to run DeepSSM tools in ShapeWorks Studio.</p> <p></p> <p>See DeepSSM in Studio for more information.</p>"},{"location":"new/new-studio.html#multiple-domain-alignments","title":"Multiple Domain Alignments","text":"<p>New in ShapeWorks 6.2, we have added support for multiple alignment strategies in ShapeWorks Studio.  This allows analysis with and without articulation with a choice of reference domain, or global alignment.</p> <p> <p>See Multiple Domain Alignments for more information.</p>"},{"location":"new/new-studio.html#shape-evaluation-charts","title":"Shape Evaluation Charts","text":"<p>New in ShapeWorks 6.2, we have added new shape evaluation charts.  Charts for Compactness, Specificity and Generalizaion are provided.</p> <p>See Studio Metrics Panel for more information.</p> <p></p>"},{"location":"new/new-studio.html#usability-features","title":"Usability Features","text":""},{"location":"new/new-studio.html#group-p-value-display","title":"Group p-value Display","text":"<p>New in ShapeWorks 6.2, Studio has the ability to view group-wise p-values for surface differences.</p> <p></p>"},{"location":"new/new-studio.html#scalar-range-controls","title":"Scalar range controls","text":"<p>New in ShapeWorks 6.2, Studio feature maps, p-value displays, deepssm surface error displays allow for manual control over scalar colormap values.</p> <p>"},{"location":"new/new-studio.html#surface-opacity-controls","title":"Surface opacity controls","text":"<p>Shape surface opacity can now be controlled on a per domain basis.</p> <p>"},{"location":"new/new-studio.html#added-narrow-band-optimization-parameter","title":"Added narrow band optimization parameter","text":"<p>The narrow band optimization parameter has been added to Studio's Optimize parameter dialog.  This allows the user to modifiy the narrow band from the default of 4 in the rare event that it needs modification.</p>"},{"location":"new/new-studio.html#new-message-history-window","title":"New message history window","text":"<p>A new button in the lower corner has been added that brings up the message history from the status bar.</p> <p></p>"},{"location":"new/new-studio.html#new-suppressible-error-dialog","title":"New suppressible error dialog","text":"<p>The error dialog has been replaced with a new dialog containing a checkbox to suppress further messages</p> <p></p>"},{"location":"new/new-studio.html#multiple-domain-export-options-combined-separate","title":"Multiple domain export options (combined + separate)","text":"<p>When exporting data in the presences of multiple anatomies/domains, you may now export a combined file, or one for each domain.</p> <p></p>"},{"location":"new/new-studio.html#allow-initial-landmark-points","title":"Allow initial landmark points","text":"<p>Initial particle positions can be specified in a Project Spreadsheet using the column prefix <code>landmarks_file_&lt;name&gt;</code> where <code>&lt;name&gt;</code> is the name of each shape domain.  For example:</p> <p></p> <p>These landmarks will be used as the initial positions of particles during optimization.  They are not yet visualized within Studio before optimization.</p>"},{"location":"new/new-studio.html#mesh-warping-improvements","title":"Mesh warping improvements","text":"<p>Multiple sources of crashes during mesh warping have been fixed and the overall speed has been dramatically improved.</p>"},{"location":"new/new-studio.html#new-in-shapeworks-studio-61","title":"New in ShapeWorks Studio 6.1","text":""},{"location":"new/new-studio.html#multiple-domains","title":"Multiple Domains","text":"<p>As of ShapeWorks 6.1, we added support in ShapeWorks Studio for modeling multiple domains (e.g. anatomies) in joint correspondance model.</p> <p></p> <p>See Multiple Domains for more information.</p>"},{"location":"new/new-studio.html#mesh-grooming","title":"Mesh Grooming","text":"<p>As of ShapeWorks 6.1, we added support in ShapeWorks Studio for mesh grooming, including smoothing, hole filling, and iterative closest point pre-alignment.</p> <p></p> <p>See Groom Module for more information.</p>"},{"location":"new/new-studio.html#mesh-support","title":"Mesh Support","text":"<p>As of ShapeWorks 6.0, we added mesh support to ShapeWorks Studio including loading meshes, optimizing shape models directly on meshes, and visualizing meshes with scalar feature values. Meshes can store values at vertices such as \"cortical thickness\", or \"fibrosis\u201d and ShapeWorks Studio uses them in a similar manner as feature maps/volumes.</p> <p>Open meshes in Studio </p> <p>Visualizing features on surface mesh </p> <p>We also added a new surface reconstruction method with support for both mesh or image inputs. This method is much faster and is the new default.</p> <p>New and faster surface reconstruction </p>"},{"location":"new/new-studio.html#improved-studio-interface","title":"Improved Studio Interface","text":"<p>As of ShapeWorks 6.0, we added support for automatic glyph sizing, draging/dropping of images and meshes. Scalar bar color is now opposite of background color (e.g., when background is white, text should be dark) (user request).</p> <p>Samples names color is opposite of the background color for a better contrast </p>"},{"location":"new/new-studio.html#surface-reconstruction","title":"Surface Reconstruction","text":"<p>ShapeWorks Studio provides a particle-based surface reconstruction that can reconstruct high quality surface meshes with fewer number of particles. See How to Analyze Your Shape Model? for details about the method.</p> <p>With particle-based surface reconstruction, there is not need to optimize denser particle systems (i.e., with more particles) to reconstruct surface meshes with subvoxel accuracy </p> <p>(old) VTK-based surface reconstruction</p> <p> <p>(new) particle-based surface reconstruction</p> <p>"},{"location":"new/new-studio.html#dynamic-loading","title":"Dynamic Loading","text":"<p>ShapeWorks Studio support load-on-demand, which makes it more scalable by supporting loading in order of 100s of samples. For instance, an old small project that took 10+ seconds to load now starts instantly in Studio.</p> <p>(old) without dynamic loading</p> <p> <p>(new) with dynamic loading</p> <p>"},{"location":"new/new-studio.html#live-particles-movement","title":"Live Particles Movement","text":"<p>ShapeWorks Studio allows for live introspection of the correpsondence placement optimization process and the ability to abort the optimization at any time (e.g., changing algorithmic parameters).</p> <p>"},{"location":"new/new-studio.html#feature-maps","title":"Feature Maps","text":"<p>ShapeWorks Studio has the ability to integrate feature maps.  A feature map is a 3d image volume that contains scalar values to be associated with each shape\u2019s surface.  For example, this could be raw or processed CT/MRI data.  The feature map can be displayed for each surface by choosing the desired feature map in the feature map combobox at the bottom of the screen.  After the correspondence is generated, the average feature map can be displayed on the mean shape in the analysis tab.</p> <p>"},{"location":"new/openvdb.html","title":"ShapeWorks Takes ~85% Less Memory","text":"<p>ShapeWorks uses signed distance transforms to represent shape samples. This, and other quantities computed from the distance transforms consumed a lot of memory.</p> <p>Instead, we now store only a subset of these values that lie within a narrow band off the surface (inside and outside the surface). A default narrow band of 4 units is used. This works well for the tested use cases and is configurable using the <code>&lt;narrow_band&gt;</code> parameter,  see: How to Optimize Your Shape Model.</p> <p>We make use of OpenVDB, a more memory-efficient data structure, for signed distance transforms. OpenVDB uses a tree-based data structure to store data in only the relevant voxels. We verified that same distance transform values are obtained and made sure optimizer loudly crashes if we sample outside the narrow band.</p> <p>Lower memory footprint and faster optimization</p> <p>Along with other refactoring and code optimizations, ShapeWorks now uses 85% less memory (from 57.09GB to 9.67GB in one use case). Additionally, the particle optimizer is now 2X faster.</p> <p></p> <p>ShapeWorks now uses\u00a085% less memory. The particles optimizer is now\u00a02X faster. These benchmarks are reported on a Pelvis datasets of 40 NRRD files and a femur dataset of 57 NRRD files. </p>"},{"location":"new/shapeworks-command.html","title":"ShapeWorks Command","text":"<p>ShapeWorks was a conglomeration of independent executables for grooming and optimization with a GUI (ShapeWorks Studio) for analysis and visualization. This design is highly inflexible, task specific, and poorly documented, and Studio duplicated a significant portion of their functionality.</p> <p>We have made significant efforts in organizing the codebase based on functionalities, implementing them as libraries rather than executables to provide a common backbone to command-line and GUI-based tools, and syncing ShapeWorks Studio to use the same underlying libraries.</p> <p>To retain command line usage, we have created a single <code>shapeworks</code> command with subcommands exposing this functionality along with greater flexibility and interactive <code>--help</code> for each subcommand.\u00a0</p> <p>This consolidation makes the framework more powerful and flexible. It also enables ShapeWorks functionality to be used as libraries linked to new applications. </p> <p>All the executables used for the segmentation-driven grooming have been consolidated, documented, tested against the original command line tools, and functionally debugged</p> <p>Comprehensive unit testing is implemented and executed as part of automatic validation run with each addition to the code. This also serves as independent examples of its use </p>"},{"location":"new/shapeworks-command.html#example-resamplevolumestobeisotropic","title":"Example: ResampleVolumesToBeIsotropic","text":"<p>Old command-line: <code>ResampleVolumesToBeIsotropic</code></p> <pre><code>./ResampleVolumesToBeIsotropic --inFilename &lt;input-file&gt; --outFilename &lt;output-file&gt; \n                               --isoSpacing &lt;voxel-spacing&gt;\n                              [--isBinaryImage] [--isCenterImageOn]\n</code></pre> <p>Disadvantages of the old command-line tool: </p> <ul> <li>Cannot be used by other classes or other APIs or other functions</li> <li>Not adaptable (need to edit script files to customize it)</li> <li>Each command needs to be given input and output paths</li> <li>Creates IO bottlenecks</li> <li>Fixed parameters cannot be changed (e.g., num iterations for binarization)</li> <li>All logic is buried behind a single command line tool</li> </ul>"},{"location":"new/shapeworks-command.html#resampling-images","title":"Resampling images","text":"<p>Old command-line: <code>ResampleVolumesToBeIsotropic</code> (for images)</p> <pre><code>./ResampleVolumesToBeIsotropic --inFilename &lt;input-file&gt; --outFilename &lt;output-file&gt; \n                               --isoSpacing &lt;voxel-spacing&gt;\n                               --isCenterImageOn\n</code></pre> <p>New command-line: <code>isoresample</code> (for images)</p> <pre><code>shapeworks readimage --name &lt;input-file&gt; recenter \n           isoresample --isospacing &lt;voxel-spacing&gt;\n           writeimage --name &lt;output-file&gt;\n</code></pre> <p>C++ (without chaining): <code>isoresample</code> (for images)</p> <pre><code>Image img(&lt;input-file&gt;);\nimg.recenter();\nimg.isoresample(&lt;voxel-spacing&gt;);\nimg.write(&lt;output-file&gt;);\n</code></pre> <p>C++ (with chaining): <code>isoresample</code> (for images)</p> <pre><code>Image img(&lt;input-file&gt;).recenter().isoresample(&lt;voxel-spacing&gt;).write(&lt;output-file&gt;);\n</code></pre> <p></p>"},{"location":"new/shapeworks-command.html#resampling-segmentations","title":"Resampling segmentations","text":"<p>Old command-line: <code>ResampleVolumesToBeIsotropic</code> (for segmentations)</p> <pre><code>./ResampleVolumesToBeIsotropic --inFilename &lt;input-file&gt; --outFilename &lt;output-file&gt; \n                               --isoSpacing &lt;voxel-spacing&gt;\n                              --isBinaryImage --isCenterImageOn\n</code></pre> <p>The old executable\u2019s functionalities are broken down further to make it more modular:</p> <ul> <li>Antialias using <code>shapeworks antialias</code> </li> <li>Recenter using <code>shapeworks recenter</code></li> <li>Binarize using <code>shapeworks binarize</code></li> </ul> <p>Advantages for the new shapeworks API:</p> <ul> <li>Promotes user\u2019s understanding of the underlying functionality (more transparency and equivalent simplicity)</li> <li>Allows the user to choose the set of commands to be run</li> <li>User can know what parameters are considered to perform each command</li> <li>User can modify parameter values each step of the way</li> <li>User can save/visualize intermediate outputs for troubleshooting </li> </ul> <p>New command-line: <code>isoresample</code> (for segmentations)</p> <pre><code>shapeworks readimage --name &lt;input-file&gt; \n           recenter antialias --iterations &lt;num-iter&gt; \n           isoresample --isospacing &lt;voxel-spacing&gt; binarize \n           writeimage --name &lt;output-file&gt;\n</code></pre> <p>C++ (without chaining): <code>isoresample</code> (for segmentations)</p> <pre><code>Image img(&lt;input-file&gt;);\nimg.recenter();\nimg.antialias(&lt;num-iter&gt;);\nimg.isoresample(&lt;voxel-spacing&gt;);\nimg.binarize();\nimg.write(&lt;output-file&gt;);\n</code></pre> <p>C++ (with chaining): <code>isoresample</code> (for images)</p> <pre><code>Image img(&lt;input-file&gt;).recenter().antialias(&lt;num-iter&gt;).isoresample(&lt;voxel-spacing&gt;).binarize().write(&lt;output-file&gt;);\n</code></pre> <p></p>"},{"location":"new/shapeworks-python.html","title":"ShapeWorks in Python","text":"<p>ShapeWorks with Python support</p> <p>ShapeWorks Python library is currently under active development and is part of our major releases as of ShapeWorks 6. </p> <p>There is no one-size-fits-all when it comes to grooming your data for shape modeling. Instead, there are general guidelines that one could consider when deciding on his/her own workflow. </p> <p>NO one-size-fits-all workflow</p> <p>Looking at your data as it goes through different processing steps is a must-do!</p> <p>To support your workflow discovery process, we have been making significant strides in developing ShapeWorks tools to be more modular, generic, and transparent. Our efforts entail consolidating the underlying computational libraries, providing a flexible and unified shapeworks command line tool, and now the ShapeWorks Python library!.</p>"},{"location":"new/shapeworks-python.html#why-shapeworks-in-python","title":"Why ShapeWorks in Python?","text":"<p>One primary goal of the ShapeWorks Python library is to open and reveal what is in the ShapeWorks black box and lay down all steps involved in preprocessing your data, optimizing and analyzing your statistical shape models in a way that supports interactive workflow discovery and makes you as a user takes the full control of your own study and analysis.</p> <p>In <code>Examples/notebooks/tutorials</code>, we provide step-by-step, hands-on tutorials on different aspects of the shape modeling workflow in a transparent, reproducible, and sharable manner. For this purpose, we have chosen Juypter Notebooks as the front-end tools for these demonstrations. These hands-on tutorials are designed to reflect the thought process that a non-expert user could go through at different shape modeling phases, starting from processing or grooming your data to analyzing your optimized shape model.</p>"},{"location":"new/shapeworks-python.html#diving-into-shapeworks-clear-box","title":"Diving into ShapeWorks' \"Clear\" Box","text":"<p>A growing list of fully-documented and self-contained notebooks demonstrate various ShapeWorks tools and shape modeling workflows.  </p> <p>To actually try the following notebooks out, open a terminal, <code>conda activate shapeworks</code>, change to the <code>Examples\\Python\\notebooks\\tutorials</code> directory and run <code>jupyter notebook</code> to start the notebook server. </p>"},{"location":"new/shapeworks-python.html#getting-started-with-juypter-notebooks","title":"Getting Started with Juypter Notebooks","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-segmentations","title":"Getting Started with Segmentations","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-meshes","title":"Getting Started with Meshes","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-segmentations_1","title":"Getting Started with Segmentations","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-exploring-segmentations","title":"Getting Started with Exploring Segmentations","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-shape-cohort-generation","title":"Getting Started with Shape Cohort Generation","text":"<p>"},{"location":"new/shapeworks-python.html#getting-started-with-data-augmentation","title":"Getting Started with Data Augmentation","text":"<p>"},{"location":"new/ssm-eval.html","title":"Shape Model Evaluation","text":"<p>ShapeWorks support quantitative evaluation of shape models, which can be used for algorithmic parameter tuning. Quantitative metrics are generalizability, specificity, and compactness. In <code>Examples/Python/</code>, run <code>python RunUseCase.py ellipsoid_evaluate</code> to see an example of how to compute these metrics.</p> <p></p> <p>Compactness</p> <p>For fixed training data, a compact model pdf should describe the data's distribution using the smallest possible number of parameters.</p> <p>Poor Model  (compactness = 0.3)</p> <p> <p>Compact Model  (compactness = 0.99)</p> <p> <p>Generalization</p> <p>The model should be able to generalize from the examples given in the training set, hence describing any valid instance of the class of object, not just those seen in the training set.</p> <p></p> <p>Specificity</p> <p>This is the requirement that the model can only represent valid instances of the class(es) of objects presented in the training set. Hence, the model is specific for this training set.</p> <p></p> <p>What is a good shape model?</p> <p>A good shape model should balance the trade-off between three requirements, namely specificity, generalization, and compactness. In particular, a shape model needs to generate samples that are plausible (i.e., respect the population statistics). It also needs to generate samples beyond the training data (i.e., generalizable) while describing the population with few parameters (i.e., compact).</p>"},{"location":"new/ssm-eval.html#shapeworks-commands","title":"ShapeWorks Commands","text":"<pre><code>shapeworks readparticlesystem --name *.particles -- compactness    --nmodes 1\nshapeworks readparticlesystem --name *.particles -- generalization --nmodes 1\nshapeworks readparticlesystem --name *.particles -- specificity    --nmodes 1\n</code></pre>"},{"location":"new/ssm-eval.html#shapeworks-python-tools","title":"ShapeWorks Python tools","text":"<p><pre><code># Read the particle files from a pre-trained shape model\nparticle_data = sw.ParticleSystem(&lt;list of local point files&gt;)\n#evaluation tools\nshapeworks.ShapeEvaluation.ComputeCompactness(particleSystem=particle_data, nModes=1, saveTo=\"scree.txt\")\nshapeworks.ShapeEvaluation.compute_generalization(particleSystem=particle_data, nModes=1, saveTo=save_dir)\nshapeworks.ShapeEvaluation.ComputeSpecificity(particleSystem=particle_data, nModes=1, saveTo=save_dir)\n</code></pre> Details about the evaluation functions can be found in the API Reference</p> <p>"},{"location":"new/ssm-eval.html#model-evaluation-in-studio","title":"Model Evaluation in Studio","text":"<p>Model evaluation is performed in Studio automatically under the metrics panel. See Studio - Metrics Panel for more information.</p>"},{"location":"new/sw-meshes.html","title":"ShapeWorks Directly on Meshes","text":"<p>Surface meshes are capable of representing complex surfaces with thin structures while using at most several megabytes of data. By allowing ShapeWorks to optimize shape models directly on meshes, we are reducing the hardware requirements and memory load of the software, allowing it to run faster on weaker systems, including personal computers.</p> <p>Note</p> <p>Femur dataset segmentation data: 9.2GB vs. mesh data: 53.1MB</p> <p>Particle updates using geodesic walks so particles never leave the surface </p> <p>Optimizing particles on spheres with lumps of different sizes</p> <p> <p>Optimizing particles on open meshes</p> <p> <p>As of ShapeWorks 6, we enabled using surface normals as correspondence features.</p> <p>Surface normals enable better modeling of thin structures </p> <p>Better surface sampling and correspondences with surface normals </p>"},{"location":"notebooks/array-passing-without-copying.html","title":"Array passing without copying","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\n</pre> import shapeworks as sw In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[\u00a0]: Copied! <pre>dims = (1,3,2) # NOTE: numpy dims are specified in z, y, x order\nfarr = np.ndarray(dims, dtype=np.float32)\n\nival = 10; jval = 50; kval = 1.75\nfor i in range(0, farr.shape[2]):\n    for j in range(0, farr.shape[1]):\n        for k in range(0, farr.shape[0]):\n            farr[k][j][i] = ival*(i/farr.shape[2]) + jval*(j/farr.shape[1]) + kval/farr.shape[0]\n</pre> dims = (1,3,2) # NOTE: numpy dims are specified in z, y, x order farr = np.ndarray(dims, dtype=np.float32)  ival = 10; jval = 50; kval = 1.75 for i in range(0, farr.shape[2]):     for j in range(0, farr.shape[1]):         for k in range(0, farr.shape[0]):             farr[k][j][i] = ival*(i/farr.shape[2]) + jval*(j/farr.shape[1]) + kval/farr.shape[0] In\u00a0[\u00a0]: Copied! <pre>farr.mean()\n</pre> farr.mean() In\u00a0[\u00a0]: Copied! <pre>farr.dtype\n</pre> farr.dtype In\u00a0[\u00a0]: Copied! <pre>farr.flags['OWNDATA']\n</pre> farr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>farrimg = sw.Image(farr)\nfarrimg  # NOTE: sw.Image dims are specified in x, y, z order\n</pre> farrimg = sw.Image(farr) farrimg  # NOTE: sw.Image dims are specified in x, y, z order In\u00a0[\u00a0]: Copied! <pre>farrimg.mean()\n</pre> farrimg.mean() In\u00a0[\u00a0]: Copied! <pre>farr.flags['OWNDATA']\n</pre> farr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>farrimg += 100\n</pre> farrimg += 100 In\u00a0[\u00a0]: Copied! <pre>farrimg.mean()\n</pre> farrimg.mean() In\u00a0[\u00a0]: Copied! <pre>farr.mean()\n</pre> farr.mean() In\u00a0[\u00a0]: Copied! <pre>del farr\n</pre> del farr In\u00a0[\u00a0]: Copied! <pre>dims = (12,3,21)\ndarr = np.ndarray(dims, dtype=np.float64)\n\nival = 10; jval = 50; kval = 1.75\nfor k in range(0, dims[0]):\n    for j in range(0, dims[1]):\n        for i in range(0, dims[2]):\n            darr[k][j][i] = ival*(i/darr.shape[2]) + jval*(j/darr.shape[1]) + kval/darr.shape[0]\n</pre> dims = (12,3,21) darr = np.ndarray(dims, dtype=np.float64)  ival = 10; jval = 50; kval = 1.75 for k in range(0, dims[0]):     for j in range(0, dims[1]):         for i in range(0, dims[2]):             darr[k][j][i] = ival*(i/darr.shape[2]) + jval*(j/darr.shape[1]) + kval/darr.shape[0] In\u00a0[\u00a0]: Copied! <pre>darr.dtype\n</pre> darr.dtype In\u00a0[\u00a0]: Copied! <pre>darr.flags['OWNDATA']\n</pre> darr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre># note: this try/catch is only used so the notebook runs to completion; not typically necessary\ntry:\n    darrimg = sw.Image(darr) # Throws an exception because dtype must be same as Image's pixel type\nexcept Exception as ex:\n    print(ex)\n</pre> # note: this try/catch is only used so the notebook runs to completion; not typically necessary try:     darrimg = sw.Image(darr) # Throws an exception because dtype must be same as Image's pixel type except Exception as ex:     print(ex) In\u00a0[\u00a0]: Copied! <pre>darrimg = sw.Image(np.array(darr, dtype=np.float32)) # Makes a copy of the array when passsed\ndarrimg\n</pre> darrimg = sw.Image(np.array(darr, dtype=np.float32)) # Makes a copy of the array when passsed darrimg In\u00a0[\u00a0]: Copied! <pre>darr.flags['OWNDATA']\n</pre> darr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>darrimg.mean()\n</pre> darrimg.mean() In\u00a0[\u00a0]: Copied! <pre>darr.mean()\n</pre> darr.mean() In\u00a0[\u00a0]: Copied! <pre>darrimg += 50\n</pre> darrimg += 50 In\u00a0[\u00a0]: Copied! <pre>darrimg.mean()\n</pre> darrimg.mean() In\u00a0[\u00a0]: Copied! <pre>darr.mean()\n</pre> darr.mean() In\u00a0[\u00a0]: Copied! <pre>darr *= 10\n</pre> darr *= 10 In\u00a0[\u00a0]: Copied! <pre>darrimg.mean()\n</pre> darrimg.mean() In\u00a0[\u00a0]: Copied! <pre>darr.mean()\n</pre> darr.mean() In\u00a0[\u00a0]: Copied! <pre>ellipsoid_path = \"../../../Testing/data/1x2x2.nrrd\"\nfemur_path = \"../../../Testing/data/femur.nrrd\"\n</pre> ellipsoid_path = \"../../../Testing/data/1x2x2.nrrd\" femur_path = \"../../../Testing/data/femur.nrrd\" In\u00a0[\u00a0]: Copied! <pre>img = sw.Image(ellipsoid_path)\nimg\n</pre> img = sw.Image(ellipsoid_path) img In\u00a0[\u00a0]: Copied! <pre>arr = img.toArray()\narr.dtype\n</pre> arr = img.toArray() arr.dtype In\u00a0[\u00a0]: Copied! <pre>arr.mean()\n</pre> arr.mean() In\u00a0[\u00a0]: Copied! <pre>img.mean()\n</pre> img.mean() In\u00a0[\u00a0]: Copied! <pre>arr.shape  # remember, numpy dims are zyx and Image dims are xyz \n</pre> arr.shape  # remember, numpy dims are zyx and Image dims are xyz  In\u00a0[\u00a0]: Copied! <pre>img.dims()\n</pre> img.dims() In\u00a0[\u00a0]: Copied! <pre>arr += 100\n</pre> arr += 100 In\u00a0[\u00a0]: Copied! <pre>img.mean()\n</pre> img.mean() In\u00a0[\u00a0]: Copied! <pre>arr.mean()\n</pre> arr.mean() In\u00a0[\u00a0]: Copied! <pre>arr.flags['OWNDATA']\n</pre> arr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>del arr\n</pre> del arr In\u00a0[\u00a0]: Copied! <pre>arr = img.toArray(copy=True)\narr.flags['OWNDATA']\n</pre> arr = img.toArray(copy=True) arr.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>arr = sw.Image(ellipsoid_path).toArray(copy=True)\narr.mean()\n</pre> arr = sw.Image(ellipsoid_path).toArray(copy=True) arr.mean() In\u00a0[\u00a0]: Copied! <pre>def use_arr(arr):\n    return arr.mean()\n</pre> def use_arr(arr):     return arr.mean() In\u00a0[\u00a0]: Copied! <pre>use_arr(sw.Image(ellipsoid_path).toArray(copy=True))\n</pre> use_arr(sw.Image(ellipsoid_path).toArray(copy=True)) In\u00a0[\u00a0]: Copied! <pre>import pyvista as pv\n</pre> import pyvista as pv In\u00a0[\u00a0]: Copied! <pre>pv.set_jupyter_backend(backend=\"ipyvtklink\")\n</pre> pv.set_jupyter_backend(backend=\"ipyvtklink\") In\u00a0[\u00a0]: Copied! <pre>#help(pv.Plotter)\n</pre> #help(pv.Plotter) In\u00a0[\u00a0]: Copied! <pre>plotter = pv.Plotter(shape    = (1, 1),\n                     notebook = True,\n                     border   = True)\nplotter.add_axes()\nplotter.add_bounding_box()\n#plotter.show_bounds()  # for some reason extremely slow on osx\n#plotter.show_grid()    # for some reason extremely slow on osx\n</pre> plotter = pv.Plotter(shape    = (1, 1),                      notebook = True,                      border   = True) plotter.add_axes() plotter.add_bounding_box() #plotter.show_bounds()  # for some reason extremely slow on osx #plotter.show_grid()    # for some reason extremely slow on osx In\u00a0[\u00a0]: Copied! <pre># NOTE: pyvisya-wrapped vtk images require 'F' ordering to prevent copying\narr = img.toArray(for_viewing = True) # 'F' is `for_viewing`\narr.flags\n</pre> # NOTE: pyvisya-wrapped vtk images require 'F' ordering to prevent copying arr = img.toArray(for_viewing = True) # 'F' is `for_viewing` arr.flags In\u00a0[\u00a0]: Copied! <pre>arr.flags\n</pre> arr.flags In\u00a0[\u00a0]: Copied! <pre># sw2vtkImage takes care of this for us\nvtkimg = sw.sw2vtkImage(img, verbose=True)\n</pre> # sw2vtkImage takes care of this for us vtkimg = sw.sw2vtkImage(img, verbose=True) In\u00a0[\u00a0]: Copied! <pre>vol = plotter.add_volume(vtkimg, shade=True, show_scalar_bar=True)\n</pre> vol = plotter.add_volume(vtkimg, shade=True, show_scalar_bar=True) In\u00a0[\u00a0]: Copied! <pre>plotter.show()\n</pre> plotter.show() In\u00a0[\u00a0]: Copied! <pre>plotter = pv.Plotter(shape    = (1, 1),\n                     notebook = True,\n                     border   = True)\nplotter.add_axes()\n</pre> plotter = pv.Plotter(shape    = (1, 1),                      notebook = True,                      border   = True) plotter.add_axes() In\u00a0[\u00a0]: Copied! <pre>img1 = sw.Image(femur_path)\n</pre> img1 = sw.Image(femur_path) In\u00a0[\u00a0]: Copied! <pre>img1.setSpacing((1.5, 0.75, 1))  # set spacing to show that it's preserved on both copy and assign\n</pre> img1.setSpacing((1.5, 0.75, 1))  # set spacing to show that it's preserved on both copy and assign In\u00a0[\u00a0]: Copied! <pre>img2 = sw.Image(img1)  # make a copy to be processed by a scipy Python filter (spacing preserved)\n</pre> img2 = sw.Image(img1)  # make a copy to be processed by a scipy Python filter (spacing preserved) In\u00a0[\u00a0]: Copied! <pre>from scipy import ndimage\n</pre> from scipy import ndimage In\u00a0[\u00a0]: Copied! <pre>ck = ndimage.gaussian_filter(img2.toArray(), 12.0)\n</pre> ck = ndimage.gaussian_filter(img2.toArray(), 12.0) In\u00a0[\u00a0]: Copied! <pre>ck.shape\n</pre> ck.shape In\u00a0[\u00a0]: Copied! <pre>ck.dtype\n</pre> ck.dtype In\u00a0[\u00a0]: Copied! <pre>ck.flags['OWNDATA']\n</pre> ck.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>img2.assign(ck)\n</pre> img2.assign(ck) In\u00a0[\u00a0]: Copied! <pre># notice numpy array ownership has been transferred to Image\nck.flags['OWNDATA']\n</pre> # notice numpy array ownership has been transferred to Image ck.flags['OWNDATA'] In\u00a0[\u00a0]: Copied! <pre>plotter.add_volume(sw.sw2vtkImage(img2), shade=True, show_scalar_bar=True)\n\nplotter.add_volume(sw.sw2vtkImage(img1), shade=True, show_scalar_bar=True)\n</pre> plotter.add_volume(sw.sw2vtkImage(img2), shade=True, show_scalar_bar=True)  plotter.add_volume(sw.sw2vtkImage(img1), shade=True, show_scalar_bar=True) In\u00a0[\u00a0]: Copied! <pre>plotter.show()\n</pre> plotter.show()"},{"location":"notebooks/array-passing-without-copying.html#shapeworks-image-from-numpy-array","title":"shapeworks Image from numpy array\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#while-the-numpy-can-still-look-at-the-memory-it-no-longer-has-ownership","title":"While the numpy can still look at the memory, it no longer has ownership:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#so-the-safest-thing-to-do-now-is-let-the-array-go-out-of-scope","title":"...so the safest thing to do now is let the array go out of scope:\u00b6","text":"<ul> <li>having used a temporary during Image construction: <code>img = sw.Image(np.array(arr))</code></li> <li>variable replacement after Image construction: <code>arr = np.zeros(1)</code></li> <li>explicit deletion after Image construction: <code>del arr</code></li> </ul>"},{"location":"notebooks/array-passing-without-copying.html#only-dtypefloat32-arrays-can-be-used-to-initialize-an-image","title":"Only dtype.float32 arrays can be used to initialize an image:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#no-unnecessary-copies-and-no-memory-leaks","title":"No unnecessary copies and no memory leaks!\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#the-numpy-array-still-owns-its-data-since-a-copy-was-passed-to-create-the-image","title":"The numpy array still owns its data since a copy was passed to create the Image.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#ownership-of-the-copys-memory-was-taken-by-the-image-before-it-went-out-of-scope","title":"Ownership of the copy's memory was taken by the image before it went out of scope.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#now-for-the-other-way-around","title":"Now for the other way around.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#numpy-array-from-shapeworks-image","title":"numpy array from shapeworks Image\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#the-numpy-array-references-the-memory-of-the-current-image-and-can-change-it","title":"The numpy array references the memory of the current Image and can change it:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#but-it-still-doesnt-have-ownership","title":"...but it still doesn't have ownership.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#since-many-image-operations-reallocate-internally-its-still-safest-to-let-it-go-out-of-scope-as-shown-above","title":"Since many Image operations reallocate internally, it's still safest to let it go out of scope as shown above.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#if-a-copy-is-needed-pass-copytrue-to-toarray","title":"If a copy is needed, pass <code>copy=True</code> to <code>toArray()</code>\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#this-can-be-useful-when-the-array-is-created-from-a-temporary-image","title":"This can be useful when the array is created from a temporary Image:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#viewing-the-image-using-pyvista","title":"viewing the image using pyvista\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#one-common-reason-to-get-the-images-array-is-for-viewing-using-pyvista-using-the-for_viewing-argument","title":"One common reason to get the Image's array is for viewing using pyvista using the <code>for_viewing</code> argument:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#finally-we-can-assign-a-numpy-array-to-an-existing-image","title":"Finally, we can <code>assign</code> a numpy array to an existing Image\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#this-retains-the-images-origin-scale-and-coordsys","title":"This retains the Image's origin, scale, and coordsys.\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#lets-use-a-scipy-operation-on-the-image","title":"Let's use a scipy operation on the image:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#the-return-from-this-filter-is-the-right-size-and-type-but-its-a-copy","title":"The return from this filter is the right size and type, but it's a copy:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#lets-assign-it-back-to-image-so-we-can-retain-images-origin-scale-and-coordsys","title":"Let's assign it back to Image so we can retain Image's origin, scale, and coordsys:\u00b6","text":""},{"location":"notebooks/array-passing-without-copying.html#now-we-can-look-at-it-again-in-the-plotter","title":"Now we can look at it again in the plotter:\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html","title":"Transforms can be used to center image data or to align two images","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\nimport numpy as np\nimport pyvista as pv\n</pre> import shapeworks as sw import numpy as np import pyvista as pv In\u00a0[\u00a0]: Copied! <pre>pv.set_jupyter_backend('static')\n</pre> pv.set_jupyter_backend('static') In\u00a0[\u00a0]: Copied! <pre>DATA = \"../ShapeWorks/Examples/Python/Data\"\n</pre> DATA = \"../ShapeWorks/Examples/Python/Data\" In\u00a0[\u00a0]: Copied! <pre>filename = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_14.nrrd\"\n</pre> filename = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_14.nrrd\" In\u00a0[\u00a0]: Copied! <pre>img = sw.Image(filename)\nprint(\"center: \", img.center())\nprint(\"center of mass: \", img.centerOfMass())\n</pre> img = sw.Image(filename) print(\"center: \", img.center()) print(\"center of mass: \", img.centerOfMass()) In\u00a0[\u00a0]: Copied! <pre>slices = sw.sw2vtkImage(img).slice_orthogonal(x=25,y=25,z=25)\n</pre> slices = sw.sw2vtkImage(img).slice_orthogonal(x=25,y=25,z=25) In\u00a0[\u00a0]: Copied! <pre>p = pv.Plotter(shape=(1,3), border=False)\n\np.subplot(0,0)\np.add_text(\"before centering\", position='lower_left')\np.add_mesh(slices[2], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'xy'\np.subplot(0,1)\np.add_mesh(slices[0], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'yz'\np.subplot(0,2)\np.add_mesh(slices[1], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'zx'\n\np.show()\n</pre> p = pv.Plotter(shape=(1,3), border=False)  p.subplot(0,0) p.add_text(\"before centering\", position='lower_left') p.add_mesh(slices[2], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'xy' p.subplot(0,1) p.add_mesh(slices[0], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'yz' p.subplot(0,2) p.add_mesh(slices[1], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'zx'  p.show() In\u00a0[\u00a0]: Copied! <pre>xform = img.createCenterOfMassTransform()\n</pre> xform = img.createCenterOfMassTransform() In\u00a0[\u00a0]: Copied! <pre># now center of mass is roughly at the center\nimg.applyTransform(xform)\nprint(\"center of mass: \", img.centerOfMass())\n</pre> # now center of mass is roughly at the center img.applyTransform(xform) print(\"center of mass: \", img.centerOfMass()) In\u00a0[\u00a0]: Copied! <pre># linear interpolation\nimg = sw.Image(filename)\nimg.applyTransform(xform, sw.InterpolationType.Linear)\nlin = sw.sw2vtkImage(img)\n</pre> # linear interpolation img = sw.Image(filename) img.applyTransform(xform, sw.InterpolationType.Linear) lin = sw.sw2vtkImage(img) In\u00a0[\u00a0]: Copied! <pre># closest point resampling\nimg = sw.Image(filename)\nimg.applyTransform(xform, sw.InterpolationType.NearestNeighbor)\nnn = sw.sw2vtkImage(img)\n</pre> # closest point resampling img = sw.Image(filename) img.applyTransform(xform, sw.InterpolationType.NearestNeighbor) nn = sw.sw2vtkImage(img) In\u00a0[\u00a0]: Copied! <pre>lin_slices = lin.slice_orthogonal(x=25,y=25,z=25)\nnn_slices = nn.slice_orthogonal(x=25,y=25,z=25)\n</pre> lin_slices = lin.slice_orthogonal(x=25,y=25,z=25) nn_slices = nn.slice_orthogonal(x=25,y=25,z=25) In\u00a0[\u00a0]: Copied! <pre>p = pv.Plotter(shape=(2,3), border=False)\n\np.subplot(0,0)\np.add_text(\"linear\")\np.add_mesh(lin_slices[2], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'xy'\np.subplot(0,1)\np.add_mesh(lin_slices[0], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'yz'\np.subplot(0,2)\np.add_mesh(lin_slices[1], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'zx'\n\np.subplot(1,0)\np.add_text(\"nearest neighbor\")\np.add_mesh(nn_slices[2], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'xy'\np.subplot(1,1)\np.add_mesh(nn_slices[0], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'yz'\np.subplot(1,2)\np.add_mesh(nn_slices[1], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'zx'\n\np.show()\n</pre> p = pv.Plotter(shape=(2,3), border=False)  p.subplot(0,0) p.add_text(\"linear\") p.add_mesh(lin_slices[2], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'xy' p.subplot(0,1) p.add_mesh(lin_slices[0], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'yz' p.subplot(0,2) p.add_mesh(lin_slices[1], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'zx'  p.subplot(1,0) p.add_text(\"nearest neighbor\") p.add_mesh(nn_slices[2], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'xy' p.subplot(1,1) p.add_mesh(nn_slices[0], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'yz' p.subplot(1,2) p.add_mesh(nn_slices[1], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'zx'  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>filename1 = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_17.nrrd\"\nfilename2 = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_19.nrrd\"\n</pre> filename1 = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_17.nrrd\" filename2 = DATA + \"/ellipsoid/Ellipsoids_UnPrepped/seg.ellipsoid_19.nrrd\" In\u00a0[\u00a0]: Copied! <pre>img1 = sw.Image(filename1)\nimg2 = sw.Image(filename2)\n</pre> img1 = sw.Image(filename1) img2 = sw.Image(filename2) In\u00a0[\u00a0]: Copied! <pre>img1_slices_orig = sw.sw2vtkImage(img1).slice_orthogonal(x=25,y=25,z=25)\nimg2_slices_orig = sw.sw2vtkImage(img2).slice_orthogonal(x=25,y=25,z=25)\n</pre> img1_slices_orig = sw.sw2vtkImage(img1).slice_orthogonal(x=25,y=25,z=25) img2_slices_orig = sw.sw2vtkImage(img2).slice_orthogonal(x=25,y=25,z=25) In\u00a0[\u00a0]: Copied! <pre>p = pv.Plotter(shape=(2,3), border=False)\n\np.subplot(0,0)\np.add_text(\"Image 1\")\np.add_mesh(img1_slices_orig[2], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'xy'\np.subplot(0,1)\np.add_mesh(img1_slices_orig[0], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'yz'\np.subplot(0,2)\np.add_mesh(img1_slices_orig[1], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'zx'\n\np.subplot(1,0)\np.add_text(\"Image 2\")\np.add_mesh(img2_slices_orig[2], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'xy'\np.subplot(1,1)\np.add_mesh(img2_slices_orig[0], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'yz'\np.subplot(1,2)\np.add_mesh(img2_slices_orig[1], style='points', show_scalar_bar=False)\np.show_grid()\np.camera_position = 'zx'\n\np.show()\n</pre> p = pv.Plotter(shape=(2,3), border=False)  p.subplot(0,0) p.add_text(\"Image 1\") p.add_mesh(img1_slices_orig[2], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'xy' p.subplot(0,1) p.add_mesh(img1_slices_orig[0], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'yz' p.subplot(0,2) p.add_mesh(img1_slices_orig[1], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'zx'  p.subplot(1,0) p.add_text(\"Image 2\") p.add_mesh(img2_slices_orig[2], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'xy' p.subplot(1,1) p.add_mesh(img2_slices_orig[0], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'yz' p.subplot(1,2) p.add_mesh(img2_slices_orig[1], style='points', show_scalar_bar=False) p.show_grid() p.camera_position = 'zx'  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>dt1 = img1.computeDT(1.0)\ndt2 = img2.computeDT(1.0)\n</pre> dt1 = img1.computeDT(1.0) dt2 = img2.computeDT(1.0) In\u00a0[\u00a0]: Copied! <pre>xform_1_to_2 = dt1.createRigidRegistrationTransform(dt2)\nxform_2_to_1 = dt2.createRigidRegistrationTransform(dt1)\n</pre> xform_1_to_2 = dt1.createRigidRegistrationTransform(dt2) xform_2_to_1 = dt2.createRigidRegistrationTransform(dt1) In\u00a0[\u00a0]: Copied! <pre>img1 = sw.Image(filename1)\nimg2 = sw.Image(filename2)\n</pre> img1 = sw.Image(filename1) img2 = sw.Image(filename2) In\u00a0[\u00a0]: Copied! <pre>img1.applyTransform(xform_1_to_2)\nimg2.applyTransform(xform_2_to_1)\n</pre> img1.applyTransform(xform_1_to_2) img2.applyTransform(xform_2_to_1) In\u00a0[\u00a0]: Copied! <pre>img1_slices = sw.sw2vtkImage(img1).slice_orthogonal(x=25,y=25,z=25)\nimg2_slices = sw.sw2vtkImage(img2).slice_orthogonal(x=25,y=25,z=25)\n</pre> img1_slices = sw.sw2vtkImage(img1).slice_orthogonal(x=25,y=25,z=25) img2_slices = sw.sw2vtkImage(img2).slice_orthogonal(x=25,y=25,z=25) In\u00a0[\u00a0]: Copied! <pre>p = pv.Plotter(shape=(3,3), border=False)\n\np.subplot(0,0)\np.add_text(\"1 -&gt; 2\")\np.add_mesh(img1_slices[2], style='points', show_scalar_bar=False, opacity=0.75)\np.add_mesh(img2_slices_orig[2], style='points', show_scalar_bar=False, opacity=0.25)\np.show_grid()\np.camera_position = 'xy'\np.subplot(0,1)\np.add_mesh(img1_slices[0], style='points', show_scalar_bar=False, opacity=0.75)\np.add_mesh(img2_slices_orig[0], style='points', show_scalar_bar=False, opacity=0.25)\np.show_grid()\np.camera_position = 'yz'\np.subplot(0,2)\np.add_mesh(img1_slices[1], style='points', show_scalar_bar=False, opacity=0.75)\np.add_mesh(img2_slices_orig[1], style='points', show_scalar_bar=False, opacity=0.25)\np.show_grid()\np.camera_position = 'zx'\n\np.subplot(1,0)\np.add_text(\"2 -&gt; 1\")\np.add_mesh(img1_slices_orig[2], style='points', show_scalar_bar=False, opacity=0.25)\np.add_mesh(img2_slices[2], style='points', show_scalar_bar=False, opacity=0.75)\np.show_grid()\np.camera_position = 'xy'\np.subplot(1,1)\np.add_mesh(img1_slices_orig[0], style='points', show_scalar_bar=False, opacity=0.25)\np.add_mesh(img2_slices[0], style='points', show_scalar_bar=False, opacity=0.75)\np.show_grid()\np.camera_position = 'yz'\np.subplot(1,2)\np.add_mesh(img1_slices_orig[1], style='points', show_scalar_bar=False, opacity=0.25)\np.add_mesh(img2_slices[1], style='points', show_scalar_bar=False, opacity=0.75)\np.show_grid()\np.camera_position = 'zx'\n\np.subplot(2,0)\np.add_text(\"both\")\np.add_mesh(img1_slices[2], style='points', show_scalar_bar=False, opacity=0.5)\np.add_mesh(img2_slices[2], style='points', show_scalar_bar=False, opacity=0.5)\np.show_grid()\np.camera_position = 'xy'\np.subplot(2,1)\np.add_mesh(img1_slices[0], style='points', show_scalar_bar=False, opacity=0.5)\np.add_mesh(img2_slices[0], style='points', show_scalar_bar=False, opacity=0.5)\np.show_grid()\np.camera_position = 'yz'\np.subplot(2,2)\np.add_mesh(img1_slices[1], style='points', show_scalar_bar=False, opacity=0.5)\np.add_mesh(img2_slices[1], style='points', show_scalar_bar=False, opacity=0.5)\np.show_grid()\np.camera_position = 'zx'\n\np.show()\n</pre> p = pv.Plotter(shape=(3,3), border=False)  p.subplot(0,0) p.add_text(\"1 -&gt; 2\") p.add_mesh(img1_slices[2], style='points', show_scalar_bar=False, opacity=0.75) p.add_mesh(img2_slices_orig[2], style='points', show_scalar_bar=False, opacity=0.25) p.show_grid() p.camera_position = 'xy' p.subplot(0,1) p.add_mesh(img1_slices[0], style='points', show_scalar_bar=False, opacity=0.75) p.add_mesh(img2_slices_orig[0], style='points', show_scalar_bar=False, opacity=0.25) p.show_grid() p.camera_position = 'yz' p.subplot(0,2) p.add_mesh(img1_slices[1], style='points', show_scalar_bar=False, opacity=0.75) p.add_mesh(img2_slices_orig[1], style='points', show_scalar_bar=False, opacity=0.25) p.show_grid() p.camera_position = 'zx'  p.subplot(1,0) p.add_text(\"2 -&gt; 1\") p.add_mesh(img1_slices_orig[2], style='points', show_scalar_bar=False, opacity=0.25) p.add_mesh(img2_slices[2], style='points', show_scalar_bar=False, opacity=0.75) p.show_grid() p.camera_position = 'xy' p.subplot(1,1) p.add_mesh(img1_slices_orig[0], style='points', show_scalar_bar=False, opacity=0.25) p.add_mesh(img2_slices[0], style='points', show_scalar_bar=False, opacity=0.75) p.show_grid() p.camera_position = 'yz' p.subplot(1,2) p.add_mesh(img1_slices_orig[1], style='points', show_scalar_bar=False, opacity=0.25) p.add_mesh(img2_slices[1], style='points', show_scalar_bar=False, opacity=0.75) p.show_grid() p.camera_position = 'zx'  p.subplot(2,0) p.add_text(\"both\") p.add_mesh(img1_slices[2], style='points', show_scalar_bar=False, opacity=0.5) p.add_mesh(img2_slices[2], style='points', show_scalar_bar=False, opacity=0.5) p.show_grid() p.camera_position = 'xy' p.subplot(2,1) p.add_mesh(img1_slices[0], style='points', show_scalar_bar=False, opacity=0.5) p.add_mesh(img2_slices[0], style='points', show_scalar_bar=False, opacity=0.5) p.show_grid() p.camera_position = 'yz' p.subplot(2,2) p.add_mesh(img1_slices[1], style='points', show_scalar_bar=False, opacity=0.5) p.add_mesh(img2_slices[1], style='points', show_scalar_bar=False, opacity=0.5) p.show_grid() p.camera_position = 'zx'  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/create-and-apply-image-transforms.html#transforms-can-be-used-to-center-image-data-or-to-align-two-images","title":"Transforms can be used to center image data or to align two images\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#center-of-mass-transforms","title":"Center of mass transforms\u00b6","text":"<p>Centers the contents of a given image using the specified resampling method</p>"},{"location":"notebooks/create-and-apply-image-transforms.html#create-and-apply-transform-noting-that-center-of-mass-is-now-roughly-in-the-center-of-the-image","title":"create and apply transform, noting that center of mass is now roughly in the center of the image\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#visualization-of-different-resampling-methods","title":"visualization of different resampling methods\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#rigid-registration-transforms","title":"Rigid registration transforms\u00b6","text":"<p>Aligns two images using their distance transforms by converting these to meshes, computing the alignment using iterative closest point (ICP), then resampling to move the center of mass of one to be aligned with the other</p> <p>NOTE: images used to compute the transform must be distance transforms</p>"},{"location":"notebooks/create-and-apply-image-transforms.html#compute-distance-transforms-to-be-used-to-compute-alignment-of-the-segmentations","title":"compute distance transforms to be used to compute alignment of the segmentations\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#create-distance-transforms-to-be-used-to-compute-the-images-alignment","title":"create distance transforms to be used to compute the images' alignment\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#create-image-alignment-transforms","title":"create image alignment transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#apply-the-transforms-to-the-original-images","title":"apply the transforms to the original images\u00b6","text":""},{"location":"notebooks/create-and-apply-image-transforms.html#visualize-the-results","title":"visualize the results\u00b6","text":"<p>Notice how it even rotates the images into each others' centers of mass</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html","title":"Transforms can also be used to align two meshes","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\nimport numpy as np\nimport pyvista as pv\nimport matplotlib\n</pre> import shapeworks as sw import numpy as np import pyvista as pv import matplotlib In\u00a0[\u00a0]: Copied! <pre>pv.set_jupyter_backend('static')\n</pre> pv.set_jupyter_backend('static') In\u00a0[\u00a0]: Copied! <pre>DATA = \"../Data\"\n</pre> DATA = \"../Data\" In\u00a0[\u00a0]: Copied! <pre>filename1 = DATA + \"/ellipsoid_1mode/meshes/ellipsoid_05.vtk\"\nfilename2 = DATA + \"/ellipsoid_1mode/meshes/ellipsoid_07.vtk\"\n</pre> filename1 = DATA + \"/ellipsoid_1mode/meshes/ellipsoid_05.vtk\" filename2 = DATA + \"/ellipsoid_1mode/meshes/ellipsoid_07.vtk\" In\u00a0[\u00a0]: Copied! <pre>mesh1 = sw.Mesh(filename1)\nmesh2 = sw.Mesh(filename2)\n</pre> mesh1 = sw.Mesh(filename1) mesh2 = sw.Mesh(filename2) In\u00a0[\u00a0]: Copied! <pre>pv_mesh1_orig = sw.sw2vtkMesh(mesh1)\npv_mesh2_orig = sw.sw2vtkMesh(mesh2)\n</pre> pv_mesh1_orig = sw.sw2vtkMesh(mesh1) pv_mesh2_orig = sw.sw2vtkMesh(mesh2) In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0)\np.camera_position = 'zx'\n\np.add_text(\"Original Meshes\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0) p.camera_position = 'zx'  p.add_text(\"Original Meshes\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', opacity=1.0) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre>xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Rigid)\nxform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Rigid)\n</pre> xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Rigid) xform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Rigid) In\u00a0[\u00a0]: Copied! <pre>mesh1.applyTransform(xform_1_to_2)\nmesh2.applyTransform(xform_2_to_1)\n</pre> mesh1.applyTransform(xform_1_to_2) mesh2.applyTransform(xform_2_to_1) In\u00a0[\u00a0]: Copied! <pre>pv_mesh1 = sw.sw2vtkMesh(mesh1)\npv_mesh2 = sw.sw2vtkMesh(mesh2)\n</pre> pv_mesh1 = sw.sw2vtkMesh(mesh1) pv_mesh2 = sw.sw2vtkMesh(mesh2) In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Rigid Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Rigid Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Rigid Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Rigid Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>mesh1 = sw.Mesh(filename1)\nmesh2 = sw.Mesh(filename2)\n</pre> mesh1 = sw.Mesh(filename1) mesh2 = sw.Mesh(filename2) In\u00a0[\u00a0]: Copied! <pre>xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Similarity)\nxform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Similarity)\n</pre> xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Similarity) xform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Similarity) In\u00a0[\u00a0]: Copied! <pre>mesh1.applyTransform(xform_1_to_2)\nmesh2.applyTransform(xform_2_to_1)\n</pre> mesh1.applyTransform(xform_1_to_2) mesh2.applyTransform(xform_2_to_1) In\u00a0[\u00a0]: Copied! <pre>pv_mesh1 = sw.sw2vtkMesh(mesh1)\npv_mesh2 = sw.sw2vtkMesh(mesh2)\n</pre> pv_mesh1 = sw.sw2vtkMesh(mesh1) pv_mesh2 = sw.sw2vtkMesh(mesh2) In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Similarity Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Similarity Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Similarity Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Similarity Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>mesh1 = sw.Mesh(filename1)\nmesh2 = sw.Mesh(filename2)\n</pre> mesh1 = sw.Mesh(filename1) mesh2 = sw.Mesh(filename2) In\u00a0[\u00a0]: Copied! <pre>xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Affine)\nxform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Affine)\n</pre> xform_1_to_2 = mesh1.createTransform(mesh2, sw.Mesh.AlignmentType.Affine) xform_2_to_1 = mesh2.createTransform(mesh1, sw.Mesh.AlignmentType.Affine) In\u00a0[\u00a0]: Copied! <pre>mesh1.applyTransform(xform_1_to_2)\nmesh2.applyTransform(xform_2_to_1)\n</pre> mesh1.applyTransform(xform_1_to_2) mesh2.applyTransform(xform_2_to_1) In\u00a0[\u00a0]: Copied! <pre>pv_mesh1 = sw.sw2vtkMesh(mesh1)\npv_mesh2 = sw.sw2vtkMesh(mesh2)\n</pre> pv_mesh1 = sw.sw2vtkMesh(mesh1) pv_mesh2 = sw.sw2vtkMesh(mesh2) In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Affine Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Affine Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh1, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh2_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre># used to maintain bounds even when meshes' positions change\na = pv.UniformGrid()\na.dimensions = np.array([9,8,8])\na.origin = (-15,-5,-15)\na.spacing = (10, 10, 10)\noutline = a.outline()\n\np = pv.Plotter(shape=(2,2), border=False)\n\np.subplot(0,0)\np.add_text(\"xy\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'xy'\n\np.subplot(0,1)\np.add_text(\"yz\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'yz'\n\np.subplot(1,0)\np.add_text(\"zx\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5)\np.camera_position = 'zx'\n\np.add_text(\"Affine Transforms\", position='lower_edge')\n\np.subplot(1,1)\np.add_text(\"persp\")\np.add_mesh(outline)\np.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0)\np.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75)\np.camera_position = [100,35,70]\np.set_viewup([0,1,0])\np.show_bounds(grid='front', location='outer', all_edges=False, )\n\np.show()\n</pre> # used to maintain bounds even when meshes' positions change a = pv.UniformGrid() a.dimensions = np.array([9,8,8]) a.origin = (-15,-5,-15) a.spacing = (10, 10, 10) outline = a.outline()  p = pv.Plotter(shape=(2,2), border=False)  p.subplot(0,0) p.add_text(\"xy\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'xy'  p.subplot(0,1) p.add_text(\"yz\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'yz'  p.subplot(1,0) p.add_text(\"zx\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.5) p.camera_position = 'zx'  p.add_text(\"Affine Transforms\", position='lower_edge')  p.subplot(1,1) p.add_text(\"persp\") p.add_mesh(outline) p.add_mesh(pv_mesh2, show_scalar_bar=False, color='#4fb080', opacity=1.0) p.add_mesh(pv_mesh1_orig, show_scalar_bar=False, color='#ced175', style='wireframe', opacity=0.75) p.camera_position = [100,35,70] p.set_viewup([0,1,0]) p.show_bounds(grid='front', location='outer', all_edges=False, )  p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#transforms-can-also-be-used-to-align-two-meshes","title":"Transforms can also be used to align two meshes\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-alignment","title":"Mesh alignment\u00b6","text":"<p>A mesh transformation can be computed rigidly, using similarity, or as an affine matrix. The alignment is computed using the iterative closest point (ICP) method for the specified number of iterations (default: a similarity transform with 10 iterations).</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#load-meshes","title":"Load meshes\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#visualize-original-meshes","title":"Visualize original meshes\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#rigid-transformation","title":"Rigid transformation\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#create-transforms","title":"create transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#apply-transforms","title":"apply transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#visualize-results","title":"visualize results\u00b6","text":"<p>Notice how the original meshes do not change shape. This is very different from affine transformations below.</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-1-mesh-2","title":"Mesh 1 -&gt; Mesh 2\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-2-mesh-1","title":"Mesh 2 -&gt; Mesh 1\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#similarity-transformation","title":"Similarity transformation\u00b6","text":"<p>This type of transformation is very similar to rigid transformations above.</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#reload-meshes","title":"Reload meshes\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#create-transforms","title":"create transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#apply-transforms","title":"apply transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#visualize-results","title":"visualize results\u00b6","text":"<p>Notice how the original meshes do not change shape (or orientation wrt the origin? How are these different from affine?)</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-1-mesh-2","title":"Mesh 1 -&gt; Mesh 2\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-2-mesh-1","title":"Mesh 2 -&gt; Mesh 1\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#affine-transformation","title":"Affine transformation\u00b6","text":"<p>This type of transformation warps the points of one mesh into the other as well as translating its position.</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#reload-meshes","title":"Reload meshes\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#create-transforms","title":"create transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#apply-transforms","title":"apply transforms\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#visualize-results","title":"visualize results\u00b6","text":"<p>Notice how the original meshes do not change shape (or orientation wrt the origin? How are these different from affine?)</p>"},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-1-mesh-2","title":"Mesh 1 -&gt; Mesh 2\u00b6","text":""},{"location":"notebooks/create-and-apply-mesh-transforms.html#mesh-2-mesh-1","title":"Mesh 2 -&gt; Mesh 1\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html","title":"Getting Started with Data Augmentation","text":"In\u00a0[\u00a0]: Copied! <pre>import os \nimport sys \nimport shapeworks\n</pre> import os  import sys  import shapeworks In\u00a0[\u00a0]: Copied! <pre>import DataAugmentationUtils\n</pre> import DataAugmentationUtils In\u00a0[\u00a0]: Copied! <pre># dataset name is the folder name for your dataset\ndatasetName  = 'femur-v0'\n\n# path to the dataset where we can find shape data \n# here we assume shape data are given as binary segmentations\ndata_dir      = '../../Data/' + datasetName + '/'\n    \nprint('Dataset Name:     ' + datasetName)\nprint('Directory:  ' + data_dir)\n</pre> # dataset name is the folder name for your dataset datasetName  = 'femur-v0'  # path to the dataset where we can find shape data  # here we assume shape data are given as binary segmentations data_dir      = '../../Data/' + datasetName + '/'      print('Dataset Name:     ' + datasetName) print('Directory:  ' + data_dir) In\u00a0[\u00a0]: Copied! <pre># Get image path list\nimg_dir = data_dir + \"groomed/images/\"\nimg_list = []\nfor file in os.listdir(img_dir):\n    img_list.append(img_dir + file)\nimg_list = sorted(img_list)\n\n# Get particles path list\nmodel_dir =  data_dir + \"shape_models/femur/1024/\" \nworld_particle_list = []\nfor file in os.listdir(model_dir):\n    if \"world\" in file:\n        world_particle_list.append(model_dir + file)\nworld_particle_list = sorted(world_particle_list)\n\nprint(\"Total shapes in original dataset: \"+ str(len(img_list)))\n</pre> # Get image path list img_dir = data_dir + \"groomed/images/\" img_list = [] for file in os.listdir(img_dir):     img_list.append(img_dir + file) img_list = sorted(img_list)  # Get particles path list model_dir =  data_dir + \"shape_models/femur/1024/\"  world_particle_list = [] for file in os.listdir(model_dir):     if \"world\" in file:         world_particle_list.append(model_dir + file) world_particle_list = sorted(world_particle_list)  print(\"Total shapes in original dataset: \"+ str(len(img_list))) In\u00a0[\u00a0]: Copied! <pre># Augmentation variables to keep constant\nnum_samples = 50\nnum_dim = 0\npercent_variability = 0.95\n</pre> # Augmentation variables to keep constant num_samples = 50 num_dim = 0 percent_variability = 0.95 In\u00a0[\u00a0]: Copied! <pre>output_directory = '../Output/GaussianAugmentation/'\nsampler_type = \"gaussian\"\nembedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, world_particle_list, num_samples, num_dim, percent_variability, sampler_type)\naug_data_csv = output_directory + \"/TotalData.csv\"\n</pre> output_directory = '../Output/GaussianAugmentation/' sampler_type = \"gaussian\" embedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, world_particle_list, num_samples, num_dim, percent_variability, sampler_type) aug_data_csv = output_directory + \"/TotalData.csv\" In\u00a0[\u00a0]: Copied! <pre>DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin')\n</pre> DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin') <p>Example output:</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>output_directory = '../Output/MixtureAugmentation/'\nsampler_type = \"mixture\"\nembedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, world_particle_list, num_samples, num_dim, percent_variability, sampler_type)\naug_data_csv = output_directory + \"/TotalData.csv\"\n</pre> output_directory = '../Output/MixtureAugmentation/' sampler_type = \"mixture\" embedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, world_particle_list, num_samples, num_dim, percent_variability, sampler_type) aug_data_csv = output_directory + \"/TotalData.csv\" In\u00a0[\u00a0]: Copied! <pre>DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin')\n</pre> DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin') <p>Example output:</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>output_directory = '../Output/KDEAugmentation/'\nsampler_type = \"kde\"\nembedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, local_particle_list, num_samples, num_dim, percent_variability, sampler_type)\naug_data_csv = output_directory + \"/TotalData.csv\"\n</pre> output_directory = '../Output/KDEAugmentation/' sampler_type = \"kde\" embedded_dim = DataAugmentationUtils.runDataAugmentation(output_directory, img_list, local_particle_list, num_samples, num_dim, percent_variability, sampler_type) aug_data_csv = output_directory + \"/TotalData.csv\" In\u00a0[\u00a0]: Copied! <pre>DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin')\n</pre> DataAugmentationUtils.visualizeAugmentation(aug_data_csv, 'violin') <p>Example output:</p> <p></p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#getting-started-with-data-augmentation","title":"Getting Started with Data Augmentation\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#before-you-start","title":"Before you start!\u00b6","text":"<ul> <li>This notebook assumes that shapeworks conda environment has been activated using <code>conda activate shapeworks</code> on the terminal.</li> <li>See Getting Started with Notebooks for information on setting up your environment and notebook shortcuts.</li> <li>Note example output was generated on Linux/Mac environment and may look different on Windows.</li> </ul>"},{"location":"notebooks/getting-started-with-data-augmentation.html#in-this-notebook-you-will-learn","title":"In this notebook, you will learn:\u00b6","text":"<ol> <li>How to generate realistic synthetic data from an existing dataset using different parametric distributions.</li> <li>How to visualize the statistical distribution of the generated data compared to the original data.</li> </ol>"},{"location":"notebooks/getting-started-with-data-augmentation.html#data-augmentation-overview","title":"Data Augmentation Overview\u00b6","text":"<p>ShapeWorks includes a Python package, DataAugmentationUtils, that supports model-based data augmentation. This package is useful to increase the training sample size to train deep networks such as DeepSSM (see SSMs Directly from Images).</p> <p>A preliminary requirement for data augmentation is a set of images and shape models from real data on which to base augmentation. Once that is acquired, the process includes:</p> <ol> <li>Embedding the real data into a low-dimensional space using principle component analysis (PCA).</li> <li>Fitting a parametric distribution to the subspace for sampling.</li> <li>Sampling from the distribution to create new instances.</li> <li>Projecting the samples back into the high-dimensional space of the original data</li> <li>Completing the sample generation by creating a corresponding synthetic image.</li> </ol> <p>This notebook shows how the distribution of the original data can be visually compared to the distribution of the synthetic data to motivate the choice of parametric distribution in step 2.</p> <p>For a full explanation of the data augmentation process and package please see: Data Augmentation for Deep Learning.</p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#import-shapeworks-and-relevant-libraries","title":"Import shapeworks and relevant libraries\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#import-data-augmentation-package","title":"Import Data Augmentation Package\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#1-defining-the-original-dataset","title":"1. Defining the original dataset\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#defining-dataset-location","title":"Defining dataset location\u00b6","text":"<p>You can download exemplar datasets from ShapeWorks data portal after you login. For new users, you can register an account for free. Please do not use an important password.</p> <p>After you login, click <code>Collections</code> on the left panel and then <code>use-case-data-v2</code>. Select the dataset you would like to download by clicking on the checkbox on the left of the dataset name. See the video below. After you download the dataset zip file, make sure you unzip/extract the contents in the appropriate location.</p> <p>This notebook assumes that you have downloaded <code>femur-v0</code> and you have placed the unzipped folder <code>femur-v0</code> in <code>Examples/Python/Data</code>. Feel free to use your own dataset.</p> <p></p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#get-file-lists","title":"Get file lists\u00b6","text":"<p>Now we need the .particle files and corresponding raw images for the original dataset.</p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#run-data-augmentation-using-a-gaussian-distribution","title":"Run data augmentation using a Gaussian Distribution\u00b6","text":"<p>Below is the command for running the complete data augmentation process:</p> <pre>DataAugmentationUtils.runDataAugmentation(out_dir, img_list, \n                                          world_point_list, num_samples, \n                                          num_dim, percent_variability, \n                                          sampler_type, mixture_num)\n</pre> <p>Input arguments:</p> <ul> <li><code>out_dir</code>: Path to the directory where augmented data will be stored</li> <li><code>img_list</code>: List of paths to images of the original dataset.</li> <li><code>world_point_list</code>: List of paths to world <code>.particles</code> files of the original dataset. Note, this list should be ordered in correspondence with the <code>img_list</code>.</li> <li><code>num_dim</code>: The number of dimensions to reduce to in PCA embedding. If zero or not specified, the percent_variability option is used to select the numnber of dimensions.</li> <li><code>percent_variability</code>: The proportion of variability in the data to be preserved in embedding. Used if <code>num_dim</code> is zero or not specified. Default value is 0.95 which preserves 95% of the varibaility in the data.</li> <li><code>sampler_type</code>: The type of parametric distribution to fit and sample from. Options: <code>gaussian</code>, <code>mixture</code>, or <code>kde</code>. Default: <code>kde</code>.</li> <li><code>mixture_num</code>: Only necessary if <code>sampler_type</code> is <code>mixture</code>. The number of clusters (i.e., mixture components) to be used in fitting a mixture model. If zero or not specified, the optimal number of clusters will be automatically determined using the elbow method).</li> </ul> <p>In this notebook we will keep most arguments the same and explore the effect of changing the <code>sampler_type</code>. First, we will try a Gaussian distribution. For further explanation about each distribution, see Data Augmentation for Deep Learning.</p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#visualize-distribution-of-real-and-augmented-data","title":"Visualize distribution of real and augmented data\u00b6","text":"<p>Below is the command for visualizing the original and augmented data:</p> <pre><code>DataAugmentationUtils.visualizeAugmentation(data_csv, viz_type)\n</code></pre> <p>Input arguments:</p> <ul> <li><code>data_csv</code>: The path to the CSV file created by running the data augmentation process.</li> <li><code>viz_type</code>: The type of visulazation to display. Options <code>splom</code> or <code>violin</code> (default: <code>splom</code>). If set to <code>splom</code>, a scatterplot matrix of pairwise PCA comparisions will open in the default browser. If set to <code>violin</code> a violin plot or rotated kernel density plot will be displayed.</li> </ul> <p>We will use a violin plot to visualize the difference in the real and augmented distributions.</p>"},{"location":"notebooks/getting-started-with-data-augmentation.html#run-data-augmentation-using-a-mixture-of-gaussian-distribution","title":"Run data augmentation using a Mixture of Gaussian Distribution\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#visualize-distribution-of-real-and-augmented-data","title":"Visualize distribution of real and augmented data\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#run-data-augmentation-using-kernel-density-estimation","title":"Run data augmentation using Kernel Density Estimation\u00b6","text":""},{"location":"notebooks/getting-started-with-data-augmentation.html#visualize-distribution-of-real-and-augmented-data","title":"Visualize distribution of real and augmented data\u00b6","text":""},{"location":"notebooks/getting-started-with-exploring-segmentations.html","title":"Getting Started with Exploring Segmentations","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\n</pre> import shapeworks as sw In\u00a0[\u00a0]: Copied! <pre>#import relevant libraries\nimport os\nimport pyvista as pv\nimport numpy as np\n\n# dataset name is the folder name for your dataset\ndatasetName  = 'ellipsoid_1mode'\n\n# path to the dataset where we can find shape data \n# here we assume shape data are given as binary segmentations\nshapeDir      = '../../Data/' + datasetName + '/segmentations/'\n    \nprint('Dataset Name:     ' + datasetName)\nprint('Shape Directory:  ' + shapeDir)\n</pre> #import relevant libraries import os import pyvista as pv import numpy as np  # dataset name is the folder name for your dataset datasetName  = 'ellipsoid_1mode'  # path to the dataset where we can find shape data  # here we assume shape data are given as binary segmentations shapeDir      = '../../Data/' + datasetName + '/segmentations/'      print('Dataset Name:     ' + datasetName) print('Shape Directory:  ' + shapeDir) In\u00a0[\u00a0]: Copied! <pre>import glob \nfrom pathlib import Path \n\n\nshapeExtention = '.nrrd'\n\n# let's get a list of files for available segmentations in this dataset\n# * here is a wild character used to retrieve all filenames \n# in the shape directory with the file extensnion\nshapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention)) \n\nprint ('Number of shapes: ' + str(len(shapeFilenames)))\nprint('Shape files found:')\nfor shapeFilename in shapeFilenames:\n    shapeFilename = Path(shapeFilename)\n    print(shapeFilename)\n</pre> import glob  from pathlib import Path    shapeExtention = '.nrrd'  # let's get a list of files for available segmentations in this dataset # * here is a wild character used to retrieve all filenames  # in the shape directory with the file extensnion shapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention))   print ('Number of shapes: ' + str(len(shapeFilenames))) print('Shape files found:') for shapeFilename in shapeFilenames:     shapeFilename = Path(shapeFilename)     print(shapeFilename) In\u00a0[\u00a0]: Copied! <pre># list of shape segmentations\nshapeSegList = []\n\n# list of shape names (shape files prefixes) to be used \n# for saving outputs and visualizations\nshapeNames   = [] \n\n# loop over all shape files and load individual segmentations\nfor shapeFilename in shapeFilenames:\n    print('Loading: ' + shapeFilename)\n    \n    # current shape name\n    segFilename = shapeFilename.split('/')[-1] \n    shapeName   = segFilename[:-len(shapeExtention)]\n    shapeNames.append(shapeName)\n    \n    # load segmentation\n    shapeSeg = sw.Image(shapeFilename)\n    \n    # append to the shape list\n    shapeSegList.append(shapeSeg)\n\nnum_samples = len(shapeSegList)\nprint('\\n' + str(num_samples) + \n      ' segmentations are loaded for the ' + datasetName + ' dataset ...')\n</pre> # list of shape segmentations shapeSegList = []  # list of shape names (shape files prefixes) to be used  # for saving outputs and visualizations shapeNames   = []   # loop over all shape files and load individual segmentations for shapeFilename in shapeFilenames:     print('Loading: ' + shapeFilename)          # current shape name     segFilename = shapeFilename.split('/')[-1]      shapeName   = segFilename[:-len(shapeExtention)]     shapeNames.append(shapeName)          # load segmentation     shapeSeg = sw.Image(shapeFilename)          # append to the shape list     shapeSegList.append(shapeSeg)  num_samples = len(shapeSegList) print('\\n' + str(num_samples) +        ' segmentations are loaded for the ' + datasetName + ' dataset ...') In\u00a0[\u00a0]: Copied! <pre># define parameters that controls the plotter\nuse_same_window = False # plot using multiple rendering windows if false\nnotebook        = False # True will enable the plots to lie inline\nshow_borders    = True  # show borders for each rendering window\nshade_volumes   = True  # use shading when performing volume rendering\ncolor_map       = \"viridis\" # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma'\nshow_axes       = True  # show a vtk axes widget for each rendering window\nshow_bounds     = True  # show volume bounding box\nshow_all_edges  = True  # add an unlabeled and unticked box at the boundaries of plot. \nfont_size       = 10    # text font size for windows\nlink_views      = True  # link all rendering windows so that they share same camera and axes boundaries\n\n# plot all segmentations in the shape list\nsw.plot_volumes(shapeSegList,    \n             volumeNames     = shapeNames, \n             use_same_window = use_same_window,\n             notebook        = notebook,\n             show_borders    = show_borders,  \n             shade_volumes   = shade_volumes, \n             color_map       = color_map,\n             show_axes       = show_axes,  \n             show_bounds     = show_bounds,\n             show_all_edges  = show_all_edges, \n             font_size       = font_size,   \n             link_views      = link_views\n             )\n</pre> # define parameters that controls the plotter use_same_window = False # plot using multiple rendering windows if false notebook        = False # True will enable the plots to lie inline show_borders    = True  # show borders for each rendering window shade_volumes   = True  # use shading when performing volume rendering color_map       = \"viridis\" # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma' show_axes       = True  # show a vtk axes widget for each rendering window show_bounds     = True  # show volume bounding box show_all_edges  = True  # add an unlabeled and unticked box at the boundaries of plot.  font_size       = 10    # text font size for windows link_views      = True  # link all rendering windows so that they share same camera and axes boundaries  # plot all segmentations in the shape list sw.plot_volumes(shapeSegList,                  volumeNames     = shapeNames,               use_same_window = use_same_window,              notebook        = notebook,              show_borders    = show_borders,                shade_volumes   = shade_volumes,               color_map       = color_map,              show_axes       = show_axes,                show_bounds     = show_bounds,              show_all_edges  = show_all_edges,               font_size       = font_size,                 link_views      = link_views              ) <p>Does this dataset need grooming? What are grooming steps needed? Let's inspect the segmentations. What do we observe?</p> In\u00a0[\u00a0]: Copied! <pre>import pyvista as pv\n# to better appreciate the pixelated nature of these segmentations, we need to only visualize \n# the binary segmentation, notice the thick slices\n\nshapeIdx = 10\nshapeSeg = shapeSegList[shapeIdx]\n \n\nshapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = True)\n\nsw.plot_volumes(shapeSeg_vtk)\n</pre> import pyvista as pv # to better appreciate the pixelated nature of these segmentations, we need to only visualize  # the binary segmentation, notice the thick slices  shapeIdx = 10 shapeSeg = shapeSegList[shapeIdx]    shapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = True)  sw.plot_volumes(shapeSeg_vtk) In\u00a0[\u00a0]: Copied! <pre># let's inspect a segmentation that touches the image boundaries\nshapeIdx = 13\nshapeSeg = shapeSegList[shapeIdx]\n\nshapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = False)\n\nsw.plot_volumes(shapeSeg_vtk)\n</pre> # let's inspect a segmentation that touches the image boundaries shapeIdx = 13 shapeSeg = shapeSegList[shapeIdx]  shapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = False)  sw.plot_volumes(shapeSeg_vtk) <p></p> <p>This segmentation touches the image boundary and hence will result in an artificially open surface. To inspect this behavior, we need extract a surface mesh (isosurface) from each segmentation. An isosurface is a three-dimensional surface that represents points of a constant value (aka isovalue) within the given volume of space.</p> In\u00a0[\u00a0]: Copied! <pre># let's see if there's a function that extracts an isosurface from an image\n# use dot-tap to get a list of functions/apis available for shapeSeg\n\n# found it - toMesh, let's see its help\nhelp(shapeSeg.toMesh)\n</pre> # let's see if there's a function that extracts an isosurface from an image # use dot-tap to get a list of functions/apis available for shapeSeg  # found it - toMesh, let's see its help help(shapeSeg.toMesh) <p>The <code>toMesh</code> function needs an isovalue, which is the constant value the represents the surface of interest. Since a shape segmentation is a binary image, the foreground is expected to have the value of 1 (white) and the background should have a zero value (black), so an appropriate isovalue to extract the foregound-background interface a value in between, e.g., 0.5</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n# let's make sure that our assumptions about the voxel values are correct\n# is the given volume a binary segmentation?\n\n# first convert to numpy array\nshapeSeg_array = shapeSeg.toArray()\n\n# make sure that it is a binary segmentation\nvoxelValues = np.unique(shapeSeg_array)\nprint('\\nVoxel values:' + str(voxelValues))\n\nif len(voxelValues) &gt; 2:\n    print('WARNING: ' + shapeName + ' is not a bindary segmentation. Voxels have more than two distinct values')\n    print('PLEASE make sure to use binary segmentations')\nelse:\n    print('Shape ' + shapeName + ' is a binary segmentation')\n</pre> import numpy as np # let's make sure that our assumptions about the voxel values are correct # is the given volume a binary segmentation?  # first convert to numpy array shapeSeg_array = shapeSeg.toArray()  # make sure that it is a binary segmentation voxelValues = np.unique(shapeSeg_array) print('\\nVoxel values:' + str(voxelValues))  if len(voxelValues) &gt; 2:     print('WARNING: ' + shapeName + ' is not a bindary segmentation. Voxels have more than two distinct values')     print('PLEASE make sure to use binary segmentations') else:     print('Shape ' + shapeName + ' is a binary segmentation') In\u00a0[\u00a0]: Copied! <pre># now define the isovalue, in case a binary segmentation has a foreground label that is not 1\n# we need to obtain a value inbetween\n\n# get min and max values\nminVal = shapeSeg_array.min()\nmaxVal = shapeSeg_array.max()\n\nprint('\\nMinimum voxel value: ' + str(minVal))\nprint('Maximum voxel value: ' + str(maxVal))\n\nisoValue = (maxVal - minVal)/2.0\nprint('\\nisoValue = ' + str(isoValue))\n</pre> # now define the isovalue, in case a binary segmentation has a foreground label that is not 1 # we need to obtain a value inbetween  # get min and max values minVal = shapeSeg_array.min() maxVal = shapeSeg_array.max()  print('\\nMinimum voxel value: ' + str(minVal)) print('Maximum voxel value: ' + str(maxVal))  isoValue = (maxVal - minVal)/2.0 print('\\nisoValue = ' + str(isoValue)) In\u00a0[\u00a0]: Copied! <pre># let's extract the segmentation isosurface and visualize it\n\n# extract isosurface\nshapeMesh = shapeSeg.toMesh(isovalue = isoValue)\n \n# sw to vtk\nshapeMesh_vtk = sw.sw2vtkMesh(shapeMesh)\n\nsw.plot_meshes([shapeMesh_vtk])\n</pre> # let's extract the segmentation isosurface and visualize it  # extract isosurface shapeMesh = shapeSeg.toMesh(isovalue = isoValue)   # sw to vtk shapeMesh_vtk = sw.sw2vtkMesh(shapeMesh)  sw.plot_meshes([shapeMesh_vtk]) <p></p> <p>So, we have been able to extract a segmentation's isosurface and visualize it as a surface mesh. It is worth noting that the jagged surface is due to the anisotropic voxel space (with spacing in z-dimension is double that of x- and y-dimensions) and large voxel size.</p> In\u00a0[\u00a0]: Copied! <pre># let's inspect some segmentations where we can observe misalignment\nshapeIdxs = [8,9,10]\n\nshapeSegSubset   = [shapeSegList[shapeIdx] for shapeIdx in shapeIdxs ]\nshapeNamesSubset = [shapeNames[shapeIdx]   for shapeIdx in shapeIdxs ]\n</pre> # let's inspect some segmentations where we can observe misalignment shapeIdxs = [8,9,10]  shapeSegSubset   = [shapeSegList[shapeIdx] for shapeIdx in shapeIdxs ] shapeNamesSubset = [shapeNames[shapeIdx]   for shapeIdx in shapeIdxs ] <p>To inspect how mutliple segmentation are spatially aligned with respect to each other, we will visualize their surfaces in the same rendering window.</p> In\u00a0[\u00a0]: Copied! <pre>shapeSegIsosurfaces     = []\nshapeSegIsosurfaces_vtk = []\n\nfor shapeSeg in shapeSegSubset:\n    \n    # extract isosurface\n    shapeIsosurface = shapeSeg.toMesh(isovalue = isoValue)\n    \n    shapeSegIsosurfaces.append(shapeIsosurface)\n \n    # sw to vtk\n    shapeSegIsosurfaces_vtk.append(sw.sw2vtkMesh(shapeIsosurface, verbose = False))\n</pre> shapeSegIsosurfaces     = [] shapeSegIsosurfaces_vtk = []  for shapeSeg in shapeSegSubset:          # extract isosurface     shapeIsosurface = shapeSeg.toMesh(isovalue = isoValue)          shapeSegIsosurfaces.append(shapeIsosurface)       # sw to vtk     shapeSegIsosurfaces_vtk.append(sw.sw2vtkMesh(shapeIsosurface, verbose = False))  In\u00a0[\u00a0]: Copied! <pre>sw.plot_meshes(shapeSegIsosurfaces,       \n            use_same_window = True, \n            notebook        = False,  \n            show_borders    = True,  \n            meshes_color    = ['tan', 'blue','red'], \n            mesh_style      = \"surface\", \n            show_mesh_edges = False, \n            show_axes       = True,  \n            show_bounds     = True,  \n            show_all_edges  = True,  \n            font_size       = 10,    \n            link_views      = True   \n           )\n</pre> sw.plot_meshes(shapeSegIsosurfaces,                    use_same_window = True,              notebook        = False,               show_borders    = True,               meshes_color    = ['tan', 'blue','red'],              mesh_style      = \"surface\",              show_mesh_edges = False,              show_axes       = True,               show_bounds     = True,               show_all_edges  = True,               font_size       = 10,                 link_views      = True               ) <p></p> In\u00a0[\u00a0]: Copied! <pre>shapeIdx = 12\nshapeSeg = shapeSegList[shapeIdx]\n\nshapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = False)\n\nsw.plot_volumes(shapeSeg_vtk)\n</pre> shapeIdx = 12 shapeSeg = shapeSegList[shapeIdx]  shapeSeg_vtk = sw.sw2vtkImage(shapeSeg, verbose = False)  sw.plot_volumes(shapeSeg_vtk) <p></p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#getting-started-with-exploring-segmentations","title":"Getting Started with Exploring Segmentations\u00b6","text":""},{"location":"notebooks/getting-started-with-exploring-segmentations.html#before-you-start","title":"Before you start!\u00b6","text":"<ul> <li>This notebook assumes that shapeworks conda environment has been activated using <code>conda activate shapeworks</code> on the terminal.</li> <li>See Getting Started with Notebooks for information on setting up your environment and notebook shortcuts.</li> <li>See Getting Started with Segmentations to learn how to load and visualize binary segmentations.</li> <li>Note example output was generated on Linux/Mac environment and may look different on Windows.</li> </ul>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#in-this-notebook-you-will-learn","title":"In this notebook, you will learn:\u00b6","text":"<ol> <li>How to define your dataset location and explore what is available in it</li> <li>How to explore your dataset</li> <li>How to decide the grooming pipeline needed for your dataset</li> </ol>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#1-defining-and-exploring-your-dataset","title":"1. Defining and exploring your dataset\u00b6","text":""},{"location":"notebooks/getting-started-with-exploring-segmentations.html#defining-dataset-location","title":"Defining dataset location\u00b6","text":"<p>You can download exemplar datasets from ShapeWorks data portal after you login. For new users, you can register an account for free. Please do not use an important password.</p> <p>After you login, click <code>Collections</code> on the left panel and then <code>use-case-data-v2</code>. Select the dataset you would like to download by clicking on the checkbox on the left of the dataset name. See the video below. After you download the dataset zip file, make sure you unzip/extract the contents in the appropriate location.</p> <p>This notebook assumes that you have downloaded <code>ellipsoid_1mode</code> and you have placed the unzipped folder <code>ellipsoid_1mode</code> in <code>Examples/Python/Data</code>. Feel free to use your own dataset.</p> <p></p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#what-is-available-in-the-dataset","title":"What is available in the dataset?\u00b6","text":"<p>First let's see how many shapes we have in the dataset.</p> <p>File formats: For binary segmentations, all itk-supported image formats can be used.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#2-exploring-your-dataset","title":"2. Exploring your dataset\u00b6","text":"<p>We would like to better understand the given dataset to decide the appropriate grooming (preprocessing) pipeline/step to prepare it for shape modeling.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#loading-your-dataset","title":"Loading your dataset\u00b6","text":"<p>First step is to load the dataset.</p> <p>Note: If your dataset is large (large volumes and/or large number of segmentations), you could select a subset for this exploration step.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#visualizing-your-dataset","title":"Visualizing your dataset\u00b6","text":"<p>Now let's visualize all samples in a grid using <code>pyvista</code>. You may need to call <code>pv.close_all()</code> every once in a while to clean up the unclosed plotters. We will use <code>sw.plot_volumes</code> function from the Shapeworks python module. This function will take in a list of shapeworks images as input and initiate a pyvista plotter to render multiple windows, each with a single segmentation, add segmentations to the plotter, and start rendering.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#3-deciding-the-grooming-pipeline-needed-for-your-dataset","title":"3. Deciding the grooming pipeline needed for your dataset\u00b6","text":""},{"location":"notebooks/getting-started-with-exploring-segmentations.html#voxel-spacing","title":"Voxel spacing\u00b6","text":"<p>Voxel spacing are not isotropic, i.e., voxel size in each of the three dimensions are not equal.This can be identified if you zoom-in in the visualization below and observe the step size in the x,y,z direction. Anisotropic spacing could adversely impact particles optimization since shapeworks assumes equal voxel spacing. Some datasets might also have different voxel spacings for each segmentation.</p> <p>Hence, it is necessary to bring all segmentations to the same voxel spacing that is equal in all dimensions.</p> <p>Another observation is voxel spacing is relatively large. This can be observed by the pixelated volume rendering and the jagged isosurface.</p> <p>We can improve the segmentation resolution by decreasing voxel spacing.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#segmentations-and-image-boundaries","title":"Segmentations and image boundaries\u00b6","text":"<p>Some segmentations are very close to the image boundary, not leaving enough room for particles (correspondences) to move and spread over these surface regions. In particular, particles could overshoot outside the image boundary during optimization.</p> <p>Furthermore, if a segmentation touches the image boundary, this will result in an artificially (i.e., not real) open surface.</p> <p>Hence, these segmentations needs to be padded with background voxels (zero-valued) to create more room along each dimension.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#shape-alignment","title":"Shape alignment\u00b6","text":"<p>One can observe from the segmentation visualization that they are not roughly aligned, i.e., they do not share the same coordinate frame where each individual shape is located differently compared to other shapes.</p> <p>Aligning shapes is a critical preprocessing step to avoid the shape model to encode variabilities pertaining to global transformations such as rotation and translation.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#too-much-background","title":"Too much background\u00b6","text":"<p>Image boundaries are not tight around shapes, leaving irrelevant background voxels that might increase the memory footprint when optimizing the shape model.</p> <p>We can crop segmentations to remove unnecessary background.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#binary-segmentations","title":"Binary segmentations\u00b6","text":"<p>In general, this binary representation is not useful for finite numerical calculation of surface geometry and features that are required in shape modeling, which assumes the image is a sampling of a smooth function.</p> <p>Hence, ShapeWorks makes use of the signed distance transform of the binary segmentation that does satisfy this criterion.</p> <p>For the correspondence optimization step, shapes can be represented as the zero level set of a smooth signed distance transform.</p>"},{"location":"notebooks/getting-started-with-exploring-segmentations.html#tentative-grooming","title":"Tentative grooming\u00b6","text":"<p>Hence, a tentative grooming pipeline entails the following steps:</p> <ol> <li>Resampling segmentations to have smaller and isotropic voxel spacing</li> <li>Rigidly aligning shapes</li> <li>Cropping and padding segmentations</li> <li>Converting segmentations to smooth signed distance transforms</li> </ol> <p>Let the fun begins!!! Please visit Getting Started with Grooming Segmentations to learn how to groom your dataset.</p>"},{"location":"notebooks/getting-started-with-meshes.html","title":"Getting Started with Meshes","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\n</pre> import shapeworks as sw In\u00a0[\u00a0]: Copied! <pre>import os # for paths and mkdir\n\n# dataset name is the folder name for your dataset\ndatasetName  = 'ellipsoid_1mode'\n\n# path to the dataset where we can find shape data \n# here we assume shape data are given as surface meshes\nshapeDir      = '../../Data/' + datasetName + '/meshes/'\n    \nprint('Dataset Name:     ' + datasetName)\nprint('Shape Directory:  ' + shapeDir)\n</pre> import os # for paths and mkdir  # dataset name is the folder name for your dataset datasetName  = 'ellipsoid_1mode'  # path to the dataset where we can find shape data  # here we assume shape data are given as surface meshes shapeDir      = '../../Data/' + datasetName + '/meshes/'      print('Dataset Name:     ' + datasetName) print('Shape Directory:  ' + shapeDir) In\u00a0[\u00a0]: Copied! <pre>import glob # for paths and file-directory search\nfrom pathlib import Path # for generating robust paths irrespective of the platform:Win/Linux/Mac\n# file extension for the shape data\nshapeExtention = '.vtk'\n\n# let's get a list of files for available meshes in this dataset\n# * here is a wild character used to retrieve all filenames \n# in the shape directory with the file extensnion\nshapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention)) \n\nprint ('Number of shapes: ' + str(len(shapeFilenames)))\nprint('Shape files found:')\nfor shapeFilename in shapeFilenames:\n    shapeFilename = Path(shapeFilename)\n    print(shapeFilename)\n</pre> import glob # for paths and file-directory search from pathlib import Path # for generating robust paths irrespective of the platform:Win/Linux/Mac # file extension for the shape data shapeExtention = '.vtk'  # let's get a list of files for available meshes in this dataset # * here is a wild character used to retrieve all filenames  # in the shape directory with the file extensnion shapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention))   print ('Number of shapes: ' + str(len(shapeFilenames))) print('Shape files found:') for shapeFilename in shapeFilenames:     shapeFilename = Path(shapeFilename)     print(shapeFilename) In\u00a0[\u00a0]: Copied! <pre># select a shape by setting the shape index (in the filenames list)\nshapeIdx       = 0\n\n# the filename for the selected shape\nshapeFilename  = shapeFilenames[shapeIdx]\n\n# use shapeworks Mesh class to load it\nprint('Loading: ' + shapeFilename)\nshapeMesh = sw.Mesh(shapeFilename)\n\n# let's print out header information of this mesh - TODO: #828 \nprint('Header information: ')\nprint(shapeMesh)\n</pre> # select a shape by setting the shape index (in the filenames list) shapeIdx       = 0  # the filename for the selected shape shapeFilename  = shapeFilenames[shapeIdx]  # use shapeworks Mesh class to load it print('Loading: ' + shapeFilename) shapeMesh = sw.Mesh(shapeFilename)  # let's print out header information of this mesh - TODO: #828  print('Header information: ') print(shapeMesh) In\u00a0[\u00a0]: Copied! <pre># convert shapeworks mesh to a vtk mesh\nshapeMesh_vtk = sw.sw2vtkMesh(shapeMesh)\n</pre> # convert shapeworks mesh to a vtk mesh shapeMesh_vtk = sw.sw2vtkMesh(shapeMesh) In\u00a0[\u00a0]: Copied! <pre># to have an interactive visualization, \n# click r to reset the view after zooming\n# click w to show wireframe and s to return back to sur\nnotebook = False # True sets the figure inline in the notebook.\nshapeMesh_vtk.plot(notebook = notebook) \n</pre> # to have an interactive visualization,  # click r to reset the view after zooming # click w to show wireframe and s to return back to sur notebook = False # True sets the figure inline in the notebook. shapeMesh_vtk.plot(notebook = notebook)  In\u00a0[\u00a0]: Copied! <pre># select a shape by setting the shape index (in the filenames list)\nshapeIdx2       = 1\n\n# the filename for the selected shape\nshapeFilename2  = shapeFilenames[shapeIdx2]\n\n# use shapeworks Mesh class to load it\nprint('Loading: ' + shapeFilename2)\nshapeMesh2 = sw.Mesh(shapeFilename2)\n\n# let's print out header information of this mesh \nprint('Header information: ')\nprint(shapeMesh2)\n</pre> # select a shape by setting the shape index (in the filenames list) shapeIdx2       = 1  # the filename for the selected shape shapeFilename2  = shapeFilenames[shapeIdx2]  # use shapeworks Mesh class to load it print('Loading: ' + shapeFilename2) shapeMesh2 = sw.Mesh(shapeFilename2)  # let's print out header information of this mesh  print('Header information: ') print(shapeMesh2) <p>Now we can view the two meshes side by side using the ShapeWorks plot_meshes() function. To view the meshes in a side-by-side view, we set the use_same_window parameter to False. To view the meshes in the same window, we set the use_same_window parameter to True.</p> In\u00a0[\u00a0]: Copied! <pre>meshList = [shapeMesh, shapeMesh2]\n# View meshes side-by-side\nsw.plot_meshes(meshList, use_same_window=False, notebook=notebook)\n</pre> meshList = [shapeMesh, shapeMesh2] # View meshes side-by-side sw.plot_meshes(meshList, use_same_window=False, notebook=notebook) <p></p> In\u00a0[\u00a0]: Copied! <pre># View meshes in the same window\nsw.plot_meshes(meshList, use_same_window=True, notebook=notebook)\n</pre> # View meshes in the same window sw.plot_meshes(meshList, use_same_window=True, notebook=notebook) <p></p>"},{"location":"notebooks/getting-started-with-meshes.html#getting-started-with-meshes","title":"Getting Started with Meshes\u00b6","text":""},{"location":"notebooks/getting-started-with-meshes.html#before-you-start","title":"Before you start!\u00b6","text":"<ul> <li>This notebook assumes that shapeworks conda environment has been activated using <code>conda activate shapeworks</code> on the terminal.</li> <li>See Setting Up ShapeWorks Environment to learn how to set up your environment to start using shapeworks library. Please note, the prerequisite steps will use the same code to setup the environment for this notebook and import <code>shapeworks</code> library.</li> <li>Note example output was generated on Linux/Mac environment and may look different on Windows.</li> </ul>"},{"location":"notebooks/getting-started-with-meshes.html#in-this-notebook-you-will-learn","title":"In this notebook, you will learn:\u00b6","text":"<ol> <li>How to define your dataset location and explore what is available in it</li> <li>How to load a single mesh</li> <li>How to convert <code>shapeworks</code> mesh to <code>vtk</code> mesh for visualization</li> <li>How to visualize a surface mesh using <code>pyvista</code></li> </ol>"},{"location":"notebooks/getting-started-with-meshes.html#importing-shapeworks-library","title":"Importing <code>shapeworks</code> library\u00b6","text":""},{"location":"notebooks/getting-started-with-meshes.html#1-defining-and-exploring-your-dataset","title":"1. Defining and exploring your dataset\u00b6","text":""},{"location":"notebooks/getting-started-with-meshes.html#defining-dataset-location","title":"Defining dataset location\u00b6","text":"<p>You can download exemplar datasets from ShapeWorks data portal after you login. For new users, you can register an account for free. Please do not use an important password.</p> <p>After you login, click <code>Collections</code> on the left panel and then <code>use-case-data-v2</code>. Select the dataset you would like to download by clicking on the checkbox on the left of the dataset name. See the video below.</p> <p>This notebook assumes that you have downloaded <code>ellipsoid_1mode</code> and you have placed the unzipped folder<code>ellipsoid_1mode</code>in <code>Examples/Python/Data</code>. Feel free to use your own dataset.</p> <p></p>"},{"location":"notebooks/getting-started-with-meshes.html#what-is-available-in-the-dataset","title":"What is available in the dataset?\u00b6","text":"<p>First let's see how many shapes we have in the dataset.</p> <p>File formats: For surface meshes, all vtk-supported mesh formats can be used (e.g., vtk, ply, and stl).</p>"},{"location":"notebooks/getting-started-with-meshes.html#2-loading-a-single-mesh","title":"2. Loading a single mesh\u00b6","text":"<p>We will select one mesh to explore for now. We will then use <code>shapeworks</code> Mesh class to load this surface mesh and print out its header information that includes .</p>"},{"location":"notebooks/getting-started-with-meshes.html#3-convert-to-a-vtk-mesh","title":"3. Convert to a VTK mesh\u00b6","text":"<p>To visualize a <code>shapeworks</code> mesh with <code>pyvista</code>, we need first to convert it to a <code>vtk</code> mesh.</p>"},{"location":"notebooks/getting-started-with-meshes.html#4-visualizing-surface-mesh-using-pyvista","title":"4. Visualizing surface mesh using <code>pyvista</code>\u00b6","text":"<p><code>pyvista</code> is a python library for 3D visualization and analysis. It is built on top of <code>vtk</code> and brings a paraview-like visualizations to notebooks. It also supports multiple rendering windows that can be linked. This feature is very useful when visualizing multiple samples from your dataset side-by-side and making them share the same camera view.</p>"},{"location":"notebooks/getting-started-with-meshes.html#5-visualizing-multiple-meshes","title":"5. Visualizing multiple meshes\u00b6","text":"<p>When exploring datasets and results of different grooming (data preprocessing) steps, it is important to simultaneously visualize multiple shape samples. Here, we visualize two meshes side-by-side and link their views using <code>pyvista</code>. This linking is useful to make all rendering windows share the same camera view.</p>"},{"location":"notebooks/getting-started-with-meshes.html#loading-the-second-mesh-and-convert-it-to-vtk-mesh","title":"Loading the second mesh and convert it to <code>vtk</code> mesh\u00b6","text":"<p>First, let's select another mesh and load it.</p>"},{"location":"notebooks/getting-started-with-notebooks.html","title":"Getting Started with Jupyter Notebooks","text":"<p>In this notebook, you will find:</p> <ol> <li>Information about running ShapeWorks Jupyter notebook tutorials</li> <li>Basics shortcuts for Jupyter notebooks</li> <li>Resources to help you with notebooks</li> </ol> In\u00a0[\u00a0]: Copied! <pre>import shapeworks\n</pre> import shapeworks <p>If the cell above gave an error make sure you have run <code>install_shapeworks</code> and have the <code>shapeworks</code> conda environment activated. See How to Install ShapeWorks? for more information.</p> <p>If you believe ShapeWorks is installed correctly but you are still unable to import it please contact us.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/getting-started-with-notebooks.html#getting-started-with-jupyter-notebooks","title":"Getting Started with Jupyter Notebooks\u00b6","text":""},{"location":"notebooks/getting-started-with-notebooks.html#shapeworks-jupyter-notebook-tutorials","title":"ShapeWorks Jupyter Notebook Tutorials\u00b6","text":""},{"location":"notebooks/getting-started-with-notebooks.html#what-is-jupyter-notebook","title":"What is Jupyter Notebook?\u00b6","text":"<p>The Jupyter Notebook is a powerful tool to interactively prototype and present ideas and workflows. The Jupyter Notebook is an open source web application that enables you to create documents that contain runnable code, text, equations, and visualizations. Jupyter supports IPython kernel to allow you to write/prototype programs in Python. You can also use other kernels (e.g., R and Julia .. etc) with Jupyter notebooks.</p> <p>The Jupyter Notebook combines three components:</p> <ul> <li>Notebook web app: An interactive web application to edit code in the browser, run code from the browser, see the results of running the code in the browser, create and use interactive widgets, and author narrative text and equations.</li> <li>Kernels: Processes launched by the notebook web app that runs code in a specific language and handles interactive widgets and tab completion. The default kernel runs Python code.</li> <li>Notebook documents: Documents that contain visible content in the notebook web app, including inputs and outputs of an interactive session, narrative text, equations, and images, and rich media representations of objects. Each notebook document has its own kernel. Notebook documents are files with a <code>.ipynb</code> extension Internally, notebook documents are <code>json</code> data with binary output encoded.</li> </ul>"},{"location":"notebooks/getting-started-with-notebooks.html#running-a-jupyter-notebook-tutorial","title":"Running a Jupyter notebook tutorial\u00b6","text":"<p>ShapeWorks installs Jupyter for you. The Jupyter Notebook is not included with Python. The <code>install_shapeworks</code> script the comes with ShapeWorks (<code>install_shapeworks.sh</code> for Mac OS and Linux and <code>install_shapeworks.bat</code> for Window) installs Jupyter Notebook for you.</p> <p>ShapeWorks also installs and enables for you</p> <ul> <li>a spell checker extension for the text cells</li> <li>a table of content extension to easily navigate notebooks</li> </ul> <p>To get the server started, all you need to do is</p> <ul> <li>open up your terminal</li> <li>go to the folder where you would like to save your notebooks in</li> <li>activate <code>shapeworks</code> environment by running <code>conda activate shapeworks</code></li> <li>launch the notebook server by running <code>jupyter notebook</code></li> </ul> <p>Note: Notebooks for demonstrating ShapeWorks tools are located in <code>Examples/Python/notebooks/tutorials</code>. We recommend that you create a folder in <code>Examples/Python/notebooks/</code> directory for your own notebooks.</p> <p></p>"},{"location":"notebooks/getting-started-with-notebooks.html#importing-shapeworks","title":"Importing ShapeWorks\u00b6","text":"<p>The Jupyter notebook tutorials require ShapeWorks to be installed so that it can be imported at the beginning of every notebook. Try running the following code cell to make sure ShapeWorks can be imported:</p>"},{"location":"notebooks/getting-started-with-notebooks.html#notebook-keyboard-shortcuts","title":"Notebook keyboard shortcuts\u00b6","text":"<ul> <li><code>Esc + H</code>: displays a complete list of keyboard shortcuts</li> <li><code>Esc + A</code>: insert new cell above the current cell</li> <li><code>Esc + B</code>: insert new cell below the current cell</li> <li><code>Esc + D + D</code>: delete current cell</li> <li><code>Esc + Z</code>: undo</li> <li><code>Shift + enter</code>: run current cell and move to next</li> <li>To show a function's argument list (i.e., signature), use <code>(</code> then <code>shift-tab</code></li> <li>Use <code>shift-tab-tab</code> to show more help for a function</li> <li>To show the help of a function, use <code>help(function)</code> or <code>function?</code></li> <li>To show all functions supported by an object, use <code>dot-tab</code> after the variable name</li> </ul>"},{"location":"notebooks/getting-started-with-notebooks.html#jupyter-notebook-resources","title":"Jupyter Notebook Resources\u00b6","text":"<ol> <li>Documentation provided by Jupyter Notebook-Here you find all a comprehensive user documentation provided by the developers</li> <li>Jupyter notebooks are widely used by the python community and you can find many videos and blogs for new users.If you are facing any specific errors while starting and running the notebooks, please check out the following resources : (a) Stack Overflow (b) Discourse (c) Stack Exchange</li> </ol>"},{"location":"notebooks/getting-started-with-segmentations.html","title":"Getting Started with Segmentations","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\n</pre> import shapeworks as sw In\u00a0[\u00a0]: Copied! <pre>import os \n\n# dataset name is the folder name for your dataset\ndatasetName  = 'ellipsoid_1mode'\n\n# path to the dataset where we can find shape data \n# here we assume shape data are given as binary segmentations\nshapeDir      = '../../Data/' + datasetName + '/segmentations/'\n\nprint('Dataset Name:     ' + datasetName)\nprint('Shape Directory:  ' + shapeDir)\n</pre> import os   # dataset name is the folder name for your dataset datasetName  = 'ellipsoid_1mode'  # path to the dataset where we can find shape data  # here we assume shape data are given as binary segmentations shapeDir      = '../../Data/' + datasetName + '/segmentations/'  print('Dataset Name:     ' + datasetName) print('Shape Directory:  ' + shapeDir) In\u00a0[\u00a0]: Copied! <pre>import glob \nfrom pathlib import Path \n\n\nshapeExtention = '.nrrd'\n\n# let's get a list of files for available segmentations in this dataset\n# * here is a wild character used to retrieve all filenames \n# in the shape directory with the file extensnion\n\nshapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention)) \n\nprint ('Number of shapes: ' + str(len(shapeFilenames)))\nprint('Shape files found:')\nfor shapeFilename in shapeFilenames:\n    shapeFilename = Path(shapeFilename)\n    print(shapeFilename)\n</pre> import glob  from pathlib import Path    shapeExtention = '.nrrd'  # let's get a list of files for available segmentations in this dataset # * here is a wild character used to retrieve all filenames  # in the shape directory with the file extensnion  shapeFilenames = sorted(glob.glob(shapeDir + '*' + shapeExtention))   print ('Number of shapes: ' + str(len(shapeFilenames))) print('Shape files found:') for shapeFilename in shapeFilenames:     shapeFilename = Path(shapeFilename)     print(shapeFilename) In\u00a0[\u00a0]: Copied! <pre># select a shape by setting the shape index (in the filenames list)\nshapeIdx       = 1\n\n# the filename for the selected shape\nshapeFilename  = shapeFilenames[shapeIdx]\n\n# since segmentation is just an image data, we will use shapeworks Image class to load it\nprint('Loading: ' + shapeFilename)\nshapeSeg = sw.Image(shapeFilename)\n\n# let's print out header information of this segmentation \nprint('Header information: ')\nprint(shapeSeg)\n</pre> # select a shape by setting the shape index (in the filenames list) shapeIdx       = 1  # the filename for the selected shape shapeFilename  = shapeFilenames[shapeIdx]  # since segmentation is just an image data, we will use shapeworks Image class to load it print('Loading: ' + shapeFilename) shapeSeg = sw.Image(shapeFilename)  # let's print out header information of this segmentation  print('Header information: ') print(shapeSeg) In\u00a0[\u00a0]: Copied! <pre>#from the shapeworks python module use the conversion function\nshapeSeg_vtk = sw.sw2vtkImage(shapeSeg)\n\n# print header info of both images, please note that the wrap function\n# only wraps the numpy array, which is oblivous to image spacing and origin\nprint('shapeworks image header information: \\n')\nprint(shapeSeg)\n\nprint('\\nvtk image header information: \\n')\nprint(shapeSeg_vtk)\n</pre> #from the shapeworks python module use the conversion function shapeSeg_vtk = sw.sw2vtkImage(shapeSeg)  # print header info of both images, please note that the wrap function # only wraps the numpy array, which is oblivous to image spacing and origin print('shapeworks image header information: \\n') print(shapeSeg)  print('\\nvtk image header information: \\n') print(shapeSeg_vtk) In\u00a0[\u00a0]: Copied! <pre>import pyvista as pv\n\nnotebook = False # True will bring the renderings inline\n# click r to reset the view after zooming\nshapeSeg_vtk.plot(volume     = True,     # volume render\n                  shade      = True,\n                  notebook = notebook)     # enable shading\n</pre> import pyvista as pv  notebook = False # True will bring the renderings inline # click r to reset the view after zooming shapeSeg_vtk.plot(volume     = True,     # volume render                   shade      = True,                   notebook = notebook)     # enable shading In\u00a0[\u00a0]: Copied! <pre># select a shape by setting the shape index (in the filenames list)\nshapeIdx2       = 2\n\n# the filename for the selected shape\nshapeFilename2  = shapeFilenames[shapeIdx2]\n\n# since segmentation is just an image data, we will use shapeworks Image class to load it\nprint('Loading: ' + shapeFilename2)\nshapeSeg2 = sw.Image(shapeFilename2)\n\n# let's print out header information of this segmentation \nprint('Header information: ')\nprint(shapeSeg2)\n</pre> # select a shape by setting the shape index (in the filenames list) shapeIdx2       = 2  # the filename for the selected shape shapeFilename2  = shapeFilenames[shapeIdx2]  # since segmentation is just an image data, we will use shapeworks Image class to load it print('Loading: ' + shapeFilename2) shapeSeg2 = sw.Image(shapeFilename2)  # let's print out header information of this segmentation  print('Header information: ') print(shapeSeg2) <p>Then, let's convert this <code>shapeworks</code> image to a <code>vtk</code> image for visualization.</p> In\u00a0[\u00a0]: Copied! <pre># sw to vtk\nshapeSeg2_vtk = sw.sw2vtkImage(shapeSeg2)\n</pre> # sw to vtk shapeSeg2_vtk = sw.sw2vtkImage(shapeSeg2) In\u00a0[\u00a0]: Copied! <pre># define parameters that controls the plotter\nnotebook       = False  # True will bring the renderings inline in the notebook\nshow_borders   = True  # show borders for each rendering window\nshade_volumes  = True  # use shading when performing volume rendering\ncolor_map      = \"coolwarm\" # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma'\nshow_axes      = True  # show a vtk axes widget for each rendering window\nshow_bounds    = False # show volume bounding box\nshow_all_edges = True  # add an unlabeled and unticked box at the boundaries of plot. \nfont_size      = 10    # text font size for windows\nlink_views     = True  # link all rendering windows so that they share same camera and axes boundaries\n\n\n#extract the shape name for display\nsegFilename = shapeFilenames[shapeIdx].split('/')[-1] \nshapeName   = segFilename[:-len(shapeExtention)]\nsegFilename2 = shapeFilenames[shapeIdx2].split('/')[-1] \nshapeName2   = segFilename2[:-len(shapeExtention)]\nshapeSegList = [shapeSeg_vtk,shapeSeg2_vtk]\nshapeNames = [shapeName,shapeName2]\n</pre>  # define parameters that controls the plotter notebook       = False  # True will bring the renderings inline in the notebook show_borders   = True  # show borders for each rendering window shade_volumes  = True  # use shading when performing volume rendering color_map      = \"coolwarm\" # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma' show_axes      = True  # show a vtk axes widget for each rendering window show_bounds    = False # show volume bounding box show_all_edges = True  # add an unlabeled and unticked box at the boundaries of plot.  font_size      = 10    # text font size for windows link_views     = True  # link all rendering windows so that they share same camera and axes boundaries   #extract the shape name for display segFilename = shapeFilenames[shapeIdx].split('/')[-1]  shapeName   = segFilename[:-len(shapeExtention)] segFilename2 = shapeFilenames[shapeIdx2].split('/')[-1]  shapeName2   = segFilename2[:-len(shapeExtention)] shapeSegList = [shapeSeg_vtk,shapeSeg2_vtk] shapeNames = [shapeName,shapeName2]   <p>Let's use the <code>plot_volumes</code> function from Shapeworks python module for adding segmentations to the pyvista plotter</p> In\u00a0[\u00a0]: Copied! <pre>sw.plot_volumes(shapeSegList,    \n             volumeNames     = shapeNames, \n             notebook = notebook, \n             show_borders   = show_borders,  \n             shade_volumes  = shade_volumes,  \n             show_axes      = show_axes,  \n             show_bounds    = show_bounds,\n             show_all_edges = show_all_edges, \n             font_size      = font_size,   \n             link_views     = True )\n</pre>  sw.plot_volumes(shapeSegList,                  volumeNames     = shapeNames,               notebook = notebook,               show_borders   = show_borders,                shade_volumes  = shade_volumes,                show_axes      = show_axes,                show_bounds    = show_bounds,              show_all_edges = show_all_edges,               font_size      = font_size,                 link_views     = True ) <p></p> In\u00a0[\u00a0]: Copied! <pre># define parameters that controls the plotter\n\nuse_same_window = True\n</pre>   # define parameters that controls the plotter  use_same_window = True In\u00a0[\u00a0]: Copied! <pre>sw.plot_volumes(shapeSegList,    \n             color_map=color_map,\n             notebook = notebook, \n             show_borders   = show_borders,  \n             shade_volumes  = shade_volumes,  \n             show_axes      = show_axes,  \n             show_bounds    = show_bounds,\n             show_all_edges = show_all_edges, \n             font_size      = font_size, \n             use_same_window = use_same_window,\n             link_views     = True )\n</pre>  sw.plot_volumes(shapeSegList,                  color_map=color_map,              notebook = notebook,               show_borders   = show_borders,                shade_volumes  = shade_volumes,                show_axes      = show_axes,                show_bounds    = show_bounds,              show_all_edges = show_all_edges,               font_size      = font_size,               use_same_window = use_same_window,              link_views     = True ) <p></p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/getting-started-with-segmentations.html#getting-started-with-segmentations","title":"Getting Started with Segmentations\u00b6","text":""},{"location":"notebooks/getting-started-with-segmentations.html#before-you-start","title":"Before you start!\u00b6","text":"<ul> <li>This notebook assumes that shapeworks conda environment has been activated using <code>conda activate shapeworks</code> on the terminal.</li> <li>See Getting Started with Notebooks for information on setting up your environment and notebook shortcuts.</li> <li>Note example output was generated on Linux/Mac environment and may look different on Windows.</li> </ul>"},{"location":"notebooks/getting-started-with-segmentations.html#in-this-notebook-you-will-learn","title":"In this notebook, you will learn:\u00b6","text":"<ol> <li>How to define your dataset location and explore what is available in it</li> <li>How to load a single segmentation</li> <li>How to convert <code>shapeworks</code> image to <code>vtk</code> image for visualization</li> <li>How to visualize a single segmentation and multiple segmentations using <code>pyvista</code></li> </ol>"},{"location":"notebooks/getting-started-with-segmentations.html#1-defining-and-exploring-your-dataset","title":"1. Defining and exploring your dataset\u00b6","text":""},{"location":"notebooks/getting-started-with-segmentations.html#defining-dataset-location","title":"Defining dataset location\u00b6","text":"<p>You can download exemplar datasets from ShapeWorks data portal after you login. For new users, you can register an account for free. Please do not use an important password.</p> <p>After you login, click <code>Collections</code> on the left panel and then <code>use-case-data-v2</code>. Select the dataset you would like to download by clicking on the checkbox on the left of the dataset name. See the video below. After you download the dataset zip file, make sure you unzip/extract the contents in the appropriate location.</p> <p>This notebook assumes that you have downloaded <code>ellipsoid_1mode</code> and you have placed the unzipped folder <code>ellipsoid_1mode</code> in <code>Examples/Python/Data</code>. Feel free to use your own dataset.</p> <p></p>"},{"location":"notebooks/getting-started-with-segmentations.html#what-is-available-in-the-dataset","title":"What is available in the dataset?\u00b6","text":"<p>First let's see how many shapes we have in the dataset.</p> <p>File formats: For binary segmentations, all itk-supported image formats can be used.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#2-loading-a-single-segmentation","title":"2. Loading a single segmentation\u00b6","text":"<p>We will select one segmentation to explore for now. We will then use shapeworks Image class to load this segmentation and print out its header information that includes image dimensions (rows, columns and slices), physical origin, physical size, and voxel spacing (in physical units).</p>"},{"location":"notebooks/getting-started-with-segmentations.html#3-converting-shapeworks-image-to-vtk-image-for-visualization","title":"3. Converting <code>shapeworks</code> image to <code>vtk</code> image for visualization\u00b6","text":"<p>We use python library <code>pyvista</code> for interactive 3D visualization. This library support, among others, <code>vtk</code> data structures for images and meshes. Hence, to visualize our <code>shapeworks</code> image, we need first to convert it to a <code>vtk</code> data structure.</p> <p>This conversion can be performed by first extracting a numpy array from the <code>shapeworks</code> image, then constructing a <code>vtk</code> image from this array. <code>pyvista</code>'s <code>wrap</code> function makes this easy.</p> <p>In the ShapeWorks python module, we have the <code>sw2vtkImage</code> function for this conversion to <code>vtk</code> image.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#4-visualizing-segmentation-using-pyvista","title":"4. Visualizing segmentation using <code>pyvista</code>\u00b6","text":"<p><code>pyvista</code> python library is built on top of <code>vtk</code> and brings a paraview-like visualizations to notebooks. It also supports multiple rendering windows that can be linked. This feature is very useful when visualizing multiple samples from your dataset side-by-side and making them share the same camera view.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#5-visualizing-two-segmentations-side-by-side-using-pyvista","title":"5. Visualizing two segmentations side-by-side using <code>pyvista</code>\u00b6","text":"<p>When exploring datasets and results of different grooming (data preprocessing) steps, it is important to simultaneously visualize multiple shape samples. Here, we will learn how to visualize two segmentations side-by-side and link their views using <code>pyvista</code>. This linking is useful to make all rendering windows share the same camera view.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#loading-the-second-segmentation-and-convert-it-to-vtk-image","title":"Loading the second segmentation and convert it to <code>vtk</code> image\u00b6","text":"<p>First, let's select another segmentation and load it.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#defining-pyvista-plotter","title":"Defining <code>pyvista</code> plotter\u00b6","text":"<p>Next, we will define a <code>pyvista</code> plotter to render multiple windows, each with a single segmentation. The multiple rendering windows will be visualized as a grid of plots. Since, we have only two segmentations, the grid size will be one row and two columns.</p> <p>The plotter also enable use to specify a color map.</p>"},{"location":"notebooks/getting-started-with-segmentations.html#6-visualizing-two-segmentations-in-the-same-rendering-window","title":"6. Visualizing two segmentations in the same rendering window\u00b6","text":"<p>This type of visualization is useful when exploring differences between more than one segmentations, e.g., when inspecting the impact of a grooming/preprocessing step or the spatial relation of multiple samples. This is also useful if your shape data contains multiple domains (or compartments) such as anatomical joints.</p> <p>Note that, since we have a single rendering window (view), linking views is not necessary. But, if this multi-surface visualization is used in conjuction with multiple rendering windows, linking views should be considered.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html","title":"Getting Started with Shape Cohort Generator","text":"In\u00a0[\u00a0]: Copied! <pre>import shapeworks as sw\n</pre> import shapeworks as sw In\u00a0[\u00a0]: Copied! <pre>import ShapeCohortGen\n</pre> import ShapeCohortGen In\u00a0[\u00a0]: Copied! <pre># define parameters that controls the plotter\n\n# common for volumes and meshes visualization\nnotebook       = False # True will set the renderings inline\nshow_borders   = True  # show borders for each rendering window\nshow_axes      = True  # show a vtk axes widget for each rendering window\nshow_bounds    = True  # show volume bounding box\nshow_all_edges = True  # add an unlabeled and unticked box at the boundaries of plot. \nfont_size      = 10    # text font size for windows\nlink_views     = True  # link all rendering windows so that they share same camera and axes boundaries\n\n# for volumes\nshade_volumes  = True  # use shading when performing volume rendering\ncolor_map       = 'coolwarm' # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma'\n\n# for meshes\nmeshes_color    = 'tan' # color to be used for meshes (can be a list with the same size as meshList if different colors are needed)\nmesh_style      = 'surface' # visualization style of the mesh. style='surface', style='wireframe', style='points'. \nshow_mesh_edges = False  # show mesh edges \n</pre> # define parameters that controls the plotter  # common for volumes and meshes visualization notebook       = False # True will set the renderings inline show_borders   = True  # show borders for each rendering window show_axes      = True  # show a vtk axes widget for each rendering window show_bounds    = True  # show volume bounding box show_all_edges = True  # add an unlabeled and unticked box at the boundaries of plot.  font_size      = 10    # text font size for windows link_views     = True  # link all rendering windows so that they share same camera and axes boundaries  # for volumes shade_volumes  = True  # use shading when performing volume rendering color_map       = 'coolwarm' # color map for volume rendering, e.g., 'bone', 'coolwarm', 'cool', 'viridis', 'magma'  # for meshes meshes_color    = 'tan' # color to be used for meshes (can be a list with the same size as meshList if different colors are needed) mesh_style      = 'surface' # visualization style of the mesh. style='surface', style='wireframe', style='points'.  show_mesh_edges = False  # show mesh edges  In\u00a0[\u00a0]: Copied! <pre>out_dir             = \"../Output/Generated_Ellipsoids/\"\nellipsoid_generator = ShapeCohortGen.EllipsoidCohortGenerator(out_dir)\n</pre> out_dir             = \"../Output/Generated_Ellipsoids/\" ellipsoid_generator = ShapeCohortGen.EllipsoidCohortGenerator(out_dir) In\u00a0[\u00a0]: Copied! <pre>num_samples = 8\nmeshFiles   = ellipsoid_generator.generate(num_samples)\n</pre> num_samples = 8 meshFiles   = ellipsoid_generator.generate(num_samples) In\u00a0[\u00a0]: Copied! <pre>meshList = []\nfor i in range(len(meshFiles)):\n    shapeMesh = sw.Mesh(meshFiles[i])\n    meshList.append(shapeMesh)\n\n# Plot the meshes\nsw.plot_meshes(meshList, use_same_window=True, notebook=notebook)\n</pre> meshList = [] for i in range(len(meshFiles)):     shapeMesh = sw.Mesh(meshFiles[i])     meshList.append(shapeMesh)  # Plot the meshes sw.plot_meshes(meshList, use_same_window=True, notebook=notebook) In\u00a0[\u00a0]: Copied! <pre>segFiles = ellipsoid_generator.generate_segmentations()\n</pre> segFiles = ellipsoid_generator.generate_segmentations() <p>Let's visualize the generated segmentations.</p> In\u00a0[\u00a0]: Copied! <pre>shapeSegList = []\nshapeNames   = []\n\nfor segFile in segFiles:\n    shapeSegList.append(sw.Image(segFile))\n    shapeNames.append(segFile.split('/')[-1])\nprint(shapeNames)\n\nsw.plot_volumes(shapeSegList,    \n             volumeNames    = shapeNames, \n             notebook       = notebook, \n             show_borders   = show_borders,  \n             shade_volumes  = shade_volumes,  \n             show_axes      = show_axes,  \n             show_bounds    = show_bounds,\n             show_all_edges = show_all_edges, \n             font_size      = font_size,\n             link_views     = True ) #link_views\n</pre> shapeSegList = [] shapeNames   = []  for segFile in segFiles:     shapeSegList.append(sw.Image(segFile))     shapeNames.append(segFile.split('/')[-1]) print(shapeNames)  sw.plot_volumes(shapeSegList,                  volumeNames    = shapeNames,               notebook       = notebook,               show_borders   = show_borders,                shade_volumes  = shade_volumes,                show_axes      = show_axes,                show_bounds    = show_bounds,              show_all_edges = show_all_edges,               font_size      = font_size,              link_views     = True ) #link_views <p></p> In\u00a0[\u00a0]: Copied! <pre>imageFiles = ellipsoid_generator.generate_images()\n</pre> imageFiles = ellipsoid_generator.generate_images() <p>Let's compare a segmentation to it's corresponding image.</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Segmentation:\")\nseg0 = sw.Image(segFiles[0])\nsw.plot_volumes(seg0)\n</pre> print(\"Segmentation:\") seg0 = sw.Image(segFiles[0]) sw.plot_volumes(seg0) <p></p> In\u00a0[\u00a0]: Copied! <pre>print(\"Image:\")\nimg0 = sw.Image(imageFiles[0])\nsw.plot_volumes(img0)\n</pre> print(\"Image:\") img0 = sw.Image(imageFiles[0]) sw.plot_volumes(img0) <p></p> In\u00a0[\u00a0]: Copied! <pre>out_dir      = \"../Output/Generated_Supershapes/\"\nss_generator = ShapeCohortGen.SupershapesCohortGenerator(out_dir)\n</pre> out_dir      = \"../Output/Generated_Supershapes/\" ss_generator = ShapeCohortGen.SupershapesCohortGenerator(out_dir) In\u00a0[\u00a0]: Copied! <pre>num_samples = 8\nmeshFiles   = ss_generator.generate(num_samples)\n</pre> num_samples = 8 meshFiles   = ss_generator.generate(num_samples) In\u00a0[\u00a0]: Copied! <pre>meshList = []\nfor i in range(len(meshFiles)):\n    shapeMesh = sw.Mesh(meshFiles[i])\n    meshList.append(shapeMesh)\n    \n# Plot the meshes\nsw.plot_meshes(meshList, use_same_window=True, notebook=notebook)\n</pre> meshList = [] for i in range(len(meshFiles)):     shapeMesh = sw.Mesh(meshFiles[i])     meshList.append(shapeMesh)      # Plot the meshes sw.plot_meshes(meshList, use_same_window=True, notebook=notebook) <p></p> In\u00a0[\u00a0]: Copied! <pre>segFiles = ss_generator.generate_segmentations()\n</pre> segFiles = ss_generator.generate_segmentations() <p>Let's visualize the generated segmentations.</p> In\u00a0[\u00a0]: Copied! <pre>shapeSegList = []\nshapeNames = []\n\nfor segFile in segFiles:\n    shapeSegList.append(sw.Image(segFile))\n    shapeNames.append(segFile.split('/')[-1])\nprint(shapeNames)\n\nsw.plot_volumes(shapeSegList,    \n             volumeNames    = shapeNames, \n             notebook       = notebook, \n             show_borders   = show_borders,  \n             shade_volumes  = shade_volumes,  \n             show_axes      = show_axes,  \n             show_bounds    = show_bounds,\n             show_all_edges = show_all_edges, \n             font_size      = font_size,   \n             link_views     = True ) #link_views)\n</pre> shapeSegList = [] shapeNames = []  for segFile in segFiles:     shapeSegList.append(sw.Image(segFile))     shapeNames.append(segFile.split('/')[-1]) print(shapeNames)  sw.plot_volumes(shapeSegList,                  volumeNames    = shapeNames,               notebook       = notebook,               show_borders   = show_borders,                shade_volumes  = shade_volumes,                show_axes      = show_axes,                show_bounds    = show_bounds,              show_all_edges = show_all_edges,               font_size      = font_size,                 link_views     = True ) #link_views) <p></p> In\u00a0[\u00a0]: Copied! <pre>imageFiles = ss_generator.generate_images()\n</pre> imageFiles = ss_generator.generate_images() <p>Let's compare a segmentation to it's corresponding image.</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Segmentation:\")\nseg0 = sw.Image(segFiles[0])\nsw.plot_volumes(seg0, notebook=notebook)\n</pre> print(\"Segmentation:\") seg0 = sw.Image(segFiles[0]) sw.plot_volumes(seg0, notebook=notebook) <p></p> In\u00a0[\u00a0]: Copied! <pre>print(\"Image:\")\nimg0 = sw.Image(imageFiles[0])\nsw.plot_volumes(img0, notebook=notebook)\n</pre> print(\"Image:\") img0 = sw.Image(imageFiles[0]) sw.plot_volumes(img0, notebook=notebook) <p></p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#getting-started-with-shape-cohort-generator","title":"Getting Started with Shape Cohort Generator\u00b6","text":""},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#before-you-start","title":"Before you start!\u00b6","text":"<ul> <li>This notebook assumes that shapeworks conda environment has been activated using <code>conda activate shapeworks</code> on the terminal.</li> <li>See Getting Started with Notebooks for information on setting up your environment and notebook shortcuts.</li> <li>See Getting Started with Meshes to learn how to load and visualize meshes.</li> <li>See Getting Started with Segmentations to learn how to load and visualize binary segmentations.</li> <li>Note example output was generated on Linux/Mac environment and may look different on Windows.</li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#in-this-notebook-you-will-learn","title":"In this notebook, you will learn:\u00b6","text":"<p>How to use the <code>ShapeCohortGenerator</code> package to generate meshes and segmentations (binary images) for synthetic shape cohorts, i.e., parameterized families of shapes.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#about-shapecohortgenerator","title":"About <code>ShapeCohortGenerator</code>\u00b6","text":"<p><code>ShapeCohortGenerator</code> is a python package that generates synthetic shape cohorts with groundtruth surface correspondences by varying different parameters describing such shape families.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#what-is-a-shape-cohort","title":"What is a shape cohort ?\u00b6","text":"<p>A shape cohort is a collection of geometric shapes that attain clear differences in shape; however, they share common characteristics that stem from the underlying mechanisms involved in their formation. For real-world shapes, e.g., anatomical structures, such common characteristics (or factor of variations) are not known in advance, hence ShapeWorks discovers such factors of variations directly from surface meshes or binary segmentations of such shapes. <code>ShapeCohortGenerator</code> uses the true factors of variations known for synthetic shapes that are analytically parameterized.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#why-shapecohortgenerator","title":"Why <code>ShapeCohortGenerator</code>?\u00b6","text":"<p>We require a shape population dataset to run the shape modeling workflow. Each population dataset requires unique grooming steps. Developing and testing complicated grooming pipelines for large-scale datasets can consume a lot of computational resources and time. Hence, having a few toy datasets, which are lightweight and robust in variability can make this development and debugging process easier and simpler.These cohorts can also be used to test the optimization workflow.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#what-families-of-shape-can-be-generated-by-shapecohortgenerator","title":"What families of shape can be generated by <code>ShapeCohortGenerator</code>?\u00b6","text":"<p><code>ShapeCohortGenerator</code> currently supports two families of synthetic shapes, namely ellipsoids and  supershapes.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#ellipsoids","title":"Ellipsoids\u00b6","text":"<p>An ellipsoidis symmetrical about three mutually perpendicular axes that intersect at the center. If a, b, and c are the principal semiaxes, the general equation of such an ellipsoid is $$\\frac{x^2}{a^2} + \\frac{y^2}{b^2} + \\frac{z^2}{c^2} = 1$$</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#supershapes","title":"Supershapes\u00b6","text":"<p>Supershapes are an extension of superellipses that can exhibit variable symmetry as well as asymmetry. Supershapes can be described through a single equation, the so-called superformula, that parametrizes a wide variety of shapes, including geometric primitives. The superformula is given by :</p> <p>$$ r(\\theta) = \\left[ \\left| \\frac{1}{a} \\cos \\left( \\frac{m\\theta}{4} \\right) \\right|^{n_2} +  \\left|  \\frac{1}{b} \\sin \\left(\\frac{m\\theta}{4} \\right) \\right|^{n_3}  \\right]^{-\\frac{1}{n_1}} $$</p> <p>Unlike superellipses, supershapes need not to be symmetric; the parameter $m$ controls the rotational symmetry. The values of  $a$ and $b$ control the size, and the exponents $n_1,n_2$ and $n_3$ control the curvature of the sides. The superformula can produce a wide range of shapes,including many shapes found in nature.</p> <p>The <code>ShapeCohortGenerator</code> package allows the user to specify the rotational symmetry $m$ and the size. The values of $n_1,n_2$ and $n_3$ are randomly selected to creates shapes with different curvatures. Examples of these supershapes with different $m$ values can be seen below.</p> <p></p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#2d-supershapes","title":"2D Supershapes\u00b6","text":"<p>2D supershapes are the same as Supershapes but two-dimensional instead of three. When generation is called, contours are created rather than meshes When generate_segmentations and generate_images are called, 2D .png images are created rather than 3D .nrrd images.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#joint-ellipsoids","title":"Joint Ellipsoids\u00b6","text":"<p>Joint ellipsoids are two ellipsoids positioned in a parameterized way in relation to each other. This cohort allows for exploring modes of variation such as relative rotation.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#torus","title":"Torus\u00b6","text":"<p>Tori are donut-shaped surfaces generated by a circle rotated about an axis in its plane that does not intersect the circle. For the tori mesh generation, the arguments are the same as for ellipsoids, except instead of <code>randomize_x_radius</code> and <code>randomize_y_radius</code> we have <code>randomize_ring_radius</code> (outside) and <code>randomize_cross_section_radius</code>(inside).</p> <p></p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#what-you-can-do-with-shapecohortgenerator","title":"What you can do with <code>ShapeCohortGenerator</code>?\u00b6","text":"<p>The <code>ShapeCohortGenerator</code> package can be used to generate collections of ellipsoids or supershapes, where the user can control the number of shapes in the cohort and the variability of the members of the cohort.</p> <p>Each cohort will have mesh data (vtk format, supershapes will be saved in stl format) and segmentation image data (nrrd format). These cohorts generated by the package can be directly run with <code>ShapeWorks</code>. Generating these cohorts in the <code>Output</code> folder would be a good way to start.</p> <p>We will also define modular/generic helper functions as we walk through these items to reuse functionalities without duplicating code.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#importing-shapeworks-library","title":"Importing <code>shapeworks</code> library\u00b6","text":""},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#importing-shapecohortgen-library","title":"Importing <code>ShapeCohortGen</code> library\u00b6","text":"<p>To use this package, first a <code>generator</code> is defined, then <code>generate()</code> is called that generates shapes in vtk mesh format. Then segmentations (binary image) and images (synthetic intensities that mimic imaging data for real shapes) can be created from those meshes.</p> <p>Each generator has three functions:</p> <ul> <li><code>generate()</code> for mesh generation (function specific to generator type)</li> <li><code>generate_segmentations()</code> for segmentation generation based on meshes (general function shared by all generator types)</li> <li><code>generate_images()</code> for image generation based on segmentations (general function shared by all generator types)</li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#defining-parameters-for-pyvista-plotter","title":"Defining parameters for <code>pyvista</code> plotter\u00b6","text":""},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#generating-an-ellipsoid-cohort","title":"Generating an Ellipsoid Cohort\u00b6","text":""},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-1-initalize-ellipsoid-generator","title":"Step 1: Initalize Ellipsoid Generator\u00b6","text":"<p>Here, we will initialize an ellipsoid cohort generator. The output directory needs to be specified, otherwise an output directory will automatically generated.</p> <p>Arguments:</p> <ul> <li><code>out_dir</code>: path where the dataset should be saved Datatype : <code>string</code> Default value : <code>current_directory/generated_ellipsoid_cohort/</code> </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-2-generate-meshes","title":"Step 2: Generate Meshes\u00b6","text":"<p>For the ellipsoid mesh generation, you can specify the following arguments:</p> <ul> <li><p><code>num_samples</code>: number of samples in the cohort(dataset) Datatype : <code>int</code>  Default value : 3  </p> </li> <li><p><code>randomize_center</code>: randomizes the centers for ellipsoid mesh generation if set to <code>True</code> Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> <li><p><code>randomize_rotation</code>: randomizes the orientation of the ellipsoid if set to <code>True</code>  Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> <li><p><code>randomize_x_radius</code>: randomizes the radius of the ellipsoid along x-axis if set to <code>True</code> or else the value is fixed as 20 for all ellipsoids Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> <li><p><code>randomize_y_radius</code>: randomizes the radius of the ellipsoid along y-axis if set to <code>True</code> or else the value is fixed as 10 for all ellipsoids Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> <li><p><code>randomize_z_radius</code>: randomizes the radius of the ellipsoid along z-axis if set to <code>True</code> or else the value is fixed as 10 for all ellipsoids Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-3-generate-segmentations","title":"Step 3: Generate Segmentations\u00b6","text":"<p>For segmentation generation, you can specify the following arguments:</p> <ul> <li><p><code>randomize_size</code>: randomize the size of the images to include more background if set to <code>True</code> Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> <li><p><code>spacing</code>: set the spacing of the segmentation image  Datatype: <code>list</code>  Default value: <code>[1,1,1]</code> </p> </li> <li><p><code>allow_on_boundary</code>: If set to <code>True</code>,randomly selects 20% samples and ensure that the shapes are touching two random selected axes out of <code>[x,y,z]</code> Datatype : <code>bool</code>  Defaut value : <code>True</code> </p> </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-4-generate-images-turning-segmentations-into-non-binary-images","title":"Step 4: Generate Images - Turning segmentations into non-binary images\u00b6","text":"<p>For the image generation, a Gaussian distribution is used to define foreground and background pixels values and a blur factor is used to blur the boundary with a Gaussian filter. You can specify the following arguments:</p> <ul> <li><code>blur_factor</code>: size of Gaussian filter to use for boundary blurring  Datatype : <code>int</code>  Defaut value : <code>1</code> </li> <li><code>foreground_mean</code>: mean of the foreground pixel value distribution  Datatype: <code>int</code>  Default value: <code>180</code> </li> <li><code>foreground_var</code>: variance of the foreground pixel value distribution  Datatype : <code>int</code>  Defaut value : <code>30</code> </li> <li><code>background_mean</code>: mean of the background pixel value distribution  Datatype: <code>int</code>  Default value: <code>80</code> </li> <li><code>background_var</code>: variance of the foreground pixel value distribution  Datatype : <code>int</code>  Defaut value : <code>30</code> </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#generating-supershapes-cohort","title":"Generating Supershapes Cohort\u00b6","text":"<p>SuperShapes are parameterized shapes that have geometry based on a given number of lobes, $m$.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-1-initialize-supershapes-generator","title":"Step 1: Initialize SuperShapes Generator\u00b6","text":"<p>Here, we will initialize  SuperShapes cohort generator. The output directory needs to be specified otherwise an output directory will automatically be generated.</p> <p>Argument:</p> <ul> <li><code>out_dir</code>: path where the dataset should be saved Datatype : <code>string</code> Default value : 'current_directory/generated_supershapes_cohort/' </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-2-generate-meshes","title":"Step 2: Generate Meshes\u00b6","text":"<p>For the supershapes mesh generation, you can specify the following arguments:</p> <ul> <li><code>num_samples</code> - number of samples in the cohort(dataset) Datatype : <code>int</code>  Default value : 3  </li> <li><code>randomize_center</code>: randomizes the centers for ellipsoid mesh generation if set to <code>True</code> Datatype : <code>bool</code>  Defaut value : <code>True</code> </li> <li><code>randomize_rotation</code>: randomizes the orientation of the ellispoids if set to <code>True</code>  Datatype : <code>bool</code>  Defaut value : <code>True</code> </li> <li><code>m</code>: number of lobes supershapes should have  Datatype : <code>int</code>  Default value: <code>3</code> </li> <li><code>size</code>: size of meshes (won't be more than 'size' away from center in any direction)  Datatype: <code>int</code>  Default value: <code>20</code> </li> </ul>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-3-generate-segmentations","title":"Step 3: Generate Segmentations\u00b6","text":"<p>This is data type independent, the options are the same as they were for the ellipsoid.</p>"},{"location":"notebooks/getting-started-with-shape-cohort-generation.html#step-4-generate-images","title":"Step 4: Generate Images\u00b6","text":"<p>This is also a standard function and has all the same options as listed before.</p>"},{"location":"python/python-api.html","title":"ShapeWorks Python API","text":"<p>ShapeWorks Python API</p>"},{"location":"python/python-api.html#shapeworks_py.ContourDomain","title":"<code>ContourDomain = &lt;DomainType.ContourDomain: 2&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.ImageDomain","title":"<code>ImageDomain = &lt;DomainType.ImageDomain: 0&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.Linear","title":"<code>Linear = &lt;InterpolationType.Linear: 0&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>Linear</p> <p>NearestNeighbor</p>"},{"location":"python/python-api.html#shapeworks_py.MeshDomain","title":"<code>MeshDomain = &lt;DomainType.MeshDomain: 1&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.NearestNeighbor","title":"<code>NearestNeighbor = &lt;InterpolationType.NearestNeighbor: 1&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>Linear</p> <p>NearestNeighbor</p>"},{"location":"python/python-api.html#shapeworks_py.Pi","title":"<code>Pi = 3.141592653589793</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"python/python-api.html#shapeworks_py.X","title":"<code>X = &lt;Axis.X: 0&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Y","title":"<code>Y = &lt;Axis.Y: 1&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Z","title":"<code>Z = &lt;Axis.Z: 2&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.invalid","title":"<code>invalid = &lt;Axis.invalid: -1&gt;</code>  <code>module-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze","title":"<code>Analyze</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.create_shape_from_points","title":"<code>create_shape_from_points()</code>  <code>method descriptor</code>","text":"<p>create_shape_from_points(self: shapeworks_py.Analyze, arg0: shapeworks::Particles) -&gt; shapeworks::Shape</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_mean_shape","title":"<code>get_mean_shape()</code>  <code>method descriptor</code>","text":"<p>get_mean_shape(self: shapeworks_py.Analyze) -&gt; shapeworks_py.Mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_mean_shape_points","title":"<code>get_mean_shape_points()</code>  <code>method descriptor</code>","text":"<p>get_mean_shape_points(self: shapeworks_py.Analyze) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_mode_shape","title":"<code>get_mode_shape()</code>  <code>method descriptor</code>","text":"<p>get_mode_shape(self: shapeworks_py.Analyze, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -&gt; shapeworks::Shape</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_num_modes","title":"<code>get_num_modes()</code>  <code>method descriptor</code>","text":"<p>get_num_modes(self: shapeworks_py.Analyze) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_num_particles","title":"<code>get_num_particles()</code>  <code>method descriptor</code>","text":"<p>get_num_particles(self: shapeworks_py.Analyze) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_num_subjects","title":"<code>get_num_subjects()</code>  <code>method descriptor</code>","text":"<p>get_num_subjects(self: shapeworks_py.Analyze) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_shape_points","title":"<code>get_shape_points()</code>  <code>method descriptor</code>","text":"<p>get_shape_points(self: shapeworks_py.Analyze, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -&gt; shapeworks::Particles</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_shapes","title":"<code>get_shapes()</code>  <code>method descriptor</code>","text":"<p>get_shapes(self: shapeworks_py.Analyze) -&gt; std::__1::vector, std::__1::allocator\\&gt;&gt;"},{"location":"python/python-api.html#shapeworks_py.Analyze.get_subject_features","title":"<code>get_subject_features()</code>  <code>method descriptor</code>","text":"<p>get_subject_features(self: shapeworks_py.Analyze, arg0: typing.SupportsInt, arg1: str) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.groups_active","title":"<code>groups_active()</code>  <code>method descriptor</code>","text":"<p>groups_active(self: shapeworks_py.Analyze) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Analyze.run_offline_analysis","title":"<code>run_offline_analysis()</code>  <code>method descriptor</code>","text":"<p>run_offline_analysis(self: shapeworks_py.Analyze, arg0: str, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Axis","title":"<code>Axis</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.X","title":"<code>X = &lt;Axis.X: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.Y","title":"<code>Y = &lt;Axis.Y: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.Z","title":"<code>Z = &lt;Axis.Z: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.invalid","title":"<code>invalid = &lt;Axis.invalid: -1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>invalid</p> <p>X</p> <p>Y</p> <p>Z</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Axis.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.DomainType","title":"<code>DomainType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.DomainType.ContourDomain","title":"<code>ContourDomain = &lt;DomainType.ContourDomain: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.DomainType.ImageDomain","title":"<code>ImageDomain = &lt;DomainType.ImageDomain: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.DomainType.MeshDomain","title":"<code>MeshDomain = &lt;DomainType.MeshDomain: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>MeshDomain</p> <p>ImageDomain</p> <p>ContourDomain</p>"},{"location":"python/python-api.html#shapeworks_py.DomainType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.DomainType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Groom","title":"<code>Groom</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Groom.run","title":"<code>run()</code>  <code>method descriptor</code>","text":"<p>run(self: shapeworks_py.Groom) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Image","title":"<code>Image</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Image.antialias","title":"<code>antialias()</code>  <code>method descriptor</code>","text":"<p>antialias(self: shapeworks_py.Image, iterations: typing.SupportsInt = 50, maxRMSErr: typing.SupportsFloat = 0.009999999776482582, layers: typing.SupportsInt = 3) -&gt; shapeworks_py.Image</p> <p>antialiases binary volumes (layers is set to 3 when not specified)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applyCurvatureFilter","title":"<code>applyCurvatureFilter()</code>  <code>method descriptor</code>","text":"<p>applyCurvatureFilter(self: shapeworks_py.Image, iterations: typing.SupportsInt = 10) -&gt; shapeworks_py.Image</p> <p>denoises an image using curvature driven flow using curvature flow image filter</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applyGradientFilter","title":"<code>applyGradientFilter()</code>  <code>method descriptor</code>","text":"<p>applyGradientFilter(self: shapeworks_py.Image) -&gt; shapeworks_py.Image</p> <p>computes gradient magnitude at each pixel using gradient magnitude filter</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applyIntensityFilter","title":"<code>applyIntensityFilter()</code>  <code>method descriptor</code>","text":"<p>applyIntensityFilter(self: shapeworks_py.Image, min: typing.SupportsFloat = 0.0, max: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</p> <p>applies intensity windowing image filter</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applySigmoidFilter","title":"<code>applySigmoidFilter()</code>  <code>method descriptor</code>","text":"<p>applySigmoidFilter(self: shapeworks_py.Image, alpha: typing.SupportsFloat = 10.0, beta: typing.SupportsFloat = 10.0) -&gt; shapeworks_py.Image</p> <p>computes sigmoid function pixel-wise using sigmoid image filter</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applyTPLevelSetFilter","title":"<code>applyTPLevelSetFilter()</code>  <code>method descriptor</code>","text":"<p>applyTPLevelSetFilter(self: shapeworks_py.Image, featureImage: shapeworks_py.Image, scaling: typing.SupportsFloat = 20.0) -&gt; shapeworks_py.Image</p> <p>segments structures in image using topology preserving geodesic active contour level set filter</p>"},{"location":"python/python-api.html#shapeworks_py.Image.applyTransform","title":"<code>applyTransform()</code>  <code>method descriptor</code>","text":"<p>applyTransform(args, *kwargs) Overloaded function.</p> <ol> <li>applyTransform(self: shapeworks_py.Image, transform: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[4, 4]\"], interp: shapeworks_py.InterpolationType = , meshTransform: bool = False) -&gt; shapeworks_py.Image <p>applies the given transformation to the image by using the specified resampling filter (Linear or NearestNeighbor)</p> <ol> <li>applyTransform(self: shapeworks_py.Image, transform: shapeworks_py.WarpTransform, interp: shapeworks_py.InterpolationType = ) -&gt; shapeworks_py.Image <p>applies the given warp transformation to the image using the specified resampling filter (Linear or NearestNeighbor)</p> <ol> <li>applyTransform(self: shapeworks_py.Image, transform: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[4, 4]\"], origin: collections.abc.Sequence[typing.SupportsFloat], dims: collections.abc.Sequence[typing.SupportsInt], spacing: collections.abc.Sequence[typing.SupportsFloat], direction: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[3, 3]\"], interp: shapeworks_py.InterpolationType = , meshTransform: bool = False) -&gt; shapeworks_py.Image <p>applies the given transformation to the image by using resampling filter with new origin, dims, spacing, and sampling along given direction axes (a 3x3 row-major matrix) using the specified interpolation method (Linear or NearestNeighbor)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.assign","title":"<code>assign()</code>  <code>method descriptor</code>","text":"<p>assign(self: shapeworks_py.Image, arg0: numpy.ndarray) -&gt; shapeworks_py.Image</p> <p>Initialize an image from a numpy array (must be dtype float32). Transfers ownership of the array without copying. If a copy is desired, construct using Image(np.array(arr)).</p>"},{"location":"python/python-api.html#shapeworks_py.Image.binarize","title":"<code>binarize()</code>  <code>method descriptor</code>","text":"<p>binarize(self: shapeworks_py.Image, minVal: typing.SupportsFloat = 0.0, maxVal: typing.SupportsFloat = 3.4028234663852886e+38, innerVal: typing.SupportsFloat = 1.0, outerVal: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</p> <p>sets portion of image greater than min and less than or equal to max to the specified value</p>"},{"location":"python/python-api.html#shapeworks_py.Image.center","title":"<code>center()</code>  <code>method descriptor</code>","text":"<p>center(self: shapeworks_py.Image) -&gt; numpy.ndarray</p> <p>physical coordinates of center of this image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.centerOfMass","title":"<code>centerOfMass()</code>  <code>method descriptor</code>","text":"<p>centerOfMass(self: shapeworks_py.Image, minVal: typing.SupportsFloat = 0.0, maxVal: typing.SupportsFloat = 1.0) -&gt; numpy.ndarray</p> <p>returns average physical coordinate of pixels in range (minval, maxval]</p>"},{"location":"python/python-api.html#shapeworks_py.Image.clip","title":"<code>clip()</code>  <code>method descriptor</code>","text":"<p>clip(args, *kwargs) Overloaded function.</p> <ol> <li>clip(self: shapeworks_py.Image, o: collections.abc.Sequence[typing.SupportsFloat], p1: collections.abc.Sequence[typing.SupportsFloat], p2: collections.abc.Sequence[typing.SupportsFloat], val: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</li> </ol> <p>sets values on the back side of cutting plane (containing three non-colinear points) to val (default 0.0)</p> <ol> <li>clip(self: shapeworks_py.Image, n: collections.abc.Sequence[typing.SupportsFloat], q: collections.abc.Sequence[typing.SupportsFloat], val: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</li> </ol> <p>sets values on the back side of cutting plane (normal n containing point p) to val (default 0.0)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.closeHoles","title":"<code>closeHoles()</code>  <code>method descriptor</code>","text":"<p>closeHoles(self: shapeworks_py.Image, foreground: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</p> <p>closes holes in a volume defined by values larger than specified value</p>"},{"location":"python/python-api.html#shapeworks_py.Image.compare","title":"<code>compare()</code>  <code>method descriptor</code>","text":"<p>compare(args, *kwargs) Overloaded function.</p> <ol> <li>compare(self: shapeworks_py.Image, other: shapeworks_py.Image, verifyall: bool = True, tolerance: typing.SupportsFloat = 0.0, precision: typing.SupportsFloat = 1e-06) -&gt; bool</li> </ol> <p>compares two images</p> <ol> <li>compare(self: shapeworks_py.Image, other: shapeworks_py.Image, verifyall: bool = True, tolerance: typing.SupportsFloat = 0.0, precision: typing.SupportsFloat = 1e-12) -&gt; bool</li> </ol> <p>compares two images</p>"},{"location":"python/python-api.html#shapeworks_py.Image.computeDT","title":"<code>computeDT()</code>  <code>method descriptor</code>","text":"<p>computeDT(self: shapeworks_py.Image, isovalue: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</p> <p>computes signed distance transform volume from an image at the specified isovalue</p>"},{"location":"python/python-api.html#shapeworks_py.Image.coordsys","title":"<code>coordsys()</code>  <code>method descriptor</code>","text":"<p>coordsys(self: shapeworks_py.Image) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[3, 3]\"]</p> <p>return 3x3 coordinate system in which this image lives in physical space</p>"},{"location":"python/python-api.html#shapeworks_py.Image.copy","title":"<code>copy()</code>  <code>method descriptor</code>","text":"<p>copy(self: shapeworks_py.Image) -&gt; shapeworks_py.Image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.createCenterOfMassTransform","title":"<code>createCenterOfMassTransform()</code>  <code>method descriptor</code>","text":"<p>createCenterOfMassTransform(self: shapeworks_py.Image) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>creates a transform that translates center of mass to center of image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.createRigidRegistrationTransform","title":"<code>createRigidRegistrationTransform()</code>  <code>method descriptor</code>","text":"<p>createRigidRegistrationTransform(self: shapeworks_py.Image, target: shapeworks_py.Image, isoValue: typing.SupportsFloat = 0.0, iterations: typing.SupportsInt = 20) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>creates transform to target image using iterative closest point (ICP) registration; images MUST be distance transforms; isovalue is used to create meshes from these distance transform images, which are then passed to ICP for the given number of iterations</p>"},{"location":"python/python-api.html#shapeworks_py.Image.crop","title":"<code>crop()</code>  <code>method descriptor</code>","text":"<p>crop(self: shapeworks_py.Image, region: shapeworks::PhysicalRegion, padding: typing.SupportsInt = 0) -&gt; shapeworks_py.Image</p> <p>crops the image down to the given (physical) region, with optional padding</p>"},{"location":"python/python-api.html#shapeworks_py.Image.dims","title":"<code>dims()</code>  <code>method descriptor</code>","text":"<p>dims(self: shapeworks_py.Image) -&gt; numpy.ndarray</p> <p>logical dimensions of the image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.evaluate","title":"<code>evaluate()</code>  <code>method descriptor</code>","text":"<p>evaluate(self: shapeworks_py.Image, pt: collections.abc.Sequence[typing.SupportsFloat]) -&gt; float</p> <p>evaluate the image at any given point in space</p>"},{"location":"python/python-api.html#shapeworks_py.Image.extractLabel","title":"<code>extractLabel()</code>  <code>method descriptor</code>","text":"<p>extractLabel(self: shapeworks_py.Image, label: typing.SupportsFloat = 1.0) -&gt; shapeworks_py.Image</p> <p>extracts/isolates a specific pixel label from a given multi-label volume and outputs the corresponding binary image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.fitRegion","title":"<code>fitRegion()</code>  <code>method descriptor</code>","text":"<p>fitRegion(self: shapeworks_py.Image, region: shapeworks::PhysicalRegion, value: typing.SupportsFloat = 0) -&gt; shapeworks_py.Image</p> <p>crops or pads the image to fit a region with optional padding value</p>"},{"location":"python/python-api.html#shapeworks_py.Image.gaussianBlur","title":"<code>gaussianBlur()</code>  <code>method descriptor</code>","text":"<p>gaussianBlur(self: shapeworks_py.Image, sigma: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</p> <p>applies gaussian blur</p>"},{"location":"python/python-api.html#shapeworks_py.Image.isolate","title":"<code>isolate()</code>  <code>method descriptor</code>","text":"<p>isolate(self: shapeworks_py.Image) -&gt; shapeworks_py.Image</p> <p>isolate largest object</p>"},{"location":"python/python-api.html#shapeworks_py.Image.logicalBoundingBox","title":"<code>logicalBoundingBox()</code>  <code>method descriptor</code>","text":"<p>logicalBoundingBox(self: shapeworks_py.Image) -&gt; shapeworks::IndexRegion</p> <p>returns the index coordinates of this image's region</p>"},{"location":"python/python-api.html#shapeworks_py.Image.logicalToPhysical","title":"<code>logicalToPhysical()</code>  <code>method descriptor</code>","text":"<p>logicalToPhysical(args, *kwargs) Overloaded function.</p> <ol> <li>logicalToPhysical(self: shapeworks_py.Image, region: shapeworks::IndexRegion) -&gt; shapeworks::PhysicalRegion</li> </ol> <p>converts from a logical region (index coordinates) to a physical region</p> <ol> <li>logicalToPhysical(self: shapeworks_py.Image, c: collections.abc.Sequence[typing.SupportsInt]) -&gt; numpy.ndarray</li> </ol> <p>converts a logical (index) coordinate to physical space</p>"},{"location":"python/python-api.html#shapeworks_py.Image.max","title":"<code>max()</code>  <code>method descriptor</code>","text":"<p>max(self: shapeworks_py.Image) -&gt; float</p> <p>maximum of image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.mean","title":"<code>mean()</code>  <code>method descriptor</code>","text":"<p>mean(self: shapeworks_py.Image) -&gt; float</p> <p>mean of image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.min","title":"<code>min()</code>  <code>method descriptor</code>","text":"<p>min(self: shapeworks_py.Image) -&gt; float</p> <p>minimum of image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.origin","title":"<code>origin()</code>  <code>method descriptor</code>","text":"<p>origin(self: shapeworks_py.Image) -&gt; numpy.ndarray</p> <p>physical coordinates of image origin</p>"},{"location":"python/python-api.html#shapeworks_py.Image.pad","title":"<code>pad()</code>  <code>method descriptor</code>","text":"<p>pad(args, *kwargs) Overloaded function.</p> <ol> <li>pad(self: shapeworks_py.Image, pad: typing.SupportsInt, value: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</li> </ol> <p>pads an image by same number of pixels in all directions with constant value</p> <ol> <li>pad(self: shapeworks_py.Image, padx: typing.SupportsInt, pady: typing.SupportsInt, padz: typing.SupportsInt, value: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</li> </ol> <p>pads an image by desired number of pixels in each direction with constant value</p> <ol> <li>pad(self: shapeworks_py.Image, region: shapeworks::IndexRegion, value: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Image</li> </ol> <p>pads an image to include the given region with constant value</p>"},{"location":"python/python-api.html#shapeworks_py.Image.physicalBoundingBox","title":"<code>physicalBoundingBox()</code>  <code>method descriptor</code>","text":"<p>physicalBoundingBox(self: shapeworks_py.Image, isovalue: typing.SupportsFloat = 1.0) -&gt; shapeworks::PhysicalRegion</p> <p>returns region of physical space occupied by the region of data &lt;= the given isoValue</p>"},{"location":"python/python-api.html#shapeworks_py.Image.physicalToLogical","title":"<code>physicalToLogical()</code>  <code>method descriptor</code>","text":"<p>physicalToLogical(args, *kwargs) Overloaded function.</p> <ol> <li>physicalToLogical(self: shapeworks_py.Image, region: shapeworks::PhysicalRegion) -&gt; shapeworks::IndexRegion</li> </ol> <p>converts from a physical region to a logical region (index coordinates)</p> <ol> <li>physicalToLogical(self: shapeworks_py.Image, p: collections.abc.Sequence[typing.SupportsFloat]) -&gt; numpy.ndarray</li> </ol> <p>converts a physical coordinate to a logical (index) space</p>"},{"location":"python/python-api.html#shapeworks_py.Image.physicalboundingBox","title":"<code>physicalboundingBox()</code>  <code>method descriptor</code>","text":"<p>physicalboundingBox(self: shapeworks_py.Image) -&gt; shapeworks::PhysicalRegion</p> <p>returns region of physical space occupied by this image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.recenter","title":"<code>recenter()</code>  <code>method descriptor</code>","text":"<p>recenter(self: shapeworks_py.Image) -&gt; shapeworks_py.Image</p> <p>recenters an image by changing its origin in the image header to the physical coordinates of the center of the image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.reflect","title":"<code>reflect()</code>  <code>method descriptor</code>","text":"<p>reflect(self: shapeworks_py.Image, axis: shapeworks_py.Axis) -&gt; shapeworks_py.Image</p> <p>reflect image with respect to logical image center and the specified axis</p>"},{"location":"python/python-api.html#shapeworks_py.Image.resample","title":"<code>resample()</code>  <code>method descriptor</code>","text":"<p>resample(args, *kwargs) Overloaded function.</p> <ol> <li>resample(self: shapeworks_py.Image, transform: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[4, 4]\"], origin: collections.abc.Sequence[typing.SupportsFloat], dims: collections.abc.Sequence[typing.SupportsInt], spacing: collections.abc.Sequence[typing.SupportsFloat], direction: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[3, 3]\"], interp: shapeworks_py.InterpolationType = ) -&gt; shapeworks_py.Image <p>resamples by applying transform then sampling from given origin along direction axes at spacing physical units per pixel for dims pixels using specified interpolator</p> <ol> <li>resample(self: shapeworks_py.Image, physicalSpacing: collections.abc.Sequence[typing.SupportsFloat], interp: shapeworks_py.InterpolationType = ) -&gt; shapeworks_py.Image <p>resamples image using new physical spacing, updating logical dims to keep all image data for this spacing</p> <ol> <li>resample(self: shapeworks_py.Image, isoSpacing: typing.SupportsFloat = 1.0, interp: shapeworks_py.InterpolationType = ) -&gt; shapeworks_py.Image <p>isotropically resamples image using giving isospacing</p>"},{"location":"python/python-api.html#shapeworks_py.Image.resize","title":"<code>resize()</code>  <code>method descriptor</code>","text":"<p>resize(self: shapeworks_py.Image, logicalDims: collections.abc.Sequence[typing.SupportsInt], interp: shapeworks_py.InterpolationType = ) -&gt; shapeworks_py.Image <p>change logical dims (computes new physical spacing)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.rotate","title":"<code>rotate()</code>  <code>method descriptor</code>","text":"<p>rotate(args, *kwargs) Overloaded function.</p> <ol> <li>rotate(self: shapeworks_py.Image, angle: typing.SupportsFloat, axis: itk::Vector) -&gt; shapeworks_py.Image <p>rotate around center (not origin) using axis (default z-axis) by angle (in radians)</p> <ol> <li>rotate(self: shapeworks_py.Image, angle: typing.SupportsFloat, axis: shapeworks_py.Axis) -&gt; shapeworks_py.Image</li> </ol> <p>rotate around center (not origin) using axis (default z-axis) by angle (in radians)</p> <ol> <li>rotate(self: shapeworks_py.Image, angle: typing.SupportsFloat, axis: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Image</li> </ol> <p>rotate around center (not origin) using axis (default z-axis) by angle (in radians)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.scale","title":"<code>scale()</code>  <code>method descriptor</code>","text":"<p>scale(self: shapeworks_py.Image, scale_vec: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Image</p> <p>scale image by scale_vec around center (not origin)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.setCoordsys","title":"<code>setCoordsys()</code>  <code>method descriptor</code>","text":"<p>setCoordsys(self: shapeworks_py.Image, coordsys: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[3, 3]\"] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]) -&gt; shapeworks_py.Image</p> <p>sets the orientation of this image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.setOrigin","title":"<code>setOrigin()</code>  <code>method descriptor</code>","text":"<p>setOrigin(self: shapeworks_py.Image, origin: collections.abc.Sequence[typing.SupportsFloat] = [0.0, 0.0, 0.0]) -&gt; shapeworks_py.Image</p> <p>sets the image origin in physical space to the given value</p>"},{"location":"python/python-api.html#shapeworks_py.Image.setSpacing","title":"<code>setSpacing()</code>  <code>method descriptor</code>","text":"<p>setSpacing(self: shapeworks_py.Image, spacing: collections.abc.Sequence[typing.SupportsFloat] = [1.0, 1.0, 1.0]) -&gt; shapeworks_py.Image</p> <p>set image spacing, the size of each pixel</p>"},{"location":"python/python-api.html#shapeworks_py.Image.size","title":"<code>size()</code>  <code>method descriptor</code>","text":"<p>size(self: shapeworks_py.Image) -&gt; numpy.ndarray</p> <p>physical dimensions of the image (dims * spacing)</p>"},{"location":"python/python-api.html#shapeworks_py.Image.spacing","title":"<code>spacing()</code>  <code>method descriptor</code>","text":"<p>spacing(self: shapeworks_py.Image) -&gt; numpy.ndarray</p> <p>physical spacing of the image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.std","title":"<code>std()</code>  <code>method descriptor</code>","text":"<p>std(self: shapeworks_py.Image) -&gt; float</p> <p>standard deviation of image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.toArray","title":"<code>toArray()</code>  <code>method descriptor</code>","text":"<p>toArray(self: shapeworks_py.Image, copy: bool = False, for_viewing: bool = False) -&gt; numpy.ndarray</p> <p>returns raw array of image data, directly sharing data by default, copying if specified. NOTE: many Image operations reallocate image array, so while the array returned from this function is writable, it is best used immediately for Python operations; use for_viewing argument to get array in column-major ('F') order ('sw2vtkImage' already does this).</p>"},{"location":"python/python-api.html#shapeworks_py.Image.toMesh","title":"<code>toMesh()</code>  <code>method descriptor</code>","text":"<p>toMesh(self: shapeworks_py.Image, isovalue: typing.SupportsFloat) -&gt; shapeworks::Mesh</p> <p>converts image to mesh at specified isovalue</p>"},{"location":"python/python-api.html#shapeworks_py.Image.topologyPreservingSmooth","title":"<code>topologyPreservingSmooth()</code>  <code>method descriptor</code>","text":"<p>topologyPreservingSmooth(self: shapeworks_py.Image, scaling: typing.SupportsFloat = 20.0, sigmoidAlpha: typing.SupportsFloat = 10.5, sigmoidBeta: typing.SupportsFloat = 10.0) -&gt; shapeworks_py.Image</p> <p>creates a feature image (by applying gradient then sigmoid filters), then passes it to the TPLevelSet filter [curvature flow filter is often applied to the image before this filter]</p>"},{"location":"python/python-api.html#shapeworks_py.Image.translate","title":"<code>translate()</code>  <code>method descriptor</code>","text":"<p>translate(self: shapeworks_py.Image, v: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Image</p> <p>translates image</p>"},{"location":"python/python-api.html#shapeworks_py.Image.write","title":"<code>write()</code>  <code>method descriptor</code>","text":"<p>write(self: shapeworks_py.Image, filename: str, compressed: bool = True) -&gt; shapeworks_py.Image</p> <p>writes the current image (determines type by its extension)</p>"},{"location":"python/python-api.html#shapeworks_py.ImageUtils","title":"<code>ImageUtils</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ImageUtils.boundingBox","title":"<code>boundingBox()</code>  <code>staticmethod</code>","text":"<p>boundingBox(args, *kwargs) Overloaded function.</p> <ol> <li>boundingBox(filenames: collections.abc.Sequence[str], isoValue: typing.SupportsFloat = 1.0) -&gt; shapeworks_py.PhysicalRegion</li> </ol> <p>compute largest bounding box surrounding the specified isovalue of the specified set of filenames</p> <ol> <li>boundingBox(images: collections.abc.Sequence[shapeworks_py.Image], isoValue: typing.SupportsFloat = 1.0) -&gt; shapeworks_py.PhysicalRegion</li> </ol> <p>compute largest bounding box surrounding the specified isovalue of the specified set of images</p>"},{"location":"python/python-api.html#shapeworks_py.ImageUtils.createWarpTransform","title":"<code>createWarpTransform()</code>  <code>staticmethod</code>","text":"<p>createWarpTransform(source_landmarks: str, target_landmarks: str, stride: typing.SupportsInt = 1) -&gt; shapeworks_py.WarpTransform</p> <p>computes a warp transform from the source to the target landmarks (in the given files) using every stride points</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion","title":"<code>IndexRegion</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.max","title":"<code>max</code>  <code>property</code>","text":"<p>max point of region</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.min","title":"<code>min</code>  <code>property</code>","text":"<p>min point of region</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.origin","title":"<code>origin()</code>  <code>method descriptor</code>","text":"<p>origin(self: shapeworks_py.IndexRegion) -&gt; numpy.ndarray</p> <p>return origin of region</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.pad","title":"<code>pad()</code>  <code>method descriptor</code>","text":"<p>pad(self: shapeworks_py.IndexRegion, padding: typing.SupportsInt) -&gt; shapeworks_py.IndexRegion</p> <p>grows or shrinks the region by the specified amount</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.size","title":"<code>size()</code>  <code>method descriptor</code>","text":"<p>size(self: shapeworks_py.IndexRegion) -&gt; numpy.ndarray</p> <p>return size of region</p>"},{"location":"python/python-api.html#shapeworks_py.IndexRegion.valid","title":"<code>valid()</code>  <code>method descriptor</code>","text":"<p>valid(self: shapeworks_py.IndexRegion) -&gt; bool</p> <p>ensure if region is valid</p>"},{"location":"python/python-api.html#shapeworks_py.InterpolationType","title":"<code>InterpolationType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>Linear</p> <p>NearestNeighbor</p>"},{"location":"python/python-api.html#shapeworks_py.InterpolationType.Linear","title":"<code>Linear = &lt;InterpolationType.Linear: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Linear</p> <p>NearestNeighbor</p>"},{"location":"python/python-api.html#shapeworks_py.InterpolationType.NearestNeighbor","title":"<code>NearestNeighbor = &lt;InterpolationType.NearestNeighbor: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Linear</p> <p>NearestNeighbor</p>"},{"location":"python/python-api.html#shapeworks_py.InterpolationType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.InterpolationType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh","title":"<code>Mesh</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Affine","title":"<code>Affine = &lt;AlignmentType.Affine: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Butterfly","title":"<code>Butterfly = &lt;SubdivisionType.Butterfly: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Butterfly</p> <p>Loop</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Face","title":"<code>Face = &lt;FieldType.Face: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Point</p> <p>Face</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Gaussian","title":"<code>Gaussian = &lt;CurvatureType.Gaussian: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Loop","title":"<code>Loop = &lt;SubdivisionType.Loop: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Butterfly</p> <p>Loop</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Mean","title":"<code>Mean = &lt;CurvatureType.Mean: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Point","title":"<code>Point = &lt;FieldType.Point: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Point</p> <p>Face</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.PointToCell","title":"<code>PointToCell = &lt;DistanceMethod.PointToCell: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>PointToPoint</p> <p>PointToCell</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.PointToPoint","title":"<code>PointToPoint = &lt;DistanceMethod.PointToPoint: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>PointToPoint</p> <p>PointToCell</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Principal","title":"<code>Principal = &lt;CurvatureType.Principal: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Rigid","title":"<code>Rigid = &lt;AlignmentType.Rigid: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.Similarity","title":"<code>Similarity = &lt;AlignmentType.Similarity: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType","title":"<code>AlignmentType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType.Affine","title":"<code>Affine = &lt;AlignmentType.Affine: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType.Rigid","title":"<code>Rigid = &lt;AlignmentType.Rigid: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType.Similarity","title":"<code>Similarity = &lt;AlignmentType.Similarity: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Rigid</p> <p>Similarity</p> <p>Affine</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.AlignmentType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType","title":"<code>CurvatureType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType.Gaussian","title":"<code>Gaussian = &lt;CurvatureType.Gaussian: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType.Mean","title":"<code>Mean = &lt;CurvatureType.Mean: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType.Principal","title":"<code>Principal = &lt;CurvatureType.Principal: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Principal</p> <p>Gaussian</p> <p>Mean</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.CurvatureType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh.DistanceMethod","title":"<code>DistanceMethod</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>PointToPoint</p> <p>PointToCell</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.DistanceMethod.PointToCell","title":"<code>PointToCell = &lt;DistanceMethod.PointToCell: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>PointToPoint</p> <p>PointToCell</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.DistanceMethod.PointToPoint","title":"<code>PointToPoint = &lt;DistanceMethod.PointToPoint: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>PointToPoint</p> <p>PointToCell</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.DistanceMethod.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.DistanceMethod.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh.FieldType","title":"<code>FieldType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>Point</p> <p>Face</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.FieldType.Face","title":"<code>Face = &lt;FieldType.Face: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Point</p> <p>Face</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.FieldType.Point","title":"<code>Point = &lt;FieldType.Point: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Point</p> <p>Face</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.FieldType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.FieldType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh.SubdivisionType","title":"<code>SubdivisionType</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Members:</p> <p>Butterfly</p> <p>Loop</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.SubdivisionType.Butterfly","title":"<code>Butterfly = &lt;SubdivisionType.Butterfly: 0&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Butterfly</p> <p>Loop</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.SubdivisionType.Loop","title":"<code>Loop = &lt;SubdivisionType.Loop: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Members:</p> <p>Butterfly</p> <p>Loop</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.SubdivisionType.name","title":"<code>name</code>  <code>property</code>","text":"<p>name(self: object, /) -&gt; str</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.SubdivisionType.value","title":"<code>value</code>  <code>property</code>","text":""},{"location":"python/python-api.html#shapeworks_py.Mesh.applySubdivisionFilter","title":"<code>applySubdivisionFilter()</code>  <code>method descriptor</code>","text":"<p>applySubdivisionFilter(self: shapeworks_py.Mesh, type: shapeworks_py.Mesh.SubdivisionType = , subdivision: typing.SupportsInt = 1) -&gt; shapeworks_py.Mesh <p>applies subdivision filter (butterfly (default) or loop)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.applyTransform","title":"<code>applyTransform()</code>  <code>method descriptor</code>","text":"<p>applyTransform(self: shapeworks_py.Mesh, transform: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[4, 4]\"], imageTransform: bool = False) -&gt; shapeworks_py.Mesh</p> <p>applies the given transformation to the mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.boundingBox","title":"<code>boundingBox()</code>  <code>method descriptor</code>","text":"<p>boundingBox(self: shapeworks_py.Mesh) -&gt; shapeworks_py.PhysicalRegion</p> <p>computes bounding box of current mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.center","title":"<code>center()</code>  <code>method descriptor</code>","text":"<p>center(self: shapeworks_py.Mesh) -&gt; numpy.ndarray</p> <p>center of mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.centerOfMass","title":"<code>centerOfMass()</code>  <code>method descriptor</code>","text":"<p>centerOfMass(self: shapeworks_py.Mesh) -&gt; numpy.ndarray</p> <p>center of mass of mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.clip","title":"<code>clip()</code>  <code>method descriptor</code>","text":"<p>clip(args, *kwargs) Overloaded function.</p> <ol> <li>clip(self: shapeworks_py.Mesh, point: collections.abc.Sequence[typing.SupportsFloat], normal: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Mesh</li> </ol> <p>clips a mesh using a cutting plane</p> <ol> <li>clip(self: shapeworks_py.Mesh, o: collections.abc.Sequence[typing.SupportsFloat], p1: collections.abc.Sequence[typing.SupportsFloat], p2: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Mesh</li> </ol> <p>clips a mesh using a cutting plane</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.clipClosedSurface","title":"<code>clipClosedSurface()</code>  <code>method descriptor</code>","text":"<p>clipClosedSurface(self: shapeworks_py.Mesh, point: collections.abc.Sequence[typing.SupportsFloat], normal: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Mesh</p> <p>clips a mesh using a cutting plane resulting in a closed surface</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.closestPoint","title":"<code>closestPoint()</code>  <code>method descriptor</code>","text":"<p>closestPoint(self: shapeworks_py.Mesh, point: collections.abc.Sequence[typing.SupportsFloat]) -&gt; tuple</p> <p>returns closest point to given point on mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.closestPointId","title":"<code>closestPointId()</code>  <code>method descriptor</code>","text":"<p>closestPointId(self: shapeworks_py.Mesh, point: collections.abc.Sequence[typing.SupportsFloat]) -&gt; int</p> <p>returns closest point id in this mesh to the given point in space</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.compareField","title":"<code>compareField()</code>  <code>method descriptor</code>","text":"<p>compareField(self: shapeworks_py.Mesh, other_mesh: shapeworks_py.Mesh, name1: str, name2: str = '', eps: typing.SupportsFloat = -1.0) -&gt; bool</p> <p>compares two meshes based on fields</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.computeNormals","title":"<code>computeNormals()</code>  <code>method descriptor</code>","text":"<p>computeNormals(self: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>computes and adds oriented point and cell normals</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.computeThickness","title":"<code>computeThickness()</code>  <code>method descriptor</code>","text":"<p>computeThickness(self: shapeworks_py.Mesh, ct: shapeworks_py.Image, dt: shapeworks_py.Image = None, maxDist: typing.SupportsFloat = 10000, medianRadius: typing.SupportsFloat = 5.0, distanceMesh: str = '') -&gt; shapeworks_py.Mesh</p> <p>Computes cortical thickness</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.copy","title":"<code>copy()</code>  <code>method descriptor</code>","text":"<p>copy(self: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.coverage","title":"<code>coverage()</code>  <code>method descriptor</code>","text":"<p>coverage(self: shapeworks_py.Mesh, otherMesh: shapeworks_py.Mesh, allowBackIntersections: bool = True, angleThreshold: typing.SupportsFloat = 0, backSearchRadius: typing.SupportsFloat = 0) -&gt; shapeworks_py.Mesh</p> <p>determines coverage between current mesh and another mesh (e.g. acetabular cup / femoral head)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.createTransform","title":"<code>createTransform()</code>  <code>method descriptor</code>","text":"<p>createTransform(self: shapeworks_py.Mesh, target: shapeworks_py.Mesh, align: shapeworks_py.Mesh.AlignmentType = , iterations: typing.SupportsInt = 10) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[4, 4]\"] <p>creates a transform using specified AlignmentType (Mesh.Rigid, Mesh.Similarity, Mesh.Affine) for specified number of iterations (default alignment: Similarity, default iterations: 10)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.curvature","title":"<code>curvature()</code>  <code>method descriptor</code>","text":"<p>curvature(self: shapeworks_py.Mesh, type: shapeworks_py.Mesh.CurvatureType = ) -&gt; numpy.ndarray <p>computes and adds curvature (principal (default) or gaussian or mean)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.distance","title":"<code>distance()</code>  <code>method descriptor</code>","text":"<p>distance(self: shapeworks_py.Mesh, target: shapeworks_py.Mesh, method: shapeworks_py.Mesh.DistanceMethod = ) -&gt; tuple <p>computes closest distance from vertices of this mesh to target mesh, returning indices of faces or vertices in target mesh that contain closest points</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.extractLargestComponent","title":"<code>extractLargestComponent()</code>  <code>method descriptor</code>","text":"<p>extractLargestComponent(self: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>extract the largest connected component from the mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.faces","title":"<code>faces()</code>  <code>method descriptor</code>","text":"<p>faces(self: shapeworks_py.Mesh) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.int32], \"[m, n]\"]</p> <p>matrix with number of faces with indices of the three points from which each face is composed</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.fillHoles","title":"<code>fillHoles()</code>  <code>method descriptor</code>","text":"<p>fillHoles(self: shapeworks_py.Mesh, hole_size: typing.SupportsFloat = 1000) -&gt; shapeworks_py.Mesh</p> <p>finds holes in a mesh and closes them</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.fixElement","title":"<code>fixElement()</code>  <code>method descriptor</code>","text":"<p>fixElement(self: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>fix element winding of mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.geodesicDistance","title":"<code>geodesicDistance()</code>  <code>method descriptor</code>","text":"<p>geodesicDistance(args, *kwargs) Overloaded function.</p> <ol> <li>geodesicDistance(self: shapeworks_py.Mesh, source: typing.SupportsInt, target: typing.SupportsInt) -&gt; float</li> </ol> <p>computes geodesic distance between two vertices (specified by their indices) on mesh</p> <ol> <li>geodesicDistance(self: shapeworks_py.Mesh, landmark: collections.abc.Sequence[typing.SupportsFloat]) -&gt; numpy.ndarray</li> </ol> <p>computes geodesic distance between a point (landmark) and each vertex on mesh</p> <ol> <li>geodesicDistance(self: shapeworks_py.Mesh, curve: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]]) -&gt; numpy.ndarray</li> </ol> <p>computes geodesic distance between a set of points (curve) and all vertices on mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getFace","title":"<code>getFace()</code>  <code>method descriptor</code>","text":"<p>getFace(self: shapeworks_py.Mesh, id: typing.SupportsInt) -&gt; numpy.ndarray</p> <p>return indices of the three points with which the face at the given index is composed</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getField","title":"<code>getField()</code>  <code>method descriptor</code>","text":"<p>getField(self: shapeworks_py.Mesh, name: str, type: shapeworks_py.Mesh.FieldType) -&gt; numpy.ndarray</p> <p>gets the field</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getFieldNames","title":"<code>getFieldNames()</code>  <code>method descriptor</code>","text":"<p>getFieldNames(self: shapeworks_py.Mesh) -&gt; list[str]</p> <p>print all field names in mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getFieldValue","title":"<code>getFieldValue()</code>  <code>method descriptor</code>","text":"<p>getFieldValue(self: shapeworks_py.Mesh, idx: str, name: typing.SupportsInt) -&gt; float</p> <p>gets the value at the given index of field</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getMultiFieldValue","title":"<code>getMultiFieldValue()</code>  <code>method descriptor</code>","text":"<p>getMultiFieldValue(self: shapeworks_py.Mesh, idx: str, name: typing.SupportsInt) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>gets the vector value at the given index of field</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.getPoint","title":"<code>getPoint()</code>  <code>method descriptor</code>","text":"<p>getPoint(self: shapeworks_py.Mesh, id: typing.SupportsInt) -&gt; numpy.ndarray</p> <p>(x,y,z) coordinates of vertex at given index</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.interpolateFieldAtPoint","title":"<code>interpolateFieldAtPoint()</code>  <code>method descriptor</code>","text":"<p>interpolateFieldAtPoint(self: shapeworks_py.Mesh, field: str, point: collections.abc.Sequence[typing.SupportsFloat]) -&gt; float</p> <p>Interpolate the feature at the location using barycentric coordinate</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.interpolate_scalars_to_mesh","title":"<code>interpolate_scalars_to_mesh()</code>  <code>method descriptor</code>","text":"<p>interpolate_scalars_to_mesh(self: shapeworks_py.Mesh, name: str, positions: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, 1]\"], scalar_values: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, 1]\"]) -&gt; None</p> <p>Interpolate scalars to mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.invertNormals","title":"<code>invertNormals()</code>  <code>method descriptor</code>","text":"<p>invertNormals(self: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>handle flipping normals</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.numFaces","title":"<code>numFaces()</code>  <code>method descriptor</code>","text":"<p>numFaces(self: shapeworks_py.Mesh) -&gt; int</p> <p>number of faces</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.numPoints","title":"<code>numPoints()</code>  <code>method descriptor</code>","text":"<p>numPoints(self: shapeworks_py.Mesh) -&gt; int</p> <p>number of points</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.points","title":"<code>points()</code>  <code>method descriptor</code>","text":"<p>points(self: shapeworks_py.Mesh) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>matrix with number of points with (x,y,z) coordinates of each point</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.probeVolume","title":"<code>probeVolume()</code>  <code>method descriptor</code>","text":"<p>probeVolume(self: shapeworks_py.Mesh, image: shapeworks_py.Image) -&gt; shapeworks_py.Mesh</p> <p>samples image data values at point locations specified by image</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.reflect","title":"<code>reflect()</code>  <code>method descriptor</code>","text":"<p>reflect(self: shapeworks_py.Mesh, axis: shapeworks_py.Axis, origin: collections.abc.Sequence[typing.SupportsFloat] = [0.0, 0.0, 0.0]) -&gt; shapeworks_py.Mesh</p> <p>reflect meshes with respect to a specified center and specific axis</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.remesh","title":"<code>remesh()</code>  <code>method descriptor</code>","text":"<p>remesh(self: shapeworks_py.Mesh, numVertices: typing.SupportsInt, adaptivity: typing.SupportsFloat) -&gt; shapeworks_py.Mesh</p> <p>applies remeshing using approximated centroidal voronoi diagrams for a given number of vertices and adaptivity</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.remeshPercent","title":"<code>remeshPercent()</code>  <code>method descriptor</code>","text":"<p>remeshPercent(self: shapeworks_py.Mesh, percentage: typing.SupportsFloat, adaptivity: typing.SupportsFloat) -&gt; shapeworks_py.Mesh</p> <p>applies remeshing using approximated centroidal voronoi diagrams for a given percentage of vertices and adaptivity</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.rotate","title":"<code>rotate()</code>  <code>method descriptor</code>","text":"<p>rotate(self: shapeworks_py.Mesh, angle: typing.SupportsFloat, axis: shapeworks_py.Axis) -&gt; shapeworks_py.Mesh</p> <p>rotate using axis by angle (in degrees)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.scale","title":"<code>scale()</code>  <code>method descriptor</code>","text":"<p>scale(self: shapeworks_py.Mesh, v: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Mesh</p> <p>scale mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.setField","title":"<code>setField()</code>  <code>method descriptor</code>","text":"<p>setField(self: shapeworks_py.Mesh, name: str, array: numpy.ndarray, type: shapeworks_py.Mesh.FieldType) -&gt; shapeworks_py.Mesh</p> <p>sets the given field for points with array</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.setFieldValue","title":"<code>setFieldValue()</code>  <code>method descriptor</code>","text":"<p>setFieldValue(self: shapeworks_py.Mesh, idx: str, value: typing.SupportsInt, name: typing.SupportsFloat = '') -&gt; None</p> <p>sets the given index of field to value</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.smooth","title":"<code>smooth()</code>  <code>method descriptor</code>","text":"<p>smooth(self: shapeworks_py.Mesh, iterations: typing.SupportsInt = 0, relaxation: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Mesh</p> <p>applies laplacian smoothing</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.smoothSinc","title":"<code>smoothSinc()</code>  <code>method descriptor</code>","text":"<p>smoothSinc(self: shapeworks_py.Mesh, iterations: typing.SupportsInt = 0, passband: typing.SupportsFloat = 0.0) -&gt; shapeworks_py.Mesh</p> <p>applies windowed sinc smoothing</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.toDistanceTransform","title":"<code>toDistanceTransform()</code>  <code>method descriptor</code>","text":"<p>toDistanceTransform(self: shapeworks_py.Mesh, region: shapeworks_py.PhysicalRegion = { min: [1e+09, 1e+09, 1e+09], max: [-1e+09, -1e+09, -1e+09] }, spacing: collections.abc.Sequence[typing.SupportsFloat] = [1.0, 1.0, 1.0], padding: collections.abc.Sequence[typing.SupportsInt] = [1, 1, 1]) -&gt; shapeworks_py.Image</p> <p>converts specified region to distance transform image with specified spacing and padding (default: unit spacing and 1 pixel of padding)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.toImage","title":"<code>toImage()</code>  <code>method descriptor</code>","text":"<p>toImage(self: shapeworks_py.Mesh, region: shapeworks_py.PhysicalRegion = { min: [1e+09, 1e+09, 1e+09], max: [-1e+09, -1e+09, -1e+09] }, spacing: collections.abc.Sequence[typing.SupportsFloat] = [1.0, 1.0, 1.0]) -&gt; shapeworks_py.Image</p> <p>rasterize specified region to create binary image of desired dims (default: unit spacing)</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.translate","title":"<code>translate()</code>  <code>method descriptor</code>","text":"<p>translate(self: shapeworks_py.Mesh, v: collections.abc.Sequence[typing.SupportsFloat]) -&gt; shapeworks_py.Mesh</p> <p>translates mesh</p>"},{"location":"python/python-api.html#shapeworks_py.Mesh.write","title":"<code>write()</code>  <code>method descriptor</code>","text":"<p>write(self: shapeworks_py.Mesh, pathname: str, binaryFile: bool = False) -&gt; shapeworks_py.Mesh</p> <p>writes mesh, format specified by filename extension</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils","title":"<code>MeshUtils</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.boundaryLoopExtractor","title":"<code>boundaryLoopExtractor()</code>  <code>staticmethod</code>","text":"<p>boundaryLoopExtractor(mesh: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>for a mesh extracts the boundary loop and export the boundary loop as a contour .vtp file</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.boundingBox","title":"<code>boundingBox()</code>  <code>staticmethod</code>","text":"<p>boundingBox(args, *kwargs) Overloaded function.</p> <ol> <li>boundingBox(filenames: collections.abc.Sequence[str], center: bool = False) -&gt; shapeworks_py.PhysicalRegion</li> </ol> <p>calculate bounding box incrementally for meshes</p> <ol> <li>boundingBox(meshes: collections.abc.Sequence[shapeworks_py.Mesh], center: bool = False) -&gt; shapeworks_py.PhysicalRegion</li> </ol> <p>calculate bounding box incrementally for meshes</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.computeMeanNormals","title":"<code>computeMeanNormals()</code>  <code>staticmethod</code>","text":"<p>computeMeanNormals(args, *kwargs) Overloaded function.</p> <ol> <li>computeMeanNormals(filenames: collections.abc.Sequence[str], autoGenerateNormals: bool = True) -&gt; numpy.ndarray</li> </ol> <p>computes average normals for each point in given set of meshes</p> <ol> <li>computeMeanNormals(meshes: collections.abc.Sequence[shapeworks_py.Mesh]) -&gt; numpy.ndarray</li> </ol> <p>computes average normals for each point in given set of meshes</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.findReferenceMesh","title":"<code>findReferenceMesh()</code>  <code>staticmethod</code>","text":"<p>findReferenceMesh(meshes: collections.abc.Sequence[shapeworks_py.Mesh], random_subset: typing.SupportsInt = -1) -&gt; int</p> <p>find reference mesh from a set of meshes</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.generateNormals","title":"<code>generateNormals()</code>  <code>staticmethod</code>","text":"<p>generateNormals(meshes: collections.abc.Sequence[shapeworks_py.Mesh], forceRegen: bool = False) -&gt; None</p> <p>generates and adds normals for points and faces for each mesh in given set of meshes</p>"},{"location":"python/python-api.html#shapeworks_py.MeshUtils.sharedBoundaryExtractor","title":"<code>sharedBoundaryExtractor()</code>  <code>staticmethod</code>","text":"<p>sharedBoundaryExtractor(mesh_l: shapeworks_py.Mesh, mesh_r: shapeworks_py.Mesh, tol: typing.SupportsFloat = 0.001) -&gt; tuple</p> <p>extract the shared boundary for the given left and right meshes and save the individual meshes</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper","title":"<code>MeshWarper</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.buildMesh","title":"<code>buildMesh()</code>  <code>method descriptor</code>","text":"<p>buildMesh(self: shapeworks_py.MeshWarper, particles: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"]) -&gt; shapeworks_py.Mesh</p> <p>Build the mesh from particle positions (matrix [Nx3])</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.extractLandmarks","title":"<code>extractLandmarks()</code>  <code>method descriptor</code>","text":"<p>extractLandmarks(self: shapeworks_py.MeshWarper, warped_mesh: shapeworks_py.Mesh) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>Extract the landmarks from the warped mesh and return the landmarks (matrix [Nx3])</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.generateWarp","title":"<code>generateWarp()</code>  <code>method descriptor</code>","text":"<p>generateWarp(args, *kwargs) Overloaded function.</p> <ol> <li>generateWarp(self: shapeworks_py.MeshWarper, reference_mesh: shapeworks_py.Mesh, reference_particles: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"]) -&gt; bool</li> </ol> <p>Assign the reference mesh/particles (matrix [Nx3]) and pre-compute the warping</p> <ol> <li>generateWarp(self: shapeworks_py.MeshWarper, reference_mesh: shapeworks_py.Mesh, reference_particles: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"], landmarks: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"]) -&gt; bool</li> </ol> <p>Assign the reference mesh/particles (matrix [Nx3]) and landmarks (matrix [Nx3]) and pre-compute the warping</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.getGoodParticlesIndices","title":"<code>getGoodParticlesIndices()</code>  <code>method descriptor</code>","text":"<p>getGoodParticlesIndices(self: shapeworks_py.MeshWarper) -&gt; list[int]</p> <p>Return the indexes of good particles.</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.getLandmarksMap","title":"<code>getLandmarksMap()</code>  <code>method descriptor</code>","text":"<p>getLandmarksMap(self: shapeworks_py.MeshWarper) -&gt; dict[int, int]</p> <p>Return the map of landmarks to vertices.</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.getReferenceMesh","title":"<code>getReferenceMesh()</code>  <code>method descriptor</code>","text":"<p>getReferenceMesh(self: shapeworks_py.MeshWarper) -&gt; shapeworks_py.Mesh</p> <p>Return the mesh used for warping.</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.getReferenceParticles","title":"<code>getReferenceParticles()</code>  <code>method descriptor</code>","text":"<p>getReferenceParticles(self: shapeworks_py.MeshWarper) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>Return the particles used for warping.</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.getWarpMatrix","title":"<code>getWarpMatrix()</code>  <code>method descriptor</code>","text":"<p>getWarpMatrix(self: shapeworks_py.MeshWarper) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>Return the warping matrix (Vertices = Warp * Control).</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.hasBadParticles","title":"<code>hasBadParticles()</code>  <code>method descriptor</code>","text":"<p>hasBadParticles(self: shapeworks_py.MeshWarper) -&gt; bool</p> <p>Return true if warping has removed any bad particle(s).</p>"},{"location":"python/python-api.html#shapeworks_py.MeshWarper.prepareMesh","title":"<code>prepareMesh()</code>  <code>staticmethod</code>","text":"<p>prepareMesh(mesh: shapeworks_py.Mesh) -&gt; shapeworks_py.Mesh</p> <p>Return the prepared mesh used for warping (before vertices were inserted).</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore","title":"<code>MorphologicalDeviationScore</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.GetMorphoDevScore","title":"<code>GetMorphoDevScore()</code>  <code>method descriptor</code>","text":"<p>GetMorphoDevScore(self: shapeworks_py.MorphologicalDeviationScore, X: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"]) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>Compute Mahalanobis-based deviation score for test samples.</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.GetMorphoDevScore--parameters","title":"Parameters","text":"<p>X : numpy.ndarray     Matrix of test samples (n_samples x n_features)</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.GetMorphoDevScore--returns","title":"Returns","text":"<p>numpy.ndarray     Vector of Mahalanobis distances for each sample.</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.SetControlShapes","title":"<code>SetControlShapes()</code>  <code>method descriptor</code>","text":"<p>SetControlShapes(self: shapeworks_py.MorphologicalDeviationScore, X: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, n]\"]) -&gt; bool</p> <p>Fit PPCA model on control shapes.</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.SetControlShapes--parameters","title":"Parameters","text":"<p>X : numpy.ndarray     Matrix of control shapes (n_samples x n_features)</p>"},{"location":"python/python-api.html#shapeworks_py.MorphologicalDeviationScore.SetControlShapes--returns","title":"Returns","text":"<p>bool     True if fitting was successful, False otherwise.</p>"},{"location":"python/python-api.html#shapeworks_py.Optimize","title":"<code>Optimize</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Optimize.GetParticleSystem","title":"<code>GetParticleSystem()</code>  <code>method descriptor</code>","text":"<p>GetParticleSystem(self: shapeworks_py.Optimize) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p>"},{"location":"python/python-api.html#shapeworks_py.Optimize.LoadParameterFile","title":"<code>LoadParameterFile()</code>  <code>method descriptor</code>","text":"<p>LoadParameterFile(self: shapeworks_py.Optimize, arg0: str) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Optimize.Run","title":"<code>Run()</code>  <code>method descriptor</code>","text":"<p>Run(self: shapeworks_py.Optimize) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Optimize.SetIterationCallbackFunction","title":"<code>SetIterationCallbackFunction()</code>  <code>method descriptor</code>","text":"<p>SetIterationCallbackFunction(self: shapeworks_py.Optimize, arg0: collections.abc.Callable[[], None]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Optimize.SetUpOptimize","title":"<code>SetUpOptimize()</code>  <code>method descriptor</code>","text":"<p>SetUpOptimize(self: shapeworks_py.Optimize, projectFile: shapeworks::Project) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters","title":"<code>Parameters</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.as_map","title":"<code>as_map()</code>  <code>method descriptor</code>","text":"<p>as_map(self: shapeworks_py.Parameters) -&gt; dict[str, str]</p> <p>get underlying map</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.get","title":"<code>get()</code>  <code>method descriptor</code>","text":"<p>get(self: shapeworks_py.Parameters, key: str, default: str = '') -&gt; str</p> <p>get a parameter based on a key, return default if it doesn't exist</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.key_exists","title":"<code>key_exists()</code>  <code>method descriptor</code>","text":"<p>key_exists(self: shapeworks_py.Parameters, key: str) -&gt; bool</p> <p>return if a key exists or not</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.remove_entry","title":"<code>remove_entry()</code>  <code>method descriptor</code>","text":"<p>remove_entry(self: shapeworks_py.Parameters, key: str) -&gt; None</p> <p>remove an entry</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.reset_parameters","title":"<code>reset_parameters()</code>  <code>method descriptor</code>","text":"<p>reset_parameters(self: shapeworks_py.Parameters) -&gt; None</p> <p>reset parameters to blank</p>"},{"location":"python/python-api.html#shapeworks_py.Parameters.set","title":"<code>set()</code>  <code>method descriptor</code>","text":"<p>set(args, *kwargs) Overloaded function.</p> <ol> <li>set(self: shapeworks_py.Parameters, key: str, Variant: shapeworks::Variant) -&gt; None</li> </ol> <p>set a parameter based on a key</p> <ol> <li>set(self: shapeworks_py.Parameters, key: str, value: str) -&gt; None</li> </ol> <p>set a parameter based on a key</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics","title":"<code>ParticleShapeStatistics</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.PCA","title":"<code>PCA()</code>  <code>method descriptor</code>","text":"<p>PCA(args, *kwargs) Overloaded function.</p> <ol> <li>PCA(self: shapeworks_py.ParticleShapeStatistics, particleSystem: shapeworks_py.ParticleSystem, domainsPerShape: typing.SupportsInt = 1) -&gt; int</li> </ol> <p>calculates the eigen values and eigen vectors of the data</p> <ol> <li>PCA(self: shapeworks_py.ParticleShapeStatistics, project: shapeworks::Project) -&gt; int</li> </ol> <p>calculates the eigen values and eigen vectors of the data from a project</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.eigenValues","title":"<code>eigenValues()</code>  <code>method descriptor</code>","text":"<p>eigenValues(self: shapeworks_py.ParticleShapeStatistics) -&gt; list[float]</p> <p>return the eigen values</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.eigenVectors","title":"<code>eigenVectors()</code>  <code>method descriptor</code>","text":"<p>eigenVectors(self: shapeworks_py.ParticleShapeStatistics) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>returns the eigenvectors</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.getMean","title":"<code>getMean()</code>  <code>method descriptor</code>","text":"<p>getMean(self: shapeworks_py.ParticleShapeStatistics) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>returns the mean shape particles</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.numDims","title":"<code>numDims()</code>  <code>method descriptor</code>","text":"<p>numDims(self: shapeworks_py.ParticleShapeStatistics) -&gt; int</p> <p>returns the number of features of the particle system</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.pcaLoadings","title":"<code>pcaLoadings()</code>  <code>method descriptor</code>","text":"<p>pcaLoadings(self: shapeworks_py.ParticleShapeStatistics) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>returns the  coefficients of the linear combination of        the original variables from which the principal        components are constructed</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.percentVarByMode","title":"<code>percentVarByMode()</code>  <code>method descriptor</code>","text":"<p>percentVarByMode(self: shapeworks_py.ParticleShapeStatistics) -&gt; list[float]</p> <p>return the variance accounted for by the principal components</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.principalComponentProjections","title":"<code>principalComponentProjections()</code>  <code>method descriptor</code>","text":"<p>principalComponentProjections(self: shapeworks_py.ParticleShapeStatistics) -&gt; int</p> <p>projects the original data on the calculated principal components</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.projectNewSample","title":"<code>projectNewSample()</code>  <code>method descriptor</code>","text":"<p>projectNewSample(self: shapeworks_py.ParticleShapeStatistics, newSample: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, \"[m, 1]\"]) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>project a new sample into the PCA space</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleShapeStatistics.sampleSize","title":"<code>sampleSize()</code>  <code>method descriptor</code>","text":"<p>sampleSize(self: shapeworks_py.ParticleShapeStatistics) -&gt; int</p> <p>returns the sample size of the particle system</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem","title":"<code>ParticleSystem</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.D","title":"<code>D()</code>  <code>method descriptor</code>","text":"<p>D(self: shapeworks_py.ParticleSystem) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.EvaluationCompare","title":"<code>EvaluationCompare()</code>  <code>method descriptor</code>","text":"<p>EvaluationCompare(self: shapeworks_py.ParticleSystem, arg0: shapeworks_py.ParticleSystem) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.ExactCompare","title":"<code>ExactCompare()</code>  <code>method descriptor</code>","text":"<p>ExactCompare(self: shapeworks_py.ParticleSystem, arg0: shapeworks_py.ParticleSystem) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.N","title":"<code>N()</code>  <code>method descriptor</code>","text":"<p>N(self: shapeworks_py.ParticleSystem) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.Particles","title":"<code>Particles()</code>  <code>method descriptor</code>","text":"<p>Particles(self: shapeworks_py.ParticleSystem) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.Paths","title":"<code>Paths()</code>  <code>method descriptor</code>","text":"<p>Paths(self: shapeworks_py.ParticleSystem) -&gt; list[str]</p>"},{"location":"python/python-api.html#shapeworks_py.ParticleSystem.ShapeAsPointSet","title":"<code>ShapeAsPointSet()</code>  <code>method descriptor</code>","text":"<p>ShapeAsPointSet(self: shapeworks_py.ParticleSystem, id_shape: typing.SupportsInt) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, n]\"]</p> <p>Return the particle pointset [Nx3] of the specified shape</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion","title":"<code>PhysicalRegion</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.max","title":"<code>max</code>  <code>property</code>","text":"<p>max point of region</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.min","title":"<code>min</code>  <code>property</code>","text":"<p>min point of region</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.expand","title":"<code>expand()</code>  <code>method descriptor</code>","text":"<p>expand(args, *kwargs) Overloaded function.</p> <ol> <li>expand(self: shapeworks_py.PhysicalRegion, other: shapeworks_py.PhysicalRegion) -&gt; shapeworks_py.PhysicalRegion</li> </ol> <p>expand this region up to the largest portions of both</p> <ol> <li>expand(self: shapeworks_py.PhysicalRegion, point: itk::Point) -&gt; shapeworks_py.PhysicalRegion <p>expand this region to include this point</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.origin","title":"<code>origin()</code>  <code>method descriptor</code>","text":"<p>origin(self: shapeworks_py.PhysicalRegion) -&gt; numpy.ndarray</p> <p>return origin of region</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.pad","title":"<code>pad()</code>  <code>method descriptor</code>","text":"<p>pad(self: shapeworks_py.PhysicalRegion, padding: typing.SupportsFloat) -&gt; shapeworks_py.PhysicalRegion</p> <p>grows or shrinks the region by the specified amount</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.shrink","title":"<code>shrink()</code>  <code>method descriptor</code>","text":"<p>shrink(self: shapeworks_py.PhysicalRegion, other: shapeworks_py.PhysicalRegion) -&gt; shapeworks_py.PhysicalRegion</p> <p>shrink this region down to the smallest portions of both</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.size","title":"<code>size()</code>  <code>method descriptor</code>","text":"<p>size(self: shapeworks_py.PhysicalRegion) -&gt; numpy.ndarray</p> <p>return size of region</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.to_string","title":"<code>to_string()</code>  <code>method descriptor</code>","text":"<p>to_string(self: shapeworks_py.PhysicalRegion) -&gt; str</p> <p>returns a string representation of this region</p>"},{"location":"python/python-api.html#shapeworks_py.PhysicalRegion.valid","title":"<code>valid()</code>  <code>method descriptor</code>","text":"<p>valid(self: shapeworks_py.PhysicalRegion) -&gt; bool</p> <p>ensure if region is valid</p>"},{"location":"python/python-api.html#shapeworks_py.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Project.clear_parameters","title":"<code>clear_parameters()</code>  <code>method descriptor</code>","text":"<p>clear_parameters(self: shapeworks_py.Project, name: str) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_domain_names","title":"<code>get_domain_names()</code>  <code>method descriptor</code>","text":"<p>get_domain_names(self: shapeworks_py.Project) -&gt; list[str]</p> <p>Return the domain names (e.g. femur, pelvis, etc)</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_feature_names","title":"<code>get_feature_names()</code>  <code>method descriptor</code>","text":"<p>get_feature_names(self: shapeworks_py.Project) -&gt; list[str]</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_filename","title":"<code>get_filename()</code>  <code>method descriptor</code>","text":"<p>get_filename(self: shapeworks_py.Project) -&gt; str</p> <p>Return the filename</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_groomed_domain_types","title":"<code>get_groomed_domain_types()</code>  <code>method descriptor</code>","text":"<p>get_groomed_domain_types(self: shapeworks_py.Project) -&gt; list[shapeworks_py.DomainType]</p> <p>Return the groomed domain types</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_groomed_present","title":"<code>get_groomed_present()</code>  <code>method descriptor</code>","text":"<p>get_groomed_present(self: shapeworks_py.Project) -&gt; bool</p> <p>Return if groomed files are present</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_group_names","title":"<code>get_group_names()</code>  <code>method descriptor</code>","text":"<p>get_group_names(self: shapeworks_py.Project) -&gt; list[str]</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_group_values","title":"<code>get_group_values()</code>  <code>method descriptor</code>","text":"<p>get_group_values(self: shapeworks_py.Project, group_names: str) -&gt; list[str]</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_headers","title":"<code>get_headers()</code>  <code>method descriptor</code>","text":"<p>get_headers(self: shapeworks_py.Project) -&gt; list[str]</p> <p>Return the headers of the subject sheet</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_images_present","title":"<code>get_images_present()</code>  <code>method descriptor</code>","text":"<p>get_images_present(self: shapeworks_py.Project) -&gt; bool</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_number_of_domains_per_subject","title":"<code>get_number_of_domains_per_subject()</code>  <code>method descriptor</code>","text":"<p>get_number_of_domains_per_subject(self: shapeworks_py.Project) -&gt; int</p> <p>Return the number of domains</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_number_of_subjects","title":"<code>get_number_of_subjects()</code>  <code>method descriptor</code>","text":"<p>get_number_of_subjects(self: shapeworks_py.Project) -&gt; int</p> <p>Return the number of subjects in the project</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_original_domain_types","title":"<code>get_original_domain_types()</code>  <code>method descriptor</code>","text":"<p>get_original_domain_types(self: shapeworks_py.Project) -&gt; list[shapeworks_py.DomainType]</p> <p>Return the original domain types</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_originals_present","title":"<code>get_originals_present()</code>  <code>method descriptor</code>","text":"<p>get_originals_present(self: shapeworks_py.Project) -&gt; bool</p> <p>Return if original files are present</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_parameters","title":"<code>get_parameters()</code>  <code>method descriptor</code>","text":"<p>get_parameters(self: shapeworks_py.Project, name: str, domain_name: str = '') -&gt; shapeworks::Parameters</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_particles_present","title":"<code>get_particles_present()</code>  <code>method descriptor</code>","text":"<p>get_particles_present(self: shapeworks_py.Project) -&gt; bool</p> <p>Return if particle files are present</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_project_path","title":"<code>get_project_path()</code>  <code>method descriptor</code>","text":"<p>get_project_path(self: shapeworks_py.Project) -&gt; str</p> <p>Return the project path</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_string_column","title":"<code>get_string_column()</code>  <code>method descriptor</code>","text":"<p>get_string_column(self: shapeworks_py.Project, name: str) -&gt; list[str]</p> <p>Return a column by name</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_subjects","title":"<code>get_subjects()</code>  <code>method descriptor</code>","text":"<p>get_subjects(self: shapeworks_py.Project) -&gt; list[shapeworks::Subject]</p> <p>Return the list of Subjects</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_supported_version","title":"<code>get_supported_version()</code>  <code>method descriptor</code>","text":"<p>get_supported_version(self: shapeworks_py.Project) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.Project.get_version","title":"<code>get_version()</code>  <code>method descriptor</code>","text":"<p>get_version(self: shapeworks_py.Project) -&gt; int</p>"},{"location":"python/python-api.html#shapeworks_py.Project.load","title":"<code>load()</code>  <code>method descriptor</code>","text":"<p>load(self: shapeworks_py.Project, filename: str) -&gt; bool</p> <p>Load from XLSX file</p>"},{"location":"python/python-api.html#shapeworks_py.Project.save","title":"<code>save()</code>  <code>method descriptor</code>","text":"<p>save(self: shapeworks_py.Project, filename: str = '') -&gt; None</p> <p>Save to XLSX file</p>"},{"location":"python/python-api.html#shapeworks_py.Project.set_filename","title":"<code>set_filename()</code>  <code>method descriptor</code>","text":"<p>set_filename(self: shapeworks_py.Project, filename: str) -&gt; None</p> <p>Set project filename</p>"},{"location":"python/python-api.html#shapeworks_py.Project.set_groomed_domain_types","title":"<code>set_groomed_domain_types()</code>  <code>method descriptor</code>","text":"<p>set_groomed_domain_types(self: shapeworks_py.Project, types: collections.abc.Sequence[shapeworks_py.DomainType]) -&gt; None</p> <p>Set the groomed domain types</p>"},{"location":"python/python-api.html#shapeworks_py.Project.set_original_domain_types","title":"<code>set_original_domain_types()</code>  <code>method descriptor</code>","text":"<p>set_original_domain_types(self: shapeworks_py.Project, types: collections.abc.Sequence[shapeworks_py.DomainType]) -&gt; None</p> <p>Set the original domain types</p>"},{"location":"python/python-api.html#shapeworks_py.Project.set_parameters","title":"<code>set_parameters()</code>  <code>method descriptor</code>","text":"<p>set_parameters(self: shapeworks_py.Project, name: str, params: shapeworks::Parameters, domain_name: str = '') -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Project.set_subjects","title":"<code>set_subjects()</code>  <code>method descriptor</code>","text":"<p>set_subjects(self: shapeworks_py.Project, subjects: collections.abc.Sequence[shapeworks::Subject]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Project.store_subjects","title":"<code>store_subjects()</code>  <code>method descriptor</code>","text":"<p>store_subjects(self: shapeworks_py.Project) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform","title":"<code>ReconstructSurface_RBFSSparseTransform</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.meanSurface","title":"<code>meanSurface()</code>  <code>method descriptor</code>","text":"<p>meanSurface(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, distanceTransformFiles: collections.abc.Sequence[str], localPointsFiles: collections.abc.Sequence[str], worldPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.samplesAlongPCAModes","title":"<code>samplesAlongPCAModes()</code>  <code>method descriptor</code>","text":"<p>samplesAlongPCAModes(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, worldPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setDoProcrustes","title":"<code>setDoProcrustes()</code>  <code>method descriptor</code>","text":"<p>setDoProcrustes(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, doProcrustes: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setDoProcrustesScaling","title":"<code>setDoProcrustesScaling()</code>  <code>method descriptor</code>","text":"<p>setDoProcrustesScaling(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, doProcrustesScaling: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setEnableOutput","title":"<code>setEnableOutput()</code>  <code>method descriptor</code>","text":"<p>setEnableOutput(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, enableOutput: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setMaxAngleDegrees","title":"<code>setMaxAngleDegrees()</code>  <code>method descriptor</code>","text":"<p>setMaxAngleDegrees(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, maxAngleDegrees: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setMaxStdDev","title":"<code>setMaxStdDev()</code>  <code>method descriptor</code>","text":"<p>setMaxStdDev(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, maxStdDev: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setMaxVarianceCaptured","title":"<code>setMaxVarianceCaptured()</code>  <code>method descriptor</code>","text":"<p>setMaxVarianceCaptured(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, maxVarianceCaptured: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setMeanBeforeWarp","title":"<code>setMeanBeforeWarp()</code>  <code>method descriptor</code>","text":"<p>setMeanBeforeWarp(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, meanBeforeWarp: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setModeIndex","title":"<code>setModeIndex()</code>  <code>method descriptor</code>","text":"<p>setModeIndex(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, modeIndex: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setNumOfClusters","title":"<code>setNumOfClusters()</code>  <code>method descriptor</code>","text":"<p>setNumOfClusters(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, numOfClusters: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setNumOfModes","title":"<code>setNumOfModes()</code>  <code>method descriptor</code>","text":"<p>setNumOfModes(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, numOfModes: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setNumOfParticles","title":"<code>setNumOfParticles()</code>  <code>method descriptor</code>","text":"<p>setNumOfParticles(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, numOfParticles: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setNumOfSamplesPerMode","title":"<code>setNumOfSamplesPerMode()</code>  <code>method descriptor</code>","text":"<p>setNumOfSamplesPerMode(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, numOfSamplesPerMode: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setOutPath","title":"<code>setOutPath()</code>  <code>method descriptor</code>","text":"<p>setOutPath(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, path: str) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.setOutPrefix","title":"<code>setOutPrefix()</code>  <code>method descriptor</code>","text":"<p>setOutPrefix(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, prefix: str) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_RBFSSparseTransform.surface","title":"<code>surface()</code>  <code>method descriptor</code>","text":"<p>surface(self: shapeworks_py.ReconstructSurface_RBFSSparseTransform, localPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform","title":"<code>ReconstructSurface_ThinPlateSplineTransform</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.meanSurface","title":"<code>meanSurface()</code>  <code>method descriptor</code>","text":"<p>meanSurface(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, distanceTransformFiles: collections.abc.Sequence[str], localPointsFiles: collections.abc.Sequence[str], worldPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.samplesAlongPCAModes","title":"<code>samplesAlongPCAModes()</code>  <code>method descriptor</code>","text":"<p>samplesAlongPCAModes(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, worldPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setDoProcrustes","title":"<code>setDoProcrustes()</code>  <code>method descriptor</code>","text":"<p>setDoProcrustes(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, doProcrustes: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setDoProcrustesScaling","title":"<code>setDoProcrustesScaling()</code>  <code>method descriptor</code>","text":"<p>setDoProcrustesScaling(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, doProcrustesScaling: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setEnableOutput","title":"<code>setEnableOutput()</code>  <code>method descriptor</code>","text":"<p>setEnableOutput(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, enableOutput: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setMaxAngleDegrees","title":"<code>setMaxAngleDegrees()</code>  <code>method descriptor</code>","text":"<p>setMaxAngleDegrees(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, maxAngleDegrees: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setMaxStdDev","title":"<code>setMaxStdDev()</code>  <code>method descriptor</code>","text":"<p>setMaxStdDev(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, maxStdDev: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setMaxVarianceCaptured","title":"<code>setMaxVarianceCaptured()</code>  <code>method descriptor</code>","text":"<p>setMaxVarianceCaptured(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, maxVarianceCaptured: typing.SupportsFloat) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setMeanBeforeWarp","title":"<code>setMeanBeforeWarp()</code>  <code>method descriptor</code>","text":"<p>setMeanBeforeWarp(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, meanBeforeWarp: bool) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setModeIndex","title":"<code>setModeIndex()</code>  <code>method descriptor</code>","text":"<p>setModeIndex(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, modeIndex: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setNumOfClusters","title":"<code>setNumOfClusters()</code>  <code>method descriptor</code>","text":"<p>setNumOfClusters(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, numOfClusters: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setNumOfModes","title":"<code>setNumOfModes()</code>  <code>method descriptor</code>","text":"<p>setNumOfModes(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, numOfModes: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setNumOfParticles","title":"<code>setNumOfParticles()</code>  <code>method descriptor</code>","text":"<p>setNumOfParticles(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, numOfParticles: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setNumOfSamplesPerMode","title":"<code>setNumOfSamplesPerMode()</code>  <code>method descriptor</code>","text":"<p>setNumOfSamplesPerMode(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, numOfSamplesPerMode: typing.SupportsInt) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setOutPath","title":"<code>setOutPath()</code>  <code>method descriptor</code>","text":"<p>setOutPath(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, path: str) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.setOutPrefix","title":"<code>setOutPrefix()</code>  <code>method descriptor</code>","text":"<p>setOutPrefix(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, prefix: str) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ReconstructSurface_ThinPlateSplineTransform.surface","title":"<code>surface()</code>  <code>method descriptor</code>","text":"<p>surface(self: shapeworks_py.ReconstructSurface_ThinPlateSplineTransform, localPointsFiles: collections.abc.Sequence[str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation","title":"<code>ShapeEvaluation</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeCompactness","title":"<code>ComputeCompactness()</code>  <code>staticmethod</code>","text":"<p>ComputeCompactness(particleSystem: shapeworks_py.ParticleSystem, nModes: typing.SupportsInt, saveTo: str = '') -&gt; float</p> <p>Computes the compactness measure for a particle system</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeFullCompactness","title":"<code>ComputeFullCompactness()</code>  <code>staticmethod</code>","text":"<p>ComputeFullCompactness(particleSystem: shapeworks_py.ParticleSystem, progress_callback: collections.abc.Callable[[typing.SupportsFloat], None] = None) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>Computes the compactness measure for a particle system, all modes</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeFullGeneralization","title":"<code>ComputeFullGeneralization()</code>  <code>staticmethod</code>","text":"<p>ComputeFullGeneralization(particleSystem: shapeworks_py.ParticleSystem, progress_callback: collections.abc.Callable[[typing.SupportsFloat], None] = None, check_abort: collections.abc.Callable[[], bool] = None, surface_distance_mode: bool = False) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>Computes the generalization measure for a particle system, all modes</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeFullSpecificity","title":"<code>ComputeFullSpecificity()</code>  <code>staticmethod</code>","text":"<p>ComputeFullSpecificity(particleSystem: shapeworks_py.ParticleSystem, progress_callback: collections.abc.Callable[[typing.SupportsFloat], None] = None, check_abort: collections.abc.Callable[[], bool] = None, surface_distance_mode: bool = False) -&gt; typing.Annotated[numpy.typing.NDArray[numpy.float64], \"[m, 1]\"]</p> <p>Computes the specificity measure for a particle system, all modes</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeGeneralization","title":"<code>ComputeGeneralization()</code>  <code>staticmethod</code>","text":"<p>ComputeGeneralization(particleSystem: shapeworks_py.ParticleSystem, nModes: typing.SupportsInt, saveTo: str = '', surface_distance_mode: bool = False) -&gt; float</p> <p>Computes the generalization measure for a particle system</p>"},{"location":"python/python-api.html#shapeworks_py.ShapeEvaluation.ComputeSpecificity","title":"<code>ComputeSpecificity()</code>  <code>staticmethod</code>","text":"<p>ComputeSpecificity(particleSystem: shapeworks_py.ParticleSystem, nModes: typing.SupportsInt, saveTo: str = '', surface_distance_mode: bool = False) -&gt; float</p> <p>Computes the specificity measure for a particle system</p>"},{"location":"python/python-api.html#shapeworks_py.Subject","title":"<code>Subject</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_constraints_filenames","title":"<code>get_constraints_filenames()</code>  <code>method descriptor</code>","text":"<p>get_constraints_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get the constraints filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_display_name","title":"<code>get_display_name()</code>  <code>method descriptor</code>","text":"<p>get_display_name(self: shapeworks_py.Subject) -&gt; str</p> <p>Get the display name</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_extra_values","title":"<code>get_extra_values()</code>  <code>method descriptor</code>","text":"<p>get_extra_values(self: shapeworks_py.Subject) -&gt; dict[str, str]</p> <p>Get extra values (extra columns we don't interpret)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_feature_filenames","title":"<code>get_feature_filenames()</code>  <code>method descriptor</code>","text":"<p>get_feature_filenames(self: shapeworks_py.Subject) -&gt; dict[str, str]</p> <p>Get the feature map filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_groomed_clipped_mesh","title":"<code>get_groomed_clipped_mesh()</code>  <code>method descriptor</code>","text":"<p>get_groomed_clipped_mesh(self: shapeworks_py.Subject, domain_id: typing.SupportsInt = 0) -&gt; shapeworks_py.Mesh</p> <p>Get the mesh clipped by constraints</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_groomed_filenames","title":"<code>get_groomed_filenames()</code>  <code>method descriptor</code>","text":"<p>get_groomed_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get groomed filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_groomed_transforms","title":"<code>get_groomed_transforms()</code>  <code>method descriptor</code>","text":"<p>get_groomed_transforms(self: shapeworks_py.Subject) -&gt; list[list[float]]</p> <p>Get the groomed transforms (one vector per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_group_value","title":"<code>get_group_value()</code>  <code>method descriptor</code>","text":"<p>get_group_value(self: shapeworks_py.Subject, group_name: str) -&gt; str</p> <p>Get a specific group value</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_group_values","title":"<code>get_group_values()</code>  <code>method descriptor</code>","text":"<p>get_group_values(self: shapeworks_py.Subject) -&gt; tsl::ordered_map, std::__1::allocator\\&gt;, std::__1::basic_string\\, std::__1::allocator\\&gt;, std::__1::hash\\, std::__1::allocator\\&gt;&gt;, std::__1::equal_to\\, std::__1::allocator\\&gt;&gt;, std::__1::allocator\\, std::__1::allocator\\&gt;, std::__1::basic_string\\, std::__1::allocator\\&gt;&gt;&gt;, std::__1::deque\\, std::__1::allocator\\&gt;, std::__1::basic_string\\, std::__1::allocator\\&gt;&gt;, std::__1::allocator\\, std::__1::allocator\\&gt;, std::__1::basic_string\\, std::__1::allocator\\&gt;&gt;&gt;&gt;, unsigned int&gt; <p>Get the group values map</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_landmarks_filenames","title":"<code>get_landmarks_filenames()</code>  <code>method descriptor</code>","text":"<p>get_landmarks_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get the landmarks filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_local_particle_filenames","title":"<code>get_local_particle_filenames()</code>  <code>method descriptor</code>","text":"<p>get_local_particle_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get local particle filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_number_of_domains","title":"<code>get_number_of_domains()</code>  <code>method descriptor</code>","text":"<p>get_number_of_domains(self: shapeworks_py.Subject) -&gt; int</p> <p>Get the number of domains</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_original_filenames","title":"<code>get_original_filenames()</code>  <code>method descriptor</code>","text":"<p>get_original_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get original filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_procrustes_transforms","title":"<code>get_procrustes_transforms()</code>  <code>method descriptor</code>","text":"<p>get_procrustes_transforms(self: shapeworks_py.Subject) -&gt; list[list[float]]</p> <p>Get the procrustes transforms (one vector per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.get_world_particle_filenames","title":"<code>get_world_particle_filenames()</code>  <code>method descriptor</code>","text":"<p>get_world_particle_filenames(self: shapeworks_py.Subject) -&gt; list[str]</p> <p>Get the world particle filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_constraints_filenames","title":"<code>set_constraints_filenames()</code>  <code>method descriptor</code>","text":"<p>set_constraints_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set the constraint filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_display_name","title":"<code>set_display_name()</code>  <code>method descriptor</code>","text":"<p>set_display_name(self: shapeworks_py.Subject, display_name: str) -&gt; None</p> <p>Set the display name</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_excluded","title":"<code>set_excluded()</code>  <code>method descriptor</code>","text":"<p>set_excluded(self: shapeworks_py.Subject, excluded: bool) -&gt; None</p> <p>Set excluded</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_extra_values","title":"<code>set_extra_values()</code>  <code>method descriptor</code>","text":"<p>set_extra_values(self: shapeworks_py.Subject, extra_values: collections.abc.Mapping[str, str]) -&gt; None</p> <p>Set extra values</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_feature_filenames","title":"<code>set_feature_filenames()</code>  <code>method descriptor</code>","text":"<p>set_feature_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Mapping[str, str]) -&gt; None</p> <p>Set the feature map filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_fixed","title":"<code>set_fixed()</code>  <code>method descriptor</code>","text":"<p>set_fixed(self: shapeworks_py.Subject, fixed: bool) -&gt; None</p> <p>Set fixed</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_groomed_filenames","title":"<code>set_groomed_filenames()</code>  <code>method descriptor</code>","text":"<p>set_groomed_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set groomed filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_groomed_transforms","title":"<code>set_groomed_transforms()</code>  <code>method descriptor</code>","text":"<p>set_groomed_transforms(self: shapeworks_py.Subject, transforms: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]]) -&gt; None</p> <p>Set the groomed transforms (one vector per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_group_values","title":"<code>set_group_values()</code>  <code>method descriptor</code>","text":"<p>set_group_values(self: shapeworks_py.Subject, Set group values mapgroup_values: collections.abc.Mapping[str, str]) -&gt; None</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_landmarks_filenames","title":"<code>set_landmarks_filenames()</code>  <code>method descriptor</code>","text":"<p>set_landmarks_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set the landmarks filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_local_particle_filenames","title":"<code>set_local_particle_filenames()</code>  <code>method descriptor</code>","text":"<p>set_local_particle_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set local particle filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_number_of_domains","title":"<code>set_number_of_domains()</code>  <code>method descriptor</code>","text":"<p>set_number_of_domains(self: shapeworks_py.Subject, number_of_domains: typing.SupportsInt) -&gt; None</p> <p>Set the number of domains</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_original_filenames","title":"<code>set_original_filenames()</code>  <code>method descriptor</code>","text":"<p>set_original_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set original filenames (one per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_procrustes_transforms","title":"<code>set_procrustes_transforms()</code>  <code>method descriptor</code>","text":"<p>set_procrustes_transforms(self: shapeworks_py.Subject, transforms: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]]) -&gt; None</p> <p>Set the procrustes transforms (one vector per domain)</p>"},{"location":"python/python-api.html#shapeworks_py.Subject.set_world_particle_filenames","title":"<code>set_world_particle_filenames()</code>  <code>method descriptor</code>","text":"<p>set_world_particle_filenames(self: shapeworks_py.Subject, filenames: collections.abc.Sequence[str]) -&gt; None</p> <p>Set the world particle filenames</p>"},{"location":"python/python-api.html#shapeworks_py.Variant","title":"<code>Variant</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.Variant.as_str","title":"<code>as_str()</code>  <code>method descriptor</code>","text":"<p>as_str(self: shapeworks_py.Variant) -&gt; str</p> <p>Return the variant string content</p>"},{"location":"python/python-api.html#shapeworks_py.VectorImage","title":"<code>VectorImage</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.VectorImage.evaluate","title":"<code>evaluate()</code>  <code>method descriptor</code>","text":"<p>evaluate(self: shapeworks_py.VectorImage, pt: collections.abc.Sequence[typing.SupportsFloat]) -&gt; list[float]</p> <p>evaluate the vector image at any given point in space</p>"},{"location":"python/python-api.html#shapeworks_py.WarpTransform","title":"<code>WarpTransform</code>","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p>"},{"location":"python/python-api.html#shapeworks_py.axis_is_valid","title":"<code>axis_is_valid()</code>  <code>builtin</code>","text":"<p>axis_is_valid(axis: collections.abc.Sequence[typing.SupportsFloat]) -&gt; bool</p> <p>ensure an axis is valid</p>"},{"location":"python/python-api.html#shapeworks_py.degToRad","title":"<code>degToRad()</code>  <code>builtin</code>","text":"<p>degToRad(deg: typing.SupportsFloat) -&gt; float</p> <p>convert degrees to radians</p>"},{"location":"python/python-api.html#shapeworks_py.mean","title":"<code>mean()</code>  <code>builtin</code>","text":"<p>mean(arg0: numpy.ndarray) -&gt; float</p> <p>incrementally compute (single-component) mean of field</p>"},{"location":"python/python-api.html#shapeworks_py.range","title":"<code>range()</code>  <code>builtin</code>","text":"<p>range(arg0: numpy.ndarray) -&gt; list[float]</p> <p>compute (single-component) range of field</p>"},{"location":"python/python-api.html#shapeworks_py.seed","title":"<code>seed()</code>  <code>builtin</code>","text":"<p>seed(seed: typing.SupportsInt = 1768427101228075) -&gt; None</p> <p>sets the seed for random number generation (internal use)</p>"},{"location":"python/python-api.html#shapeworks_py.set_progress_callback","title":"<code>set_progress_callback()</code>  <code>builtin</code>","text":"<p>set_progress_callback(callback: typing_extensions.CapsuleType) -&gt; None</p> <p>sets up a progress callback</p>"},{"location":"python/python-api.html#shapeworks_py.setup_console_logging","title":"<code>setup_console_logging()</code>  <code>builtin</code>","text":"<p>setup_console_logging(show_progress: bool = True, xml_status: bool = False) -&gt; None</p> <p>sets up console logging options</p>"},{"location":"python/python-api.html#shapeworks_py.stddev","title":"<code>stddev()</code>  <code>builtin</code>","text":"<p>stddev(arg0: numpy.ndarray) -&gt; float</p> <p>compute (single-component) standard deviation of field</p>"},{"location":"python/python-api.html#shapeworks_py.toAxis","title":"<code>toAxis()</code>  <code>builtin</code>","text":"<p>toAxis(str: str) -&gt; shapeworks_py.Axis</p> <p>convert to axis</p>"},{"location":"studio/ai-assisted-segmentation.html","title":"Why Use AI-Assisted Segmentation in ShapeWorks?","text":"<p>AI-assisted segmentation revolutionizes medical image analysis by delivering fast, accurate, and reproducible segmentation results. Traditional manual segmentation is not only time-consuming but also prone to inter-observer variability, leading to inconsistencies in analysis.  </p> <p>By leveraging AI models such as those provided by MONAI Label, users can automate and refine segmentation tasks with minimal manual effort. This enhances workflow efficiency and improves clinical decision-making by providing reliable and high-quality segmentation results.  </p> <p>ShapeWorks now seamlessly integrates MONAI Label, enabling end-to-end AI-assisted segmentation within its ecosystem. This allows users to directly generate precise shape models from AI-derived segmentations and utilize the full functionality of ShapeWorks\u2014including statistical shape analysis, shape modeling, and visualization\u2014without additional manual processing. This integration accelerates research, improves reproducibility, and facilitates more advanced shape-based analyses from medical images.</p>"},{"location":"studio/ai-assisted-segmentation.html#monai-label-steps","title":"MONAI Label Steps","text":"<p>This guide walks through setting up and using MONAI Label for AI-assisted segmentation within ShapeWorks.</p>"},{"location":"studio/ai-assisted-segmentation.html#installation-prerequisites","title":"Installation Prerequisites","text":"<p>Before starting, ensure you meet the necessary requirements.</p>"},{"location":"studio/ai-assisted-segmentation.html#1-install-monai-label","title":"1. Install MONAI Label","text":"<p>Supported Platforms: - Ubuntu and Windows OS with GPU/CUDA enabled - Requires Python 3.8 or 3.9 with PyTorch and CUDA installed</p> <p>Note</p> <p>MONAI Label features are not verified on other Python versions.</p> <p>To install MONAI Label, run:</p> <pre><code>pip install monailabel\n</code></pre>"},{"location":"studio/ai-assisted-segmentation.html#2-download-monai-label-applications","title":"2. Download MONAI Label Applications","text":"<p>Once installed, set up the MONAI Label application.</p>"},{"location":"studio/ai-assisted-segmentation.html#download-the-monai-bundle-app","title":"Download the MONAI Bundle App","text":"<p>The MONAI Bundle App enables easy import of any model present in MONAI Model Zoo Bundles into MONAI Label, but models must comply with the MONAI Bundle Specification.</p> <pre><code>monailabel apps --download --name monaibundle --output path/to/workspace_dir\n</code></pre> <p>This command downloads the <code>monaibundle</code> app into the specified workspace directory.</p> <p>Other supported MONAI Label app:   -    - Radiology </p>"},{"location":"studio/ai-assisted-segmentation.html#steps-for-ai-assisted-segmentation-in-shapeworks","title":"Steps for AI-Assisted Segmentation in ShapeWorks","text":"<p>Once all the prerequisites are met, follow these steps to use MONAI Label feature in ShapeWorks for AI-assisted segmentation.</p>"},{"location":"studio/ai-assisted-segmentation.html#1-start-the-monai-label-server","title":"1. Start the MONAI Label Server","text":"<p>To launch the MONAI Label server, run the following command in your terminal:</p> <pre><code>monailabel start_server --app path/to/monaibundle --studies path/to/images --conf models model_name\n</code></pre>"},{"location":"studio/ai-assisted-segmentation.html#command-arguments","title":"Command Arguments","text":"<ul> <li><code>--app</code>: Specifies the path to the MONAI Label app in the workspace directory.  </li> <li>Example: <code>path/to/monaibundle</code> </li> <li><code>--studies</code>: Defines the directory where input images are stored for MONAI Label.  </li> <li>Example: <code>path/to/images</code> </li> <li><code>--conf</code>: Configuration settings for the selected model.  </li> <li>Example: <code>--conf model model_name</code> </li> <li><code>model_name</code>: The AI model used for segmentation (refer to the Supported Models section below).</li> </ul>"},{"location":"studio/ai-assisted-segmentation.html#supported-models","title":"\ud83d\udccc Supported Models","text":"<p>The MONAI Model Zoo provides a variety of AI models for automated medical image segmentation. Below is a list of supported models and their functionalities:</p> model_name Model Type Targeted Structures Modality Description spleen_ct_segmentation UNet Spleen CT 3D segmentation of the spleen swin_unetr_btcv_segmentation SwinUNETR Multi-Organ CT 3D multi-organ segmentation prostate_mri_anatomy UNet Prostate MRI 3D prostate segmentation from MRI pancreas_ct_dints_segmentation DiNTS Pancreas/Tumor CT AutoML method for pancreas/tumor segmentation renalStructures_UNEST_segmentation UNesT Kidney Substructures CT Kidney cortex, medulla, and pelvis segmentation wholeBrainSeg_UNEST_segmentation UNesT Whole Brain MRI T1 3D segmentation of 133 brain structures lung_nodule_ct_detection RetinaNet Lung Nodule CT AI-powered detection of lung nodules in 3D CT scans wholeBody_ct_segmentation SegResNet 104 Body Structures CT 3D segmentation of whole-body structures (TotalSegmentator dataset) <p>\ud83d\udd17 More details on supported models: MONAI Model Zoo </p>"},{"location":"studio/ai-assisted-segmentation.html#2-create-a-shapeworks-project","title":"2. Create a ShapeWorks Project","text":"<ul> <li>Ensure that the input image paths (relative to the project file) are defined under the field <code>images_*name*</code>, e.g., <code>images_ct</code>.</li> </ul>"},{"location":"studio/ai-assisted-segmentation.html#3-open-shapeworks-studio-and-connect-to-monai-label","title":"3. Open ShapeWorks Studio and Connect to MONAI Label","text":"<ul> <li>Open your project file in ShapeWorks Studio and navigate to the MONAI Tab.</li> <li>Enter the MONAI Label server address (default: <code>http://127.0.0.1:8000/</code>).</li> <li>Click the Connect Server button.</li> </ul>"},{"location":"studio/ai-assisted-segmentation.html#4-start-segmentation","title":"4. Start Segmentation","text":"<p>Follow these steps to segment your images:</p> <ol> <li>Upload Sample </li> <li> <p>Click Upload Sample to send the selected sample to the MONAI Label server for inference.    !!! danger \" \"     Ensure PHI (Protected Health Information) is removed from the scans if using a remote server.   <p> </p> </p> </li> <li> <p>Run Segmentation </p> </li> <li>Click Run to apply AI inference on the current sample.  </li> <li> <p>The segmentation results will be displayed in a few seconds.   <p> </p> </p> </li> <li> <p>Process More Samples </p> </li> <li>Use the Source Volume combo box to navigate to the next sample and repeat the segmentation steps.</li> <li>If using a DeepEdit model, before proceeding with the next sample, click Submit Label to send user-edited predictions back to the MONAI Label server for model refinement.   <p> </p> </li> </ol>"},{"location":"studio/deepssm-in-studio.html","title":"DeepSSM in Studio","text":"<p>ShapeWorks Studio supports the full DeepSSM pipeline, including prep (groom/optimize), data augmentation and DeepSSM model training and testing. For a full explanantion of the process see: Data Augmentation for Deep Learning and SSMs Directly from Images. </p> <p>Running DeepSSM in Studio requires a project with both images and shapes that will be used for training, validation and testing.  </p> <p>To run DeepSSM in Studio, load a ShapeWorks Project Spreadsheet with the following columns: <code>shape_*name*</code>, <code>image_*name*</code> (e.g. <code>shape_la</code>, <code>image_mri</code>).  For example:</p> <p></p>"},{"location":"studio/deepssm-in-studio.html#example-data-for-deepssm","title":"Example Data for DeepSSM","text":"<p>In this example, we demonstrate DeepSSM in studio with a left atrim dataset. The data is available at https://www.sci.utah.edu/~shapeworks/doc-resources/zips/deepssm_la.zip.</p> <p>To view the data, download and unzip the file.  Then open the project in ShapeWorks Studio.  Switching to the Data tab, you should see the following:</p> <p></p>"},{"location":"studio/deepssm-in-studio.html#defining-data-split","title":"Defining Data Split","text":"<p>The first step is to define what percentage of the input data to use in training, validation, and testing. First, the testing data is split from the dataset and kept out of data augmentation and model training. For example, if the dataset is comprised of 10 samples and the test split is set to 20 percent, then the test set will have two samples. After data augmentation, the validation split is used to define a validation set. For example, if there are 8 real samples (excluding test examples) and 2 are augmented and the validation split is set to 30 percent, then the validation set will have 3 of those 10. </p> <p></p> <p>Two other parameters to define for DeepSSM are the Percent of Variability Preserved and the Image Spacing.</p> Parameter Description Percent of Variability Preserved This parameter is used in data augmentation to determine how many PCA dimensions to use.  DeepSSM will use the number of dimension required to meet the percent of variability requested. Image Spacing This parameter defines the image spacing to use for the images.  Images will be resampled to this spacing."},{"location":"studio/deepssm-in-studio.html#prep","title":"Prep","text":"<p>The next step is to run the prep phase which will perform the following tasks:</p> Task Description Groom Training Shapes The shapes marked \"training\" (see split column) will be groomed according to the parameters in the groom tab Optimize Training Shapes The shapes marked \"training\" will have correspondence particles generated and optimized according to the parameters in the optimize tab Groom/Optimize Validation Shapes The validation shapes will have correspondence particles generated and optimized according to the parameters  n the optimize tab using the training shapes as fixed domains Groom Images The training images will be aligned and prepped according to the grooming parameters. The validation images will be aligned and prepped using image to image registration with the training images. <p>After running the prep stage, you should see the following with all five stages done:</p> <p></p>"},{"location":"studio/deepssm-in-studio.html#augmentation","title":"Augmentation","text":"<p>The next step is to run data augmentation to create more training examples. Users can specify how many samples to generate and what type of sampling distribution to use. For a more detailed description of these parameters, please see: Data Augmentation for Deep Learning and Data Augmentation Notebook.</p> <p></p> <p>While data augmentation is running a progress bar is displayed across the bottom. After it has completed, the newly generated data is displayed below the real data in the right panel for comparison. A table is shown which contains the real and augmented image paths, particle paths, and PCA scores. Parallel violin plots are displayed to compare the distribution of each PCA score across the real and augmented data. This can be helpful in visually assessing if the type of distribution used in augmentation provided a good fit for the data. </p> <p></p>"},{"location":"studio/deepssm-in-studio.html#training","title":"Training","text":"<p>The next step is to train the DeepSSM model. Some training parameters are exposed which are explained in detail here: SSMs Directly from Images.</p> <p></p> <p>As the model trains, each epoch the display updates. The \"Training Output\" table logs the epochs, learning rate, and training and validation errors. The training and validation error are also plotted over epochs in a scatterplot below. To the right, examples of training andvalidation predictions are displayed and updated every epoch. Here we can see the examples with the greatest, smallest, and median error. The distance from the predicted particles to the true particles is displayed as a heat map with a corresponding scale. This gives an idea of model prediction quality as the model trains. </p> <p></p>"},{"location":"studio/deepssm-in-studio.html#testing","title":"Testing","text":"<p>In the final step, predictions are made on the testing set which is unseen to the DeepSSM model. A mesh is created based on these particle positions and the surface to surface distance from this mesh to the true mesh is calculated. This is displayed as a heat map on the predictions and the average for each sample is shown in the table. </p> <p></p>"},{"location":"studio/deepssm-in-studio.html#inference","title":"Inference","text":"<p>To use an completed DeepSSM model for inference, simply add additional images to the project spreadsheet and run the test step again.  In the example, we have provided two more images that can be used to try this out.</p> <p></p> <p>The new shapes won't have distance differences as they have no ground truth.  However, the predicted particles will be displayed and the mesh will be created and displayed.  The mesh can be saved by right clicking on the mesh and selecting \"Save Mesh\".  </p> <p></p>"},{"location":"studio/getting-started-with-studio.html","title":"Getting Started With ShapeWorks Studio","text":"<p>ShapeWorks Studio provides an all-in-one GUI based interface to the ShapeWorks toolkit.  In Studio, you can manage input Data, Groom, Optimize and Analyze your data all within a single interface.</p>"},{"location":"studio/getting-started-with-studio.html#splash-screen","title":"Splash Screen","text":"<p>The splash screen provides access to recent projects and an option to create a new blank project.</p> <p></p>"},{"location":"studio/getting-started-with-studio.html#data-module","title":"Data Module","text":"<p>The Data Module shows the project data table, landmarks, constraints as well as user-defined/saved notes. This module enables you to add and remove shapes (segmentations and surface meshes) to your cohort, define anatomical landmarks, place cutting planes and free form constraints for surface exclusion.</p> <p></p> <p>See Studio Data Module for more information.</p>"},{"location":"studio/getting-started-with-studio.html#groom-module","title":"Groom Module","text":"<p>The Groom module provides options to preprocess/groom the input data.  Options differ for binary segmentations and meshes. You also have the option of skipping grooming if your data is already prepped.</p> <p></p> <p>See Studio Groom Module for more information.</p>"},{"location":"studio/getting-started-with-studio.html#optimize-module","title":"Optimize Module","text":"<p>The Optimize module provides options for the particle-based optimization.  After selecting options and clicking \"Run Optimize\", you can monitor the process of the optimization in real-time.  Particle positions will be displayed on individual shapes as they progress where color encodes surface correspondences across different shapes in your cohort.</p> <p></p> <p>See Studio Optimize Module for more information.</p>"},{"location":"studio/getting-started-with-studio.html#analysis-module","title":"Analysis Module","text":"<p>After optimization is complete, you may analyze the data in Studio using the Analysis module.  There are several panels available in the Analysis Module.</p> <p>See Studio Analyze Module for more information.</p>"},{"location":"studio/getting-started-with-studio.html#preferences","title":"Preferences","text":"<p>Studio provides a number of preference options.</p> <p></p> Option Description Color Scheme Base foreground and background colors for viewers Particle Colors Choice of color for particles Color Map Color map used for scalar ranges Reverse Color Map Option to reverse the color map Discrete Color Mode Option to use discrete colors for color map Groom Output Folder name for groom output Optimize Output Folder name for optimize particle output Parallel Processing Enabled Whether to use parallelized grooming, optimizing and mesh reconstruction Parallel Number of Threads How many threads to use for parallelized operations Mesh Cache Enabled Whether to use a cache of meshes Mesh Cache Memory to Use Percentage of phyisical memory to allow mesh cache to use Log Location A display of where the current log file is located Orientation Marker Type Medical, Triad, or None Orientation Marker Corner Upper Right, Upper Left, Lower Left, Lower Right PCA Range Number of standard deviations for PCA slider Number of PCA Steps Number of steps for PCA slider bar Geodesics Cache Size Multiplier Multiplier value for geodesics caching Automatically Check for Updates Whether Studio should automatically check for updates to ShapeWorks Send Anonymous Usage Statistics Whether Studio should send anonymous usage statistics to the ShapeWorks team to help improve the software"},{"location":"studio/getting-started-with-studio.html#data-collection","title":"Data Collection","text":"<p>ShapeWorks Studio can optionally send anonymous usage statistics to the ShapeWorks team.  This data helps the team by providing basic user tracking numbers that we report to funding agencies to help in acquiring additional funding.  Additionally, we are prospectively collecting a few usage parameters that may aid in development of particular features.  No user data (images, meshes, segmentations, etc) are ever transferred, only basic user event information (e.g. number of times optimize is run).</p>"},{"location":"studio/getting-started-with-studio.html#viewer-controls","title":"Viewer Controls","text":"<p>See Studio Viewer Controls for details on viewer controls.</p>"},{"location":"studio/getting-started-with-studio.html#menus","title":"Menus","text":""},{"location":"studio/getting-started-with-studio.html#file-menu","title":"File Menu","text":"<ul> <li><code>New Project</code> - Create a new project</li> <li><code>Open Project</code> - Open a project from disk</li> <li><code>Show Project folder</code> - Open Explorer/Finder for project location (windows/mac)</li> <li><code>Save Project</code> - Save project to disk</li> <li><code>Save Project As</code> - Save a copy of the project to a new file</li> <li><code>Import Shapes...</code> - Import new shapes</li> <li><code>Export</code> - See export below</li> <li>Up to 8 recent projects are shown at the bottom</li> </ul>"},{"location":"studio/getting-started-with-studio.html#export-menu","title":"Export Menu","text":"<p>See Studio Export Options for details on export options.</p>"},{"location":"studio/getting-started-with-studio.html#project-setup","title":"Project setup","text":"<p>ShapeWorks Studio and the <code>shapeworks</code> commands <code>groom</code> and <code>optimize</code> store project data in an XLSX spreadsheet. The spreadsheet format profiles a uniform, easy to edit, easy to organize way of inputing data into shapeworks for grooming, optimizing and analyzing data. See Here for more details regaring the project sheet and the python API available to generate the project sheet. </p>"},{"location":"studio/multiple-domains.html","title":"Multiple Domains SSM","text":"<p>ShapeWorks Studio supports grooming, optimization and analysis for multiple domains/anatomies within a project.  To set up a project with multiple domains per subject, simply add additional <code>shape</code> columns to a ShapeWorks Project Spreadsheet:</p> <p></p>"},{"location":"studio/multiple-domains.html#importing-data-for-multiple-domains","title":"Importing Data for Multiple Domains","text":"<p>In this example, we have defined two domains, <code>left_atrium</code> and <code>appendage</code>.  The multiple domains are shown in the Data panel when importing a ShapeWorks Project Spreadsheet file with more than one column with the <code>shape</code> prefix. When we open this in Studio, we will see:</p> <p></p>"},{"location":"studio/multiple-domains.html#grooming-multiple-domains","title":"Grooming Multiple Domains","text":"<p>When multiple domains are present, grooming options will be available on a per-domain basis with a combobox at the top of the grooming panel.  This allows for different grooming options depending on the anatomy type.  You may also apply the same grooming to all domains using the <code>Apply grooming parameters to all domains</code> checkbox.</p> <p></p>"},{"location":"studio/multiple-domains.html#optimizing-multi-domain-ssm","title":"Optimizing Multi-Domain SSM","text":"<p>For optimization, each domain can be given a different number of particles, but all other parameters are global to the optimization process.</p> <p></p>"},{"location":"studio/multiple-domains.html#analyzing-multi-domain-ssm","title":"Analyzing Multi-Domain SSM","text":"<p>Analysis options are similar for multiple domains as for single domain usage.  Each domain will be reconstructed separated and shown as a mesh with a different color.</p> <p></p> <p>Here is an illustration for the full multi-domain workflow.</p> <p>"},{"location":"studio/multiple-domains.html#mixed-type-domains","title":"Mixed-type Domains","text":"<p>Multiple domains in ShapeWorks are implemented in a domain-type agnostic, where shapes models can be groomed, optimized, and analyzed for cohorts of mixed-types such as meshes and binary segmentations. Here is an example of grooming, optimizing, and analyzing a multi-domain model with the pelvis given as a surface mesh and the femur given as a binary segmentation.</p> <p>"},{"location":"studio/multiple-domains.html#multiple-domain-alignments","title":"Multiple Domain Alignments","text":"<p>In the presence of multiple anatomies, there are multiple alignment strategies that can be employed.  These strategies can be explored as part of the Analysis module.  The correspondence model can be aligned based on any particular reference domain, a global alignment, or with all articulation removed (local alignment).</p> <p>Below is an example of these four options with a pelvis and femur model.</p> <p>"},{"location":"studio/segmentation-tool.html","title":"ShapeWorks Studio Segmentation Tool","text":"<p>ShapeWorks Studio includes a segmentation tool that allows users to segment images using a paintbrush tool.</p> <p></p> <p>When painting is enabled, you can choose either segmenting or erasing mode. In segmenting mode, you can paint on the image to segment the object of interest. In erasing mode, you can paint on the image to remove the unwanted segmentations. You can also adjust the brush size.</p> <p>Segmentation can be performed on each slide and in any of the three views (X, Y, or Z).</p> <p>Click \"Recompute Surface\" to regenerate the surface mesh based on the updated segmentation.</p> <p></p>"},{"location":"studio/studio-analyze.html","title":"ShapeWorks Studio Analyze Module","text":"<p>After optimization is complete, you may analyze the data in Studio using the Analysis module.  There are several panels available in the Analysis Module.</p>"},{"location":"studio/studio-analyze.html#view-panel","title":"View Panel","text":"<p>The View panel contains all of the options for controlling the analyis viewer options.</p> <p></p>"},{"location":"studio/studio-analyze.html#group","title":"Group","text":"<p>The Group mode allows for group comparison to quantify and visualize population-level differences.  Each <code>group_&lt;value&gt;</code> column from the project can be selected and the differences between any two values (i.e., group identifiers) in the groups can be displayed by selecting the group values in the left and right dropdown boxes.  A group difference display showing vectors and a colormap of distance can be shown using the \"Diff --&gt;\" button.</p> <p></p> <p>There are three different group analysis options available:</p> <ul> <li>LDA</li> <li>Group Particle P-Values</li> <li>Network Analysis</li> </ul>"},{"location":"studio/studio-analyze.html#lda","title":"LDA","text":"<p>Selecting LDA from the analysis method dropdown will generate an LDA chart based on the two groups:</p> <p></p>"},{"location":"studio/studio-analyze.html#group-particle-p-values","title":"Group Particle P-Values","text":"<p>Performs per particle p-value computation for each group.  </p> <p></p>"},{"location":"studio/studio-analyze.html#network-analysis","title":"Network Analysis","text":"<p>The Network Analysis tool provides a method to statistically analyze data captured in feature maps. Two implementations have been included: Network Analysis and SPM1D. Statistical parametric mapping (SPM, https://www.fil.ion.ucl.ac.uk/spm/) was introduced for the analysis of brain imaging data and has since been used in statistical analysis of surface-based group differences. The SPM1D option uses this technique without consideration of the connectivity and spatial relationship of the input data. The Network Analysis method uses the relative size of the network of connected correspondence particles to identify significant differences amongst groups, as originally described by Forman and colleagues (Forman SD, et al. Magnetic Resonance in Medicine33:636-647, 1995). Our publication on the specifics of this method and example applications is in review and will be referenced here when available.</p> Option Description Feature Map Choose which feature to operate on. P-value Threshold The initial p-value used to threshold particles as an initial step to the evaluation of cluster size. Only modify from 0.05 for adjusted statistical assumptions. Cluster P-value The cluster p-value defines the p-value used to identify significant clusters for the group. Traditional statistics would assume a p-value of 0.05. Permutations This is the number of permutations used in the analysis. The maximum value is driven by the sample size, however 10,000 is generally considered acceptably large. Display Choose to display Network Analysis output or SPM1D <p>After running the Network Analysis, you can enable the display of values with the \"Display\" checkbox:</p> <p></p>"},{"location":"studio/studio-analyze.html#samples","title":"Samples","text":"<p>The Samples tab of the view panel allows you to view all of the samples in your cohort, view a single sample by index, or view the median sample.</p> <p></p>"},{"location":"studio/studio-analyze.html#pca","title":"PCA","text":"<p>The PCA tab of the View panel shows reconstructed shapes (surface meshes) along PCA modes of variation. Modes of variations are shape parameters learned/discovered from your data that describes shape variations. You can control the location along the PCA mode with the Standard Deviation slider.  The extent of this slider is configurable in Preferences.  Values displayed:</p> <p><code>Lambda</code> - This shows the PCA loading of current position of the slider.  The middle of the slider, at the mean value, will be 0.  The extent of lambda is defined by the number of standard deviations of the slider as described above.  At standard deviation of 1.0, it will be the square root of the mode's eigenvalue.</p> <p><code>Eigenvalue</code> - This shows the eigenvalue of the currently selected mode.  This is a unitless measure of how much variance is explained by this mode.  The modes are sorted in decreasing order of eigenvalue, corresponding to the most variance explained first.</p> <p></p>"},{"location":"studio/studio-analyze.html#multi-level-pca","title":"Multi-Level PCA","text":"<p>The PCA tab of the View panel shows options to select modes of variation in different subspaces when a multiple domain shape model is loaded: </p> <p><code>Shape and Relative Pose</code> - Selecting this option shows reconstructed shapes and it's eigenvalue and lambda, along ordinary PCA modes of variation. PCA is done in the shared space of the multi-object shape structure and thus  the shsape and pose variations are entangled here.</p> <p><code>Shape</code> - Selecting this option shows reconstructed shapes and it's eigenvalue and lambda, along only morphological modes of variation. Multi-Level Component Analysis is done in the shape subspace (within-object) of the multi-object shape structure. Shape and pose variations are disentangled here and we only see morphological changes of each object in the shape structure.</p> <p><code>Relative Pose</code> - Selecting this option shows reconstructed shapes and it's eigenvalue and lambda, along only relative pose modes of variation. Multi-Level Component Analysis is done in the relative pose subspace (between-objects) of the multi-object shape structure. Shape and pose variations are disentangled here and we only see alignment changes between the objects in the multi-object shape structure.</p>"},{"location":"studio/studio-analyze.html#show-difference-to-mean","title":"Show Difference to Mean","text":"<p>This checkbox allows for visualization from any surface to the mean.  Arrow glyphs can be shown to display the difference as well.</p> <p></p>"},{"location":"studio/studio-analyze.html#metrics-panel","title":"Metrics Panel","text":"<p>The Metrics panel shows the Compactness, Specificity, and Generalization charts.  These are interactive charts with hover menus and the ability to zoom, pan, etc.</p> <p></p>"},{"location":"studio/studio-analyze.html#distance-calculation-options","title":"Distance Calculation Options","text":"<ol> <li> <p>Particle to Particle (Default): Calculates the distance directly between particles when evaluating the metrics.</p> </li> <li> <p>Particle to Surface: Calculates the distance between particles and the actual shape surface. This method enhances accuracy by measuring generalization as the distance between reconstructed particles and the true shape surface. Specificity is determined by the distance between sampled particles and the surface, ensuring generated shapes accurately reflect the true shape population and providing reliable and consistent metrics.</p> </li> </ol> <p>See Shape Model Evaluation for more information about shape evaluation.</p>"},{"location":"studio/studio-analyze.html#surface-reconstruction-panel","title":"Surface Reconstruction Panel","text":"<p>The surface reconstruction panel provides options for the surface reconstruction method.  There are three surface reconstruction methods available depending on the data you supply.</p> <p><code>Legacy</code> - If an older XML file with only particle files is supplied, then only this option is available.  This is the fallback option since it requires only the particles.</p> <p><code>Mesh Warping Based</code> - Mesh warping based method that utilizes the mean mesh.  You must have either meshes supplied or image based (distance transforms).</p> <p><code>Distance Transform Based</code> - Surface reconstruction based on distance transforms.  Project must have distance transforms.</p> <p></p> <p>Below is an example of the difference in using this option.</p> <p></p>"},{"location":"studio/studio-analyze.html#goodbad-particles-panel","title":"Good/Bad Particles Panel","text":"<p>The Good/Bad Particles Panel enabled the display of \"good/bad particles\" in ShapeWorks Studio.  A maximum angle parameter is given (default 45 degrees).  When a particle's surface normal across subjects (averaged) exceeds this angle, the particle will be marked \"bad\" and shown in red.  Good particles are shown in green.  This can help in identifying problems with correspondence as it is typically expected that surface normals for given particles should be similar across subjects.</p>"},{"location":"studio/studio-analyze.html#particle-area-analysis","title":"Particle Area Analysis","text":"<p>The Particle Area Analysis panel allows for the visualization of the area of each particle in the shape model.  This can be useful for identifying areas that are not being captured well by the modell.  There are two options for visualization, mean and standard deviation.</p> <p></p> <p></p>"},{"location":"studio/studio-analyze.html#shapescalar-correlation","title":"Shape/Scalar Correlation","text":"<p>The Shape/Scalar Correlation panel uses 2 block PLS regression to identify the relationship between shape and scalar data. </p> <p>To use this panel, you must have scalar values (feature map).  Choose the desired feature map from the dropdown menu.</p> <p>Use the \"Determine number of components\" option to show the mean squared error for each number of components:</p> <p></p> <p>After choosing the desired number of components, you can plot the relationship between shape and scalar data:</p> <p></p> <p>Additionally, you can use the 2 Block PLS regression to predict the scalar value from the shape data and vice versa:</p> <p></p> <p>The options \"Shape Only\", \"Scalar Only\", and \"Shape and Scalar\" are available to choose from and the PCA will be performed accordingly.</p>"},{"location":"studio/studio-data.html","title":"ShapeWorks Studio Data Module","text":""},{"location":"studio/studio-data.html#importing-data","title":"Importing data","text":"<p>There are multiple ways to import data into studio:</p> <ol> <li>From the command line:</li> </ol> <pre><code>  ShapeWorksStudio [file1] [file2]...\n</code></pre> <ol> <li>File -&gt; Import Shapes</li> <li>Click the <code>plus</code> / Import button in the Table panel</li> <li>Drag and drop supported files over the Studio window</li> </ol>"},{"location":"studio/studio-data.html#landmarks","title":"Landmarks","text":"<p>Studio supports adding, manipulating and moving anatomical landmarks for each input shape.  Landmarks should be corresponding between shapes and can be used for alignment/registration as well as initial particle position placement.</p> <p></p> <p>Below is a demonstration of the landmarks functionality.</p> <p>"},{"location":"studio/studio-data.html#using-constraints-in-studio","title":"Using Constraints in Studio","text":"<p>ShapeWorks Studio supports grooming, optimization and analysis of shapes with constraints, i.e. explicit inclusion and exclusion areas of the surfaces. These constraints can be defined in Studio as cutting-plane or free-form constraints. In other words, when you define a constraint, particles will be limited to the allowed area and will not cross into the disallowed region.</p>"},{"location":"studio/studio-data.html#defining-cutting-plane-constraints","title":"Defining Cutting-Plane Constraints","text":"<p>Follow the steps below to define cutting planes on an existing project:</p> <ol> <li>Make sure you are on the Data tab.</li> <li>Click the Constraints drop-down menu. </li> <li>ctrl+click 3 points on a shape surface to define a plane. </li> <li>Slide plane along the normal with shift+click. </li> <li>Right click plane point to flip, delete or copy plane to other shapes. </li> <li>Now the newly defined cutting-plane constraint is active for the desired domain on the desired shape. This will show on the constraints panel. Now particles will not spread to the grayed out area. </li> </ol>"},{"location":"studio/studio-data.html#defining-free-form-constraints","title":"Defining Free-Form Constraints","text":"<p>Follow the steps below to define free-form constraints on an existing project:</p> <ol> <li>Make sure you are on the Data tab.</li> <li>Click the Constraints drop-down menu. </li> <li>Click the \"Painting Enabled\" toggle to checked. </li> <li>Select brush size using slider if different from default. </li> <li>Select whether to paint included or excluded area. </li> <li>Paint on the shape you would like to define the free-form constraint on. </li> <li>Now the newly-defined free form constraint is active for the desired domain on the desired shape. This will show on the constraints panel. Now particles will not spread to the grayed out area. </li> </ol>"},{"location":"studio/studio-data.html#removing-a-constraint","title":"Removing a Constraint","text":"<p>To remove a constraint:</p> <ol> <li>Make sure you are on the Data tab with the constraints drop-down menu open.</li> <li>The planes and free-form constraints previously defined will be listed. For cutting planes, you can also right click a plane point for the same effect. </li> <li>To delete, select the one to delete and click delete. </li> </ol> <p>Below is a demonstration of the free form constraints functionality.</p> <p>"},{"location":"studio/studio-export.html","title":"ShapeWorks Studio Export Options","text":"<p>The File -&gt; Export menu is shown below.</p> <p></p> <ul> <li>Export Current Mesh - Export the current mesh as a VTK mesh file</li> <li>Export Current Particles - Export the currently display particles as an \"X Y Z\" particles file</li> <li>Export Current Particle Scalars - Export the currently displayed particle scalars as a CSV file</li> <li>Export Current Mesh Scalars - Export the currently displayed mesh scalars as a CSV file</li> <li>Export All Subjects Particle Scalars - Export the particle scalars for all subjects</li> <li>Export Eigenvectors - Export the PCA eigenvectors</li> <li>Export Eigenvalues - Export the PCA eigenvalues</li> <li>Export PCA Component Scores - Export the raw PCA component scores for each subject as a CSV file</li> <li>Export PCA Mode Particles - Export the PCA mode particles at each step of the PCA slider</li> <li>Export PCA Montage - Launch export dialog for exporting montage of PCA images</li> <li>Export Screenshot - Launch export dialog for exporting current display</li> </ul>"},{"location":"studio/studio-export.html#export-screenshot-dialog","title":"Export Screenshot Dialog","text":"<p>The Export Screenshot dialog allows you to export the currently displayed image using a variety of options</p> Option Description Show Corner Widget Show or hide the orientation widget Transparent Background Enables transparent background in image export Show Color Scale Show or hide color scale, when applicable Override Window Size Override the window size and choose a resolution for export"},{"location":"studio/studio-export.html#export-pca-montage","title":"Export PCA Montage","text":"<p>The PCA Montage exporter allows you to create a multi-image montage across PCA modes. Options are similar to the screenshot export with the addition of controls:</p> Option Description PCA Modes Comma separated list of modes or ranges to include PCA Images Number of images to export on either side of the mean PCA Range Standard deviation range of PCA export"},{"location":"studio/studio-export.html#creating-videos","title":"Creating Videos","text":"<p>The best way to create videos from ShapeWorks Studio is to use a dedicated stand-alone screen video recording tool.  This gives full control over changes in camera angle, display options (e.g. PCA modes, slider animation), compression levels, video formats, etc.  We recommend the following tools:</p> <ul> <li> <p>MacOS built in screen recording </p> </li> <li> <p>OBS Studio for Windows, MacOS and Linux</p> </li> </ul>"},{"location":"studio/studio-groom.html","title":"ShapeWorks Studio Groom Module","text":"<p>The Groom module provides options to preprocess/groom the input data.  Options differ for binary segmentations and meshes. You also have the option of skipping grooming if your data is already prepped.</p> <p></p> <p>Image Grooming Parameters</p> Parameter Description Isolate Isolate the largest object in a segmentation.  This removes extraneous noise voxels that would result in disjoint objects. Fill Holes Fill small holes in segmentation Crop Crop image down to ROI of segmentation Pad Pad image with zeroes by a given number of voxels.  Typically combined with cropping Antialias Perform anti-aliasing to reduce segmentation stairstep effect Resample Resample image spacing either to isotropic (recommended) or any given spacing Distance Transform Create a distance transform for image based optimization Blur Perform smoothing on the distance transform using a gaussian blur Convert to Mesh Optionally convert to mesh at the end of Image Grooming.  This enables the Mesh Grooming pipeline and will run the optimization on meshes <p>Mesh Grooming Parameters</p> Parameter Description Fill Holes Fill small holes in the mesh Smooth Perform either Laplacian or Windowed Sinc smoothing Laplacian Smoothing Laplacian smoothing option with specified iterations and relaxation factor.  In general, it is recommended to use smaller relaxation factors and more iterations rather than larger relaxation and fewer iterations Windowed Sinc Smoothing Windowed Sinc smoothing with specified iterations and passband (typically between 0 and 2).  Lower passpand values produce more smoothing. Remesh Enabled remeshing using ACVD library Remesh Percent Specify target vertices as a percentage of existing vertices Remesh Vertices Specify target vertices directly Remesh Adaptivity Curvature adaptivity of remeshing (0 = uniform, 2.0 most adaptive).  This allocates more triangles/vertices to areas of higher curvature <p>Alignment Parameters</p> Parameter Description Reflect Option to reflect some shapes over a given axis if a given column matches a given value (e.g. reflect 'side' over 'Y' if 'left') Alignment Option to align with centering (center of mass), iterative closest point (translation and rotation), or landmarks (best fit, when specified)"},{"location":"studio/studio-optimize.html","title":"ShapeWorks Studio Optimize Module","text":"<p>The Optimize module provides options for the particle-based optimization.  After selecting options and clicking \"Run Optimize\", you can monitor the process of the optimization in real-time.  Particle positions will be displayed on individual shapes as they progress where color encodes surface correspondences across different shapes in your cohort.</p> <p></p> <p>Optimization Parameters</p> Parameter Description Number of Particles The desired number of particles to be placed. ShapeWorks will produce the smallest power-of-2 number of particles greater than or equal to the given value Initial Relative Weighting The relative weight of the correspondence term in the initialization steps to make sure that optimization steps start with evenly spaced particle distributions that cover the entire surfaces (usually in the order of ~0.1 or 0.01) Relative Weighting The relative weight of the correspondence term in the optimization steps. Starting Regularization Sets the starting regularization value.  See details about regularization here Ending Regularization Sets the ending regularization value. See details about regularization here Iterations per Split The number of iterations in the initialization step for each split (i.e., scale) Optimization Iterations Number of iterations for each optimization step. Geodesic Distance Enable the use of geodesic distance for particle to particle interactions.  This is much slower, but can help with some complex structures/ Normals Enable the use of surface normals as a correspondence feature Normals Strength Amount to scale surface normals feature to give it enough weight relative to XYZ. Procrustes Enable use of procrustes registration as part of optimization Procrustes Scaling Enable scaling as part of procrustes to remove overall scale from the model Procrustes Rotation/Translation Enable procrustes rotation/translation to remove translation/rotation from the model Procrustes Interval Interval of iterations to run procrustes Multiscale Mode Enable multiscale optimization where each particle split level after the multiscale start number runs in both initialization and optimization modes Multiscale Start Number of particles to begin multscale mode Use Initial Landmarks Enable the use of landmarks as starting particles Narrow Band Number of voxels surrounding zero level for distance transform based optimizations.  Normally a value of 4 is sufficient"},{"location":"studio/studio-shared-boundary.html","title":"Shared Boundaries in Studio","text":"<p>ShapeWorks Studio supports modeling shared boundaries to capture inter-domains correlations and interactions. This feature is useful when the shapes in the dataset have shared boundaries, such as the left and right atria in the heart.  See also the Shared Boundary Use Case.</p>"},{"location":"studio/studio-shared-boundary.html#example-data","title":"Example Data","text":"<p>The example data for this tutorial is provided in the <code>Examples/Studio/SharedBoundary</code> directory.</p> <p>To open the project, start ShapeWork Studio, and open the project file <code>Examples/Studio/SharedBoundary/peanut_shared_boundary_studio.xlsx</code>.</p> <p></p>"},{"location":"studio/studio-shared-boundary.html#grooming","title":"Grooming","text":"<p>Grooming options are prepared for shared boundary modeling.  When multiple domains are present the Multiple Domains panel appears and gives options for shared boundary extraction and boundary loop generation.  This processing will generate two addition domains, one for the shared boundary and one for the boundary loop.</p> <p></p>"},{"location":"studio/studio-shared-boundary.html#optimization","title":"Optimization","text":"<p>The optimization panel has options for shared boundary modeling with the ability to enable/disable shared boundary support and a weighting value for the shared boundary.</p> <p></p>"},{"location":"studio/studio-shared-boundary.html#analysis","title":"Analysis","text":"<p>Analyzing shared boundary models is similar to analyzing other multi-domain models.  The shared surface and boundary loop appear as addition domains.</p> <p></p>"},{"location":"studio/studio-viewer.html","title":"ShapeWorks Studio Viewer Controls","text":"<p>At the bottom of the viewers are the controls for the viewers:</p> <p></p> <p>Each button has tooltips with descriptions.  The controls from left to right are:</p> <ul> <li>Autoview / reset view</li> <li>Cutting plane visibility</li> <li>Landmark visibility</li> <li>Glyph visibility with dropdown for glyph size and detail</li> <li>Isosurface visibility with dropdown for surface opacity (of each domain)</li> <li>View mode (original/groomed/reconstructed)</li> <li>Align (whether to align each object based on the alignment strategy)</li> <li>Compare mode (e.g. compare original vs groomed)</li> <li>Number of views in lightbox (1,2,4,9,16,25,36,49,64)</li> </ul>"},{"location":"studio/studio-viewer.html#comparing-mesh-types","title":"Comparing mesh types","text":"<p>The comparison mode toggle also has a dropdown with additional controls:</p> <p></p> <p>Comparison can be performed either as an overlay (with individual opacity controls):</p> <p></p> <p>Or comparison can be performed showing a surface to surface distance:</p> <p></p>"},{"location":"studio/studio-viewer.html#feature-maps-and-scalars-controls","title":"Feature maps and scalars controls","text":"<p>When feature volumes or meshes with scalars are loaded, or other scalar values are present, the extended panel will be displayed:</p> <p></p> <p>This adds the feature map / scalar selection and a checkbox to apply a uniform scale to all viewers, vs local scale for each.  Additionally, the auto range can be turned off and specified range can be set.</p>"},{"location":"studio/studio-viewer.html#image-volume-support","title":"Image volume support","text":"<p>When image volumes are provided, another extended panel will be displayed:</p> <p></p> <ul> <li>Image selection</li> <li>Plane direction (X/Y/Z)</li> <li>Enabled 2D/3D viewere mode</li> <li>Shared Brightness/Contrast between viewers</li> <li>Sync slice position between viewers</li> </ul> <p></p>"},{"location":"studio/studio-viewer.html#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>The keyboard shortcuts are available from the Help -&gt; Keyboard Shortcuts menu item.</p> <p></p>"},{"location":"studio/studio-viewer.html#point-selection","title":"Point selection","text":"<p>As shown in the keyboard shortcuts panel, you can hover over a particle and press the '1' key.  This will select this point on all viewers.</p> <p>The selected point will become white and all other points will change to a color based on the distance to the chosen point.</p> <p></p> <p>To turn off this display, press '1' while hovering over something other than a particle.</p> <p>Additionally, after selecting a point, you may select another point by pressing '2' while hovering.  This will set the first point to white, the second point to yellow and the rest to black.  This is an easy way to see how particlar particles vary and correspond across shapes.</p> <p></p>"},{"location":"studio/using-constraints.html","title":"Using Constraints in Studio","text":"<p>ShapeWorks Studio supports grooming, optimization and analysis of shapes with constraints, i.e. explicit inclusion and exclusion areas of the surfaces. These constraints can be defined in Studio as cutting-plane or free-form constraints. In other words, when you define a constraint, particles will be limited to the allowed area and will not cross into the disallowed region.</p>"},{"location":"studio/using-constraints.html#defining-cutting-plane-constraints","title":"Defining Cutting-Plane Constraints","text":"<p>Follow the steps below to define cutting planes on an existing project:</p> <ol> <li>Make sure you are on the Data tab.</li> <li>Click the Constraints drop-down menu. </li> <li>ctrl+click 3 points on a shape surface to define a plane. </li> <li>Slide plane along the normal with shift+click. </li> <li>Right click plane point to flip, delete or copy plane to other shapes. </li> <li>Now the newly defined cutting-plane constraint is active for the desired domain on the desired shape. This will show on the constraints panel. Now particles will not spread to the grayed out area. </li> </ol>"},{"location":"studio/using-constraints.html#defining-free-form-constraints","title":"Defining Free-Form Constraints","text":"<p>Follow the steps below to define free-form constraints on an existing project:</p> <ol> <li>Make sure you are on the Data tab.</li> <li>Click the Constraints drop-down menu. </li> <li>Click the \"Painting Enabled\" toggle to checked. </li> <li>Select brush size using slider if different from default. </li> <li>Select whether to paint included or excluded area. </li> <li>Paint on the shape you would like to define the free-form constraint on. </li> <li>Now the newly-defined free form constraint is active for the desired domain on the desired shape. This will show on the constraints panel. Now particles will not spread to the grayed out area. </li> </ol>"},{"location":"studio/using-constraints.html#removing-a-constraint","title":"Removing a Constraint","text":"<p>To remove a constraint:</p> <ol> <li>Make sure you are on the Data tab with the constraints drop-down menu open.</li> <li>The planes and free-form constraints previously defined will be listed. For cutting planes, you can also right click a plane point for the same effect. </li> <li>To delete, select the one to delete and click delete. </li> </ol>"},{"location":"tools/ShapeWorksCommands.html","title":"ShapeWorks Commands","text":"<p><code>shapeworks</code> is a single executable for ShapeWorks with a set of sub-executables (commands) that are flexible, modular, loosely coupled, and standardized subcommands, with interactive help to perform individual operations needed for a typical shape modeling workflow that includes the Groom, Optimize, and Analyze phases.</p> <p>Activate shapeworks environment</p> <p>Each time you use ShapeWorks from the command line, you must first activate its environment using the <code>conda activate shapeworks</code> command on the terminal. </p> <p>Add shapeworks to your path</p> <p>Please make sure that <code>shapeworks</code> is in your path. See Adding to PATH Environment Variable. </p>"},{"location":"tools/ShapeWorksCommands.html#shapeworks","title":"shapeworks","text":"<p>Usage:</p> <pre><code>  shapeworks &lt;command&gt; [args]...\n</code></pre> <p>Description: Unified ShapeWorks executable that includes command line utilities for automated construction of compact statistical landmark-based shape models of ensembles of shapes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--version: show program's version number and exit</p> <p>-q, --quiet: don't print status messages</p> <p>Back to Top</p>"},{"location":"tools/ShapeWorksCommands.html#analyze-commands","title":"Analyze Commands","text":""},{"location":"tools/ShapeWorksCommands.html#analyze","title":"analyze","text":"<p>Usage:</p> <pre><code>shapeworks  analyze [args]...\n</code></pre> <p>Description: Offline analysis of a shapeworks project, output json and meshes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to project file.</p> <p>--output=STRING: Path to output file.</p> <p>--range=FLOAT: Standard deviation range for PCA [default: 3.0].</p> <p>--steps=INT: Number of steps to use for PCA [default: 21].</p> <p>Back to Top</p> <p>Back to Analyze Commands</p>"},{"location":"tools/ShapeWorksCommands.html#deepssm-commands","title":"DeepSSM Commands","text":""},{"location":"tools/ShapeWorksCommands.html#deepssm","title":"deepssm","text":"<p>Usage:</p> <pre><code>shapeworks  deepssm [args]...\n</code></pre> <p>Description: run deepssm steps</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to input project file (xlsx or swproj).</p> <p>--prep=CHOICE: Preparation step to run (choose from 'all', 'groom_training', 'optimize_training', 'optimize_validation', 'groom_images')</p> <p>--augment: Run data augmentation</p> <p>--train: Run training</p> <p>--test: Run testing</p> <p>--all: Run all steps</p> <p>--num_workers=INT: Number of data loader workers (default: 0)</p> <p>Back to Top</p> <p>Back to DeepSSM Commands</p>"},{"location":"tools/ShapeWorksCommands.html#groom-commands","title":"Groom Commands","text":""},{"location":"tools/ShapeWorksCommands.html#groom","title":"groom","text":"<p>Usage:</p> <pre><code>shapeworks  groom [args]...\n</code></pre> <p>Description: groom a shapeworks project</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to project file.</p> <p>--progress: Show progress [default: false].</p> <p>--xmlconsole: XML console output [default: false].</p> <p>Back to Top</p> <p>Back to Groom Commands</p>"},{"location":"tools/ShapeWorksCommands.html#image-commands","title":"Image Commands","text":""},{"location":"tools/ShapeWorksCommands.html#add","title":"add","text":"<p>Usage:</p> <pre><code>shapeworks  add [args]...\n</code></pre> <p>Description: add a value to each pixel in the given image and/or add another image in a pixelwise manner</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --value=DOUBLE:  Value to add to each pixel [default: 0.0].</p> <p>--name=STRING: Name of image to add pixelwise.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#antialias","title":"antialias","text":"<p>Usage:</p> <pre><code>shapeworks  antialias [args]...\n</code></pre> <p>Description: antialiases binary volumes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--iterations=INT: Maximum number of iterations [default: 50].</p> <p>--maxrmserror=DOUBLE: Maximum RMS error determines how fast the solver converges. Range [0.0, 1.0], larger is faster [default: 0.01].</p> <p>--layers=INT: Number of layers around a 3d pixel to use for this computation [default: 3].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#binarize","title":"binarize","text":"<p>Usage:</p> <pre><code>shapeworks  binarize [args]...\n</code></pre> <p>Description: sets portion of image greater than min and less than or equal to max to the specified value</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--min=DOUBLE: Lower threshold level [default: 0.0].</p> <p>--max=DOUBLE: Upper threshold level [default: inf ].</p> <p>--value=DOUBLE: Value to set region [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#blur","title":"blur","text":"<p>Usage:</p> <pre><code>shapeworks  blur [args]...\n</code></pre> <p>Description: applies gaussian blur</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--sigma=DOUBLE: Value of sigma [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#bounding-box-image","title":"bounding-box-image","text":"<p>Usage:</p> <pre><code>shapeworks  bounding-box-image [args]...\n</code></pre> <p>Description: compute largest physical bounding box surrounding the specified isovalue of the specified set of images</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--names :  Paths to images (must be followed by <code>--</code>), ex: \"bounding-box-image --names *.nrrd -- --isovalue 1.5\") <p>--isovalue=DOUBLE: Threshold value [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#clip-image","title":"clip-image","text":"<p>Usage:</p> <pre><code>shapeworks  clip-image [args]...\n</code></pre> <p>Description: clips volume with the specified cutting planes defined by three 3D points</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--x1=DOUBLE: Value of x1 for cutting plane [default: 0].</p> <p>--y1=DOUBLE: Value of y1 for cutting plane [default: 0].</p> <p>--z1=DOUBLE: Value of z1 for cutting plane [default: 0].</p> <p>--x2=DOUBLE: Value of x2 for cutting plane [default: 0].</p> <p>--y2=DOUBLE: Value of y2 for cutting plane [default: 0].</p> <p>--z2=DOUBLE: Value of z2 for cutting plane [default: 0].</p> <p>--x3=DOUBLE: Value of x3 for cutting plane [default: 0].</p> <p>--y3=DOUBLE: Value of y3 for cutting plane [default: 0].</p> <p>--z3=DOUBLE: Value of z3 for cutting plane [default: 0].</p> <p>--value=DOUBLE: Value of clipped pixels [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#close-holes","title":"close-holes","text":"<p>Usage:</p> <pre><code>shapeworks  close-holes [args]...\n</code></pre> <p>Description: closes holes in a volume defined by values larger than specified value</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--value=DOUBLE: Largest value not in volume [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#compare-image","title":"compare-image","text":"<p>Usage:</p> <pre><code>shapeworks  compare-image [args]...\n</code></pre> <p>Description: compare two images</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Compare this image with another.</p> <p>--verifyall=BOOL: Also verify origin, spacing, and direction matches [default: true].</p> <p>--tolerance=DOUBLE: Allowed percentage of pixel differences [default: 0].</p> <p>--precision=DOUBLE: Allowed difference between two pixels for them to still be considered equal [default: 1e-5].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#compute-dt","title":"compute-dt","text":"<p>Usage:</p> <pre><code>shapeworks  compute-dt [args]...\n</code></pre> <p>Description: computes signed distance transform volume from an image at the specified isovalue</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--isovalue=DOUBLE: Level set value that defines the interface between foreground and background [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#crop","title":"crop","text":"<p>Usage:</p> <pre><code>shapeworks  crop [args]...\n</code></pre> <p>Description: crop image down to the current region of physical space (from bounding-box or set-region commands)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#curvature","title":"curvature","text":"<p>Usage:</p> <pre><code>shapeworks  curvature [args]...\n</code></pre> <p>Description: denoises an image using curvature driven flow using curvature flow image filter</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--iterations=INT: Number of iterations [default: 10].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#divide","title":"divide","text":"<p>Usage:</p> <pre><code>shapeworks  divide [args]...\n</code></pre> <p>Description: divide an image by a constant</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --value=DOUBLE:  Value with which to divide [default: 0.0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#extract-label","title":"extract-label","text":"<p>Usage:</p> <pre><code>shapeworks  extract-label [args]...\n</code></pre> <p>Description: extracts/isolates a specific voxel label from a given multi-label volume and outputs the corresponding binary image</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--label=DOUBLE: Label value to be extracted [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#gradient","title":"gradient","text":"<p>Usage:</p> <pre><code>shapeworks  gradient [args]...\n</code></pre> <p>Description: computes gradient magnitude of an image region at each pixel using gradient magnitude filter</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#icp-image","title":"icp-image","text":"<p>Usage:</p> <pre><code>shapeworks  icp-image [args]...\n</code></pre> <p>Description: transform current image using iterative closest point (ICP) 3D rigid registration computed from current distance map to target distance map</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--target=STRING: Distance map of target image.</p> <p>--isovalue=DOUBLE: Isovalue of distance maps used to create ICPtransform [default: 0].</p> <p>--iterations=UNSIGNED:  Number of iterations run ICP registration [default: 20].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#image-bounds","title":"image-bounds","text":"<p>Usage:</p> <pre><code>shapeworks  image-bounds [args]...\n</code></pre> <p>Description: return bounds of image, optionally with an isovalue to restrict region</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--isovalue=DOUBLE: Isovalue [default: entire image].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#image-info","title":"image-info","text":"<p>Usage:</p> <pre><code>shapeworks  image-info [args]...\n</code></pre> <p>Description: prints requested image dimensions, spacing, size, origin, direction (coordinate system), center, center of mass and bounding box [default: prints everything]</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--dims: Whether to display image dimensions [default: true].</p> <p>--spacing: Whether to display physical spacing [default: true].</p> <p>--size: Whether to display size [default: true].</p> <p>--origin: Whether to display physical origin [default: true].</p> <p>--direction: Whether to display direction [default: true].</p> <p>--center: Whether to display center. [default: true]</p> <p>--centerofmass: Whether to display center of mass. [default: true]</p> <p>--boundingbox: Whether to display bounding box. [default: true]</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#image-to-mesh","title":"image-to-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  image-to-mesh [args]...\n</code></pre> <p>Description: converts the current image to a mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-v DOUBLE, --isovalue=DOUBLE:  Isovalue to determine mesh boundary [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#intensity","title":"intensity","text":"<p>Usage:</p> <pre><code>shapeworks  intensity [args]...\n</code></pre> <p>Description: applies intensity windowing image filter</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--min=DOUBLE: Minimum value of window [default: 0].</p> <p>--max=DOUBLE: Maximum value of window [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#isolate","title":"isolate","text":"<p>Usage:</p> <pre><code>shapeworks  isolate [args]...\n</code></pre> <p>Description: finds the largest object in a binary segmentation and removes all other objects</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#multiply","title":"multiply","text":"<p>Usage:</p> <pre><code>shapeworks  multiply [args]...\n</code></pre> <p>Description: multiply an image by a constant</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --value=DOUBLE:  Value with which to multiply [default: 1.0]</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#negate","title":"negate","text":"<p>Usage:</p> <pre><code>shapeworks  negate [args]...\n</code></pre> <p>Description: negate the values in the given image</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#pad","title":"pad","text":"<p>Usage:</p> <pre><code>shapeworks  pad [args]...\n</code></pre> <p>Description: pads an image with specified value by specified number of voxels in the x-, y-, and/or z- directions; origin remains at the same location (note: negative padding to shrink an image is permitted)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--padding=INT: Pad this many voxels in ALL directions (used if set) [default: 0].</p> <p>-x INT, --padx=INT: Pad this many voxels in the x-direction [default: 0].</p> <p>-y INT, --pady=INT: Pad this many voxels in the y-direction [default: 0].</p> <p>-z INT, --padz=INT: Pad this many voxels in the z-direction [default: 0].</p> <p>--value=DOUBLE: Value used to fill padded voxels [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#read-image","title":"read-image","text":"<p>Usage:</p> <pre><code>shapeworks  read-image [args]...\n</code></pre> <p>Description: reads an image</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of file to read.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#recenter","title":"recenter","text":"<p>Usage:</p> <pre><code>shapeworks  recenter [args]...\n</code></pre> <p>Description: recenters an image by changing its origin in the image header to the physical coordinates of the center of the image</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#reflect-image","title":"reflect-image","text":"<p>Usage:</p> <pre><code>shapeworks  reflect-image [args]...\n</code></pre> <p>Description: reflect image with respect to logical image center and the specified axis</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--axis=STRING: Axis along which to reflect (X, Y, or Z).</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#resample","title":"resample","text":"<p>Usage:</p> <pre><code>shapeworks  resample [args]...\n</code></pre> <p>Description: resamples an image using new physical spacing (computes new dims)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--isospacing=DOUBLE: Use this spacing in all dimensions.</p> <p>--spacex=DOUBLE: Pixel spacing in x-direction [default: 1].</p> <p>--spacey=DOUBLE: Pixel spacing in y-direction [default: 1].</p> <p>--spacez=DOUBLE: Pixel spacing in z-direction [default: 1].</p> <p>--sizex=UNSIGNED: Output size in x-direction [default: current size].</p> <p>--sizey=UNSIGNED: Output size in y-direction [default: current size].</p> <p>--sizez=UNSIGNED: Output size in z-direction [default: current size].</p> <p>--originx=DOUBLE: Output origin in x-direction [default: current origin].</p> <p>--originy=DOUBLE: Output origin in y-direction [default: current origin].</p> <p>--originz=DOUBLE: Output origin in z-direction [default: current origin].</p> <p>--interp=CHOICE: Interpolation method to use [default: linear]. (choose from 'linear', 'nearest')</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#resize","title":"resize","text":"<p>Usage:</p> <pre><code>shapeworks  resize [args]...\n</code></pre> <p>Description: resizes an image (computes new physical spacing)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x UNSIGNED, --sizex=UNSIGNED:  Output size in x-direction [default: current size].</p> <p>-y UNSIGNED, --sizey=UNSIGNED:  Output size in y-direction [default: current size].</p> <p>-z UNSIGNED, --sizez=UNSIGNED:  Output size in z-direction [default: current size].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#rotate","title":"rotate","text":"<p>Usage:</p> <pre><code>shapeworks  rotate [args]...\n</code></pre> <p>Description: rotates image by specified value</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --rx=DOUBLE:  Physical axis around which to rotate [default: z-axis].</p> <p>-y DOUBLE, --ry=DOUBLE:  Physical axis around which to rotate [default: z-axis].</p> <p>-z DOUBLE, --rz=DOUBLE:  Physical axis around which to rotate [default: z-axis].</p> <p>--radians=DOUBLE: Angle in radians.</p> <p>--degrees=DOUBLE: Angle in degrees.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#scale-image","title":"scale-image","text":"<p>Usage:</p> <pre><code>shapeworks  scale-image [args]...\n</code></pre> <p>Description: scales image by specified value</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --sx=DOUBLE:  X scale.</p> <p>-y DOUBLE, --sy=DOUBLE:  Y scale.</p> <p>-z DOUBLE, --sz=DOUBLE:  Z scale.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#set-origin","title":"set-origin","text":"<p>Usage:</p> <pre><code>shapeworks  set-origin [args]...\n</code></pre> <p>Description: set origin</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --x=DOUBLE:  X value of origin [default: 0].</p> <p>-y DOUBLE, --y=DOUBLE:  Y value of origin [default: 0].</p> <p>-z DOUBLE, --z=DOUBLE:  Z value of origin [default: 0].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#set-region","title":"set-region","text":"<p>Usage:</p> <pre><code>shapeworks  set-region [args]...\n</code></pre> <p>Description: set the current (physical) region to the specified min/max in each direction, for use with downstreams commands such as crop (note: could instead use the image-bounds command with an isovalue)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--xmin=DOUBLE: Minimum X.</p> <p>--xmax=DOUBLE: Maximum X.</p> <p>--ymin=DOUBLE: Minimum Y.</p> <p>--ymax=DOUBLE: Maximum Y.</p> <p>--zmin=DOUBLE: Minimum Z.</p> <p>--zmax=DOUBLE: Maximum Z.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#set-spacing","title":"set-spacing","text":"<p>Usage:</p> <pre><code>shapeworks  set-spacing [args]...\n</code></pre> <p>Description: set spacing</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --x=DOUBLE:  x value of spacing [default: 1].</p> <p>-y DOUBLE, --y=DOUBLE:  y value of spacing [default: 1].</p> <p>-z DOUBLE, --z=DOUBLE:  z value of spacing [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#sigmoid","title":"sigmoid","text":"<p>Usage:</p> <pre><code>shapeworks  sigmoid [args]...\n</code></pre> <p>Description: computes sigmoid function pixel-wise using sigmoid image filter</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--alpha=DOUBLE: Value of alpha [default: 10].</p> <p>--beta=DOUBLE: Value of beta [default: 10].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#subtract","title":"subtract","text":"<p>Usage:</p> <pre><code>shapeworks  subtract [args]...\n</code></pre> <p>Description: subtract a value from each pixel in this image and/or subtract another image in a pixelwise manner</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --value=DOUBLE:  Value to subtract from each pixel [default: 0.0].</p> <p>--name=STRING: Name of image to subtract pixelwise.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#topo-preserving-smooth","title":"topo-preserving-smooth","text":"<p>Usage:</p> <pre><code>shapeworks  topo-preserving-smooth [args]...\n</code></pre> <p>Description: helper command that applies gradient and sigmoid filters to create a feature image for the TPLevelSet filter; note that a curvature flow filter is sometimes applied to the image before this</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--scaling=DOUBLE: Scale for TPLevelSet level set filter [default: 20].</p> <p>--alpha=DOUBLE: Value of alpha for sigmoid fitler [default: 10].</p> <p>--beta=DOUBLE: Value of beta for sigmoid fitler [default: 10].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#tp-levelset","title":"tp-levelset","text":"<p>Usage:</p> <pre><code>shapeworks  tp-levelset [args]...\n</code></pre> <p>Description: segments structures in image using topology preserving geodesic active contour level set filter</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--featureimage=STRING:  Path of feature image for filter</p> <p>--scaling=DOUBLE: Value of scale [default: 20].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#translate-image","title":"translate-image","text":"<p>Usage:</p> <pre><code>shapeworks  translate-image [args]...\n</code></pre> <p>Description: translates image by specified physical (image space) distance</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--centerofmass: Use center of mass [default: false].</p> <p>-x DOUBLE, --tx=DOUBLE:  X distance.</p> <p>-y DOUBLE, --ty=DOUBLE:  Y distance.</p> <p>-z DOUBLE, --tz=DOUBLE:  Z distance.</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#warp-image","title":"warp-image","text":"<p>Usage:</p> <pre><code>shapeworks  warp-image [args]...\n</code></pre> <p>Description: finds the warp between the source and target landmarks and transforms image by this warp</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--source=STRING: Path to source landmarks.</p> <p>--target=STRING: Path to target landmarks.</p> <p>--stride=INT: Every stride points will be used for warping [default: 1].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#write-image","title":"write-image","text":"<p>Usage:</p> <pre><code>shapeworks  write-image [args]...\n</code></pre> <p>Description: writes the current image (determines type by its extension)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of file to write.</p> <p>--compressed=BOOL: Whether to compress file [default: true].</p> <p>Back to Top</p> <p>Back to Image Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-commands","title":"Mesh Commands","text":""},{"location":"tools/ShapeWorksCommands.html#bounding-box-mesh","title":"bounding-box-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  bounding-box-mesh [args]...\n</code></pre> <p>Description: compute bounding box of mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--names :  Paths to meshes (must be followed by <code>--</code>), ex: \"bounding-box-mesh --names *.vtk -- --center 1\") <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#clip-closed-surface","title":"clip-closed-surface","text":"<p>Usage:</p> <pre><code>shapeworks  clip-closed-surface [args]...\n</code></pre> <p>Description: clips mesh resulting in a closed surface</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--px=DOUBLE: Value of point.x for cutting plane [default: 0].</p> <p>--py=DOUBLE: Value of point.y for cutting plane [default: 0].</p> <p>--pz=DOUBLE: Value of point.z for cutting plane [default: 0].</p> <p>--nx=DOUBLE: Value of normal.x for cutting plane [default: 0].</p> <p>--ny=DOUBLE: Value of normal.y for cutting plane [default: 0].</p> <p>--nz=DOUBLE: Value of normal.z for cutting plane [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#clip-mesh","title":"clip-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  clip-mesh [args]...\n</code></pre> <p>Description: clips mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--px=DOUBLE: Value of point.x for cutting plane [default: 0].</p> <p>--py=DOUBLE: Value of point.y for cutting plane [default: 0].</p> <p>--pz=DOUBLE: Value of point.z for cutting plane [default: 0].</p> <p>--nx=DOUBLE: Value of normal.x for cutting plane [default: 0].</p> <p>--ny=DOUBLE: Value of normal.y for cutting plane [default: 0].</p> <p>--nz=DOUBLE: Value of normal.z for cutting plane [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#closest-point","title":"closest-point","text":"<p>Usage:</p> <pre><code>shapeworks  closest-point [args]...\n</code></pre> <p>Description: returns closest point to given point on mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--x=DOUBLE: Value of x for point.</p> <p>--y=DOUBLE: Value of y for point.</p> <p>--z=DOUBLE: Value of z for point.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#compare-mesh","title":"compare-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  compare-mesh [args]...\n</code></pre> <p>Description: compare two meshes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Compare this mesh with another.</p> <p>--epsilon=DOUBLE: Epsilon [default: -1].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#compute-normals","title":"compute-normals","text":"<p>Usage:</p> <pre><code>shapeworks  compute-normals [args]...\n</code></pre> <p>Description: computes and adds oriented point and cell normals</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#compute-thickness","title":"compute-thickness","text":"<p>Usage:</p> <pre><code>shapeworks  compute-thickness [args]...\n</code></pre> <p>Description: Computes thickness values each mesh vertex and output vtk meshes with scalar field defined</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--image=STRING: Path of image.</p> <p>--distance_transform=STRING:  Path of distance_transform.</p> <p>--max_dist=DOUBLE: Maximum distance to determine thickness</p> <p>--median_radius=DOUBLE:  Median radius for smoothing, multiplier of average edge length</p> <p>--distance_mesh=STRING:  Path to write distance mesh.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#coverage","title":"coverage","text":"<p>Usage:</p> <pre><code>shapeworks  coverage [args]...\n</code></pre> <p>Description: creates mesh of coverage between two meshes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to other mesh with which to create coverage.</p> <p>--allowbackintersections=BOOL:  Allow back-intersections in coverage calculation [default: true].</p> <p>--anglethreshold=DOUBLE:  This checks the cosine between the ray\u2019s direction vector (e1) and the normal at the intersection point (e2) [default: 0].</p> <p>--backsearchradius=DOUBLE:  Max distance of a back-intersection [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#distance","title":"distance","text":"<p>Usage:</p> <pre><code>shapeworks  distance [args]...\n</code></pre> <p>Description: computes the distance between two meshes, printing the largest distance between any point from source to target, target to source, and the Hausdorff distance (the largest of these two)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Filename of other mesh.</p> <p>--method=CHOICE: Method used to compute distance (point-to-point or point-to-cell) [default: point-to-cell]. (choose from 'point-to-point', 'point-to-cell')</p> <p>--ids=BOOL: Set shared field to the ids of the closest points/cells instead of the distances [default: false].</p> <p>--summary=BOOL: Print largest distance of any point in mesh to target [default: true].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#field-mean","title":"field-mean","text":"<p>Usage:</p> <pre><code>shapeworks  field-mean [args]...\n</code></pre> <p>Description: prints the mean of the given field</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>--type=CHOICE: Type of field to fetch (point or face). (choose from 'point', 'face')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#field-names","title":"field-names","text":"<p>Usage:</p> <pre><code>shapeworks  field-names [args]...\n</code></pre> <p>Description: prints all the field names present in mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#field-range","title":"field-range","text":"<p>Usage:</p> <pre><code>shapeworks  field-range [args]...\n</code></pre> <p>Description: prints the range of the given field</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>--type=CHOICE: Type of field to fetch (point or face). (choose from 'point', 'face')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#field-std","title":"field-std","text":"<p>Usage:</p> <pre><code>shapeworks  field-std [args]...\n</code></pre> <p>Description: prints the standard deviation of the given field</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>--type=CHOICE: Type of field to fetch (point or face). (choose from 'point', 'face')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#fill-holes","title":"fill-holes","text":"<p>Usage:</p> <pre><code>shapeworks  fill-holes [args]...\n</code></pre> <p>Description: finds holes in a mesh and closes them</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#fix-element","title":"fix-element","text":"<p>Usage:</p> <pre><code>shapeworks  fix-element [args]...\n</code></pre> <p>Description: fix element winding of mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#geodesic-distance","title":"geodesic-distance","text":"<p>Usage:</p> <pre><code>shapeworks  geodesic-distance [args]...\n</code></pre> <p>Description: computes geodesic distance between two vertices on mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--v1=INT: Index of first point in mesh.</p> <p>--v2=INT: Index of second point in mesh.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#geodesic-distance-landmark","title":"geodesic-distance-landmark","text":"<p>Usage:</p> <pre><code>shapeworks  geodesic-distance-landmark [args]...\n</code></pre> <p>Description: computes geodesic distance between a point (landmark) and each vertex on mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--x=DOUBLE: Value of x for landmark point.</p> <p>--y=DOUBLE: Value of y for landmark point.</p> <p>--z=DOUBLE: Value of z for landmark point.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#get-field","title":"get-field","text":"<p>Usage:</p> <pre><code>shapeworks  get-field [args]...\n</code></pre> <p>Description: gets field of mesh with given name</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>--type=CHOICE: Type of field to get (point or face). (choose from 'point', 'face')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#get-field-value","title":"get-field-value","text":"<p>Usage:</p> <pre><code>shapeworks  get-field-value [args]...\n</code></pre> <p>Description: prints value of element at index in given field of mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>-i INT, --index=INT: index of value to return [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#invert-normal","title":"invert-normal","text":"<p>Usage:</p> <pre><code>shapeworks  invert-normal [args]...\n</code></pre> <p>Description: flips the normal</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#landmark-geodesics","title":"landmark-geodesics","text":"<p>Usage:</p> <pre><code>shapeworks  landmark-geodesics [args]...\n</code></pre> <p>Description: Computes geodesic distance to each landmark and store as a field</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--landmarks=STRING: Path of landmarks file.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mean-normals","title":"mean-normals","text":"<p>Usage:</p> <pre><code>shapeworks  mean-normals [args]...\n</code></pre> <p>Description: computes average normals for each point in given set of meshes</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--names :  Paths to meshes (must be followed by <code>--</code>), ex: \"mean-normals --names *.vtk --\") <p>--generatenormals=BOOL:  Auto generate normals if the mesh does not have normals [default: true].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-bounds","title":"mesh-bounds","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-bounds [args]...\n</code></pre> <p>Description: return physical bounds of mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-curvature","title":"mesh-curvature","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-curvature [args]...\n</code></pre> <p>Description: computes and adds curvature</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--type=CHOICE: Curvature type to use [default: principal]. (choose from 'principal', 'gaussian', 'mean')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-info","title":"mesh-info","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-info [args]...\n</code></pre> <p>Description: prints requested mesh center, center of mass, number of vertices, number of faces and bounding box [default: prints everything]</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--vertices: Whether to display number of vertices [default: true].</p> <p>--faces: Whether to display number of faces [default: true].</p> <p>--center: Whether to display center [default: true].</p> <p>--centerofmass: Whether to display center of mass [default: true].</p> <p>--boundingbox: Whether to display bounding box [default: true].</p> <p>--fieldnames: Whether to display field names [default: true].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-largest-component","title":"mesh-largest-component","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-largest-component [args]...\n</code></pre> <p>Description: extract the largest connected component from the mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-to-dt","title":"mesh-to-dt","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-to-dt [args]...\n</code></pre> <p>Description: converts mesh to a distance transform, using unit spacing by default</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--sx=DOUBLE: Spacing of output image in x-direction [default: unit spacing].</p> <p>--sy=DOUBLE: Spacing of output image in y-direction [default: unit spacing].</p> <p>--sz=DOUBLE: Spacing of output image in z-direction [default: unit spacing].</p> <p>--pad=INT: Number of pixels to pad the output region [default: 1].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#mesh-to-image","title":"mesh-to-image","text":"<p>Usage:</p> <pre><code>shapeworks  mesh-to-image [args]...\n</code></pre> <p>Description: converts mesh to a binary segmentation image, using unit spacing by default</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--sx=DOUBLE: Spacing of output image in x-direction [default: unit spacing].</p> <p>--sy=DOUBLE: Spacing of output image in y-direction [default: unit spacing].</p> <p>--sz=DOUBLE: Spacing of output image in z-direction [default: unit spacing].</p> <p>--pad=DOUBLE: Pad the region to extract [default: 0.0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#probe-volume","title":"probe-volume","text":"<p>Usage:</p> <pre><code>shapeworks  probe-volume [args]...\n</code></pre> <p>Description: probe feature volumes at each mesh vertex and output vtk meshes with scalar field defined based on such probing process</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--image=STRING: Path of image.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#read-mesh","title":"read-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  read-mesh [args]...\n</code></pre> <p>Description: reads a mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of file to read.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#reflect-mesh","title":"reflect-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  reflect-mesh [args]...\n</code></pre> <p>Description: reflect meshes with respect to a specified center and specific axis</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--axis=STRING: Axis along which to reflect (X, Y, or Z).</p> <p>-x DOUBLE, --originx=DOUBLE:  Origin about which reflection occurs in x-direction [default: 0].</p> <p>-y DOUBLE, --originy=DOUBLE:  Origin about which reflection occurs in y-direction [default: 0].</p> <p>-z DOUBLE, --originz=DOUBLE:  Origin about which reflection occurs in z-direction [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#remesh","title":"remesh","text":"<p>Usage:</p> <pre><code>shapeworks  remesh [args]...\n</code></pre> <p>Description: applies remeshing using approximated centroidal voronoi diagrams for a given number of vertices and adaptivity</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--target=DOUBLE: Target number of vertices.</p> <p>--adaptivity=DOUBLE: 0-2, low adaptivity to high adaptivity</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#remesh-percent","title":"remesh-percent","text":"<p>Usage:</p> <pre><code>shapeworks  remesh-percent [args]...\n</code></pre> <p>Description: applies remeshing using approximated centroidal voronoi diagrams for a given percentage of vertices and adaptivity</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--percentage=DOUBLE: Target percentage number of vertices</p> <p>--adaptivity=DOUBLE: 0-2, low adaptivity to high adaptivity</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#scale-mesh","title":"scale-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  scale-mesh [args]...\n</code></pre> <p>Description: scales mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --sx=DOUBLE:  X scale.</p> <p>-y DOUBLE, --sy=DOUBLE:  Y scale.</p> <p>-z DOUBLE, --sz=DOUBLE:  Z scale.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#set-field","title":"set-field","text":"<p>Usage:</p> <pre><code>shapeworks  set-field [args]...\n</code></pre> <p>Description: adds the current field to the current mesh with the given name.</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>--type=CHOICE: Type of field to set (point or face). (choose from 'point', 'face')</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#set-field-value","title":"set-field-value","text":"<p>Usage:</p> <pre><code>shapeworks  set-field-value [args]...\n</code></pre> <p>Description: sets value of element at index in given field of mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of scalar field.</p> <p>-i INT, --index=INT: index of value to return [default: 0].</p> <p>--value=DOUBLE: value to be set [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#smooth","title":"smooth","text":"<p>Usage:</p> <pre><code>shapeworks  smooth [args]...\n</code></pre> <p>Description: applies laplacian smoothing</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--iterations=INT: Number of iterations [default: 0].</p> <p>--relaxation=DOUBLE: Amount of displacement for a vertex to move in each iteration [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#smooth-sinc","title":"smooth-sinc","text":"<p>Usage:</p> <pre><code>shapeworks  smooth-sinc [args]...\n</code></pre> <p>Description: applies windowed sinc smoothing</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--iterations=INT: Number of iterations [default: 0].</p> <p>--passband=DOUBLE: Set the passband value for the windowed sinc filter [default: 0].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#transform-mesh","title":"transform-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  transform-mesh [args]...\n</code></pre> <p>Description: transform mesh to target mesh using iterative closest point (ICP) using specified landmark transform (rigid, similarity, or affine)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--target=STRING: Filename of target mesh.</p> <p>--type=CHOICE: Alignment type to use [default: similarity]. (choose from 'rigid', 'similarity', 'affine')</p> <p>--iterations=UNSIGNED:  Number of iterations run [default: 10].</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#translate-mesh","title":"translate-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  translate-mesh [args]...\n</code></pre> <p>Description: translates mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>-x DOUBLE, --tx=DOUBLE:  X distance.</p> <p>-y DOUBLE, --ty=DOUBLE:  Y distance.</p> <p>-z DOUBLE, --tz=DOUBLE:  Z distance.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#warp-mesh","title":"warp-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  warp-mesh [args]...\n</code></pre> <p>Description: warps a mesh given reference and target particles</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--reference_mesh=STRING:  Name of reference mesh.</p> <p>--reference_points=STRING:  Name of reference points.</p> <p>--landmark_file=STRING:  Optional Argument to specify the name of Landmark file, if landmarks are available for warping</p> <p>--target_points :  Names of target points (must be followed by <code>--</code>), ex: \"... --target_points *.particles -- ... <p>--save_dir=STRING: Optional: Path to the directory where the mesh files will be saved</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#write-mesh","title":"write-mesh","text":"<p>Usage:</p> <pre><code>shapeworks  write-mesh [args]...\n</code></pre> <p>Description: writes the current mesh</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Name of file to write.</p> <p>--binary=BOOL: Whether to write file as binary.</p> <p>Back to Top</p> <p>Back to Mesh Commands</p>"},{"location":"tools/ShapeWorksCommands.html#optimize-commands","title":"Optimize Commands","text":""},{"location":"tools/ShapeWorksCommands.html#optimize","title":"optimize","text":"<p>Usage:</p> <pre><code>shapeworks  optimize [args]...\n</code></pre> <p>Description: generate a particle system</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to project file.</p> <p>--progress: Show progress [default: false].</p> <p>--xmlconsole: XML console output [default: false].</p> <p>Back to Top</p> <p>Back to Optimize Commands</p>"},{"location":"tools/ShapeWorksCommands.html#particlesystem-commands","title":"ParticleSystem Commands","text":""},{"location":"tools/ShapeWorksCommands.html#compactness","title":"compactness","text":"<p>Usage:</p> <pre><code>shapeworks  compactness [args]...\n</code></pre> <p>Description: Compute compactness of a loaded particle system</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--nmodes=INT: Number of modes to use [default: 1].</p> <p>--saveto=STRING: Save the scree plots for all modes to a file.</p> <p>Back to Top</p> <p>Back to ParticleSystem Commands</p>"},{"location":"tools/ShapeWorksCommands.html#generalization","title":"generalization","text":"<p>Usage:</p> <pre><code>shapeworks  generalization [args]...\n</code></pre> <p>Description: compute generalization of a loaded particle system</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--nmodes=INT: Number of modes to use [default: 1].</p> <p>--saveto=STRING: Save the reconstructions sorted by generalization along with the mapping to the original shape.</p> <p>Back to Top</p> <p>Back to ParticleSystem Commands</p>"},{"location":"tools/ShapeWorksCommands.html#read-particle-system","title":"read-particle-system","text":"<p>Usage:</p> <pre><code>shapeworks  read-particle-system [args]...\n</code></pre> <p>Description: reads a particle system</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--names :  Paths to .particle files (must be followed by <code>--</code>), ex: \"--names *.particle -- next-command...\") <p>Back to Top</p> <p>Back to ParticleSystem Commands</p>"},{"location":"tools/ShapeWorksCommands.html#specificity","title":"specificity","text":"<p>Usage:</p> <pre><code>shapeworks  specificity [args]...\n</code></pre> <p>Description: compute specificity of a loaded particle system</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--nmodes=INT: Number of modes to use [default: 1].</p> <p>--saveto=STRING: Save the reconstructions sorted by specificity along with the mapping to the original shape.</p> <p>Back to Top</p> <p>Back to ParticleSystem Commands</p>"},{"location":"tools/ShapeWorksCommands.html#project-commands","title":"Project Commands","text":""},{"location":"tools/ShapeWorksCommands.html#convert-project","title":"convert-project","text":"<p>Usage:</p> <pre><code>shapeworks  convert-project [args]...\n</code></pre> <p>Description: convert a shapeworks project (xlsx or swproj)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--name=STRING: Path to input project file (xlsx or swproj).</p> <p>--output=STRING: Path to output project file (xlsx or swproj).</p> <p>Back to Top</p> <p>Back to Project Commands</p>"},{"location":"tools/ShapeWorksCommands.html#shapeworks-commands_1","title":"Shapeworks Commands","text":""},{"location":"tools/ShapeWorksCommands.html#seed","title":"seed","text":"<p>Usage:</p> <pre><code>shapeworks  seed [args]...\n</code></pre> <p>Description: sets the seed for random number generation (useful for debugging)</p> <p>Options:</p> <p>-h, --help: show this help message and exit</p> <p>--value=INT: Value of seed.</p> <p>Back to Top</p> <p>Back to Shapeworks Commands</p>"},{"location":"use-cases/right-ventricle.html","title":"Right Ventricle: Highly Variable Shapes","text":""},{"location":"use-cases/right-ventricle.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>This use case demonstrates using ShapeWorks tools to perform the following.</p> <ul> <li>Model the highly variable shapes of the right ventricle</li> <li>Study the group difference of right ventricle shape between control and patients</li> <li>Build a shape model where shapes are given as binary segmentations</li> <li>Groom a dataset that only contains shapes</li> </ul> <p>In this study, we have two sets of data, the control group with 6 subjects, and the patient group consists of 26 subjects. For each group, we have diastole and systole segmentations. The goal is to study the variation of the systole and diastole in the two groups. We pre-process/groom diastole and systole data and then optimize the particle system for them, independently. Then using the group difference analysis tool of ShapeWorks, we can quantify and study the difference of variation in control and patient groups from diastole to systole stage of heart.</p> <p>Important</p> <p>This use case is not yet released!</p>"},{"location":"use-cases/right-ventricle.html#grooming-steps","title":"Grooming Steps","text":"<p>For a description of the grooming tools and parameters, see: How to Groom Your Dataset?.</p> <ol> <li>Isotropic Resampling: Binary segmentations are resampled to have an isotropic voxel spacing using a user-defined spacing. This step could also be used to produce images and segmentations with smaller voxel spacing, and thereby reduce aliasing artifacts (i.e., staircase/jagged surface) due to binarization for segmentations.</li> <li>Apply Padding: Segmentations that touch the image boundary will have an artificial hole at that intersection. Segmentations are padded by adding a user-defined number of voxels along each image direction (rows, cols, and slices) to avoid introducing artificial holes.</li> <li>Center-of-Mass Alignment: This translational alignment step is performed before rigidly aligning the samples to a shape reference. This factors out translations to reduce the risk of misalignment and allow for a medoid sample to be automatically selected as the reference for rigid alignment.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) distance transform of the segmentations, then selecting the sample closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: All of the segmentations are then aligned to the selected reference using rigid alignment, which factors out the rotation and remaining translation. </li> <li>Cropping: The segmentations are cropped so that all of the samples are within the same bounding box. The bounding box parameters are computed based on the biggest bounding box that encapsulates all the segmentations of the given dataset.</li> <li>Distance Transform: Finally, the signed distance transform is computed, and the dataset is now ready for the optimize phase.</li> </ol> <p></p>"},{"location":"use-cases/right-ventricle.html#supported-tags","title":"Supported Tags","text":"<pre><code>        --use_subsample --num_subsample --skip_grooming --tiny_test\n</code></pre>"},{"location":"use-cases/right-ventricle.html#optimizing-parameters","title":"Optimizing Parameters","text":""},{"location":"use-cases/right-ventricle.html#analyzing-shape-model","title":"Analyzing Shape Model","text":""},{"location":"use-cases/use-cases.html","title":"Getting Started with Use Cases","text":""},{"location":"use-cases/use-cases.html#what-is-a-use-case","title":"What is a Use Case?","text":"<p>Use cases are Python examples that can help users get familiar with ShapeWorks and the general shape modeling workflow. The full dataset associated with each use case (input and output) is available on ShapeWorks Data Portal and downloads automatically when the use case runs.</p> <p>Most use cases demomstrates the Shape Modeling Workflow:</p> <ol> <li>Grooming a dataset for optimization.</li> <li>Optimizing a correpsondence model on the groomed data.</li> <li>Analyzing the correspondence model.</li> </ol> <p>However, some do not involve grooming, and some only demonstrate the functionality of ShapeWorks statistical tools. For an overview and brief description of the available use cases, see Examples.</p>"},{"location":"use-cases/use-cases.html#running-a-use-case","title":"Running A Use Case","text":"<p>The use cases are located at: <code>Examples/Python/</code>. To run a use case, run the following commands with the <code>shapeworks</code> environment activated: <pre><code>$ cd /path/to/shapeworks/Examples/Python\n$ python RunUseCase.py [use case name]\n</code></pre></p> <p>To see the names currently supported use cases and the complete list of optional arguments, run: <pre><code>$ python RunUseCase.py --help\n</code></pre></p> <p>Using bash on Windows</p> <p>Windows also has several Unix shells such as git-bash available. These also work with <code>conda activate shapeworks</code> in the same way. However, there is one crucial issue: running Python scripts requires prefixing with <code>winpty</code>. For example, <code>winpty python RunUseCase.py ...</code>.</p> <p>When a use case is run, the dataset required for the use case is automatically downloaded. This requires registering for a free ShapeWorks account by visiting the ShapeWorks Data Portal.</p> <p>Danger</p> <p>Do not use the same password as for your bank account or email.</p> <p>After registering a free account, you can log in from within the script.  Note: You are only required to enter your credentials the first time you run a use case. </p>"},{"location":"use-cases/use-cases.html#uploading-a-dataset","title":"Uploading a Dataset","text":"<p>Uploading a dataset requires the following parameters:</p> <ol> <li> <p>dataset_name - The name of the dataset and the same name must be used while running the usecase.</p> </li> <li> <p>licence_filename - File location which contains licence information of the dataset</p> </li> <li> <p>ack_filename - File location which contains acknowledge information of the dataset</p> </li> <li> <p>description - Description of the dataset</p> </li> <li> <p>project_file - File location which contains the project file of dataset using by the usecase which needs to be uploaded. (must be in swproj extension)</p> </li> <li> <p>overwrite - This is a boolean variable which controls any existing dataset with same name should be deleted or not. if True is passed it will delete the existing dataset. The default value is True.</p> </li> </ol> <p>For example refer the following command <pre><code>$ import shapeworks as sw\n$ sw.upload_dataset(dataset_name, licence_filename, acknowledgement_filename, description, project_file, overwrite)\n</code></pre></p>"},{"location":"use-cases/use-cases.html#downloading-a-dataset","title":"Downloading a Dataset","text":"<p>Downloading a Dataset requires the following parameters:</p> <ol> <li> <p>datasetName - The name of the dataset which needs to be downloaded.</p> </li> <li> <p>outputDirectory - The location where the dataset should be downloaded.</p> </li> </ol> <p>For example refer the following command <pre><code>$ python portal.py [dataset name] [output directory]\n</code></pre></p>"},{"location":"use-cases/use-cases.html#use-case-data","title":"Use Case Data","text":"<p>When a use case runs, the appropriate zipped data downloads to <code>Examples/Python/Data/</code>. The data is then extracted to <code>Examples/Python/output/use_case_name/</code> where all the output from running the use case is also saved.</p> <p>The downloaded data includes the raw input data (segmentations, meshes, and/or images) as well as the expected output from both the final grooming step of the use case (i.e., distance transforms) and the optimized shape model (particle files and project excel sheets). </p> <p>An \"project.swproj\" file is included so that the resulting shape model can be visualized in Studio without running the use case. For example, to view the shape model downloaded for the ellipsoid use case run: <pre><code>$ cd Examples/Python/Output/ellipsoid/ellipsoid_1mode/\n$ cp shape_model ../\n$ ShapeWorksStudio ellipsoid_multiscale.xlsx or\n$ ShapeWorksStudio ellipsoid_multiscale.swproj\n</code></pre></p>"},{"location":"use-cases/use-cases.html#use-cases-arguments","title":"Use Cases Arguments","text":"<p>When calling <code>RunUseCase.py</code>, various optional arguments can be used.  To see the complete list of supported arguments from the command line, run: <pre><code>$ python RunUseCase.py --help\n</code></pre> A description of each optional argument and how to use it is provided below.</p>"},{"location":"use-cases/use-cases.html#-use_subsample","title":"--use_subsample","text":"<p>Users can run a use case on a subset of the data by adding the <code>--use_subsample</code> argument followed by the <code>--num_subsample</code> argument with the number of samples you wish to use. This will select a representative subset of the specified sample size to run through the pipeline so that the use case runs faster and uses less memory. The subset is determined by running clustering, then picking one sample from each cluster so that the resulting subset is representative of all the data. If <code>--use_subsample</code> is used without <code>--num_subsample</code>, it will use the default number of subsamples which is 3. Note the entire dataset will still be downloaded to run the clustering.</p> <pre><code>$ python RunUseCase.py [use case name] --use_subsample --num_subsample 10\n</code></pre>"},{"location":"use-cases/use-cases.html#-use_single_scale","title":"--use_single_scale","text":"<p>Use cases can be run with multi-scale or single-scale optimization. In both cases, particles on each shape sample are initialized using the particle splitting strategy starting from a single particle (or a given set of landmarks) until reaching the required number of particles. The optimized particles at each scale are used to initialize the next scale. At each scale, particles undergo initialization and optimization stages. The multi-scale argument triggers both the initialization and optimization stages. The single-scale mode uses the initialization stage at each scale and runs the optimization stage when the required number of particles is reached (i.e., at the last scale). </p> <p>The differences between initialization and optimization stages are: </p> <ol> <li> <p>How important the correspondence (inter-surface) objective is compared to the surface sampling (intra-surface) term using a relative weighting parameter. Hence, the  <code>initial_relative_weighting</code> parameter is the weight used in the initialization stage, and the <code>relative_weighting</code> is the weight used for the optimization stage.</p> </li> <li> <p>How the notion of correspondence (inter-surface) is quantified. In initialization, especially when we do not have enough particles to describe the geometry of each surface, we use mean energy (i.e., pushing all shapes in the shape space to the mean shape or, in other words, the covariance matrix is assumed to be identity). In optimization, we use the entropy of the distribution of the shapes (assuming Gaussian-distributed shapes), which is quantified based on the covariance matrix. In the multi-scale setting, we can use shape statistics at later scales using the <code>use_shape_statistics_after</code> parameter, where we have more particles that can reveal the covariance structure.The default mode is multi-scale. To run single-scale, use the <code>--use_single_scale</code> argument.</p> </li> </ol> <pre><code>$ python RunUseCase.py [use case name] --use_single_scale\n</code></pre>"},{"location":"use-cases/use-cases.html#-mesh_mode","title":"--mesh_mode","text":"<p>Use cases that optimize on distance transforms can be run in mesh mode to optimize on meshes instead. When the <code>--mesh_mode</code> argument is used, groomed distance transforms are converted to meshes (by extracting the isosurface at zero), and those meshes are passed to the optimizer. The <code>--mesh_mode</code> argument does not affect mesh-based use cases.</p> <pre><code>$ python RunUseCase.py [insert name of image-based use case here] --mesh_mode\n</code></pre>"},{"location":"use-cases/use-cases.html#-tiny_test","title":"--tiny_test","text":"<p>Users can run a fast version of the use case using the <code>--tiny_test</code> argument. This runs on a subset of the data for fewer optimization iterations to verify ShapeWorks has been properly installed. It is meant to quickly test that use cases can run, not to create a good correspondence model. Only a subset of the data will be downloaded directly in the <code>Output</code> folder for the tiny test, and no zip file will be downloaded in the <code>Data</code> folder. No new data will be downloaded if the data has already been unzipped in the <code>Output</code> folder.</p> <pre><code>$ python RunUseCase.py [use case name] --tiny_test\n</code></pre>"},{"location":"use-cases/use-cases.html#-verify","title":"--verify","text":""},{"location":"use-cases/use-cases.html#use-case-workflow-overview","title":"Use Case Workflow Overview","text":"<p>The use cases which demomstrate the Shape Modeling Workflow follow this general outline:</p>"},{"location":"use-cases/use-cases.html#grooming","title":"Grooming","text":"<p>Grooming involves pre-processing steps to prepare the data for optimization and calculate the alignment transforms which will be passed to the optimizer. This involves generating distance transforms if starting with binary segmentations or generating groomed meshes if starting with unaligned meshes and calculating the alignment transformation matrix for each shape. The grooming steps are unique to each use case, but common steps are explained here: Common Grooming Steps.</p> <p>Note some use cases start with pre-aligned data that does not require grooming. </p> <p>Prefix Transforms</p> <p>Worflow Switched from Transforming the Data (e.g. centering) to Passing the Transform as the Prefix Transform.</p> <p>Instead of passing groomed and aligned shapes to the optimizer, now, the use cases only perform the grooming steps that do not change the co-ordinates of the shape. For the grooming steps that alter the co-ordinates, the transformation matrices are calculated and sent to the optimizer to be applied(pre-multiplied) after optimization. See How to Step Up Optimization? page for details regarding setting up the project sheet.</p>"},{"location":"use-cases/use-cases.html#optimization","title":"Optimization","text":"<p>Optimization involves automatically computing a dense set of corresponding landmark positions from the groomed shape representations (distance transforms or meshes). Optimization can be run with different parameters in ShapeWorksStudio or via the command line. In the use cases, optimization parameters are defined in the optimize sheet of the project.xlsx or project.swproj and optimization is run from the command line. </p> <p>For a full decription of parameters, please see: optimization parameters. </p>"},{"location":"use-cases/use-cases.html#analysis-of-results","title":"Analysis of Results","text":"<p>The resulting correspondence points from optimization can be viewed and analyzed in ShapeWorks Studio. This is a Qt and VTK-based graphical user interface (GUI), that allows visualizing the correspondence model for each shape sample where particle coloring is used to reflect correspondence among shapes. After optimization, the use cases create and open an <code>project.xlsx</code> or <code>project.swproj</code> file for viewing the results in Studio. Studio opens automatically when the use case finishes running. </p> <p> <p>This <code>project.xlsx</code> or <code>project.swproj</code> file can be reopened at any time after running the use case for subsequent analysis by calling <code>ShapeworksStudio project.xlsx</code> or <code>ShapeworksStudio project.swproj</code>. For a full description of how to analyze results in Studio, see Analyzing Results.</p>"},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html","title":"Ellipsoid: Cutting Planes","text":""},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_cut</code> example demonstrates using multiple cutting planes to constrain the distribution of particles on ellipsoids which are already aligned. This can be used in modeling scenarios where statistical modeling/analysis is needed for a region-of-interest on the anatomy/object-class at hand without having to affect the input data. </p> <p>Here is an example of where the cutting planes intersect and ellipsoid:</p> <p>"},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html#grooming-steps","title":"Grooming Steps","text":"<p>This use case starts with pre-aligned segmentations. The only grooming step is computing the signed distance transform for each segmentation. </p>"},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --mesh_mode --tiny_test</p>"},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\": 32,\n        \"use_normals\": 1,\n        \"normals_strength\": 15,\n        \"checkpointing_interval\": 200,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 3000,\n        \"optimization_iterations\": 3000,\n        \"starting_regularization\": 100,\n        \"ending_regularization\": 10,\n        \"recompute_regularization_interval\": 2,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 15,\n        \"initial_relative_weighting\": 0.05,\n        \"verbosity\": 0,\n}\n</code></pre> <p>Here <code>cutting_plane_counts</code> is two for every ellipsoid and there are 15 ellipsoids so it is a list of twos of length 15. The <code>cutting_planes</code> parameter is a list of the two cutting plane points of length 15.</p>"},{"location":"use-cases/constraint-based/ellipsoid-cutting-planes.html#analyzing-shape-models","title":"Analyzing Shape Models","text":"<p>Below we can see the resulting shape model where correspondence points do not lie beyond the cutting planes and only a secton of the ellipsoids are modeled. </p> <p></p>"},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html","title":"Studio Femur: Shape Model from Meshes with Cutting Planes Using Studio (WIP)","text":""},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>femur</code> use case demonstrates using the shape modeling workflow on a real-world femur dataset. The femur shapes are represented as triangular surface meshes and the dataset also contains corresponding imaging data (e.g., CT).</p> <p>This is a tutorial on how to use this in Studio. The files will be available in Shapeworks/Examples/Studio/FemurConstraints for you to follow along or see the results.</p>"},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html#starting-a-new-project-with-constraints","title":"Starting a New Project with Constraints","text":"<p>Follow these instructions to start a new project and define constraints on your shapes:</p> <ol> <li>Open ShapeWorks Studio and click \"Start New Project\" from the Splash Screen. If you just want to explore and not follow, you can just load Shapeworks/Examples/Studio/FemurConstraints/FemurConstraints.xlsx.</li> <li>Drag-and-drop or import the femurs in Shapeworks/Examples/Studio/FemurConstraints.</li> <li>Follow the instructions for using constraints to define constraints. Here we define a cutting plane and a free-form constraint to each of four femurs.</li> </ol>"},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html#grooming-steps","title":"Grooming Steps","text":"<p>You can select the grooming parameters in the Groom tab and click \"Run Groom\". The default parameters work for this use case, but you can experiment with tuning them.</p> <p></p> <p>Here is what the femur meshes look like before grooming: </p> <p>The femur mesh grooming steps are:</p> <ol> <li>Reflect Meshes: In this use case, we have both right and left femur surface meshes. To align all the femurs, we choose one side to reflect.</li> <li>Smoothing and Remeshing: Meshes are smoothed and remeshed to ensure uniform vertices.</li> <li>Centering: Meshes are translated so that their center lies at [0,0,0].</li> <li>Reference Selection: The reference is selected by first computing the mean (average) mesh, then selecting the mesh closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: All of the meshes are aligned to the selected reference using rigid alignment, which factors out the rotation and translation.</li> </ol> <p>Here are the resulting groomed femurs: </p>"},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html#optimization-parameters","title":"Optimization Parameters","text":"<p>We modify the following parameters to these values for the optimization</p> <ul> <li>\"number_of_particles\" : 128</li> <li>\"optimization_iterations\" : 2000</li> <li>\"starting_regularization\" : 100</li> <li>\"ending_regularization\" : 50</li> <li>\"relative_weighting\" : 1</li> <li>\"initial_relative_weighting\" : 0.05</li> </ul> <p>Here is a video showing the entire procedure:  </p> <p>"},{"location":"use-cases/constraint-based/femur-cutting-planes-studio.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Here is the mean shape of the optimized shape mode using multi-scale optimization.</p> <p></p> <p>Note the particles are not placed below the cutting-plane constraint nor the free-form constraint. The surface extending below the particles is a surface reconstruction artifact which can be ignored.</p>"},{"location":"use-cases/constraint-based/femur-cutting-planes.html","title":"Femur: Shape Model from Meshes with Cutting Planes","text":""},{"location":"use-cases/constraint-based/femur-cutting-planes.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>femur</code> use case demonstrates using the shape modeling workflow on a real-world femur dataset. The femur shapes are represented as triangular surface meshes and the dataset also contains corresponding imaging data (e.g., CT).</p> <p>There are both left and right femurs in this dataset, thus some must be reflected so that they can all be aligned. The femur meshes have also been segmented with various shaft lengths, as can be seen below. To remove this variability so that it is not captured in the shape model, a cutting plane is used as an optimization constraint. </p> <p>Important</p> <p>Minimum of 32GB of RAM required to run the full use case.</p>"},{"location":"use-cases/constraint-based/femur-cutting-planes.html#grooming-steps","title":"Grooming Steps","text":"<p>Here is what the femur meshes look like before grooming. Some femurs are out of frame because they are not centered or aligned.  </p> <p>The femur mesh grooming steps are:</p> <ol> <li>Reflect Meshes: In this use case, we have both right and left femur surface meshes. To align all the femurs, we choose one side to reflect.</li> <li>Smoothing and Remeshing: Meshes are smoothed and remeshed to ensure uniform vertices.</li> <li>Centering: Meshes are translated so that their center lies at [0,0,0].</li> <li>Reference Selection: The reference is selected by first computing the mean (average) mesh, then selecting the mesh closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform'</li> </ol> <p>Here we show how the shapes would look like if the transforms are applied along with respective cutting planes: </p>"},{"location":"use-cases/constraint-based/femur-cutting-planes.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/constraint-based/femur-cutting-planes.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case. <pre><code>{\n        \"number_of_particles\" : 512,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\" : 200,\n        \"keep_checkpoints\" : 0,\n        \"iterations_per_split\" : 1000,\n        \"optimization_iterations\" : 500,\n        \"starting_regularization\" : 100,\n        \"ending_regularization\" : 0.1,\n        \"recompute_regularization_interval\" : 2,\n        \"domains_per_shape\" : 1,\n        \"relative_weighting\" : 10,\n        \"initial_relative_weighting\" : 0.1,\n        \"procrustes\" : 1,\n        \"procrustes_interval\" : 1,\n        \"procrustes_scaling\" : 1,\n        \"save_init_splits\" : 1,\n        \"debug_projection\" : 0,\n        \"verbosity\" : 0,\n        \"use_statistics_in_init\" : 0,\n        \"adaptivity_mode\": 0\n} \n</code></pre></p> <p>Here <code>cutting_plane_counts</code> is 49, one for every femur and the <code>cutting_planes</code> is the same cutting plane points for every femur.</p>"},{"location":"use-cases/constraint-based/femur-cutting-planes.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Here is the mean shape of the optimized shape mode using multi-scale optimization.</p> <p></p> <p>Note the particles are not placed below the cutting plane constraint. The surface extending below the particles is a surface reconstruction artifact which can be ignored.</p> <p>Here are femur samples with their optimized correspondences. </p> <p>Here is a video showing the shape modes of variation (computed using principal component analysis - PCA) of the femur dataset.</p> <p></p>"},{"location":"use-cases/contour-based/supershapes-contour.html","title":"Supershapes:Shape Model for Contour Domains","text":""},{"location":"use-cases/contour-based/supershapes-contour.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>supershapes_1mode_contour</code> use case demonstrates using ShapeWorks tools to perform optimization for N-dimensional contours. Contours are represented as a series of lines, that may be a closed loop. We consider 2D shapes generated from the supershape equation, with a single parameter sampled from a chi-squared distribution. Here is an example of the data: </p>"},{"location":"use-cases/contour-based/supershapes-contour.html#grooming-steps","title":"Grooming Steps","text":"<p>In this use case, we download pre-groomed data. The input contours are:  </p>"},{"location":"use-cases/contour-based/supershapes-contour.html#relevant-arguments","title":"Relevant Arguments","text":"<p>This use case does not support any arguments</p>"},{"location":"use-cases/contour-based/supershapes-contour.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\" : 64,\n        \"use_normals\": 0,\n        \"normals_strength\": 0.0,\n        \"keep_checkpoints\" : 0,\n        \"iterations_per_split\" : 100,\n        \"optimization_iterations\" : 500,\n        \"starting_regularization\" : 100,\n        \"ending_regularization\" : 1,\n        \"recompute_regularization_interval\" : 1,\n        \"domains_per_shape\" : 1,\n        \"relative_weighting\" : 5,\n        \"initial_relative_weighting\" : 0.1,\n        \"procrustes\" : 1,\n        \"procrustes_interval\" : 2,\n        \"procrustes_scaling\" : 1,\n        \"save_init_splits\" : 0,\n        \"verbosity\" : 0,\n        \"multiscale\": 1,\n        \"multiscale_particles\": 4,\n}\n</code></pre>"},{"location":"use-cases/contour-based/supershapes-contour.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model. </p> <p>During the generation of the input supershapes data,the n2 and n3 variables were kept constant, and only the n1 variable was varied according to values sampled from a chi squared distribution. We obtain a shape model that accurately captures this variation(first mode variance = 98%) </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html","title":"Femur Shape Model Directly from Images","text":""},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>deep_ssm</code> use case demonstrates how to get shape models from unsegmented images using deep learning on the femur data. This includes performing data augmentation as well as building, training and testing a DeepSSM model. For a detailed description of these processes, please see Data Augmentation for Deep Learning and SSMs Directly from Images. The image and shape data used for training and testing results from running the femur use case. Note running this use case does not require running the femur use case, the required data will automatically be downloaded.</p> <p>On CUDA</p> <p>This use case uses Pytorch and requires a GPU to run in a timely manner. When you source <code>install_shapeworks.sh</code>, it detects if you have a GPU and installs the version of Pytorch compatible with your version of CUDA. </p> <p>Note we only support the three most recent versions of CUDA. If your GPU requires an older CUDA version, you will need to update the Pytorch install in your shapeworks conda environment to the correct CUDA version. For more information on doing so, see pytorch.org. </p> <p>To do a quick check to see if Pytorch is running on your GPU, you can run the use case with the <code>--tiny-test</code> tag. This will quickly run the use case on a few examples and print an error if it is not running on the GPU.</p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--tiny_test</p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#use-case-pipeline","title":"Use Case Pipeline","text":"<p>The use case pipeline includes creation of a training, validation, and testing sets. This involves particle optimization, image grooming, and data augmentation. Additionally, the use case demonstrates creating and training a DeepSSM network using ShapeWorks Python packages. For a full explanation of these packages see Using the Data Augmentation Python Package and Using the DeepSSM Python Package. Each step of the pipeline is outlined below.</p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-1-getting-the-original-data","title":"Step 1: Getting the original data","text":"<p>The femur data is downloaded from the ShapeWorks Data Portal. The data includes the original unsegmented <code>.nrrd</code> images, corresponding <code>.ply</code> mesh files, and <code>.json</code> constraint files with cutting planes. Below is one example of an MRI (blue), mesh (white), and corrresponding cutting plane (green). </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-2-define-the-data-split","title":"Step 2: Define the data split","text":"<p>The data is randomly split into training (80%), validation (10%), and test (10%) sets. Of the 49 examples in the femur dataset, 39 are used to create training set, 5 are held out for the validation set, and the remaining 5 are held out for a test set. If running <code>--tiny_test</code> only 5 samples are downloaded and 3 are used in training, 1 for validation, and 1 for testing. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-3-find-training-alignment-transforms","title":"Step 3: Find training alignment transforms","text":"<p>Training DeepSSM requires labels or ground truth particles, thus we run optimization on the training set. As the femur meshes are unaligned, this requires finiding the alignment transforms to use in optimization. The steps for computing the transforms are the same as in the Femur Use Case. See Groom for more information on specific steps. In addition to computing the transforms, the smallest bounding box which contains all aligned meshes is computed.  </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-4-optimize-training-particles","title":"Step 4: Optimize training particles","text":"<p>Particles are optimized on the training femur meshes using corresponding alignment transforms and cutting planes as is done in the Femur Use Case. </p> <p>Below are some training set femur samples with their optimized correspondences. </p> <p>Here is the mean shape of the optimized training shape model. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-5-groom-training-images","title":"Step 5: Groom training images","text":"<p>Input images for the DeepSSM training set are created by taking the original training MRIs and applying the corresponding alignment transform (from step 3), applying the corresponding Procrustes transform (from optimization in step 4), and cropping using the boudning box (computed in step 3). This results in input images which consistently cropped and in alignment with the ground truth world particles. </p> <p>Here are some examples of slices of the groomed training images. These are now in alignment with the optimized world particles from Step 4. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-6-data-augmentation","title":"Step 6: Data augmentation","text":"<p>Data augmentation is run using the images and particle files allocated for training. 2967 augmented samples are created so that DeepSSM can be trained on 3000 total examples. The data is embedded to 12 dimensions using PCA, preserving 95% of the population variation. A Gaussian distribution is then fit to the embedded data and used in sampling new shape samples for data augmentation. </p> <p>The functions relevant to this step are runDataAugmentation and visualizeAugmentation.</p> <p>The distribution of real and augmented PCA scores are visualized as parallel violin plots. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-7-find-validation-and-test-alignment-transforms-and-groom-images","title":"Step 7: Find validation and test alignment transforms and groom images","text":"<p>To prepare the input images for the validation and test sets, the original MRIs are reflected if neccesary then aligned to a reference image using image registration. The reference image is selected as the groomed image corresponded to the training sample used in mesh alignment in step 3. The images are then cropped using the same bounding box computed in step 3 and the combined transforms are saved. Note this step does not use the validation or test meshes and can be performed without segmentation. </p> <p>Here are some examples of the groomed validation and test images.  </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-8-optimize-validation-particles-with-fixed-domains","title":"Step 8: Optimize validation particles with fixed domains","text":"<p>In order to quantify the accuracy of DeepSSM, ground truth particles are optimized on the validation set. This is done by adding the validation meshes to the training model while keeping the training particles fixed as is done in the Fixed Domain Use Case. The transforms found in step 7 are passed and Procrustes is turned off as these transform matrices account for scale.</p> <p></p> <p>Below are the resulting particles on the validation femurs. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-9-create-pytorch-loaders-from-data","title":"Step 9: Create PyTorch loaders from data","text":"<p>The groomed images and particle files are reformatted into tensors for training and testing the DeepSSM network. In the case of the test loader, a place holder is used for the particles as we do not have ground truth particles. The functions relevant to this step are getTrainValLoaders and getTestLoader.</p> <p>Note</p> <p>If a CUDA memory error occurs when running the use case, the batch size value may need to be decreased. </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-10-training-deepssm","title":"Step 10: Training DeepSSM","text":"<p>A DeepSSM model is created and trained for 10 epochs. A learning rate of 0.001 is used, and the validation error is calculated and reported every epoch.</p> <p>The function relevant to this step is trainDeepSSM.</p> <p>The training and validation errors are plotted after each epoch.  </p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-11-predict-validation-particles-and-analyze-accuracy","title":"Step 11: Predict validation particles and analyze accuracy","text":"<p>The trained DeepSSM model is used to predict the world particles for the validation images. The function relevant to this step is testDeepSSM. The predicted local particles are aquired by applying the inverse transforms from step 7 to the world particles. </p> <p>The accuracy is then analyzed via two means. The first is the mean square error between the predicted worl dparticles and ground truth world particles. The second is the surface-to-surface distance between the true mesh and the mesh generated from the predicted local particles. These results are printed to the console. The function relevant to this step is analyzeResults.</p>"},{"location":"use-cases/deep-learning-based/deep-ssm-femur.html#step-12-predict-test-particles-and-analyze-accuracy","title":"Step 12: Predict test particles and analyze accuracy","text":"<p>Similarly, the trained DeepSSM model is used to predict the world particles for the test images via testDeepSSM. As there are no ground truth particles, accuracy is just analyzed using the surface-to-surface distance between the true mesh and the mesh generated from the predicted local particles. </p> <p>Below we can see the results on the 5 test shapes. The original image is with the predicted meshes which have a heat map displaying the surface-tosurface distance to the true mesh. </p>"},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html","title":"Shape Model for Multiple Domains directly from Mesh","text":""},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_multiple_domain_mesh</code> use case demonstrates using ShapeWorks tools to perform shape modelings for anatomies with multiple structures (domains), e.g., joints to capture inter-domains correlations and interactions directly on triangular surface meshes The dataset available for this use case:</p> <ul> <li>ellipsoid_joint_rotation - two stacked ellipsoids with the same radii, with the top ellipsoid rotating w.r.t the bottom ellipsoid. </li> </ul>"},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html#grooming-data","title":"Grooming Data","text":"<p>This is how the meshes in the dataset look before grooming.Here it can been seen that the ellipsoids have random centers andn orientations.</p> <ol> <li>Remeshing: Meshes are remeshed to ensure uniform vertices.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) mesh, then selecting the sample closest to that mean (i.e., medoid). The reference is selected based on domain 1 shapes. </li> <li>Rigid Alignment: For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform'</li> </ol> <p>Here we show how the shapes would look like if the transforms are applied. </p>"},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"checkpointing_interval\" : 200,\n        \"keep_checkpoints\" : 0,\n        \"iterations_per_split\" : 200,\n        \"optimization_iterations\" : 200,\n        \"starting_regularization\" :1000,\n        \"ending_regularization\" : 0.1,\n        \"recompute_regularization_interval\" : 1,\n        \"domains_per_shape\" : 2,\n        \"relative_weighting\" : 10, \n        \"initial_relative_weighting\" : 0.1,\n        \"procrustes_interval\" : 0,\n        \"procrustes_scaling\" : 0,\n        \"save_init_splits\" : 0,\n        \"verbosity\" : 0\n\n}\n    num_particles = [128,128]\n</code></pre>"},{"location":"use-cases/mesh-based/ellipsoid-multiple-domain-mesh.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model.  Here is the optimized shape. </p> <p>Below are the particles for each sample, we can see they are uniformly distributed. </p>"},{"location":"use-cases/mesh-based/ellipsoid_mesh.html","title":"Ellipsoid Mesh: Basic Example","text":""},{"location":"use-cases/mesh-based/ellipsoid_mesh.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_mesh</code> use case uses the same dataset as the <code>ellipsoid</code> use case, but optimization is done on meshes rather than distance transforms. The dataset comprises of axis-aligned ellipsoids with varying radii along the x-axis. The <code>ellipsoid_mesh</code> use case represents the standard use version of a shape modeling workflow from meshes using ShapeWorks. </p>"},{"location":"use-cases/mesh-based/ellipsoid_mesh.html#grooming-steps","title":"Grooming Steps","text":"<p>This is how the meshes in the dataset look before grooming. The ellipsoids have random orientations.</p> <p></p> <ol> <li>Remeshing: Meshes are remeshed to ensure uniform vertices.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) mesh, then selecting the sample closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform'</li> </ol> <p>Here we show how the shapes would look like if the transforms are applied. </p>"},{"location":"use-cases/mesh-based/ellipsoid_mesh.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/mesh-based/ellipsoid_mesh.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\": 128,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 1000,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 1000,\n        \"optimization_iterations\": 1000,\n        \"starting_regularization\": 10,\n        \"ending_regularization\": 1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 1,\n        \"initial_relative_weighting\": 0.05,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0\n}\n</code></pre>"},{"location":"use-cases/mesh-based/ellipsoid_mesh.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Below is the mean shape reulting from optimization. Here we can see that there is only one major mode of variation. </p> <p>Animating along the first PCA mode we can see the variation in the radius along the x-axis. </p>"},{"location":"use-cases/mesh-based/hip.html","title":"Shape Model for Multiple Domains directly from Mesh","text":""},{"location":"use-cases/mesh-based/hip.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>hip_multiple_domain</code> use case demonstrates using ShapeWorks tools to perform shape modelings for anatomies with multiple structures (domains). The use case uses the hip joint to demonstrate the capability of ShapeWorks to capture inter-domains correlations and interactions directly on triangular surface meshes. The use case showcases how to calculate the different alignment options available for multiple organ anatomies. The dataset available for this use case:</p> <ul> <li>hip - a collection of femur and pelvis bones.</li> </ul>"},{"location":"use-cases/mesh-based/hip.html#grooming-data","title":"Grooming Data","text":"<p>This is how the meshes in the dataset look before grooming. </p> <ol> <li>Smoothing and Remeshing: Meshes are smoothed and remeshed to ensure uniform vertices.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) mesh, then selecting the mesh closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: This use case calculates three types of alignment:      a. Calculate the local alignment matrix using only femurs w.r.t to the femur of the reference shape     b. Calcualte the local alignment matrix using only pelvis w.r.t to the pelvis of the reference shape     c. Calcualte the global alignment matrix for the complete joint using the reference shape</li> </ol> <p>Here we show how the shapes would look like if the transforms are applied. Meshes obtained after grooming w.r.t femurs:  Meshes obtained after grooming w.r.t pelvis:  Meshes obtained after grooming w.r.t the whole joint: </p>"},{"location":"use-cases/mesh-based/hip.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/mesh-based/hip.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Optimization parameters for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"checkpointing_interval\" : 200,\n        \"keep_checkpoints\" : 0,\n        \"iterations_per_split\" : 2500,\n        \"optimization_iterations\" : 200,\n        \"starting_regularization\" : 1000,\n        \"ending_regularization\" : 10,\n        \"relative_weighting\" : 3,\n        \"initial_relative_weighting\" : 0.05,\n        \"save_init_splits\" : 0,\n        \"verbosity\" : 0,\n        \"use_normals\": 1,\n        \"normals_strength\": 5.0,\n        \"procrustes\" : 1,\n        \"procrustes_scaling\" : 1,\n        \"procrustes_rotation_translation\" : 1\n}\nnum_particles = [256,256]\n</code></pre>"},{"location":"use-cases/mesh-based/hip.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model.  Here is the optimized shape.</p> <p>Modes of variation of the hip joint with global alignment</p> <p>Modes of variation of the hip joint by aligning w.r.t the femur</p> <p>Modes of variation of the hip joint by aligning w.r.t the pelvis</p>"},{"location":"use-cases/mesh-based/lumps.html","title":"Lumps: Shape Model directly from Mesh","text":""},{"location":"use-cases/mesh-based/lumps.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>lumps</code> use case demonstrates a minimal example of running ShapeWorks directly on a mesh using a synthetic dataset. The shapes in this dataset are spheres with two lumps or nodes that vary in size. The use case demonstrates that the ShapeWorks workflow results in a correct shape model- i.e., only the position of particles on the lumps vary; the rest are constant across the shape population.</p>"},{"location":"use-cases/mesh-based/lumps.html#grooming-steps","title":"Grooming Steps","text":"<p>This is a synthetic dataset that is already in alignment and does not require grooming. Here are some examples of the meshes: </p>"},{"location":"use-cases/mesh-based/lumps.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/mesh-based/lumps.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\": 512,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 100,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 2000,\n        \"optimization_iterations\": 500,\n        \"starting_regularization\": 10,\n        \"ending_regularization\": 1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 10,\n        \"initial_relative_weighting\": 1,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0\n}\n</code></pre>"},{"location":"use-cases/mesh-based/lumps.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Here is the mean shape of the optimized shape mode using single-scale optimization. Note the two tiny lumps at the top, and towards the right.</p> <p></p> <p>Here are lumps samples with their optimized correspondences. </p> <p>Here is a video showing the shape modes of variation (computed using principal component analysis - PCA) of the lumps dataset using single-scale optimization.</p> <p> <p>Note that the particles which do not lie on the lumps remain stationary. The shape model correctly caputures the modes of variation.</p>"},{"location":"use-cases/mesh-based/thin-cavity-bean.html","title":"Thin Cavity Bean: Shape Model with Geodesic Distances","text":""},{"location":"use-cases/mesh-based/thin-cavity-bean.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>thin_cavity_bean</code> use case demonstrates using geodesic distance based repulsion for mesh domains in optimization.</p> <p>Here is an example of the data: </p> <p>The shapes vary only in location of the thin cavity. This use case demonstrates that ShapeWorks optimization with geodescic distance can correctly capture this mode of variation.</p>"},{"location":"use-cases/mesh-based/thin-cavity-bean.html#grooming-steps","title":"Grooming Steps","text":"<p>In this use case, we download pre-groomed data. Here are some examples of the meshes: </p>"},{"location":"use-cases/mesh-based/thin-cavity-bean.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --tiny_test</p>"},{"location":"use-cases/mesh-based/thin-cavity-bean.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code> {\n        \"number_of_particles\": 1024,\n        \"use_normals\": 1,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 200,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 300,\n        \"optimization_iterations\": 2500,\n        \"starting_regularization\": 3000,\n        \"ending_regularization\": 0.1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 15,\n        \"initial_relative_weighting\": 0.01,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0,\n        \"use_geodesic_distance\": 1,\n    }\n</code></pre> <p>Note <code>geodesics_enabled</code> is set to on.</p>"},{"location":"use-cases/mesh-based/thin-cavity-bean.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Here we can see the resulting shape model correctly captures the moving cavity as the only mode of variation.</p> <p></p>"},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html","title":"Fixed Domains Ellipsoid: Shape Model on New Shapes","text":""},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_fd</code> use case is designed to demonstrate the functionality of the fixed domain of ShapeWorks. Fixed domains is used in cases where we need to place correspondences on new shapes using a pre-existing shape model. In this example, we use a dataset which contains a previously generated shape model on ellipsoids (see Ellispoid Use Case) and prepped segmentations of five new ellipsoids.</p> <p></p>"},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html#grooming-steps","title":"Grooming Steps","text":"<p>This use case assumes that the new samples are already aligned with the existing shape model. The only grooming step is computing the signed distance transform for each new segmentation.</p> <p>Below are the pre-existing (first fifteen) and new (last five) groomed distance transforms. </p>"},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--tiny_test</p>"},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code> {\n        \"number_of_particles\": 128,\n        \"use_normals\": 0,\n        \"normals_strength\": 15.0,\n        \"checkpointing_interval\": 0,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 10,\n        \"optimization_iterations\": 10,\n        \"starting_regularization\": 100,\n        \"ending_regularization\": 0.1,\n        \"recompute_regularization_interval\": 2,\n        \"relative_weighting\": 15,\n        \"initial_relative_weighting\": 0.05,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0,\n        \"use_landmarks\": 1,\n        \"use_fixed_subjects\": 1,\n        \"narrow_band\": 1e10,\n        \"fixed_subjects_column\": \"fixed\",\n        \"fixed_subjects_choice\": \"yes\"\n    }\n</code></pre>"},{"location":"use-cases/multistep/fixed-domain-ellipsoid.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Here we can see the optimized particles for the new samples (numbers 15-19). The particles for the original samples (0-14) have remained the same. </p> <p>The primary mode of variation is along the x-axis as it was before adding the new shapes. </p>"},{"location":"use-cases/multistep/incremental_supershapes.html","title":"Incremental Supershapes: Building a Shape Model Incrementally","text":""},{"location":"use-cases/multistep/incremental_supershapes.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>incremental_supershapes</code> use case demonstrates how a shape model can be built incrementally. This approach is beneficial in two scenarios. The first is when the cohort of shapes is very large, where optimizing particle position across all shapes at once would take a very long time. In this case, by fitting a shape model on a subset of the data, then incrementally updating the shape model using the previous model as initialization, the total time for optimization can be greatly reduced. The second scenario is when the dataset is small but contains a large amount of shape variation. In this case, by initially fitting a model on the most similar shapes, then incrementally adding outlier shapes, we can achieve a more compact shape model with better correspondence than if we were to optimize the whole dataset at once.</p> <p>The use case dataset is comprised of parameterized meshes called Supershapes generated using the ShapeWorks Shape Cohort Generation package. There are 50 meshes that vary greatly in shape. They have 2 to 7 lobes, and the parameters are sampled from a chi-squared distribution. The function used to generate the data is included in the Python script.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#use-case-options","title":"Use Case Options","text":"<p>When this use case is run with the <code>--interactive</code> tag, the user is prompted to set the following options: sorting method, initial model size, and incremental batch size.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#sorting-method","title":"Sorting Method","text":"<p>The sorting method determines how the shapes are sorted to be added incrementally. There are three options:         - random : This option results in sorting the shapes randomly. It may be appropriate to use when the cohort of shapes is very large and the effect of outliers is likely small.         - median : When this option is used, the pairwise surface-to-surface distance between all of the meshes is first computed. Then the median shape (the shape with minimum distance to all other shapes) is found. The meshes are then sorted from closest to the median to furthest. The shapes furthest from the median typically represent outliers.         - distribution : Similar to median, when this option is used, the pairwise surface-to-surface distances are computed and the median mesh is selected. We then incrementally add one mesh at a time to the distribution (starting with the median), selecting the mesh with minimum distance to all others in the distribution. This results in meshes sorted from most inlying to most outlying.  The default option is median.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#initial-model-size","title":"Initial Model Size","text":"<p>The initial model size specifies how many shapes to use in the initial optimization. This can range between 2 and 50 and the default value is 10. Note when 50 is used, all of the shapes are used in the initial model; thus the use case is not incremental. The initial shapes are the first of the sorted shapes. After the initial shape model is optimized, Studio opens to allow for visualization. Incremental optimization pursues after Studio is closed.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#incremental-batch-size","title":"Incremental Batch Size","text":"<p>The incremental batch size specifies how many shapes to add in each incremental optimization. This can range from 1 to (50 - initial model size) and the default is 5. After all batches have been incrementally optimized, Studio opens to allow for visualization.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#grooming-steps","title":"Grooming Steps","text":"<p>In this use case, the Superhapes are generated so that they are already aligned/groomed. Here are some examples of the meshes: </p>"},{"location":"use-cases/multistep/incremental_supershapes.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --tiny_test --interactive</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#incremental-optimization","title":"Incremental Optimization","text":"<p>In incremental optimization, an initial shape model is fit by running optimization as usual. Additional shapes are then added, and the shape model is incrementally updated by initializing particles using the previous shape model and running optimization again. The mean particles from the existing shape model are used to initialize particles on new shapes.</p> <p>The order in which shapes are added depends on the specified sorting method. The first batch is used to create an initial shape model and the remaining batches are incrementally added and optimized.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks, which requires that the optimization parameters are specified in a python dictionary. Please refer to Parameter Dictionary in Python for more details. </p> <p>Here are the parameters used for optimizing the initial shape model: <pre><code>{        \n        \"number_of_particles\": 128,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 300,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 300,\n        \"optimization_iterations\": 1400,\n        \"starting_regularization\": 10,\n        \"ending_regularization\": 1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 1,\n        \"initial_relative_weighting\": 0.05,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0,\n        \"multiscale\": 1,\n        \"multiscale_particles\": 32\n}\n</code></pre> After the initial optimization, the following parameters are updated for each incremental optimization: <pre><code>{        \n        \"use_landmarks\": 1,\n        \"iterations_per_split\": 0,\n        \"optimization_iterations\": 100,\n        \"multiscale\": 0\n}\n</code></pre> Here \"use_landmarks\" enables particle initialization. We use single scale optimization with no initialization iterations since the particles are already initialized by the former shape model or mean particles. We can also reduce the optimization iterations as we are not starting from scratch.</p>"},{"location":"use-cases/multistep/incremental_supershapes.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>The following example output was generated using the default options: median sorting, initial model size of 10, and incremental batch size of 5.</p> <p>Below is the initial shape model after optimizing on the first batch of 10 meshes. We can see all 10 are relatively similar.  </p> <p>Below is the final shape model after incrementally adding batches and running optimization. We can see the shape model accurately captures the original shapes as well as the more unique ones. </p> <p>Here is the mean shape of the final shape model along the first PCA mode. Almost all of the variance is captured by the first four PCA modes. </p>"},{"location":"use-cases/multistep/incremental_supershapes.html#evaluation-of-the-benefits-of-incremental-optimization","title":"Evaluation of the Benefits of Incremental Optimization","text":"<p>To see the benefit of incremental optimization, we can compare the results from running the use case with different options.  By comparing the variance graphs below, we can see that the incremental optimization results in a mode compact shape model. Sorting the shapes using either median or distribution so that optimization is done on inliers first and then outliers are incrementally added, results in a better model.</p> <p></p>"},{"location":"use-cases/multistep/incremental_supershapes.html#subsample-of-dataset","title":"Subsample of Dataset","text":"<p>The benefit of incremental optimization is even more apparent in the case where the dataset is small and varies greatly. To see this, we can run the use case with the <code>--use_subsample</code> tag. The subsample is automatically selected using clustering so that it is representative of the entire dataset, thus it is defined to have as much variation as possible. For example, when <code>--num_subsample</code> is set to 9, the selected meshes are shown below.</p> <p></p> <p>Below is the first mode of variation from the shape model optimized incrementally on the subset.  </p> <p>Below is the first mode of variation from a shape model optimized on the whole subset at once for the same total number of optimization iterations as the incremental model.  </p> <p>We can see that the incremental optimization approach resulted in a much better shape model.</p>"},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html","title":"Shape Model for Multiple Domains from Segmentations","text":""},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_multiple_domain</code> use case demonstrates using ShapeWorks tools to perform shape modelings for anatomies with multiple structures (domains), e.g., joints, to capture inter-domains correlations and interactions. The dataset available for this use case:</p> <ul> <li>ellipsoid_joint_rotation - two stacked ellipsoids with the same radii, with the top ellipsoid rotating w.r.t the bottom ellipsoid. </li> </ul>"},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html#grooming-steps","title":"Grooming Steps","text":"<p>This is how the segmentations in the dataset look before grooming.Here it can been seen that the ellipsoids have random centers andn orientations.</p> <ol> <li>Isotropic Resampling: Binary segmentations in the ellipsoid joint dataset are resampled with an isotropic voxel spacing.</li> <li>Reference Selection:  For the ellipsoid_joint datasets available on the ShapeWorks portal, the mode of variation is rotation and/or size of the second ellipsoid w.r.t to the first ellipsoid. Hence, we align the shapes using the first domain as the reference. This is domain-specific alignment.  The reference is selected by first computing the mean (average) distance transform of the segmentations belonging to the reference domain, then selecting the sample closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform' 4.Bounding Box:  The smallest region which fits all of the samples is found.</li> <li>Cropping: The segmentations are cropped to the size of the bounding box.</li> <li>Padding: The segmentations are padded with zeros on every side.</li> <li>Distance Transform: Finally, the smooth signed distance transform is computed, and the dataset is now ready for the optimize phase.</li> </ol> <p>Distance transform obtained after grooming.Here we show how the shapes would look like if the transforms are applied.</p>"},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --mesh_mode --tiny_test</p>"},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"checkpointing_interval\" : 200,\n        \"keep_checkpoints\" : 0,\n        \"iterations_per_split\" : 200,\n        \"optimization_iterations\" : 200,\n        \"starting_regularization\" :1000,\n        \"ending_regularization\" : 0.1,\n        \"recompute_regularization_interval\" : 1,\n        \"domains_per_shape\" : domains_per_shape,\n        \"relative_weighting\" : 10, \n        \"initial_relative_weighting\" : 0.1,\n        \"procrustes_interval\" : 0,\n        \"procrustes_scaling\" : 0,\n        \"save_init_splits\" : 0,\n        \"verbosity\" : 0\n      }\n    num_particles = [128,128]\n</code></pre>"},{"location":"use-cases/segmentation-based/ellipsoid-multiple-domain.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model.  Here is the optimized shape. </p> <p>Below are the particles for each sample; we can see they are uniformly distributed. </p>"},{"location":"use-cases/segmentation-based/ellipsoid.html","title":"Ellipsoid: Basic Example","text":""},{"location":"use-cases/segmentation-based/ellipsoid.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The ellipsoid dataset comprises of axis-aligned ellipsoids with varying radii along all the x-axis. This example is a stepping stone for the user to get familiar with the workflow of ShapeWorks. </p> <p>The <code>ellipsoid</code> use case represents the standard use version of a shape modeling workflow using ShapeWorks. </p>"},{"location":"use-cases/segmentation-based/ellipsoid.html#grooming-steps","title":"Grooming Steps","text":"<p>This is how the segmentations in the dataset look before grooming.Here it can been seen that the ellipsoids have random centers andn orientations.</p> <ol> <li>Isotropic Resampling: Binary segmentations in <code>ellipsoid/segmentations/</code> are resampled to have an isotropic voxel spacing.</li> <li>Center-of-Mass Alignment: This translational alignment step is performed before rigidly aligning the samples to a shape reference. This factors out translations to reduce the risk of misalignment and allow for a medoid sample to be automatically selected as the reference for rigid alignment.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) distance transform of the segmentations, then selecting the sample closest to that mean (i.e., medoid).</li> <li>Rigid Alignment:For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform'</li> <li>Bounding Box: The smallest region which fits all of the samples is found.</li> <li>Cropping: The segmentations are cropped to the size of the bounding box.</li> <li>Padding: The segmentations are padded with zeros on every side.</li> <li>Distance Transform: Finally, the smooth signed distance transform is computed, and the dataset is now ready for the optimize phase.</li> </ol> <p>Distance transform obtained after grooming.Here we show how the shapes would look like if the transforms are applied.</p>"},{"location":"use-cases/segmentation-based/ellipsoid.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --skip_grooming --use_single_scale --mesh_mode --tiny_test</p>"},{"location":"use-cases/segmentation-based/ellipsoid.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\": 128,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 1000,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 1000,\n        \"optimization_iterations\": 1000,\n        \"starting_regularization\": 10,\n        \"ending_regularization\": 1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 1,\n        \"initial_relative_weighting\": 0.05,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0\n    }\n</code></pre>"},{"location":"use-cases/segmentation-based/ellipsoid.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model. </p> <p>Below is the mean shape reulting from optimization. Here we can see that there is only one major mode of variation. </p> <p>Below are the particles for each sample, we can see they are uniformly distributed. </p> <p>Animating along the first PCA mode we can see the variation in the radius along the x-axis. </p>"},{"location":"use-cases/segmentation-based/left-atrium.html","title":"Left Atrium: Shape Model from Segmentations","text":""},{"location":"use-cases/segmentation-based/left-atrium.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>left_atrium</code> use case demonstrates using ShapeWorks tools to perform the following: - Groom data and build a shape model where shapes are given as binary segmentations - Showcase both single-scale and multi-scale optimization for particles optimization Corresponding imaging data (e.g., MRI) is available with this dataset.</p>"},{"location":"use-cases/segmentation-based/left-atrium.html#grooming-steps","title":"Grooming Steps","text":"<p>This is how the segmentations in the dataset look before grooming.Here it can been seen that the atriums have random centers andn orientations.</p> <p>The grooming stage entails rigid transformations to align samples for groupwise modeling and analysis. It also changes the origin, voxel size, image size, orientation, etc. of the shape data. Grooming can be done with imaging data (CT/MRI) so that it is carried through each grooming step and with the shapes so that is remains in alignemtn and can be used for subsequent analysis. Here are the grooming steps:</p> <ol> <li>Isotropic Resampling: Binary segmentations in <code>left_atrium/segmentations/</code> are resampled to have an isotropic voxel spacing.</li> <li>Centering: Segmenations are translated to have an origin at (0,0,0).</li> <li>Apply Padding: Segmentations that touch the image boundary will have an artificial hole at that intersection. Segmentations are padded by adding a user-defined number of voxels along each image direction (rows, cols, and slices) to avoid introducing artificial holes.</li> <li>Center-of-Mass Alignment: This translational alignment step is performed before rigidly aligning the samples to a shape reference. This factors out translations to reduce the risk of misalignment and allow for a medoid sample to be automatically selected as the reference for rigid alignment.</li> <li>Reference Selection: The reference is selected by first computing the mean (average) distance transform of the segmentations, then selecting the sample closest to that mean (i.e., medoid).</li> <li>Rigid Alignment: For all the shapes, the transformation is calculated to factor out translation and rotation based on the reference shape.This transformation matrix will be sent to the optimizer as a 'prefix transform'</li> <li>Bounding Box: The smallest region which fits all of the samples is found.</li> <li>Cropping: The segmentations are cropped to the size of the bounding box.</li> <li>Distance Transform: Finally, the signed distance transform is computed, and the dataset is now ready for the optimize phase.</li> </ol> <p>Here are the resulting groomed ditsance transforms.Here we show how the shapes would look like if the transforms are applied. </p>"},{"location":"use-cases/segmentation-based/left-atrium.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --use_single_scale --mesh_mode --tiny_test</p>"},{"location":"use-cases/segmentation-based/left-atrium.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code>{\n        \"number_of_particles\": 512,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 200,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 4000,\n        \"optimization_iterations\": 4000,\n        \"starting_regularization\": 1000,\n        \"ending_regularization\": 10,\n        \"recompute_regularization_interval\": 2,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 10,\n        \"procrustes\": 1,\n        \"initial_relative_weighting\": 0.1,\n        \"procrustes_interval\": 1,\n        \"procrustes_scaling\": 1,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0\n    }\n</code></pre>"},{"location":"use-cases/segmentation-based/left-atrium.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model. </p> <p>Here is the mean shape of the optimized shape mode using multi-scale optimization.</p> <p></p> <p>Here is a video showing the shape modes of variation (computed using principal component analysis - PCA) of the left atrium dataset using multi-scale optimization. </p>"},{"location":"use-cases/shared-boundary-based/peanut.html","title":"Peanut: Shape Model of Multiple Domains with Shared Boundaries","text":""},{"location":"use-cases/shared-boundary-based/peanut.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>peanut_shared_boundary</code> use case demonstrates using ShapeWorks tools to perform shape modelings for anatomies with multiple structures (domains), e.g., joints, with shared boundaries to capture inter-domains correlations and interactions. It also demonstrates the shared mesh boundary and contour extraction tools and runs multi-domain (meshes and contours) optimization on the peanut dataset.</p> <p>The peanut dataset,consists of two aligned spheres, but one of the spheres is subtracted from the other. There exists a shared surface between the two spheres. The radii of the two spheres vary inversely, ie: as one gets bigger the other gets smaller.</p>"},{"location":"use-cases/shared-boundary-based/peanut.html#grooming-steps","title":"Grooming Steps","text":"<p>This is how the meshes in the dataset look before grooming.</p> <p></p> <ol> <li>Remeshing: Meshes are remeshed to ensure uniform vertices.</li> <li>Extract Shared Boundary: In this step, we ingest the two original shapes and output three new shapes, two of which correspond to the original shapes and one for the shared boundary.</li> <li>Smoothing:Applied laplacian smoothing.</li> <li>Extract Contour: The boundary loop of the shared surface is obtained.</li> </ol> <p>Groomed dataset.  </p>"},{"location":"use-cases/shared-boundary-based/peanut.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--use_subsample --num_subsample --tiny_test</p>"},{"location":"use-cases/shared-boundary-based/peanut.html#optimization-parameters","title":"Optimization Parameters","text":"<p>The python code for the use case calls the <code>optimize</code> command of ShapeWorks which reads the project sheet with the shape filenames and optimization parameter values. See Project excel file for details regarding creating the project sheet. Below are the default optimization parameters for this use case.</p> <pre><code># Create a dictionary for all the parameters required by optimization\n    parameter_dictionary = {\n        \"number_of_particles\": 128,\n        \"use_normals\": 0,\n        \"normals_strength\": 10.0,\n        \"checkpointing_interval\": 1000,\n        \"keep_checkpoints\": 0,\n        \"iterations_per_split\": 1000,\n        \"optimization_iterations\": 1000,\n        \"starting_regularization\": 10,\n        \"ending_regularization\": 1,\n        \"recompute_regularization_interval\": 1,\n        \"domains_per_shape\": 1,\n        \"relative_weighting\": 1,\n        \"initial_relative_weighting\": 0.05,\n        \"procrustes_interval\": 0,\n        \"procrustes_scaling\": 0,\n        \"save_init_splits\": 0,\n        \"verbosity\": 0\n    }\n</code></pre>"},{"location":"use-cases/shared-boundary-based/peanut.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>Once the python code runs the optimization, the files are saved in the <code>Output</code> folder after which ShapeWorks Studio is launched from the python code to analyze the model. </p> <p></p>"},{"location":"use-cases/stats-based/ellipsoid-evaluate.html","title":"Ellipsoid: Shape Evaluation in Python","text":""},{"location":"use-cases/stats-based/ellipsoid-evaluate.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_evaluate</code> use case demonstrates the functionality of shape evaluation tools of ShapeWorks python API. These API's include calculation of quantitative evaluation metrics such as specificity, generalization, and compactness.For detailed explaination of the evaluation metrics, refer to Shape Model Evaluation.  This use case reads the correspondence model of the ellipsoid segmentation images use case.</p> <p></p>"},{"location":"use-cases/stats-based/ellipsoid-evaluate.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--tiny_test</p>"},{"location":"use-cases/stats-based/ellipsoid-evaluate.html#analyzing-shape-model-using-python-apis","title":"Analyzing Shape Model Using Python APIs","text":"<p>The <code>ShapeEvaluation()</code> module of <code>ShapeWorks</code> python API, calcutates the three evaluation metrics given the correspondence model. The correspondence model can be read using the <code>ParticleSystem()</code> module. </p> <pre><code># Read the particle files from a pre-trained shape model\nparticle_data = sw.ParticleSystem(&lt;list of local point files&gt;)\n</code></pre> <p>The <code>ShapeEvaluation()</code> module has two types of commands which can query either a particular metric at the specified mode of variation or get the metric values for all the modes of variation. </p> <p>To access the metrics at a specified mode of variation:</p> <pre><code># Get the compactness of a specific mode \nnCompactness = sw.ShapeEvaluation.ComputeCompactness(particleSystem=particle_data,Modes=3)\n\n# Get the generalization of a specific mode and saves the reconstructions\nnGeneralization = sw.ShapeEvaluation.compute_generalization(particleSystem=particle_data, nModes=3,saveTo=save_dir)\n\n# Calculate specificity of a given mode and saves the reconstructions\nnSpecificity = sw.ShapeEvaluation.ComputeSpecificity(particleSystem=particle_data, nModes=3,saveTo=save_dir)\n</code></pre> <p>To access the metrics for all the modes of variations:</p> <pre><code># Get compactness of all the modes\nallCompactness = sw.ShapeEvaluation.ComputeFullCompactness(particleSystem=particle_data)\n\n#Get generalization values for all modes\nallGeneralization = sw.ShapeEvaluation.ComputeFullGeneralization(particleSystem=particle_data)\n\n#Get specificity values for all modes\nallSpecificity = sw.ShapeEvaluation.ComputeFullSpecificity(particleSystem=particle_data)\n</code></pre> <p>Details about the evaluation functions can be found in the API Reference</p> <p>Generalization value of the 3rd mode -  0.09600121582319728</p> <p>Generalization Best Reconstruction Generalization Worst Reconstruction</p> <p>Specificity value of the 3rd mode -  0.21431799055403217</p> <p>Specificity Best Reconstruction Specificity Worst Reconstruction</p>"},{"location":"use-cases/stats-based/ellipsoid-pca.html","title":"Ellipsoid: Shape Statistics in Python","text":""},{"location":"use-cases/stats-based/ellipsoid-pca.html#what-is-the-use-case","title":"What is the Use Case?","text":"<p>The <code>ellipsoid_pca</code> use case demonstrates the functionality of shape statistics tools of ShapeWorks python API. These APIs include reading particle files and computing eigenvectors, eigenvalues, and PCA loadings. This use case reads the correspondence model of the ellipsoid segmentation images use case. </p>"},{"location":"use-cases/stats-based/ellipsoid-pca.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--tiny_test</p>"},{"location":"use-cases/stats-based/ellipsoid-pca.html#analyzing-shape-model-using-python-apis","title":"Analyzing Shape Model Using Python APIs","text":"<p>The <code>ParticleShapeStatistics()</code> of <code>ShapeWorks</code> python API analyzes the optimized particle-based shape model by calculating the principal components of the shape model, eigenvalues, eigenvectors, and PCA loadings. This tool also estimates the variance explained by each mode and generates plots for PCA metrics similar to <code>ShapeWorks Studio.</code> </p> <pre><code># Read the particle files from a pre-trained shape model\nparticle_data = sw.ParticleSystem(&lt;list of local point files&gt;)\n</code></pre> <p>To perform PCA:</p> <pre><code>shape_statistics = sw.ParticleShapeStatistics()\nshape_statistics.PCA(particleSystem = particle_data,domainsPerShape=1)\n</code></pre> <p>Using <code>shape_statistics</code> object, you can now extract the following entities:</p> <ul> <li> <p>Calculate principal components : <code>principalComponentProjections()</code></p> </li> <li> <p>Extract the loadings: <code>pcaLoadings()</code></p> </li> <li>Eigen Values: <code>eigenValues()</code></li> <li>Eigen Vectors: <code>eigenVectors()</code></li> <li>Number of shapes in the model: <code>sampleSize()</code></li> <li>Dimension of each shape: <code>numDims()</code></li> <li>Variance explained by each mode: <code>percentVarByMode()</code></li> </ul> <p>Details about shape statistics functions can be found in the API Reference</p> <p>When the use case is run, plots similar to those below will be generated.  </p>"},{"location":"use-cases/stats-based/femur-pvalues.html","title":"Femur: Group Difference Statistics in Python","text":""},{"location":"use-cases/stats-based/femur-pvalues.html#what-and-where-is-the-use-case","title":"What and Where is the Use Case?","text":"<p>This use case demonstrates the functionality of shape statistics tools to perform hypothesis testing of group shape differences. This use case analyzes the femur shape model obtained from running the Femur: SSM from Meshes with Cutting Planes use case. The data has 21 examples of normal femurs and 5 examples of pathological femurs with cam impingement. This use case analyzes the femur shape model obtained from running the Femur: SSM from Meshes with Cutting Planes use case. Separate statistical tests for differences in correspondence positions are applied to every correspondence index. We use Hotelling \\(T^2\\) metric(nonparametric permutation test) with false discovery rate correction (FDR) for multiple comparisons. This method helps identify and visualize localized regions of significant shape differences.</p> <p>The use case also demonstrates Linear Discrimination of Variation (LDA) for analyzing shape variation between the subgroups of patients with and without cam impingement and the distribution of individual shapes among these groups. In the group of samples, the mean shape (i.e., average correspondence particle locations) of the group of patients with cam impingement was compared to the mean shape of the group without cam impingement. The linear discrimination between the two groups was defined as the difference vector between the two mean shape vectors. The shape of each subject was then mapped/projected onto this vector by taking the dot product between the subject-specific shape representation (the particle correspondences) and this difference vector. This mapping results in a single scalar value (or a \"shape-based score\") that places subject-specific anatomy on a group-based shape difference that is statistically derived from the shape population. For interpretability, the mappings of the group mean shapes were normalized to -1 (patients with cam impingement) and 1 (without cam impingement). The other subjects' mappings were then similarly normalized relative to these values, giving a shape distribution of individual members of the population close to the mean shapes of their respective groups. A univariate Gaussian distribution was then fit to the normalized mapping of each group to define the probability density function of the shape scores for each group.</p> <p>Here are femur samples with their optimized correspondences. </p> <p>A brief overview of the analysis:</p> <ol> <li>Given a shape model with group IDs, we create the subsets based on the group IDs. </li> <li>Since the shape models are in correspondence, we access one particle location at a time and create two vectors. x: All particle locations of group 1 at ith location y: All particle locations of group 2 at ith location</li> <li>Using the two-sample Hotelling-T2 test, we are trying to see if the particle positions at the ith location of all group 1 samples come from the same distribution as the particle position at ith location of group 2 samples. </li> <li>If the group differences are significant, the particle positions are not from the same distribution.</li> </ol>"},{"location":"use-cases/stats-based/femur-pvalues.html#relevant-arguments","title":"Relevant Arguments","text":"<p>--tiny_test</p>"},{"location":"use-cases/stats-based/femur-pvalues.html#analyzing-shape-model","title":"Analyzing Shape Model","text":"<p>For the femur mode, separate statistical tests for differences in correspondence positions are applied to every correspondence index. We use Hotelling \\(T^2\\) metric(nonparametric permutation test) with false discovery rate correction (FDR) for multiple comparisons. This method helps identify and visualize localized regions of significant shape differences. The null hypothesis for this test is that the distributions of the locations of corresponding sample points are the same regardless of the groups. Hence, lower p-values would mean we can reject the null hypothesis and conclude that the group differences are significant and not from the same distribution. </p> <p>This use case calculates the p-values and saves them in a text file. This same functionality is also available in ShapeWorks Studio, where you can also visualize the p-values on the mean shapes. The use case also generates a plot based on LDA with the shape-based scores for both the groups of femurs. </p> <p></p>"},{"location":"users/citation.html","title":"How to Cite ShapeWorks?","text":""},{"location":"users/citation.html#acknowledgements","title":"Acknowledgements","text":"<p>If you use ShapeWorks in work that leads to published research, we humbly ask that you to cite ShapeWorks, add the following to the 'Acknowledgments' section of your paper: </p> <p>\"The National Institutes of Health supported this work under grant numbers NIBIB-U24EB029011, NIAMS-R01AR076120, NHLBI-R01HL135568, and NIBIB-R01EB016701.\"</p> <p>and add the following 'disclaimer':</p> <p>\"The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health.\"</p>"},{"location":"users/citation.html#citation","title":"Citation","text":"<p>When referencing ShapeWorks, please include a bibliographical reference to the paper below, and, if possible, include a link to shapeworks.sci.utah.edu. </p> <p> Joshua Cates, Shireen Elhabian, Ross Whitaker. \"Shapeworks: particle-based shape correspondence and visualization software.\" Statistical Shape and Deformation Analysis. Academic Press, 2017. 257-298. </p> <p>@incollection{cates2017shapeworks,  title = {Shapeworks: particle-based shape correspondence and visualization software},    author = {Cates, Joshua and Elhabian, Shireen and Whitaker, Ross},    booktitle = {Statistical Shape and Deformation Analysis},    pages = {257--298},    year = {2017},    publisher = {Elsevier} }</p>"},{"location":"users/install.html","title":"How to Install ShapeWorks?","text":""},{"location":"users/install.html#first-download-shapeworks","title":"First, download ShapeWorks","text":"<p>Release Builds</p> <p>We provide official user releases for Windows, MacOS, and Linux.  </p> <p>Their features can be seen at Release Notes.</p> <p>Development Builds</p> <p>We also provide up-to-date development builds from the master branch Windows Dev Build Mac Dev Build Linux Dev Build</p> <p>Please understand that these are in-progress development builds, not official releases.</p>"},{"location":"users/install.html#next-follow-the-instructions-for-your-platform","title":"Next, follow the instructions for your platform.","text":"<p>Windows Mac Linux</p>"},{"location":"users/install.html#installing-shapeworks-on-windows","title":"Installing ShapeWorks on Windows","text":"<p>Please make sure that you download the latest ShapeWorks binary release, or up-to-date development builds from the master branch for Windows (remember these are in-progress development builds, not official releases).</p> <ol> <li> <p>Download and install Miniconda for Windows. https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe</p> </li> <li> <p>Double-click on the ShapeWorks installer that you downloaded and follow the installation steps.</p> </li> <li> <p>Open an Anaconda terminal and change directory to the chosen installation path. <code>cd \"C:\\Program Files\\ShapeWorks\"</code></p> </li> <li> <p>Create the shapeworks conda environment, installing everything necessary to run. <code>install_shapeworks.bat</code> </p> </li> </ol> <p>Note: You can pass a different name for the environment, enabling multiple installations. <code>install_shapeworks shapeworks_61</code></p> <p>Warning</p> <p>If you already have anaconda/miniconda installed, this step may hang.  If so please uninstall anaconda/miniconda, re-install it, then run install_shapeworks again. This seems to be an occasional problem with Anaconda on Windows.</p> <p>Important</p> <p>Your shapeworks conda environment must always be activated before using ShapeWorks python packages.</p>"},{"location":"users/install.html#shapeworks-comes-with-examples-to-get-you-started","title":"ShapeWorks comes with examples to get you started.","text":"<ol> <li>Copy the Examples folder to another location of your choosing (you can also use Explorer). <code>xcopy /E/H Examples %HOMEPATH%\\ShapeWorks-Examples\\</code></li> </ol>"},{"location":"users/install.html#studio","title":"Studio","text":"<ol> <li> <p>Open ShapeWorks Studio</p> </li> <li> <p>Select \"Open Exising Project\"</p> </li> <li> <p>Select Examples/Studio/Ellipsoid/ellipsoid.xlsx</p> </li> <li> <p>Experiment with the Studio interface.</p> </li> </ol>"},{"location":"users/install.html#python","title":"Python","text":"<ol> <li> <p>Open an Anaconda terminal and activate the shapeworks conda environment (use the environment name passed to <code>install_shapeworks</code> above). <code>conda activate shapeworks</code></p> </li> <li> <p>Change to the Python folder of the Examples directory you copied. <code>cd %HOMEPATH%\\ShapeWorks-Examples\\Python</code></p> </li> <li> <p>Run one of the included use cases. To list them all, run: <code>python RunUseCase.py --help</code>. <code>python RunUseCase.py ellipsoid</code></p> </li> </ol>"},{"location":"users/install.html#shapeworks-also-includes-interactive-jupyter-python-notebook-examples","title":"ShapeWorks also includes interactive Jupyter Python notebook examples.","text":"<ol> <li> <p>Open an Anaconda terminal and activate the shapeworks conda environment (use the environment name passed to <code>install_shapeworks</code> above). <code>conda activate shapeworks</code></p> </li> <li> <p>Change to the notebook tutorials folder of the Examples directory you copied. <code>cd %HOMEPATH%\\ShapeWorks-Examples\\Python\\notebooks\\tutorials</code></p> </li> <li> <p>Start the Jupyter notebook server. This will open a new tab in your web browser. <code>jupyter notebook</code></p> </li> <li> <p>Click on a notebook to get started.</p> </li> </ol>"},{"location":"users/install.html#installing-shapeworks-on-mac","title":"Installing ShapeWorks on Mac","text":"<p>Please make sure that you download the latest ShapeWorks binary release, or up-to-date development builds from the master branch for Mac (remember these are in-progress development builds, not official releases).</p> <ol> <li> <p>Install the ShapeWorks .pkg file by double-clicking on the file.</p> </li> <li> <p>Open a terminal and change directory to the installation path. <code>cd /Applications/ShapeWorks</code></p> </li> <li> <p>Create a protected conda environment that installs everything necessary to run. <code>source install_shapeworks.sh</code> Note: You can pass a different name for the environment, enabling multiple installations. <code>source install_shapeworks.sh shapeworks_61</code></p> </li> </ol> <p>Important</p> <p>Your shapeworks conda environment must always be activated before using ShapeWorks python packages.</p>"},{"location":"users/install.html#shapeworks-comes-with-examples-to-get-you-started_1","title":"ShapeWorks comes with examples to get you started.","text":""},{"location":"users/install.html#studio_1","title":"Studio","text":"<ol> <li> <p>Copy the /Applications/ShapeWorks/Examples folder to another location of your choosing. (You can also use Finder.)</p> </li> <li> <p>Open ShapeWorks Studio</p> </li> <li> <p>Select \"Open Exising Project\"</p> </li> <li> <p>Select Examples/Studio/Ellipsoid/ellipsoid.xlsx</p> </li> <li> <p>Experiment with the Studio interface.</p> </li> </ol>"},{"location":"users/install.html#python_1","title":"Python","text":"<ol> <li> <p>Open a terminal and activate the shapeworks conda environment (use the environment name passed to install_shapeworks above). <code>conda activate shapeworks</code></p> </li> <li> <p>Copy the Examples folder to another location of your choosing. <code>cp -r Examples $HOME/ShapeWorks-Examples</code></p> </li> <li> <p>Change to the Python folder of the Examples directory you copied. <code>cd $HOME/ShapeWorks-Examples/Python</code></p> </li> <li> <p>Run one of the included use cases. To list them all, run: <code>python RunUseCase.py --help</code>. <code>python RunUseCase.py &lt;insert name of use case here&gt;</code></p> </li> <li> <p>More information about running use cases can be found here.</p> </li> </ol>"},{"location":"users/install.html#shapeworks-also-includes-interactive-jupyter-python-notebook-examples_1","title":"ShapeWorks also includes interactive Jupyter Python notebook examples.","text":"<ol> <li> <p>Open a terminal and activate the shapeworks conda environment (use the environment name passed to install_shapeworks above). <code>conda activate shapeworks</code></p> </li> <li> <p>Change to the notebook tutorials folder of the Examples directory you copied. <code>cd $HOME/ShapeWorks-Examples/Python/notebooks/tutorials</code></p> </li> <li> <p>Start the Jupyter notebook server. This will open a new tab in your web broswer. <code>jupyter notebook</code></p> </li> <li> <p>Click on a notebook to get started.</p> </li> </ol>"},{"location":"users/install.html#installing-shapeworks-on-linux","title":"Installing ShapeWorks on Linux","text":"<p>Please make sure that you download the latest ShapeWorks binary release, or up-to-date development builds from the master branch for Linux (remember these are in-progress development builds, not official releases).</p> <ol> <li> <p>Open a terminal and change directory to the installation path (where you unzipped the downloaded file). <code>cd /path/to/shapeworks</code></p> </li> <li> <p>Create a protected conda environment that installs everything necessary to run. <code>source install_shapeworks.sh</code> Note: You can pass a different name for the environment, enabling multiple installations. <code>source install_shapeworks.sh shapeworks_61</code></p> </li> </ol> <p>Important</p> <p>Your shapeworks conda environment must always be activated before using ShapeWorks python packages.</p>"},{"location":"users/install.html#shapeworks-comes-with-examples-to-get-you-started_2","title":"ShapeWorks comes with examples to get you started.","text":""},{"location":"users/install.html#studio_2","title":"Studio","text":"<ol> <li> <p>Open ShapeWorks Studio</p> </li> <li> <p>Select \"Open Exising Project\"</p> </li> <li> <p>Select Examples/Studio/Ellipsoid/ellipsoid.xlsx</p> </li> <li> <p>Experiment with the Studio interface.</p> </li> </ol>"},{"location":"users/install.html#python_2","title":"Python","text":"<ol> <li> <p>Open a terminal and activate the shapeworks conda environment (use the environment name passed to install_shapeworks above). <code>conda activate shapeworks</code></p> </li> <li> <p>Copy the Examples folder to another location of your choosing. <code>cp -r Examples $HOME/ShapeWorks-Examples</code></p> </li> <li> <p>Change to the Python folder of the Examples directory you copied.   <code>cd $HOME/ShapeWorks-Examples/Python</code></p> </li> <li> <p>Run one of the included use cases. To list them all, run: <code>python RunUseCase.py --help</code>. <code>python RunUseCase.py &lt;insert name of use case here&gt;</code></p> </li> <li> <p>More information about running use cases can be found here.</p> </li> </ol>"},{"location":"users/install.html#shapeworks-also-includes-interactive-jupyter-python-notebook-examples_2","title":"ShapeWorks also includes interactive Jupyter Python notebook examples.","text":"<ol> <li> <p>Open a terminal and activate the shapeworks conda environment (use the environment name passed to install_shapeworks above). <code>conda activate shapeworks</code></p> </li> <li> <p>Change to the notebook tutorials folder of the Examples directory you copied. <code>cd $HOME/ShapeWorks-Examples/Python/notebooks/tutorials</code></p> </li> <li> <p>Start the Jupyter notebook server. This will open a new tab in your web broswer. <code>jupyter notebook</code></p> </li> <li> <p>Click on a notebook to get started.</p> </li> </ol>"},{"location":"users/papers.html","title":"Relevant Papers","text":"<p>Note</p> <p>If you would like to have your publication listed here: e-mail us!</p> <p> The following selected papers give background on the methods used in ShapeWorks, and a sample of the areas ShapeWorks has been applied: </p> <p> M. Jacxsens, S. Elhabian, S. Brady, P. Chalmers, R. Tashjian, and H. Henninger. \"Coracoacromial morphology: a contributor to recurrent traumatic anterior glenohumeral instability,\" Journal of Shoulder and Elbow Surgery, 1:1316-1325, 2019. </p> <p> P. R. Atkins, Y. Shin, P. Agrawal, S. Y. Elhabian, R. T. Whitaker, J. A. Weiss, S. K. Aoki, C. L. Peters ,and A. E.  Anderson. \"Which Two-dimensional Radiographic Measurements of Cam Femoroacetabular Impingement Best Describe the Three-dimensional Shape of the Proximal Femur?,\" Clinical Orthopaedics and Related Research, 477(1):242\u2013253, 2019. </p> <p> T. Sodergren, R. Bhalodia, R. Whitaker, J. Cates, N. Marrouche, and S. Elhabian. \"Mixture modeling of global shape priors and autoencoding local intensity priors for left atrium segmentation,\" In STACOM- MICCAI: Statistical Atlases and Computational Modeling of the Heart workshop, page in press. Springer, 2018. </p> <p> A. Goparaju, I. Csecs, A. Morris, E. Kholmovski, N. Marrouche, R. Whitaker, and S. Elhabian. \"On the Evaluation and Validation of Off-the-Shelf Statistical Shape Modeling Tools: A Clinical Application,\" In International Workshop on Shape in Medical Imaging, pages 14\u201327. Springer, 2018. </p> <p> E. T. Bieging, A. Morris, B. D. Wilson, C. J. McGann, N. F. Marrouche, and J. Cates. \"Left atrial shape predicts recurrence after atrial fibrillation catheter ablation,\" Journal of Cardiovascular Electrophysiology, 2018. </p> <p> P. R. Atkins, S. Y. Elhabian, P. Agrawal, M. D. Harris, R. T. Whitaker, J. A. Weiss, C. L. Peters, and A. E. Anderson. \"Quantitative comparison of cortical bone thickness using correspondence-based shape modeling in patients with cam femoroacetabular impingement,\" Journal of Orthopaedic Research, 35(8):1743\u20131753, 2017. </p> <p> J. Cates, L. Nevell, S. I. Prajapati, L. D. Nelon, J. Y. Chang, M. E. Randolph, B. Wood, C. Keller, and R. T. Whitaker. \"Shape analysis of the basioccipital bone in Pax7-deficient mice,\" Scientific Reports, 7(1):17955, 2017. </p> <p> J. Cates, S. Elhabian, and R. Whitaker. \"ShapeWorks: particle-based shape correspondence and visualization software,\" In G. Zheng, S. Li, and G. Szekely, editors, Statistical Shape and Deformation Analysis: Methods, Implementation and Applications, 1st Edition, chapter 10. Academic Press, 2017. </p> <p> P. Agrawal, S.Y. Elhabian, R.T. Whitaker, \"Learning Deep Features for Automated Placement of Correspondence Points on Ensembles of Complex Shapes,\" In International Conference on Medical Image Computing and Computer-Assisted Intervention, pp. 185-193. Springer, Cham, 2017. </p> <p> S. Sultana, P. Agrawal, S. Elhabian, R. Whitaker, T. Rashid, J. Blatt, J. Cetas, and M. Audette. \"Towards a statistical shape-aware deformable contour model for cranial nerve identification,\" In Workshop on Clinical Image-Based Procedures, pages 68\u201376. Springer, 2016. </p> <p> J. Cates, E. Bieging, A. Morris, G. Gardner, N. Akoum, E. Kholmovski, N. Marrouche, C. McGann, and R. S. MacLeod. \"Computational shape models characterize shape change of the left atrium in atrial fibrillation,\" Clinical Medicine Insights. Cardiology, 8(Suppl 1):99, 2015. </p> <p> Ken Museth. \"VDB: High-resolution sparse volumes with dynamic topology\" ACM Transactions on Graphics, July 2013, Article No.: 27 </p> <p> M. Datar, I. Lyu, S. Kim, J. Cates, M. Styner, R. Whitaker. \"Geodesic distances to landmarks for dense correspondence on ensembles of complex shapes,\" In International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer, Berlin, Heidelberg, pp. 19-26, 2013. </p> <p> M.D. Harris, M. Datar, R.T. Whitaker, E.R. Jurrus, C.L. Peters, A.E. Anderson.  \"Statistical Shape Modeling of Cam Femoroacetabular Impingement,\" In Journal of Orthopaedic Research,  Vol. 31, No. 10, pp. 1620--1626. 2013. </p> <p> K.B. Jones, M. Datar, S. Ravichandran, H. Jin, E. Jurrus, R.T. Whitaker, M.R. Capecchi.  \"Toward an Understanding of the Short Bone Phenotype Associated with Multiple Osteochondromas,\"  In Journal of Orthopaedic Research, Vol. 31, No. 4, pp. 651--657. 2013. </p> <p> J. Cates, P.T. Fletcher, Z. Warnock, R.T. Whitaker.  \"A Shape Analysis Framework for Small Animal Phenotyping with Application to Mice with  a Targeted Disruption of Hoxd11,\" In Proceedings of the 5th IEEE International Symposium  on Biomedical Imaging (ISBI '08), pp. 512--516. 2008. DOI: 10.1109/ISBI.2008.4541045 </p> <p> J. Cates, P.T. Fletcher, M. Styner, H. Hazlett, R.T. Whitaker.  \"Particle-Based Shape Analysis of Multi-Object Complexes,\"  In Proceedings of the 11th International Conference on Medical Image Computing and  Computer Assisted Intervention (MICCAI '08), Lecture Notes In Computer Science (LCNS),  pp. 477--485. 2008. ISBN: 978-3-540-85987-1 </p> <p> J. Cates, P. T. Fletcher, M. Styner, M. Shenton, and R. Whitaker. \"Shape modeling and analysis with entropy-based particle systems,\" In Information Processing in Medical Imaging, pages 333\u2013345. Springer, 2007. </p>"},{"location":"workflow/analyze.html","title":"How to Analyze Your Shape Model?","text":""},{"location":"workflow/analyze.html#surface-correspondences","title":"Surface Correspondences","text":"<p>ShapeWorks includes a Qt and VTK-based graphical user interface (GUI), ShapeWorks Studio, that allows visualizing the optimized particle system (i.e., correspondence model) for each shape sample where particle coloring is used to reflect correspondence among shapes. </p> <p>Particles' coloring reflects surface correspondences across different shape samples </p> <p>You can scroll through the dataset and zoom in and out to inspect fewer or more samples. ShapeWorks Studio keeps a consistent camera view across all shape samples to facilitate qualitative comparisons of different samples relative to each other.</p> <p>Correspondence model inspectation by scrolling though the dataset and zooming in &amp; out</p> <p>"},{"location":"workflow/analyze.html#running-shapeworks-studio","title":"Running ShapeWorks Studio","text":"<p>When you open ShapeWorks Studio without a project, either from terminal or double-clicking on the application binary/exe file, the splash screen is displayed to enable you to load a recent project, open existing projects on your local machine, or create a new project.</p> <p>ShapeWorks Studio splash screen </p>"},{"location":"workflow/analyze.html#using-xml-files","title":"Using XML Files","text":"<p>You can run ShapeWorks Studio using an XML parameter file that includes the following tags.</p> <ul> <li><code>&lt;point_files&gt;</code> [required]: list of <code>_world.particles</code> files (output of the <code>shapeworks optimize</code>)</li> <li><code>&lt;group_ids&gt;</code> [optional]: the group id (1 or 2) in case the data contains groups</li> <li><code>&lt;world_point_files&gt;</code> [optional]: list of <code>_world.particles</code> files (output of the <code>shapeworks optimize</code>), same as <code>&lt;point_files&gt;</code></li> <li><code>&lt;local_point_files&gt;</code> [optional]: list of <code>_local.particles</code> files (output of the <code>shapeworks optimize</code>)</li> <li><code>&lt;distance_transform_files&gt;</code> [optional]: list of distance transforms (input of the <code>shapeworks optimize</code>)</li> </ul> <p>Please note the following:</p> <ul> <li>If the xml file only contains the <code>&lt;point_files&gt;</code> list, VTK-based surface reconstruction is used for surface reconstruction. </li> <li>To enable particle-based surface reconstruction,<code>&lt;world_point_files&gt;</code>, <code>&lt;local_point_files&gt;</code>, and <code>&lt;distance_transform_files&gt;</code> lists should be given.</li> <li><code>Examples/Python/&lt;use-case-name&gt;.py</code> include an analyze step that generates <code>analyze.xml</code>, which includes the path to the input data and corresponding particles. </li> <li>All lists should have the same order of shape samples</li> </ul> <p>Given the XML files, you can launch ShapeWorks Studio through the terminal using the following command.</p> <pre><code>$ ShapeWorksStudio analyze.xml\n</code></pre>"},{"location":"workflow/analyze.html#using-spreadsheets","title":"Using Spreadsheets","text":"<p>ShapeWorks Studio can also load datasets (and shape models) using spreadsheets, a more user-friendly user-editable file format. See the ellipsoid studio example in <code>Examples/Studio/ellipsoid.xlsx</code> for an example. </p> <p>ShapeWorks Studio keeps track of results from different phases in individual sheets</p> <p></p> <p>"},{"location":"workflow/analyze.html#surface-reconstruction","title":"Surface Reconstruction","text":"<p>For visualization purposes, the shape's particle system is used to reconstruct its surface mesh using a template-deformation approach to establish an inter-sample dense surface correspondence given a sparse set of optimized particles. To avoid introducing bias due to template choice, we use an unbiased framework for template mesh construction that entails:</p> <ul> <li>A generalized Procrustes alignment to define the mean particle system</li> <li>A nonlinear warping function built using the shape's particle system and the mean one as control points.</li> <li>A mean distance transform (DT) computed by averaging warped sample-specific DT. </li> </ul> <p>The template mesh will then be constructed by triangulating the isosurface of this mean DT. A warping function is constructed to deform the dense template mesh to the sample space using the sample's and mean particle systems as control points to reconstruct a sample-specific surface mesh.</p> <p>Particle-based surface reconstruction currently supported by ShapeWorks Studio </p> <p>(old) VTK-based surface reconstruction</p> <p> <p>(new) particle-based surface reconstruction</p> <p> <p>You can export any mesh using <code>File -&gt; Export -&gt; Export Current Mesh ...</code>. </p>"},{"location":"workflow/analyze.html#statistical-analysis","title":"Statistical Analysis","text":"<p>Statistical analysis is performed using principal component analysis (PCA), where the mean and modes of shape variation are computed based on the optimized correspondence model. Animation is allowed to watch the shape morph at various standard deviations along a user-selected variation mode. </p> <p>Animating the shape variation along with a principal component while passing through the mean shape</p> <p> <p>You can also export the eigenvalues and each shape's PCA loadings in an excel sheet for further analysis. </p>"},{"location":"workflow/analyze.html#group-differences","title":"Group Differences","text":"<p>If there are groups in the data, ShapeWorks Studio can visualize significant group differences. </p> <p>Statistical group differences for characterizing scapular morphology in Hill-Sachs patients </p> <p>If you are using an XML file to load your data into ShapeWorks Studio, a group id (1 or 2) should be given to each sample. If you are using a spreadsheet, specify group columns in the <code>data</code> (first) sheet in the spreadsheet with the prefix <code>group_</code>, which enables adding multiple groups to your project and selecting the group-of-interest within ShapeWorks Studio. </p> <p>Groups as columns in the project spreadsheet </p> <p>In the Group tab of the Analyze panel, choose which column to indicate the group set of interest </p> <p>Then, select which groups you would like to compare (now support more than two groups) </p>"},{"location":"workflow/analyze.html#feature-maps","title":"Feature Maps","text":"<p>ShapeWorks Studio has the ability to integrate feature maps.  A feature map is a 3d image volume that contains scalar values to be associated with each shape\u2019s surface.  For example, this could be raw or processed CT/MRI data.  The feature map can be displayed for each surface by choosing the desired feature map in the feature map combobox at the bottom of the screen.  After the correspondence is generated, the average feature map can be displayed on the mean shape in the analysis tab.</p> <p>"},{"location":"workflow/groom.html","title":"How to Groom Your Dataset?","text":"<p>ShapeWorks needs suitable distance transforms or meshes for establishing shape correspondence. The groom stage has the pipeline to generate aligned distance transforms from binary segmentations or groomed meshes from unaligned meshes.  Common grooming steps are outlined below. For descriptions of the ShapeWorks commands used, see: ShapeWorks Commands.</p>"},{"location":"workflow/groom.html#common-pre-processing-steps-for-segmentations","title":"Common Pre-Processing Steps for Segmentations","text":""},{"location":"workflow/groom.html#resampling-images-and-segmentations","title":"Resampling images and segmentations","text":"<p>This grooming step resamples all the binary volumes, which in a raw setting could be in different physical spaces (different dimensions and voxel spacing). This grooming step brings all segmentations to the same voxel spacing, typically isotropic spacing (e.g., 1,1,1).</p> <p>A smaller voxel spacing than the original spacing improves the resolution of the segmentations and reduces the aliasing (i.e., staircase) artifact resulting from the thresholding/binarization process. </p> <p>Resampling both images and segmentations</p> <p>If your dataset contains both images (e.g., CTs, MRIs) and binary segmentations, it is recommended that resampling is performed on both to keep them aligned for subsequent analyses that might entail/need imaging data. </p> <p>Since image resampling entails interpolation, directly resampling binary segmentations will not result in a binary segmentation, but rather an interpolated version that does not have two distinct labels (i.e., foreground and background).</p> <p>To mitigate this behavior, we need first to convert the binary segmentations (with zero-one voxels) to a continuous-valued (gray-scale) image. This can be done by either antialiasing the segmentations, which smooths the foreground-background interface, or converting a segmentation to a signed distance transform, where each voxel encodes the physical distance to the closest surface point (zero-one interface) with the sign indicating whether the voxel is inside or outside the foreground region.</p> <p>Here is a resampling pipeline example for binary segmentation that uses antialiasing:</p> <ul> <li><code>antialias</code> the binary segmentation to convert it to a smooth continuous-valued image</li> <li><code>resample</code> the antialiased image using the same (and possible smaller) voxel spacing for all dimensions</li> <li><code>binarize</code> (aka thresholding) the resampled image to results in a binary segmentation with the desired voxel spacing</li> </ul> <p>Here is an example of resampling an ellipsoid with spacing (1,1,2) to have spacing (1,1,1):</p> <p><pre><code>antialias_iterations = 30\nshape_seg            = sw.Image(in_shape_filename)\n\nshape_seg.antialias(antialias_iterations)\nshape_seg.resample([1,1,1], sw.InterpolationType.Linear)\nshape_seg.binarize().write(out_shape_filename)\n</code></pre> </p> <p>Resampling images</p> <p>Images are already given as a continued-valued grid of pixels. Hence, images can be directly resampled without any pre- or post-processing steps.</p> <p>Resampling images reduces pixelation and smooths out intensity noise. </p> <p>Resampling segmentations smooths out shape boundaries and reduces binarization aliasing. </p>"},{"location":"workflow/groom.html#aligning-segmentations","title":"Aligning segmentations","text":"<p>Rigidly aligning a cohort of shapes entails removing differences across these shapes pertaining to global transformations, i.e., translation and rotation. This step requires a reference coordinate frame to align all shapes to, where one of the shapes can be selected as a reference.</p> <p>Rigid alignment (aka registration) is an optimization process that might get stuck in a bad local minima if shapes are significantly out of alignment. To bring shapes closer, we can remove translation differences using center-of-mass alignment. This factors out translations to reduce the risk of misalignment and allow for a medoid sample to be automatically selected as the reference for subsequent rigid alignment.</p> <p>Applying transformation to segmentations</p> <p>Applying a transformation to segmentations entails interpolation due to image resampling in the new coordinate frame. Similar to the resampling workflow, we will first antialias the segmentation to convert it to a continuous-valued image with a smooth foreground-background interface, then apply the transformation, and finally binarize the tranformed image.</p> <p>Hence, the shapes alignment pipeline includes the following steps:</p> <ul> <li>Center-of-mass alignment for segmentations: <ul> <li><code>antialias</code> the binary segmentation to convert it to a smooth continuous-valued image</li> <li><code>translate</code> the binary segmentation so that the center of the image doamin is the center of mass of the shape.</li> <li><code>binarize</code> (aka thresholding) to get a binary segmentation</li> </ul> </li> <li> <p><code>recenter</code> moves the center of the image (which is now the center of mass) to (0,0,0)</p> </li> <li> <p>Reference shape selection: One option for a reference is to select the shape that is closest to all other samples in the given cohort, i.e., the medoid shape. If shape instances are misaligned (i.e., do not share the same coordinate frame), translational and rotational differences should be factored out before reference selection.</p> <ul> <li>Use the pymodule function <code>find_reference_image_index</code> that perform pairwise rigid registration using the iterative closest point method and selects the sample that is closest to all other samples after factoring out global transformation differences. </li> </ul> </li> <li> <p>Rigid alignment:</p> <ul> <li><code>antialias</code> the binary segmentation and reference to convert them to a smooth continuous-valued image</li> <li><code>createTransform</code>: compute the rigid transformation parameters that would align a segmentation  to the reference shape</li> <li><code>applyTransform</code>: apply the rigid transformation to the segmentation and make it have the same cooridnate system as the reference </li> <li><code>binarize</code> (aka thresholding) to get a binary segmentation</li> </ul> </li> </ul> <p>Here is an example of performing center of mass alignment on one ellipsoid:</p> <pre><code>shape_seg            = sw.Image(in_shape_filename)\nantialias_iterations = 30\ntranslation_vector   =  shape_seg.center() - shape_seg.centerOfMass() \n\nshape_seg.antialias(antialias_iterations)\n         .translate(translation_vector)\n         .binarize().recenter()\n         .write(out_shape_filename)\n</code></pre> <p></p> <p> <p>Finding the reference:</p> <pre><code>ref_index = sw.find_reference_image_index(shape_seg_list)\nref_seg   = shape_seg_list[ref_index].write('reference.nrrd')\n</code></pre> <p></p> <p>Rigid alignment:</p> <pre><code>antialias_iterations = 30\n\nref_seg    = sw.Image(ref_shape_filename)\nshape_seg  = sw.Image(in_shape_filename)\n\nref_seg.antialias(antialias_iterations)\nshape_seg.antialias(antialias_iterations)\n\niso_value      = 1e-20\nicp_iterations = 200\nrigidTransform = shape_seg.createTransform(ref_seg, sw.TransformType.IterativeClosestPoint, iso_value, icp_iterations)\n\nshape_seg.applyTransform(rigidTransform,\n                         ref_seg.origin(),  ref_seg.dims(),\n                         ref_seg.spacing(), ref_seg.coordsys(),\n                         sw.InterpolationType.Linear)\n\nshape_seg.binarize().write(out_shape_filename)\n</code></pre> <p></p> <p>"},{"location":"workflow/groom.html#clip-segmentations","title":"Clip segmentations","text":"<p>In some cases, binary segmentations need to be clipped with a cutting plane so that only the desired part of the shape is reflected in the shape model. To perform this step, you can use <code>clip</code> defined the cutting plane defined using three points.</p> <p>Example of clipping:</p> <pre><code>shape_seg            = sw.Image(in_shape_filename)\ncutting_plane_point_1 = [10, 10, 0]\ncutting_plane_point_2 = [-10, -10, 0]\ncutting_plane_point_3 = [10, -10, 0]\n\nshape_seg.clip(cutting_plane_point_1,\n               cutting_plane_point_2,\n               cutting_plane_point_3,![](![](![]()))\n              ).write(out_shape_filename)\n</code></pre> <p></p>"},{"location":"workflow/groom.html#cropping-and-padding-segmentations","title":"Cropping and padding segmentations","text":"<p>In many cases, image boundaries are not tight around shapes. This leaves too much irrelevant background voxels that might increase the memory footprint when optimizing the shape model. We can remove this irrelevant background while keeping our segmentations intact and avoid cropped segmentations to touch image boundaries, which results in artifical holes in the shape boundary and does not allow particles to be distributed in regions touching the image boundary. </p> <p>This cropping and padding step entails the following steps:</p> <ul> <li><code>ImageUtils.boundingBox</code>: computes the smallest bounding box (ShapeWorks region) that fits all segmentations in the given shape cohort. Note that this step should be applied to at segmentations that share the same coordinate frame (i.e., aligned)</li> <li><code>crop</code> the segmentation using the computed bounding box</li> <li><code>pad</code> the cropped segmentation to ensure the shape is not touching the image boundary</li> </ul> <p>Example of cropping and padding:</p> <p><pre><code>iso_value         = 0.5 # a threshold value between 0 and 1 for binary segmentations\npadding_size      = 10  # number of voxels to pad for each dimension\npadding_value     = 0  # the constant value used to pad the segmentations\n\nsegs_bounding_box = sw.ImageUtils.boundingBox(shape_seg_list, iso_value)\nshape_seg         = sw.Image(in_shape_filename)\n\nshape_seg.crop(segs_bounding_box)\n         .pad(padding_size, padding_value)\n         .write(out_shape_filename)\n</code></pre> </p>"},{"location":"workflow/groom.html#converting-segmentations-to-smooth-signed-distance-transforms","title":"Converting segmentations to smooth signed distance transforms","text":"<p>For numerical computations for correspondences optimization, we need to convert binary segmentations to a continuous-valued image that satisfies the following requirements.</p> <ul> <li>smooth for gradient updates stability</li> <li>reflect the shape's surface (i.e., foreground-background) interface</li> <li>provide a signal for the particle to snap (move back) to the surface in case particles gets off the surface during optimization, which is a typical scenario when using gradient descent based optimization</li> </ul> <p>An antialiased segmentation satisfies the first two requirements. However, if a particles leaves the surface (i.e., the zero-level set) during model optimization, which is typical in gradient descent based optimization, it would be challenging to snap it back to the surface.</p> <p>A representation that satisfies all the requirements is the signed distance transform. </p> <ul> <li>A signed distance transform assigns to each voxel the physical distance to the closest point on the surface (i.e., the minimum distance from that voxel to nearest voxel on the foreground-background interface).</li> <li>The sign is used to indicate whether that voxel is inside or outside the foreground object.</li> <li>The zero-level set (zero-distance to the surface) indicates the foreground-background interface (i.e., the shape's surface).</li> <li>The gradient of a signed distance transform at a voxels indicates what direction to move in from that voxels to most rapidly increase the value of this distance. Hence, we can use the negative of this gradient as a signal to move a particle back to the surface.</li> </ul> <p>The <code>computeDT</code> API needs an <code>iso_value</code> that defines the foreground-background interface. To create  a smoother interface, we first antialias the segmentation then compute the distance transform at the zero-level set. We then need to smooth the DT as it will have some remaining aliasing effect of binarization. </p> <p>So the steps are:</p> <ul> <li><code>antialias</code> the binary segmentation to convert it to a smooth continuous-valued image</li> <li><code>computeDT</code>: Compute distance transform</li> <li><code>gaussianBlur</code>: Apply smoothing by convolving the image with a 3D gaussian filter with a given sigma (in physical coordinates)</li> <li>Save the distance transform</li> </ul> <p><pre><code>iso_value = 0\nsigma     = 1.3\n\nshape_seg = sw.Image(in_shape_filename)\n\nshape_seg.antialias(antialias_iterations)\n         .computeDT(iso_value)\n         .gaussianBlur(sigma)\n         .write(out_shape_filename)\n</code></pre> </p> <p>Gaussian blur with a small sigma. Note aliasing left-overs!</p> <p> <p>Gaussian blur with a larger sigma. Note a smooth surface.</p> <p> <p>Caution when using Gaussian blur</p> <p>The <code>gaussianBlur</code> method could be use for blobby-like structures. However, for shapes with thin features and high curvature regions, the gaussian blurring method could impact the underlying geometrical features. For these shapes, topology-preserving smoothing is recommended. Topology-preserving smoothing is currently under developement and will be released soon.</p>"},{"location":"workflow/groom.html#common-pre-processing-steps-for-meshes","title":"Common Pre-Processing Steps for Meshes","text":""},{"location":"workflow/groom.html#reflect-meshes","title":"Reflect meshes","text":"<p>It is common in medical imaging data to have a left and right anatomy. To align and model all such shapes, we must reflect some meshes so that all are oriented the same.</p> <ul> <li><code>reflect</code>: reflects the mesh across the given axis (typically x-axis for anatomy)</li> </ul> <p>Here is an example of reflecting a mesh:</p> <pre><code>shape_mesh = sw.Mesh(in_mesh_filename)\nshape_mesh.reflect(sw.X).write(out_mesh_filename)\n</code></pre> <p></p>"},{"location":"workflow/groom.html#meshes-to-volumes","title":"Meshes to volumes","text":"<p>Meshes can be converted to binary segmentations if desired so that grooming can be done on segmentations and optimization on distance transforms. </p> <p>The steps to convert meshes to volumes are:</p> <ul> <li><code>toImage</code> convert the mesh to a signed distance transform</li> <li><code>binarize</code> (aka thresholding) to get a binary segmentation</li> </ul> <p>Example of turning a mesh to a segmentation:</p> <pre><code>shape_mesh = sw.Mesh(in_mesh_filename)\nshape_seg  = shape_mesh.toImage()\n                       .binarize()\n                       .write(out_shape_filename)\n</code></pre> <p></p> <p>For list of commands, check out ShapeWorks Commands</p>"},{"location":"workflow/groom.html#remesh","title":"Remesh","text":"<p>Remeshing creates meshes with evenly spaced vertices.  - <code>remeshPercent</code> remeshes the mesh to have a given percent of the current number of vertices</p> <p><pre><code>mesh.remeshPercent(percentage=0.80, adaptivity=1.0)\n</code></pre> </p>"},{"location":"workflow/groom.html#aligning-meshes","title":"Aligning meshes","text":"<p>Rigidly aligning a cohort of shapes entails removing differences across these shapes pertaining to global transformations, i.e., translation and rotation. This step requires a reference coordinate frame to align all shapes to, where one of the shapes can be selected as a reference.</p> <p>Hence, the shapes alignment pipeline includes the following steps:</p> <ul> <li>Reference shape selection: One option for a reference is to select the shape that is closest to all other samples in the given cohort, i.e., the medoid shape. If shape instances are misaligned (i.e., do not share the same coordinate frame), translational and rotational differences should be factored out before reference selection.</li> <li> <p>Use the pymodule function <code>find_reference_mesh_index</code> that perform pairwise rigid registration using the iterative closest point method and selects the sample that is closest to all other samples after factoring out global transformation differences.    </p> </li> <li> <p>Rigid alignment:</p> </li> <li><code>createTransform</code>: compute the rigid transformation parameters that would align a segmentation      to the reference shape</li> <li><code>applyTransform</code>: apply the rigid transformation to the segmentation and make it have the same cooridnate system as the reference </li> </ul> <p>Here is an example of performing reference selection and rigid alignment on a list of meshes:</p> <p><pre><code># reference selection \nref_index = sw.find_reference_mesh_index(mesh_list)\nref_mesh = mesh_list[ref_index]\n# align all meshes in the list to the reference \nfor mesh in mesh_list:\n    # compute rigid transformation\n    rigid_transform = mesh.createTransform(ref_mesh, sw.Mesh.AlignmentType.Rigid, 100)\n    # apply rigid transform\n    mesh.applyTransform(rigid_transform)\n</code></pre> </p>"},{"location":"workflow/groom.html#extract-shared-boundary","title":"Extract Shared Boundary","text":"<p>In this step, we ingest the two original shapes and the output consists of three new shapes, two of which correspond to the original shapes and one for the shared boundary. Let us designate the original meshes as Lo and Ro. Then:</p> <ol> <li>Find all the triangles in Lo that are close to Ro, and construct a mesh with these triangles called Ls. A triangle with vertices v0, v1 and v2 is considered close to a mesh if the shortest euclidean distance to the mesh for all the three vertices is below a small threshold. We similarly find all the triangles in Ro that are close to Lo and designate this mesh as Rs</li> <li>Find the remainder of the mesh in Lo after removing the triangles in Ls and designate this as Lr. Similarly, we find the remainder of the mesh in Ro after removing the triangles in Rs and designate this as Rr.</li> <li>Arbitrary designed Rs as the shared surface M.</li> <li>Snap all the points on the boundary loop of Lr to the boundary loop of M</li> <li>Return three new shapes Lr, M and Rr</li> </ol> <pre><code> extracted_l,extracted_r,extracted_s = \n sw.MeshUtils.sharedBoundaryExtractor(mesh_l,mesh_r,tol)\n</code></pre>"},{"location":"workflow/groom.html#input-shapes-with-shared-surface","title":"Input shapes with shared surface","text":""},{"location":"workflow/groom.html#output-extracted-surfaces","title":"Output extracted surfaces","text":""},{"location":"workflow/groom.html#extract-contour","title":"Extract Contour","text":"<p>The boundary loop of the shared surface M obtained using the <code>sharedBoundaryExtractor</code> is computed.  <pre><code>output_contour = sw.MeshUtils.boundaryLoopExtractor(extracted_shared_meshes)\n</code></pre> </p>"},{"location":"workflow/groom.html#smoothing","title":"Smoothing","text":"<p>Laplacian Smoothing allows you to reduce noise on a mesh\u2019s surface with minimal changes to its shape.The effect is to \"relax\" the mesh, making the cells better shaped and the vertices more evenly distributed. <pre><code>mesh.smooth(iterations, relaxation)\n</code></pre> </p>"},{"location":"workflow/optimize.html","title":"How to Optimize Your Shape Model?","text":""},{"location":"workflow/optimize.html#particle-based-shape-modeling","title":"Particle-based Shape Modeling","text":"<p>ShapeWorks constructs statistically optimal anatomical mapping across different shape samples by automatically computing a dense set of corresponding landmark positions that are geometrically consistent on a set of anatomy segmentations or surface meshes and does not rely on any specific surface parameterization. </p> <p>ShapeWorks uses a set of interacting particle systems, one for each shape, to produce optimal sets of surface correspondences in an ensemble. Particles interact with one another via mutually repelling forces to cover optimally and, therefore, describe surface geometry. Particles are positioned on surfaces automatically by optimizing the model's information content via an entropy optimization scheme. </p> <p>ShapeWorks optimizes landmark positions to minimize the overall information content of the model (first term) while maintaining a good sampling of surface geometry (second term) </p>"},{"location":"workflow/optimize.html#particle-based-representation","title":"Particle-based Representation","text":"<p>More formally, consider a cohort of shapes \\(\\mathcal{S} = \\{\\mathbf{z}_1, \\mathbf{z}_2, ..., \\mathbf{z}_N\\}\\) of \\(N\\) surfaces, each with its own set of \\(M\\) corresponding particles \\(\\mathbf{z}_n = [\\mathbf{z}_n^1, \\mathbf{z}_n^2, ..., \\mathbf{z}_n^M] \\in \\mathbb{R}^{dM}\\) where each particle \\(\\mathbf{z}_n^m \\in \\mathbb{R}^d\\) lives in a \\(d-\\)dimensional Cartesian space (typically \\(d=3\\) for anatomies), and whose ordering implies correspondence among shapes. Each of the particles is called a correspondence point, and is constrained to lie on the shape's surface. Collectively, the set of \\(M\\) particles is known as the configuration.</p>"},{"location":"workflow/optimize.html#shape-vs-configuration-spaces","title":"Shape vs. Configuration Spaces","text":"<p>This particle-based representation incorporates two types of random variables: a shape space variable \\(\\mathbf{Z} \\in \\mathbb{R}^{dM}\\) and a particle position variable \\(\\mathbf{X}_n \\in \\mathbb{R}^d\\) that encodes the distribution of particles on the \\(n-\\)th shape (configuration space). This particle-based representation avoids many of the problems inherent in parametric representations such as the limitation to specific topologies, processing steps necessary to construct parameterizations, and bias toward model initialization. </p>"},{"location":"workflow/optimize.html#world-vs-local-coordinates","title":"World vs. Local Coordinates","text":"<p>For groupwise modeling, shapes in the shape space should share the same world coordinate system. Hence, we use generalized Procrustes alignment to estimate a rigid transformation matrix \\(\\mathbf{T}_n\\) that can transform the particles in the \\(n-\\)th shape local coordinate \\(\\mathbf{x}_n^m\\) in the configuration space to the world common coordinate \\(\\mathbf{z}_n^m\\) in the shape space such that \\(\\mathbf{z}_n^m = \\mathbf{T}_n\\mathbf{x}_n^m\\). </p>"},{"location":"workflow/optimize.html#optimization-cost-function","title":"Optimization Cost Function","text":"<p>Correspondences are established by minimizing a combined shape correspondence and surface sampling cost function \\(Q = \\alpha H(\\mathbf{Z}) - \\sum_{n=1}^N H(\\mathbf{X}_n)\\), where \\(H\\) is an entropy estimation of the shape distribution in the shape space, and \\(\\alpha\\) is the relative weighting of the correspondence term. </p> <p>In particular, ShapeWorks explicitly models the inherent trade-off between the statistical simplicity of the model (i.e., compactness or lowest entropy) in the shape space (i.e., inter-surface) and the accuracy of the shape representations (i.e., good surface samplings or highest entropy) in the configuration space (i.e., intra-surface). The cost function \\(Q\\) is minimized using gradient descent with an adaptive time step.</p> <p>Because correspondence points (or particles) in this formulation are not tied to a specific surface parameterization, the method operates directly on both volumetric data and triangular surface meshes. It can also be easily extended to arbitrary shapes, even nonmanifold surfaces.</p>"},{"location":"workflow/optimize.html#particles-initialization-optimization","title":"Particles Initialization &amp; Optimization","text":"<p>ShapeWorks entails a nonconvex optimization problem. Hence, it is not practical to perform the optimization of the configuration space (intra-surface) and the shape space (inter-surface) with a full set of correspondence points (or particles) in one step.</p> <p>We address this using a coarse-to-fine optimization scheme to speed up convergence to an acceptable local minimum. In particular, the optimization is performed as a multi-step process where particles are added via spitting each particle to produce a new, nearby particle at each step until the desired number of particles is reached. </p> <p>ShapeWorks uses a particle splitting strategy, in which the full set of particles is optimized in a multi-scale (i.e., coarse-to-fine) fashion</p> <p> <p>For these steps, the optimization of the configuration space (intra-surface) and the shape space (inter-surface) is weighted to downplay the effect of the correspondence term (default \\(\\alpha = 0.05\\)), which results in an evenly spaced distribution of particles on each surface. These steps are collectively called the initialization steps.</p> <p>At each scale, the initialization step is followed by an optimization step. For this step, the optimization of the configuration space (intra-surface) and the shape space (inter-surface) are weighted (equally or sometimes using \\(\\alpha &gt; 1\\) to emphasize the correspondence term).</p> <p>Thus, the initialization proceeds simultaneously with the optimization in a multi-scale fashion, generating progressively more detailed correspondence models with each split. </p> <p>For both, the initialization and optimization steps, the weighting to the shape space may be set by the user. Further, as each step of the optimization is an iterative process, the number of iterations may be set by the user.</p> <p>At each scale, the number of iterations could impact the quality of the optimized model</p> <p> <p>The first particle: The particle system is initialized with a single particle on each shape. The first particle is found by raster-scanning the signed distance map and finding the first zero crossing. The particle system can also be initialized using user-defined sparse corresponding landmarks across all shapes.</p>"},{"location":"workflow/optimize.html#on-algorithmic-parameters","title":"On Algorithmic Parameters","text":"<p>Optimizing the shape models entails several algorithmic parameters. Below, we highlight the most important ones that might need tuning depending on the dataset at hand. </p> <p></p>"},{"location":"workflow/optimize.html#correspondence-relative-weighting","title":"Correspondence Relative Weighting","text":"<p>One difference between initialization and optimization steps is how important the correspondence (inter-surface) objective is compared to the surface sampling (intra-surface) term using a relative weighting factor for the correspondence term (i.e., \\(\\alpha\\) in \\(Q\\)). Hence <code>initial_relative_weighting</code> is the weight (or \\(\\alpha\\)) used in initialization steps and the <code>relative_weighing</code> is the weight (or \\(\\alpha\\)) used for optimization steps.</p> <p>Typically <code>initial_relative_weighting</code> is selected to be small (in the order of 0.01) to enable particles to be uniformly distributed (i.e., evenly spaced) over each shape, and hence optimization starts with a good surface sampling.</p> <p>It can be noted that by allowing correspondence to dominate the optimization process (using higher relative weighting), particles tend to be distributed in regions with relatively small variability across the given population. As the relative weighting tends to infinity, particles will be cluttered in one spot on each surface, which means that all shapes will be represented as a point at the shape space origin. Also, using lower relative weighting, i.e., allowing surface sampling to dominate the optimization process, results in particles becoming out-of-correspondence.</p> <p>As we increase the <code>relative_weighting</code>, i.e., the correspondence term weight, particles tend to be distributed over surface regions that have less variability across shape samples; hence the shape distribution in the shape space tends to collapse to a single point (i.e., shape) </p>"},{"location":"workflow/optimize.html#shape-statistics-in-initialization-and-optimization-steps","title":"Shape Statistics in Initialization and  Optimization Steps","text":"<p>At earlier scales, we do not have enough particles to describe the geometry of each surface. Hence, to quantify the notion of correspondence (inter-surface), we use mean energy (i.e., pushing all shapes in the shape space to the mean shape or, in other words, the covariance matrix is assumed to be identity). </p> <p>As more particles are added to the correspondence model, we use the entropy of the distribution of the shapes (assumed to be Gaussian distributed), where we have more particles that can reveal the covariance structure of the shape space.</p> <p>This behavior is controlled by the <code>use_shape_statistics_after</code> parameter, which specifies the number of particles, after which shape statistics can be used in the initialization and optimization steps.</p> <p>Using shape statistics (i.e., covariance structure) results in a better correspondence over iterations, below we use <code>use_shape_statistics_after</code> after 1024 particles</p> <p>"},{"location":"workflow/optimize.html#starting-and-ending-regularization","title":"Starting and Ending Regularization","text":"<p>Particle movement during optimization (due to the correspondence term) entails computing the covariance matrix's inverse. We regularize the covariance matrix to handle degenerate covariances. </p> <p><code>starting_regularization</code> and <code>ending_regularization</code> parameters determine the covariance matrix's regularization for the shape-space entropy estimation. This regularization exponentially decays along with optimization iterations where better covariance structure can be estimated with a better correspondence model. </p> <p>Higher regularization values would undermine the ensemble's underlying covariance structure and favors all shapes to converge to the mean shape. Hence, it is recommended to use starting regularization value as ~5% of the covariance matrix's expected highest eigenvalue while ending regularization can be taken as ten times less than the starting value.</p> <p>This regularization can be considered as having a Gaussian ball in the shape space. Starting regularization pushes all samples to the mean and hides the underlying \u201cunoptimized\u201d covariance structure. Ending regularization should be small enough to reveal the optimized covariance structure. </p>"},{"location":"workflow/optimize.html#optimizing-correspondences","title":"Optimizing Correspondences","text":"<p>You can use either ShapeWorks Studio or <code>shapeworks optimize &lt;parameters.xml&gt;</code> or <code>shapeworks optimize &lt;project.xlsx&gt;</code> command to optimize your shape model. Both use a set of algorithmic parameters to control the optimization process.</p> <p>See the  for details regarding the XML file and project file format. </p>"},{"location":"workflow/optimize.html#parameter-tuning","title":"Parameter Tuning","text":""},{"location":"workflow/optimize.html#general-process","title":"General Process","text":"<p>The general process for parameter tuning is to:</p> <ol> <li>Select a subsample of data to tune on.</li> <li>Start with default parameters and a small number of particles.</li> <li>Tune parameters one at a time until particles are evenly spread over the entire geometry and in good correspondence.</li> <li>Optimize on the entire cohort with the best set of hyper-parameters and desired number of particles to get the final shape model. </li> </ol>"},{"location":"workflow/optimize.html#qualitative-assessment","title":"Qualitative Assessment","text":"<p>To assess the quality of an optimized shape model, consider the following:</p> <ul> <li>Are the particles evenly spaced, covering the entire geometry of each sample?</li> <li>Are the particles in good correspondence across the samples? This can be assessed by inspecting the neighboring correspondences of particles (in Studio hover over a particle and press \u20181\u2019 to visualize).</li> <li>Does the surface reconstruction result in non-anatomical/plausible shapes?</li> <li>Do the shape modes of variation (PCA) reflect meaningful and are they smooth variations? All particles should move at similar velocities and along similar trajectories to their neighbors.  </li> </ul>"},{"location":"workflow/optimize.html#tips-and-tricks","title":"Tips and Tricks","text":"<ul> <li>Use a Subsample: To reduce the time spent tuning algorithmic parameters for model optimization, tuning should be done on a representative subsample. If working with complex shapes or highly variable anatomies, start with a small subset (e.g., 5 samples) with shapes that are most similar. A clustering-based approach can be used to automate this selection e.g., k-means on segmentations, spectral clustering on meshes. Once parameters have been found which result in a good correspondence model on the subset, the subset size can be increased. It may be helpful to increase the subset size and re-assess before moving to the full cohort. </li> <li>Start Small: Parameter tuning time can also be decreased by starting with a smaller number of particles and iterations than desired. In general, parameters which yield a good shape model with fewer particles will also yield a good model with increased particles. For this reason, the number of particles should be the last parameter tuned. </li> <li>Procrustes: Only consider using Procrustes if the groomed cohort has left-out misalignments.</li> <li>Unevenly Distributed: If particles are not evenly distributed on the surface, try increasing initialization iterations or decreasing relative weighting.</li> <li>Bad Correspondence: If particles are not in good correspondence, try increasing relative weighting. If particles are flipping sides on thin structures, enabling normals can resolve this.</li> </ul>"},{"location":"workflow/optimize.html#correspondences-on-new-samples","title":"Correspondences on New Samples","text":"<p>ShapeWorks supports an optimization mode, namely fixed domains, to place (i.e., optimize) correspondences on new shapes using a pre-existing shape model. In the fixed domains mode, particles on selected shapes that construct the pre-existing shape model are fixed, and particles on new shapes are optimized to represent them in the context of this shape model. See Fixed Domains for Ellipsoid: Correspondences on New Shape for an example. </p> <p>To enable the fixed domains mode, the XML should have the below additional tags. For this mode, you can use <code>\"use_shape_statistics_after\": 0</code> to enable shape statistics in all the steps as the pre-existing shape model already has enough particles optimized to reflect the covariance structure in the shape space.</p> <ul> <li><code>&lt;point_files&gt;</code>: A list of local.particles files to be fixed, i.e., the pre-existing shape model. The new (to be optimized) samples/domains should be initialized with the mean particles.</li> <li><code>&lt;fixed_domains&gt;</code>: A list of domain ids (starting from 0) of the domains that are fixed (i.e., not optimized).</li> </ul>"},{"location":"workflow/parameters.html","title":"Optimization Parameters","text":"<p><code>ShapeWorks</code> supports two formats for handling the data for performing grooming and optimization via the python interface and <code>ShapeWorksStudio</code>:</p> <ul> <li> <p>XML Parameter file</p> </li> <li> <p>Project excel file</p> </li> <li> <p>Project JSON file (swproj)</p> </li> </ul> <p>The project excel/json file formats are the current standard project file format. The older XML format is deprecated and will not have newer features added to it.  Users are encouraged to use the project excel/json file.  </p>"},{"location":"workflow/parameters.html#xml-parameter-file-deprecated","title":"XML Parameter File (deprecated)","text":"<p>Here is the list of the parameters to be included in the <code>&lt;parameters.xml&gt;</code> file.</p> <ul> <li><code>&lt;inputs&gt;</code>: List of surface meshes or distance transforms (i.e., groom stage output) that comprises your dataset.</li> <li><code>&lt;output_dir&gt;</code>:  The directory to save the output produced by the ShapeWorks optimization.</li> <li><code>&lt;domain_type&gt;</code>: (default: image) The type of the domain in <code>&lt;inputs&gt;</code>, <code>image</code> for signed distance transforms, and <code>mesh</code> for triangular surface meshes.</li> <li><code>&lt;domains_per_shape&gt;</code>: (default: 1) The number of domains for anatomies with multiple structures (domains), e.g., joints. The list of <code>&lt;inputs&gt;</code> should be ordered to list a consistent order of the domains (surface mesh or distance transform) of each shape (e.g., shape1-domain1, shape1-domain2, shape2-domain1, shape2-domain2 ... etc.).</li> <li><code>&lt;narrow_band&gt;</code>: (default: 4.0 of <code>&lt;fixed_domains&gt;</code> is not active) The off-surface distance (in voxel units, largest spacing dimension) used to truncate (zero out) distance values for signed distance transforms beyond the narrow band radius (i.e., a narrow band of 4.0 preserve distance values within +/- 4.0 voxels off the surface). This is used to reduce the memory footprint required for keeping volumetric distance transforms in memory. If you get an error that particles are shooting outside the narrow band, please consider increasing this value. Narrow banding is disabled if <code>&lt;fixed_domains&gt;</code> is active. This does not significantly affect the memory footprint since distance transforms of the fixed domains are not loaded in memory.</li> <li><code>&lt;number_of_particles&gt;</code>: The desired number of particles to be placed. ShapeWorks will produce the smallest power-of-2 number of particles greater than or equal to the given <code>&lt;number_of_particles&gt;.</code></li> <li><code>&lt;iterations_per_split&gt;</code>: (default: 1000) The number of iterations in the initialization step for each split (i.e., scale). </li> <li><code>&lt;optimization_iterations&gt;</code>: (default: 2000) Number of iterations for each optimization step.</li> <li><code>&lt;save_init_splits&gt;</code>: (default: 1) A flag to save the particles for each split in the initialization steps. </li> <li><code>&lt;use_xyz&gt;</code>: (default: 1) A flag to enable using the XYZ coordinates for particles as a feature for correspondence.</li> <li><code>&lt;use_normals&gt;</code>: (default: 0) A flag to consider surface normals (along with particles positions, i.e., <code>&lt;use_xyz&gt; 1 &lt;/use_xyz&gt;</code>) as a correspondence feature.</li> <li><code>&lt;attribute_scales&gt;</code>: A vector of weights that scale each dimension considered in the correspondence entropy. For example, if only XYZ coordinates are used for particles, <code>&lt;attribute_scales&gt;</code> is a vector of three weights that scale the particle's x- and y- and z- coordinates (default = 1). If surface normals are also used, <code>&lt;attribute_scales&gt;</code> should be a vector of 6 entries, 3 for the XYZ coordinates, and 3 for the surface normal (usually on a scale of 10), assuming 3D anatomies.</li> <li><code>&lt;use_shape_statistics_after&gt;</code>: (default: -1) (e.g., 32 or 64) The number of particles after which to use shape space entropy (i.e., the covariance structure) in the initialization and optimization steps. Use -1 if you want shape statistics only used when the number of particles reaches the desired <code>&lt;number_of_particles&gt;</code>. Hence, all initialization and optimization steps will use mean energy till the <code>&lt;number_of_particles&gt;</code> is reached.</li> <li><code>&lt;starting_regularization&gt;</code>: (default: 1000) Sets the starting regularization value (usually high value).</li> <li><code>&lt;ending_regularization&gt;</code>: (default: 1.0) Sets the ending regularization value (usually small value less than 1).</li> <li><code>&lt;initial_relative_weighting&gt;</code>: (default: 0.05) The relative weight of the correspondence term in the initialization steps to make sure that optimization steps start with evenly spaced particle distributions that cover the entire surfaces (usually in the order of ~0.1 or 0.01).</li> <li><code>&lt;relative_weighting&gt;</code>: (default: 1) The relative weight of the correspondence term in the optimization steps.</li> <li><code>&lt;procrustes_scaling&gt;</code>: (default: 1) A flag to enable factoring out scaling in the shape space when performing the Procrustes alignment.</li> <li><code>&lt;procrustes_interval&gt;</code>: (default: 3) Number of iterations (interval) between performing Procrustes alignment; use 0 to turn Procrustes off.</li> <li><code>&lt;mesh_based_attributes&gt;</code>: (default: 0) A flag that should be enabled when <code>&lt;use_normals&gt;</code> is enabled to cache and interpolate surface normals using isosurfaces.</li> <li><code>&lt;keep_checkpoints&gt;</code>: (default: 0) A flag to save the shape (correspondence) models through the initialization/optimization steps for debugging and troubleshooting.  </li> <li><code>&lt;checkpointing_interval&gt;</code>: (default: 50) The interval (number of iterations) to be used to save the checkpoints.</li> <li><code>&lt;verbosity&gt;</code>: (default: 0) '0' : almost zero verbosity (error messages only), '1': minimal verbosity (notification of running initialization/optimization steps), '2': additional details about parameters read from xml and files written, '3': full verbosity.</li> <li><code>&lt;adaptivity_mode&gt;</code>: (default: 0) Used to change the expected behavior of the particles sampler, where the sampler is expected to distribute evenly spaced particles to cover all the surface. Currently, 0 is used to trigger the update project method of cutting planes.</li> <li>'`: Number of cutting planes for each shape if constrained particle optimization is used. <li><code>&lt;cutting_planes&gt;</code>: A list of cutting planes for all shapes. Three points define each cutting plane in an order that indicates the plane's normal, i.e., the direction where particles are allowed to be distributed.</li>"},{"location":"workflow/parameters.html#parameter-dictionary-in-python","title":"Parameter Dictionary in Python","text":"<p>Prior to <code>ShapeWorks 6.3</code>, all the In <code>Examples/Python/&lt;use-case-name.py&gt;</code>,we used XML files to run optimization. A python code - <code>Examples/Python/OptimizeUtils.py</code> was used to convert a list of parameter dictionary in python to an XML file. </p> <p>Below is a list of the currently exposed algorithmic parameters. All the keys of this parameter dictionary correspond to the XML tags, except for <code>\"normals_strength\"</code> that sets the <code>&lt;attribute_scales&gt;</code> of the surface normal vector.</p> <p><pre><code>{\n    \"number_of_particles\": 1024,\n    \"use_normals\": 0, \n    \"normals_strength\": 0.0, \n    \"checkpointing_interval\" : 10000, \n    \"keep_checkpoints\" : 0, \n    \"iterations_per_split\" : 4000, \n    \"optimization_iterations\" : 500, \n    \"starting_regularization\" : 10, \n    \"ending_regularization\" : 1, \n    \"relative_weighting\" : 10,\n    \"initial_relative_weighting\" : 1,\n    \"procrustes_interval\" : 1,\n    \"procrustes_scaling\" : 1,\n    \"save_init_splits\" : 0,\n    \"verbosity\" : 2,\n}\n</code></pre> </p>"},{"location":"workflow/parameters.html#project-excel-file","title":"Project Excel File","text":"<p>ShapeWorks Studio and the <code>shapeworks</code> commands <code>groom</code> and <code>optimize</code> use a new project format based on XLSX. The new spreadsheet format profiles a uniform, easy to edit, easy to organize way of inputting data into shapeworks for grooming, optimizing, and analyzing data.</p> <p></p> <p>Users input shapes (either binary segmentations or meshes) in the first sheet (or datasheet) using unique column names to indicate type:</p> Prefix Description shape_&lt;name&gt; An input shape (segmentation/mesh) with a given name.* Specify multiple shape_&lt;name&gt; columns to input multiple anatomies for each subject group_&lt;name&gt; An group column with categorical types feature_&lt;name&gt; A feature volume (such as an MRI or CT) <p> Many other columns will be filled in automatically by the ShapeWorks tools.</p> <p>A more complete example is provided in Examples/Studio/FeatureMap/feature_map_example.xlsx :</p> <p></p> <p>After completing the grooming and optimization steps, this worksheet will look like this:</p> <p></p> <p>There will also be new worksheets with parameters from those tools and other studio settings.</p>"},{"location":"workflow/parameters.html#project-json-file","title":"Project JSON File","text":"<p>ShapeWorks also supports a JSON version of the Excel project file for easier interoperability with other tools as well as text editor support.</p> <p>The format is very similar to that of the Excel spreadsheet with JSON objects for each sheet and for the data sheet, one object per subject with key/values the same as spreasheet columns.</p> <p>For example:</p> <pre><code>{\n    \"data\": [\n        {\n            \"name\": \"\",\n            \"shape_femur\": \"195916_R_FM_align.nrrd\",\n            \"shape_pelvis\": \"195916_R_PV_align.ply\",\n            \"groomed_femur\": \"groomed/195916_R_FM_align_DT.nrrd\",\n            \"groomed_pelvis\": \"groomed/195916_R_PV_align_groomed.vtk\",\n        },\n        {\n            \"name\": \"\",\n            \"shape_femur\": \"187609_R_FM_align.nrrd\",\n            \"shape_pelvis\": \"187609_R_PV_align.ply\",\n            \"groomed_femur\": \"groomed/187609_R_FM_align_DT.nrrd\",\n            \"groomed_pelvis\": \"groomed/187609_R_PV_align_groomed.vtk\",\n        },\n    ...\n    \"optimize\": {\n        \"ending_regularization\": \"1.000000\",\n        \"geodesic_cache_multiplier\": \"0\",\n        \"initial_relative_weighting\": \"0.050000\",\n        \"iterations_per_split\": \"1000\",\n        \"multiscale\": \"false\",\n        \"multiscale_particles\": \"32\",\n    ...\n</code></pre>"},{"location":"workflow/parameters.html#python-api-for-generation-project-sheet","title":"Python API for Generation Project Sheet","text":"<p>The <code>Project</code> class of <code>ShapeWorks</code> lets you create the project excel sheet. It comprises various functions to add the input shape names, groomed file names, optimization parameters, transform matrices, etc. A details description of the C++ class and its functions can be found here. The C++ functions also have a python interface, the use of which is demonstrated in the use cases.  Setting up the project sheet using the python API entails the following steps:</p> <ol> <li> <p>Subjects: Each input shape(segmentation/mesh) is called a <code>subject</code>. This represents a single row of the datasheet. Using the Python API, an object of type <code>Subject</code> can be initialized, and the following properties can be set:</p> <ol> <li>Number of domains</li> <li>Original filename: Filename (including the relative path) of the input shape</li> <li>Groomed filename: Filename (including the relative path) of the groomed shape</li> <li>Groomed transform: Transform matrix obtained after grooming( list of 16 numbers). The 4x4 matrix should follow VTK transform matrix format. </li> <li>Constraint filename: Filename of the JSON file containing the plane constraint. Example of JSON file containing two plane constraints</li> </ol> </li> </ol> <pre><code>{\n    \"planes\": [\n            {\n            \"points\": [[ 10, 10, 0 ],\n                       [-10,-10, 0 ],\n                       [ 10,-10, 0 ]] \n            },\n            {\n            \"points\": [[ 10, 0, 10 ],\n                       [-10, 0, 10 ],\n                       [ 10, 0,-10 ]] \n            }\n              ] \n}\n</code></pre> <p>Setting up the subjects <pre><code># Set subjects\n    subjects = []\n    number_domains = 1\n    transforms = np.eye(4) # 4x4 matrix\n    for i in range(number_of_shapes):\n    subject = sw.Subject()\n    subject.set_number_of_domains(number_domains)\n    subject.set_original_filenames(input_shape_name[i])\n    subject.set_groomed_filenames(groomed_shape_name[i])\n    transform = [ transforms.flatten() ] #flatten into a vector and convert to list\n    subject.set_groomed_transforms(transform)\n    subject.set_constraints_filenames(plane_name[i]) #name pf the json file of the constraint plane\n    subjects.append(subject) # create a list of all subjects\n</code></pre> Specify if the shape is part of fixed domain. If the shape is marked with \"fixed\" = \"yes\" they refer to the shapes of the pre-existing model If the shape is marked with \"fixed\" = \"no\", new correspondences will be placed on these new shapes using a pre-existing shape model. </p> <pre><code>    subject.set_extra_values({\"fixed\": \"yes\"}) \n</code></pre> <p>If there are multiple domains, the subjects will contain list of string of filenames.  <pre><code># Set subjects\n    subjects = []\n    domains_per_shape = 2\n    for i in range(number_of_shapes):\n        subject = sw.Subject()\n        subject.set_number_of_domains(domains_per_shape)\n        rel_seg_files = []\n        rel_groom_files = []\n        transform = []\n        for d in range(domains_per_shape):\n            shape_files += input_shape_name[i*domains_per_shape+d]\n            groom_files += groomed_shape_name[i*domains_per_shape+d]\n            transform.append(transforms[i*domains_per_shape+d].flatten())\n\n        subject.set_groomed_transforms(transform)\n        subject.set_groomed_filenames(groom_files)\n        subject.set_original_filenames(shape_files)\n        subjects.append(subject)\n</code></pre> 2. Parameters: Each optimization parameter can be set using <code>Parameter</code> object. The <code>parameter</code> object consists of a list of type <code>Variant</code> <pre><code>    parameters = sw.Parameters()\n\n    # Create a dictionary for all the parameters required by optimization\n    parameter_dictionary = {\n    \"number_of_particles\" : 512,\n    \"use_normals\": 0,\n    \"normals_strength\": 10.0,\n    \"checkpointing_interval\" : 200,\n    \"keep_checkpoints\" : 0,\n    \"iterations_per_split\" : 1000,\n    \"optimization_iterations\" : 500,\n    \"starting_regularization\" : 100,\n    \"ending_regularization\" : 0.1,\n    \"recompute_regularization_interval\" : 2,\n    \"domains_per_shape\" : 1,\n    \"relative_weighting\" : 10,\n    \"initial_relative_weighting\" : 0.1,\n    \"procrustes\" : 1,\n    \"procrustes_interval\" : 1,\n    \"procrustes_scaling\" : 1,\n    \"save_init_splits\" : 1,\n    \"debug_projection\" : 0,\n    \"verbosity\" : 0,\n    \"use_statistics_in_init\" : 0,\n    \"adaptivity_mode\": 0\n    } \n\n    for key in parameter_dictionary:\n    parameters.set(key,sw.Variant([parameter_dictionary[key]]))\n    parameters.set(\"domain_type\",sw.Variant('mesh'))\n</code></pre> 3. Project: Once, the list of subjects and parameters, are created, they can be set in the project file using the <code>Project</code> object</p> <pre><code>    # Set project\n    project = sw.Project()\n    project.set_subjects(subjects)\n    # provide the sheet name - 'optimize' for the optimization parameter\n    project.set_parameters(\"optimize\",parameters)\n    project.save(spreadsheet_file)\n</code></pre>"}]}