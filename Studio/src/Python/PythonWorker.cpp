// pybind
#include <pybind11/embed.h>
#include <pybind11/stl.h>
#include <pybind11/eigen.h>
namespace py = pybind11;
using namespace pybind11::literals; // to bring in the `_a` literal

#include <sstream>
#include <iostream>

#include <QProcess>
#include <QMessageBox>
#include <QFileInfo>

#include <Data/StudioLog.h>
#include <Data/Shape.h>
#include <Python/PythonWorker.h>

namespace shapeworks {

//---------------------------------------------------------------------------
class PythonLogger {
public:

  void set_callback(const std::function<void(std::string)>& callback)
  {
    this->callback_ = callback;
  }

  void set_progress_callback(const std::function<void(double)>& callback)
  {
    this->progress_callback_ = callback;
  }

  void cpp_log(std::string msg)
  {
    this->callback_(msg);
  }

  void cpp_progress(double progress)
  {
    this->progress_callback_(progress * 100);
  }

  void clear_abort()
  {
    this->aborted_ = false;
  }

  void set_abort()
  {
    this->aborted_ = true;
  }

  bool check_abort()
  {
    return this->aborted_;
  }

private:
  std::function<void(std::string)> callback_;
  std::function<void(double)> progress_callback_;
  std::atomic<bool> aborted_{false};
};

//---------------------------------------------------------------------------
PYBIND11_EMBEDDED_MODULE(logger, m) {
  py::class_<PythonLogger, std::shared_ptr<PythonLogger>>(m, "PythonLogger")
  .def(py::init<>())
  .def("log", &PythonLogger::cpp_log)
  .def("check_abort", &PythonLogger::check_abort)
  .def("progress", &PythonLogger::cpp_progress);
};

//---------------------------------------------------------------------------
PythonWorker::PythonWorker()
{
  this->python_logger_ = QSharedPointer<PythonLogger>::create();

  // create singular Python thread and move this object to the new thread
  this->thread_ = new QThread(this);
  this->moveToThread(this->thread_);
  this->thread_->start();
}

//---------------------------------------------------------------------------
PythonWorker::~PythonWorker()
{
  this->end_python();
  this->thread_->wait();
  delete this->thread_;
}

//---------------------------------------------------------------------------
void PythonWorker::set_vtk_output_window(vtkSmartPointer<StudioVtkOutputWindow> output_window)
{
  this->studio_vtk_output_window_ = output_window;
}

//---------------------------------------------------------------------------
void PythonWorker::start_job(QSharedPointer<Job> job)
{
  if (this->init()) {
    try {
      this->current_job_ = job;
      this->current_job_->run();
      emit this->current_job_->message(this->current_job_->get_completion_message());
    } catch (py::error_already_set& e) {
      emit error_message(e.what());
      emit this->current_job_->error_message(e.what());
    }
  }

  this->python_logger_->clear_abort();
  emit this->current_job_->finished();
}

//---------------------------------------------------------------------------
void PythonWorker::run_job(QSharedPointer<Job> job)
{
  emit job->progress(0);
  emit job->message("Running Task: " + job->name());

  job->start_timer();
  this->current_job_ = job;
  job->moveToThread(this->thread_);

  // run on python thread
  QMetaObject::invokeMethod(this, "start_job", Qt::QueuedConnection,
                            Q_ARG(QSharedPointer<Job>, job));
}

//---------------------------------------------------------------------------
bool PythonWorker::init()
{
  std::string script = "install_shapeworks.sh";
#ifdef _WIN32
  script = "install_shapeworks.bat";
#endif

  if (this->initialized_) {
    if (!this->initialized_success_) {
      emit error_message(
        QString::fromStdString("Unable to initialize Python. Please run " + script));
    }
    return this->initialized_success_;
  }
  this->initialized_ = true;

  STUDIO_LOG_MESSAGE("Initializing Python!");

  QString home = qgetenv("HOME");
#ifdef _WIN32
  home = qgetenv("USERPROFILE");
#endif

  // read list generated by something like this:
  // python -c "import sys; print('\n'.join(sys.path))" > $HOME/.shapeworks/python_path.txt
  std::vector<std::string> python_path;
  std::fstream file;
  QString python_home;
  file.open(home.toStdString() + "/.shapeworks/python_path.txt", std::ios::in);
  if (file.is_open()) {
    std::string line;
    while (getline(file, line)) {
      if (QFileInfo(QString::fromStdString(line) + "/python.exe").exists()) {
        python_home = QString::fromStdString(line);
      }
      python_path.push_back(line);
    }
    file.close();
  }
  else {
    emit error_message(
      QString::fromStdString("Unable to initialize Python. Please run " + script));

    this->initialized_success_ = false;
    return false;
  }

#ifdef _WIN32
  if (python_home.isEmpty()) {
    emit error_message(QString::fromStdString(
                         "Unable to initialize Python\nPlease run install_shapeworks.bat"));
    return false;
  }
  else {
    qputenv("PYTHONHOME", python_home.toUtf8());

    std::fstream file;
    QString path;
    file.open(home.toStdString() + "/.shapeworks/path.txt", std::ios::in);
    if (file.is_open()) {
      std::string line;
      while (getline(file, line)) {
        path = QString::fromStdString(line);
      }
      file.close();
    }

    qputenv("PATH", path.toUtf8());
    STUDIO_LOG_MESSAGE("Setting PATH for Python to: " + path.toUtf8());
  }
#endif // ifdef _WIN32

  try {
    py::initialize_interpreter();

    py::module sys = py::module::import("sys");

#ifdef __APPLE__
    setenv("OMP_NUM_THREADS", "1", 1);
#endif

    sys.attr("path") = python_path;

    // this is necessary or the plots will crash the process
    py::module py_matplot_lib = py::module::import("matplotlib");
    py_matplot_lib.attr("use")("agg");

    this->python_logger_->set_callback(
      std::bind(&PythonWorker::incoming_python_message, this, std::placeholders::_1));
    this->python_logger_->set_progress_callback(
      std::bind(&PythonWorker::incoming_python_progress, this, std::placeholders::_1));
    py::module logger = py::module::import("logger");

    py::module sw_utils = py::module::import("shapeworks.utils");

    py::object get_version = sw_utils.attr("get_api_version");
    std::string version = get_version().cast<std::string>();
    if (version != PythonWorker::python_api_version) {
      emit error_message(
        QString::fromStdString("Unable to initialize Python. Expected API version " + std::string(PythonWorker::python_api_version) +
                               " but found API version " + version + ". Please run " + script));
      this->initialized_success_ = false;
      return false;
    }

    py::object set_sw_logger = sw_utils.attr("set_sw_logger");
    set_sw_logger(this->python_logger_.data());

    // must reset the output window so that vtkPython's from conda's python doesn't take over
    vtkOutputWindow::SetInstance(this->studio_vtk_output_window_);

    STUDIO_LOG_MESSAGE("Embedded Python Interpreter Initialized");
  } catch (py::error_already_set& e) {
    emit error_message(QString::fromStdString("Error initializing Python:\n") + e.what());
    this->initialized_success_ = false;
    return false;
  } catch (const std::exception& e) {
    emit error_message(QString::fromStdString("Error initializing Python:\n") + e.what());
    this->initialized_success_ = false;
    return false;
  }

  this->initialized_success_ = true;
  return true;
}

//---------------------------------------------------------------------------
void PythonWorker::incoming_python_message(std::string message_string)
{
  emit this->current_job_->message(QString::fromStdString(message_string));
}

//---------------------------------------------------------------------------
void PythonWorker::end_python()
{
  // send to python thread
  QMetaObject::invokeMethod(this, "finalize_python");
}

//---------------------------------------------------------------------------
void PythonWorker::finalize_python()
{
  if (this->initialized_success_) {
    py::finalize_interpreter();
  }
  this->thread_->exit();
}

//---------------------------------------------------------------------------
void PythonWorker::incoming_python_progress(double value)
{
  emit this->current_job_->progress(value);
}

//---------------------------------------------------------------------------
void PythonWorker::abort_job()
{
  this->python_logger_->set_abort();
}
}
